{"version":3,"file":"rxjs-interop.mjs","sources":["../../../../../../packages/core/rxjs-interop/src/take_until_destroyed.ts","../../../../../../packages/core/rxjs-interop/src/to_observable.ts","../../../../../../packages/core/src/error_details_base_url.ts","../../../../../../packages/core/src/errors.ts","../../../../../../packages/core/src/signals/src/api.ts","../../../../../../packages/core/src/util/global.ts","../../../../../../packages/core/src/util/ng_dev_mode.ts","../../../../../../packages/core/src/signals/src/weak_ref.ts","../../../../../../packages/core/src/signals/src/graph.ts","../../../../../../packages/core/src/signals/src/computed.ts","../../../../../../packages/core/src/signals/src/errors.ts","../../../../../../packages/core/src/signals/src/signal.ts","../../../../../../packages/core/src/signals/src/untracked.ts","../../../../../../packages/core/src/signals/src/watch.ts","../../../../../../packages/core/rxjs-interop/src/to_signal.ts","../../../../../../packages/core/rxjs-interop/rxjs-interop.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an injection context. Otherwise, the\n * current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>(observer => {\n    const unregisterFn = destroyRef!.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, DestroyRef, effect, EffectRef, inject, Injector, Signal, untracked} from '@angular/core';\nimport {Observable, ReplaySubject} from 'rxjs';\n\n/**\n * Options for `toObservable`.\n *\n * @developerPreview\n */\nexport interface ToObservableOptions {\n  /**\n   * The `Injector` to use when creating the underlying `effect` which watches the signal.\n   *\n   * If this isn't specified, the current injection context will be used.\n   */\n  injector?: Injector;\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nexport function toObservable<T>(\n    source: Signal<T>,\n    options?: ToObservableOptions,\n    ): Observable<T> {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = effect(() => {\n    let value: T;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {injector, manualCleanup: true});\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nexport const ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n\n/**\n * URL for the XSS security documentation.\n */\nexport const XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_DETAILS_PAGE_BASE_URL} from './error_details_base_url';\n\n/**\n * The list of error codes used in runtime code of the `core` package.\n * Reserved error code range: 100-999.\n *\n * Note: the minus sign denotes the fact that a particular code has a detailed guide on\n * angular.io. This extra annotation is needed to avoid introducing a separate set to store\n * error codes which have guides, which might leak into runtime code.\n *\n * Full list of available error guides can be found at https://angular.io/errors.\n *\n * Error code ranges per package:\n *  - core (this package): 100-999\n *  - forms: 1000-1999\n *  - common: 2000-2999\n *  - animations: 3000-3999\n *  - router: 4000-4999\n *  - platform-browser: 5000-5500\n */\nexport const enum RuntimeErrorCode {\n  // Change Detection Errors\n  EXPRESSION_CHANGED_AFTER_CHECKED = -100,\n  RECURSIVE_APPLICATION_REF_TICK = 101,\n\n  // Dependency Injection Errors\n  CYCLIC_DI_DEPENDENCY = -200,\n  PROVIDER_NOT_FOUND = -201,\n  INVALID_FACTORY_DEPENDENCY = 202,\n  MISSING_INJECTION_CONTEXT = -203,\n  INVALID_INJECTION_TOKEN = 204,\n  INJECTOR_ALREADY_DESTROYED = 205,\n  PROVIDER_IN_WRONG_CONTEXT = 207,\n  MISSING_INJECTION_TOKEN = 208,\n  INVALID_MULTI_PROVIDER = -209,\n\n  // Template Errors\n  MULTIPLE_COMPONENTS_MATCH = -300,\n  EXPORT_NOT_FOUND = -301,\n  PIPE_NOT_FOUND = -302,\n  UNKNOWN_BINDING = 303,\n  UNKNOWN_ELEMENT = 304,\n  TEMPLATE_STRUCTURE_ERROR = 305,\n  INVALID_EVENT_BINDING = 306,\n  HOST_DIRECTIVE_UNRESOLVABLE = 307,\n  HOST_DIRECTIVE_NOT_STANDALONE = 308,\n  DUPLICATE_DIRECTITVE = 309,\n  HOST_DIRECTIVE_COMPONENT = 310,\n  HOST_DIRECTIVE_UNDEFINED_BINDING = 311,\n  HOST_DIRECTIVE_CONFLICTING_ALIAS = 312,\n\n  // Bootstrap Errors\n  MULTIPLE_PLATFORMS = 400,\n  PLATFORM_NOT_FOUND = 401,\n  MISSING_REQUIRED_INJECTABLE_IN_BOOTSTRAP = 402,\n  BOOTSTRAP_COMPONENTS_NOT_FOUND = -403,\n  PLATFORM_ALREADY_DESTROYED = 404,\n  ASYNC_INITIALIZERS_STILL_RUNNING = 405,\n  APPLICATION_REF_ALREADY_DESTROYED = 406,\n  RENDERER_NOT_FOUND = 407,\n\n  // Hydration Errors\n  HYDRATION_NODE_MISMATCH = -500,\n  HYDRATION_MISSING_SIBLINGS = -501,\n  HYDRATION_MISSING_NODE = -502,\n  UNSUPPORTED_PROJECTION_DOM_NODES = -503,\n  INVALID_SKIP_HYDRATION_HOST = -504,\n  MISSING_HYDRATION_ANNOTATIONS = -505,\n\n  // Signal Errors\n  SIGNAL_WRITE_FROM_ILLEGAL_CONTEXT = 600,\n  REQUIRE_SYNC_WITHOUT_SYNC_EMIT = 601,\n\n  // Styling Errors\n\n  // Declarations Errors\n\n  // i18n Errors\n  INVALID_I18N_STRUCTURE = 700,\n  MISSING_LOCALE_DATA = 701,\n\n  // standalone errors\n  IMPORT_PROVIDERS_FROM_STANDALONE = 800,\n\n  // JIT Compilation Errors\n  // Other\n  INVALID_DIFFER_INPUT = 900,\n  NO_SUPPORTING_DIFFER_FACTORY = 901,\n  VIEW_ALREADY_ATTACHED = 902,\n  INVALID_INHERITANCE = 903,\n  UNSAFE_VALUE_IN_RESOURCE_URL = 904,\n  UNSAFE_VALUE_IN_SCRIPT = 905,\n  MISSING_GENERATED_DEF = 906,\n  TYPE_IS_NOT_STANDALONE = 907,\n  MISSING_ZONEJS = 908,\n  UNEXPECTED_ZONE_STATE = 909,\n  UNSAFE_IFRAME_ATTRS = -910,\n  VIEW_ALREADY_DESTROYED = 911,\n  COMPONENT_ID_COLLISION = -912,\n}\n\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nexport class RuntimeError<T extends number = RuntimeErrorCode> extends Error {\n  constructor(public code: T, message: null|false|string) {\n    super(formatRuntimeError<T>(code, message));\n  }\n}\n\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nexport function formatRuntimeError<T extends number = RuntimeErrorCode>(\n    code: T, message: null|false|string): string {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage =\n        `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReactiveNode} from './graph';\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = Symbol('SIGNAL');\n\n/**\n * A reactive value which notifies consumers of any changes.\n *\n * Signals are functions which returns their current value. To access the current value of a signal,\n * call it.\n *\n * Ordinary values can be turned into `Signal`s with the `signal` function.\n *\n * @developerPreview\n */\nexport type Signal<T> = (() => T)&{\n  [SIGNAL]: unknown;\n};\n\n/**\n * Checks if the given `value` function is a reactive `Signal`.\n */\nexport function isSignal(value: Function): value is Signal<unknown> {\n  return (value as Signal<unknown>)[SIGNAL] !== undefined;\n}\n\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`).\n *\n * @param fn A zero-argument function which will be converted into a `Signal`.\n */\nexport function createSignalFromFunction<T>(node: ReactiveNode, fn: () => T): Signal<T>;\n\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n *\n * @param fn A zero-argument function which will be converted into a `Signal`.\n * @param extraApi An object whose properties will be copied onto `fn` in order to create a specific\n *     desired interface for the `Signal`.\n */\nexport function createSignalFromFunction<T, U extends Record<string, unknown>>(\n    node: ReactiveNode, fn: () => T, extraApi: U): Signal<T>&U;\n\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n */\nexport function createSignalFromFunction<T, U extends Record<string, unknown> = {}>(\n    node: ReactiveNode, fn: () => T, extraApi: U = ({} as U)): Signal<T>&U {\n  (fn as any)[SIGNAL] = node;\n  // Copy properties from `extraApi` to `fn` to complete the desired API of the `Signal`.\n  return Object.assign(fn, extraApi) as (Signal<T>& U);\n}\n\n/**\n * A comparison function which can determine if two values are equal.\n *\n * @developerPreview\n */\nexport type ValueEqualityFn<T> = (a: T, b: T) => boolean;\n\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nexport function defaultEquals<T>(a: T, b: T) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any;\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global: any = (/* @__PURE__ */ (\n    () => (typeof globalThis !== 'undefined' && globalThis) ||\n        (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n        (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n         self instanceof WorkerGlobalScope && self))());\n\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from './global';\n\ndeclare global {\n  /**\n   * Values of ngDevMode\n   * Depending on the current state of the application, ngDevMode may have one of several values.\n   *\n   * For convenience, the “truthy” value which enables dev mode is also an object which contains\n   * Angular’s performance counters. This is not necessary, but cuts down on boilerplate for the\n   * perf counters.\n   *\n   * ngDevMode may also be set to false. This can happen in one of a few ways:\n   * - The user explicitly sets `window.ngDevMode = false` somewhere in their app.\n   * - The user calls `enableProdMode()`.\n   * - The URL contains a `ngDevMode=false` text.\n   * Finally, ngDevMode may not have been defined at all.\n   */\n  const ngDevMode: null|NgDevModePerfCounters;\n\n  interface NgDevModePerfCounters {\n    namedConstructors: boolean;\n    firstCreatePass: number;\n    tNode: number;\n    tView: number;\n    rendererCreateTextNode: number;\n    rendererSetText: number;\n    rendererCreateElement: number;\n    rendererAddEventListener: number;\n    rendererSetAttribute: number;\n    rendererRemoveAttribute: number;\n    rendererSetProperty: number;\n    rendererSetClassName: number;\n    rendererAddClass: number;\n    rendererRemoveClass: number;\n    rendererSetStyle: number;\n    rendererRemoveStyle: number;\n    rendererDestroy: number;\n    rendererDestroyNode: number;\n    rendererMoveNode: number;\n    rendererRemoveNode: number;\n    rendererAppendChild: number;\n    rendererInsertBefore: number;\n    rendererCreateComment: number;\n    hydratedNodes: number;\n    hydratedComponents: number;\n    dehydratedViewsRemoved: number;\n    dehydratedViewsCleanupRuns: number;\n    componentsSkippedHydration: number;\n  }\n}\n\nexport function ngDevModeResetPerfCounters(): NgDevModePerfCounters {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters: NgDevModePerfCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0,\n  };\n\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nexport function initNgDevMode(): boolean {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\nimport '../../util/ng_dev_mode';\n\nimport {global} from '../../util/global';\n\n/**\n * A `WeakRef`-compatible reference that fakes the API with a strong reference\n * internally.\n */\nclass LeakyRef<T>/* implements WeakRef<T> */ {\n  constructor(private readonly ref: T) {}\n\n  deref(): T|undefined {\n    return this.ref;\n  }\n}\n\n// `WeakRef` is not always defined in every TS environment where Angular is compiled. Instead,\n// read it off of the global context if available.\n// tslint:disable-next-line: no-toplevel-property-access\nlet WeakRefImpl: WeakRefCtor|undefined = global['WeakRef'] ?? LeakyRef;\n\nexport interface WeakRef<T extends object> {\n  deref(): T|undefined;\n}\n\nexport function newWeakRef<T extends object>(value: T): WeakRef<T> {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) {\n    throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);\n  }\n  return new WeakRefImpl!(value);\n}\n\nexport interface WeakRefCtor {\n  new<T extends object>(value: T): WeakRef<T>;\n}\n\nexport function setAlternateWeakRefImpl(impl: WeakRefCtor) {\n  // no-op since the alternate impl is included by default by the framework. Remove once internal\n  // migration is complete.\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\nimport '../../util/ng_dev_mode';\n\nimport {throwInvalidWriteToSignalError} from './errors';\nimport {newWeakRef, WeakRef} from './weak_ref';\n\n/**\n * Counter tracking the next `ProducerId` or `ConsumerId`.\n */\nlet _nextReactiveId: number = 0;\n\n/**\n * Tracks the currently active reactive consumer (or `null` if there is no active\n * consumer).\n */\nlet activeConsumer: ReactiveNode|null = null;\n\n/**\n * Whether the graph is currently propagating change notifications.\n */\nlet inNotificationPhase = false;\n\nexport function setActiveConsumer(consumer: ReactiveNode|null): ReactiveNode|null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\n/**\n * A bidirectional edge in the dependency graph of `ReactiveNode`s.\n */\ninterface ReactiveEdge {\n  /**\n   * Weakly held reference to the consumer side of this edge.\n   */\n  readonly producerNode: WeakRef<ReactiveNode>;\n\n  /**\n   * Weakly held reference to the producer side of this edge.\n   */\n  readonly consumerNode: WeakRef<ReactiveNode>;\n  /**\n   * `trackingVersion` of the consumer at which this dependency edge was last observed.\n   *\n   * If this doesn't match the consumer's current `trackingVersion`, then this dependency record\n   * is stale, and needs to be cleaned up.\n   */\n  atTrackingVersion: number;\n\n  /**\n   * `valueVersion` of the producer at the time this dependency was last accessed.\n   */\n  seenValueVersion: number;\n}\n\n/**\n * A node in the reactive graph.\n *\n * Nodes can be producers of reactive values, consumers of other reactive values, or both.\n *\n * Producers are nodes that produce values, and can be depended upon by consumer nodes.\n *\n * Producers expose a monotonic `valueVersion` counter, and are responsible for incrementing this\n * version when their value semantically changes. Some producers may produce their values lazily and\n * thus at times need to be polled for potential updates to their value (and by extension their\n * `valueVersion`). This is accomplished via the `onProducerUpdateValueVersion` method for\n * implemented by producers, which should perform whatever calculations are necessary to ensure\n * `valueVersion` is up to date.\n *\n * Consumers are nodes that depend on the values of producers and are notified when those values\n * might have changed.\n *\n * Consumers do not wrap the reads they consume themselves, but rather can be set as the active\n * reader via `setActiveConsumer`. Reads of producers that happen while a consumer is active will\n * result in those producers being added as dependencies of that consumer node.\n *\n * The set of dependencies of a consumer is dynamic. Implementers expose a monotonically increasing\n * `trackingVersion` counter, which increments whenever the consumer is about to re-run any reactive\n * reads it needs and establish a new set of dependencies as a result.\n *\n * Producers store the last `trackingVersion` they've seen from `Consumer`s which have read them.\n * This allows a producer to identify whether its record of the dependency is current or stale, by\n * comparing the consumer's `trackingVersion` to the version at which the dependency was\n * last observed.\n */\nexport abstract class ReactiveNode {\n  private readonly id = _nextReactiveId++;\n\n  /**\n   * A cached weak reference to this node, which will be used in `ReactiveEdge`s.\n   */\n  private readonly ref = newWeakRef(this);\n\n  /**\n   * Edges to producers on which this node depends (in its consumer capacity).\n   */\n  private readonly producers = new Map<number, ReactiveEdge>();\n\n  /**\n   * Edges to consumers on which this node depends (in its producer capacity).\n   */\n  private readonly consumers = new Map<number, ReactiveEdge>();\n\n  /**\n   * Monotonically increasing counter representing a version of this `Consumer`'s\n   * dependencies.\n   */\n  protected trackingVersion = 0;\n\n  /**\n   * Monotonically increasing counter which increases when the value of this `Producer`\n   * semantically changes.\n   */\n  protected valueVersion = 0;\n\n  /**\n   * Whether signal writes should be allowed while this `ReactiveNode` is the current consumer.\n   */\n  protected abstract readonly consumerAllowSignalWrites: boolean;\n\n  /**\n   * Called for consumers whenever one of their dependencies notifies that it might have a new\n   * value.\n   */\n  protected abstract onConsumerDependencyMayHaveChanged(): void;\n\n  /**\n   * Called for producers when a dependent consumer is checking if the producer's value has actually\n   * changed.\n   */\n  protected abstract onProducerUpdateValueVersion(): void;\n\n  /**\n   * Polls dependencies of a consumer to determine if they have actually changed.\n   *\n   * If this returns `false`, then even though the consumer may have previously been notified of a\n   * change, the values of its dependencies have not actually changed and the consumer should not\n   * rerun any reactions.\n   */\n  protected consumerPollProducersForChange(): boolean {\n    for (const [producerId, edge] of this.producers) {\n      const producer = edge.producerNode.deref();\n\n      if (producer === undefined || edge.atTrackingVersion !== this.trackingVersion) {\n        // This dependency edge is stale, so remove it.\n        this.producers.delete(producerId);\n        producer?.consumers.delete(this.id);\n        continue;\n      }\n\n      if (producer.producerPollStatus(edge.seenValueVersion)) {\n        // One of the dependencies reports a real value change.\n        return true;\n      }\n    }\n\n    // No dependency reported a real value change, so the `Consumer` has also not been\n    // impacted.\n    return false;\n  }\n\n  /**\n   * Notify all consumers of this producer that its value may have changed.\n   */\n  protected producerMayHaveChanged(): void {\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n      for (const [consumerId, edge] of this.consumers) {\n        const consumer = edge.consumerNode.deref();\n        if (consumer === undefined || consumer.trackingVersion !== edge.atTrackingVersion) {\n          this.consumers.delete(consumerId);\n          consumer?.producers.delete(this.id);\n          continue;\n        }\n\n        consumer.onConsumerDependencyMayHaveChanged();\n      }\n    } finally {\n      inNotificationPhase = prev;\n    }\n  }\n\n  /**\n   * Mark that this producer node has been accessed in the current reactive context.\n   */\n  protected producerAccessed(): void {\n    if (inNotificationPhase) {\n      throw new Error(\n          typeof ngDevMode !== 'undefined' && ngDevMode ?\n              `Assertion error: signal read during notification phase` :\n              '');\n    }\n\n    if (activeConsumer === null) {\n      return;\n    }\n\n    // Either create or update the dependency `Edge` in both directions.\n    let edge = activeConsumer.producers.get(this.id);\n    if (edge === undefined) {\n      edge = {\n        consumerNode: activeConsumer.ref,\n        producerNode: this.ref,\n        seenValueVersion: this.valueVersion,\n        atTrackingVersion: activeConsumer.trackingVersion,\n      };\n      activeConsumer.producers.set(this.id, edge);\n      this.consumers.set(activeConsumer.id, edge);\n    } else {\n      edge.seenValueVersion = this.valueVersion;\n      edge.atTrackingVersion = activeConsumer.trackingVersion;\n    }\n  }\n\n  /**\n   * Whether this consumer currently has any producers registered.\n   */\n  protected get hasProducers(): boolean {\n    return this.producers.size > 0;\n  }\n\n  /**\n   * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n   * based on the current consumer context.\n   */\n  protected get producerUpdatesAllowed(): boolean {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n  }\n\n  /**\n   * Checks if a `Producer` has a current value which is different than the value\n   * last seen at a specific version by a `Consumer` which recorded a dependency on\n   * this `Producer`.\n   */\n  private producerPollStatus(lastSeenValueVersion: number): boolean {\n    // `producer.valueVersion` may be stale, but a mismatch still means that the value\n    // last seen by the `Consumer` is also stale.\n    if (this.valueVersion !== lastSeenValueVersion) {\n      return true;\n    }\n\n    // Trigger the `Producer` to update its `valueVersion` if necessary.\n    this.onProducerUpdateValueVersion();\n\n    // At this point, we can trust `producer.valueVersion`.\n    return this.valueVersion !== lastSeenValueVersion;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createSignalFromFunction, defaultEquals, Signal, ValueEqualityFn} from './api';\nimport {ReactiveNode, setActiveConsumer} from './graph';\n\n/**\n * Options passed to the `computed` creation function.\n *\n * @developerPreview\n */\nexport interface CreateComputedOptions<T> {\n  /**\n   * A comparison function which defines equality for computed values.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nexport function computed<T>(computation: () => T, options?: CreateComputedOptions<T>): Signal<T> {\n  const node = new ComputedImpl(computation, options?.equal ?? defaultEquals);\n\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  return createSignalFromFunction(node, node.signal.bind(node)) as unknown as Signal<T>;\n}\n\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET: any = Symbol('UNSET');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING: any = Symbol('COMPUTING');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED: any = Symbol('ERRORED');\n\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nclass ComputedImpl<T> extends ReactiveNode {\n  constructor(private computation: () => T, private equal: (oldValue: T, newValue: T) => boolean) {\n    super();\n  }\n  /**\n   * Current value of the computation.\n   *\n   * This can also be one of the special values `UNSET`, `COMPUTING`, or `ERRORED`.\n   */\n  private value: T = UNSET;\n\n  /**\n   * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n   * be re-thrown.\n   */\n  private error: unknown = null;\n\n  /**\n   * Flag indicating that the computation is currently stale, meaning that one of the\n   * dependencies has notified of a potential change.\n   *\n   * It's possible that no dependency has _actually_ changed, in which case the `stale`\n   * state can be resolved without recomputing the value.\n   */\n  private stale = true;\n\n  protected override readonly consumerAllowSignalWrites = false;\n\n  protected override onConsumerDependencyMayHaveChanged(): void {\n    if (this.stale) {\n      // We've already notified consumers that this value has potentially changed.\n      return;\n    }\n\n    // Record that the currently cached value may be stale.\n    this.stale = true;\n\n    // Notify any consumers about the potential change.\n    this.producerMayHaveChanged();\n  }\n\n  protected override onProducerUpdateValueVersion(): void {\n    if (!this.stale) {\n      // The current value and its version are already up to date.\n      return;\n    }\n\n    // The current value is stale. Check whether we need to produce a new one.\n\n    if (this.value !== UNSET && this.value !== COMPUTING &&\n        !this.consumerPollProducersForChange()) {\n      // Even though we were previously notified of a potential dependency update, all of\n      // our dependencies report that they have not actually changed in value, so we can\n      // resolve the stale state without needing to recompute the current value.\n      this.stale = false;\n      return;\n    }\n\n    // The current value is stale, and needs to be recomputed. It still may not change -\n    // that depends on whether the newly computed value is equal to the old.\n    this.recomputeValue();\n  }\n\n  private recomputeValue(): void {\n    if (this.value === COMPUTING) {\n      // Our computation somehow led to a cyclic read of itself.\n      throw new Error('Detected cycle in computations.');\n    }\n\n    const oldValue = this.value;\n    this.value = COMPUTING;\n\n    // As we're re-running the computation, update our dependent tracking version number.\n    this.trackingVersion++;\n    const prevConsumer = setActiveConsumer(this);\n    let newValue: T;\n    try {\n      newValue = this.computation();\n    } catch (err) {\n      newValue = ERRORED;\n      this.error = err;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n\n    this.stale = false;\n\n    if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n        this.equal(oldValue, newValue)) {\n      // No change to `valueVersion` - old and new values are\n      // semantically equivalent.\n      this.value = oldValue;\n      return;\n    }\n\n    this.value = newValue;\n    this.valueVersion++;\n  }\n\n  signal(): T {\n    // Check if the value needs updating before returning it.\n    this.onProducerUpdateValueVersion();\n\n    // Record that someone looked at this signal.\n    this.producerAccessed();\n\n    if (this.value === ERRORED) {\n      throw this.error;\n    }\n\n    return this.value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nfunction defaultThrowError(): never {\n  throw new Error();\n}\n\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\n\nexport function throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\n\nexport function setThrowInvalidWriteToSignalError(fn: () => never): void {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createSignalFromFunction, defaultEquals, Signal, ValueEqualityFn} from './api';\nimport {throwInvalidWriteToSignalError} from './errors';\nimport {ReactiveNode} from './graph';\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn: (() => void)|null = null;\n\n/**\n * A `Signal` with a value that can be mutated via a setter interface.\n *\n * @developerPreview\n */\nexport interface WritableSignal<T> extends Signal<T> {\n  /**\n   * Directly set the signal to a new value, and notify any dependents.\n   */\n  set(value: T): void;\n\n  /**\n   * Update the value of the signal based on its current value, and\n   * notify any dependents.\n   */\n  update(updateFn: (value: T) => T): void;\n\n  /**\n   * Update the current value by mutating it in-place, and\n   * notify any dependents.\n   */\n  mutate(mutatorFn: (value: T) => void): void;\n\n  /**\n   * Returns a readonly version of this signal. Readonly signals can be accessed to read their value\n   * but can't be changed using set, update or mutate methods. The readonly signals do _not_ have\n   * any built-in mechanism that would prevent deep-mutation of their value.\n   */\n  asReadonly(): Signal<T>;\n}\n\nclass WritableSignalImpl<T> extends ReactiveNode {\n  private readonlySignal: Signal<T>|undefined;\n\n  protected override readonly consumerAllowSignalWrites = false;\n\n  constructor(private value: T, private equal: ValueEqualityFn<T>) {\n    super();\n  }\n\n  protected override onConsumerDependencyMayHaveChanged(): void {\n    // This never happens for writable signals as they're not consumers.\n  }\n\n  protected override onProducerUpdateValueVersion(): void {\n    // Writable signal value versions are always up to date.\n  }\n\n  /**\n   * Directly update the value of the signal to a new value, which may or may not be\n   * equal to the previous.\n   *\n   * In the event that `newValue` is semantically equal to the current value, `set` is\n   * a no-op.\n   */\n  set(newValue: T): void {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    if (!this.equal(this.value, newValue)) {\n      this.value = newValue;\n      this.valueVersion++;\n      this.producerMayHaveChanged();\n\n      postSignalSetFn?.();\n    }\n  }\n\n  /**\n   * Derive a new value for the signal from its current value using the `updater` function.\n   *\n   * This is equivalent to calling `set` on the result of running `updater` on the current\n   * value.\n   */\n  update(updater: (value: T) => T): void {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    this.set(updater(this.value));\n  }\n\n  /**\n   * Calls `mutator` on the current value and assumes that it has been mutated.\n   */\n  mutate(mutator: (value: T) => void): void {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    // Mutate bypasses equality checks as it's by definition changing the value.\n    mutator(this.value);\n    this.valueVersion++;\n    this.producerMayHaveChanged();\n\n    postSignalSetFn?.();\n  }\n\n  asReadonly(): Signal<T> {\n    if (this.readonlySignal === undefined) {\n      this.readonlySignal = createSignalFromFunction(this, () => this.signal());\n    }\n    return this.readonlySignal;\n  }\n\n  signal(): T {\n    this.producerAccessed();\n    return this.value;\n  }\n}\n\n/**\n * Options passed to the `signal` creation function.\n *\n * @developerPreview\n */\nexport interface CreateSignalOptions<T> {\n  /**\n   * A comparison function which defines equality for signal values.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nexport function signal<T>(initialValue: T, options?: CreateSignalOptions<T>): WritableSignal<T> {\n  const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);\n\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {\n                     set: signalNode.set.bind(signalNode),\n                     update: signalNode.update.bind(signalNode),\n                     mutate: signalNode.mutate.bind(signalNode),\n                     asReadonly: signalNode.asReadonly.bind(signalNode)\n                   }) as unknown as WritableSignal<T>;\n  return signalFn;\n}\n\nexport function setPostSignalSetFn(fn: (() => void)|null): (() => void)|null {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {setActiveConsumer} from './graph';\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReactiveNode, setActiveConsumer} from './graph';\n\n/**\n * A cleanup function that can be optionally registered from the watch logic. If registered, the\n * cleanup logic runs before the next watch execution.\n */\nexport type WatchCleanupFn = () => void;\n\n/**\n * A callback passed to the watch function that makes it possible to register cleanup logic.\n */\nexport type WatchCleanupRegisterFn = (cleanupFn: WatchCleanupFn) => void;\n\nconst NOOP_CLEANUP_FN: WatchCleanupFn = () => {};\n\n/**\n * Watches a reactive expression and allows it to be scheduled to re-run\n * when any dependencies notify of a change.\n *\n * `Watch` doesn't run reactive expressions itself, but relies on a consumer-\n * provided scheduling operation to coordinate calling `Watch.run()`.\n */\nexport class Watch extends ReactiveNode {\n  protected override readonly consumerAllowSignalWrites: boolean;\n  private dirty = false;\n  private cleanupFn = NOOP_CLEANUP_FN;\n  private registerOnCleanup =\n      (cleanupFn: WatchCleanupFn) => {\n        this.cleanupFn = cleanupFn;\n      }\n\n  constructor(\n      private watch: (onCleanup: WatchCleanupRegisterFn) => void,\n      private schedule: (watch: Watch) => void, allowSignalWrites: boolean) {\n    super();\n    this.consumerAllowSignalWrites = allowSignalWrites;\n  }\n\n  notify(): void {\n    if (!this.dirty) {\n      this.schedule(this);\n    }\n    this.dirty = true;\n  }\n\n  protected override onConsumerDependencyMayHaveChanged(): void {\n    this.notify();\n  }\n\n  protected override onProducerUpdateValueVersion(): void {\n    // Watches are not producers.\n  }\n\n  /**\n   * Execute the reactive expression in the context of this `Watch` consumer.\n   *\n   * Should be called by the user scheduling algorithm when the provided\n   * `schedule` hook is called by `Watch`.\n   */\n  run(): void {\n    this.dirty = false;\n    if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) {\n      return;\n    }\n\n    const prevConsumer = setActiveConsumer(this);\n    this.trackingVersion++;\n    try {\n      this.cleanupFn();\n      this.cleanupFn = NOOP_CLEANUP_FN;\n      this.watch(this.registerOnCleanup);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n\n  cleanup() {\n    this.cleanupFn();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, computed, DestroyRef, inject, Injector, signal, Signal, WritableSignal} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../src/errors';\nimport {untracked} from '../../src/signals';\n\n/**\n * Options for `toSignal`.\n *\n * @publicApi\n */\nexport interface ToSignalOptions<T> {\n  /**\n   * Initial value for the signal produced by `toSignal`.\n   *\n   * This will be the value of the signal until the observable emits its first value.\n   */\n  initialValue?: T;\n\n  /**\n   * Whether to require that the observable emits synchronously when `toSignal` subscribes.\n   *\n   * If this is `true`, `toSignal` will assert that the observable produces a value immediately upon\n   * subscription. Setting this option removes the need to either deal with `undefined` in the\n   * signal type or provide an `initialValue`, at the cost of a runtime error if this requirement is\n   * not met.\n   */\n  requireSync?: boolean;\n\n  /**\n   * `Injector` which will provide the `DestroyRef` used to clean up the Observable subscription.\n   *\n   * If this is not provided, a `DestroyRef` will be retrieved from the current injection context,\n   * unless manual cleanup is requested.\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the subscription should be automatically cleaned up (via `DestroyRef`) when\n   * `toObservable`'s creation context is destroyed.\n   *\n   * If manual cleanup is enabled, then `DestroyRef` is not used, and the subscription will persist\n   * until the `Observable` itself completes.\n   */\n  manualCleanup?: boolean;\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * Before the `Observable` emits its first value, the `Signal` will return `undefined`. To avoid\n * this, either an `initialValue` can be passed or the `requireSync` option enabled.\n *\n * By default, the subscription will be automatically cleaned up when the current injection context\n * is destroyed. For example, when `toObservable` is called during the construction of a component,\n * the subscription will be cleaned up when the component is destroyed. If an injection context is\n * not available, an explicit `Injector` can be passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n */\nexport function toSignal<T>(source: Observable<T>): Signal<T|undefined>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * Before the `Observable` emits its first value, the `Signal` will return the configured\n * `initialValue`, or `undefined` if no `initialValue` is provided. If the `Observable` is\n * guaranteed to emit synchronously, then the `requireSync` option can be passed instead.\n *\n * By default, the subscription will be automatically cleaned up when the current injection context\n * is destroyed. For example, when `toObservable` is called during the construction of a component,\n * the subscription will be cleaned up when the component is destroyed. If an injection context is\n * not available, an explicit `Injector` can be passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T>(\n    source: Observable<T>,\n    options?: ToSignalOptions<undefined>&{requireSync?: false}): Signal<T|undefined>;\n\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * Before the `Observable` emits its first value, the `Signal` will return the configured\n * `initialValue`. If the `Observable` is guaranteed to emit synchronously, then the `requireSync`\n * option can be passed instead.\n *\n * By default, the subscription will be automatically cleaned up when the current injection context\n * is destroyed. For example, when `toObservable` is called during the construction of a component,\n * the subscription will be cleaned up when the component is destroyed. If an injection context is\n * not available, an explicit `Injector` can be passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T, U extends T|null|undefined>(\n    source: Observable<T>,\n    options: ToSignalOptions<U>&{initialValue: U, requireSync?: false}): Signal<T|U>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current injection context\n * is destroyed. For example, when `toObservable` is called during the construction of a component,\n * the subscription will be cleaned up when the component is destroyed. If an injection context is\n * not available, an explicit `Injector` can be passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T>(\n    source: Observable<T>, options: ToSignalOptions<undefined>&{requireSync: true}): Signal<T>;\nexport function toSignal<T, U = undefined>(\n    source: Observable<T>, options?: ToSignalOptions<U>): Signal<T|U> {\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef =\n      requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T|U>>;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({kind: StateKind.NoValue});\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal<State<T|U>>({kind: StateKind.Value, value: options?.initialValue as U});\n  }\n\n  const sub = source.subscribe({\n    next: value => state.set({kind: StateKind.Value, value}),\n    error: error => state.set({kind: StateKind.Error, error}),\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (ngDevMode && options?.requireSync && untracked(state).kind === StateKind.NoValue) {\n    throw new RuntimeError(\n        RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n        '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case StateKind.Value:\n        return current.value;\n      case StateKind.Error:\n        throw current.error;\n      case StateKind.NoValue:\n        // This shouldn't really happen because the error is thrown on creation.\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new RuntimeError(\n            RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  });\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState|ValueState<T>|ErrorState;\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["untracked","global","signal","computed"],"mappings":"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"}