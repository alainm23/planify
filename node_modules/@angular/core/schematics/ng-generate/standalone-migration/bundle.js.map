{
  "version": 3,
  "sources": ["../../../../../../../../packages/core/schematics/ng-generate/standalone-migration/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/compiler_host.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/invalid_file_system.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/helpers.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/logical.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/node_js_file_system.ts", "../../../../../../../../packages/compiler/src/selector.ts", "../../../../../../../../packages/compiler/src/core.ts", "../../../../../../../../packages/compiler/src/i18n/big_integer.ts", "../../../../../../../../packages/compiler/src/i18n/digest.ts", "../../../../../../../../packages/compiler/src/output/output_ast.ts", "../../../../../../../../packages/compiler/src/constant_pool.ts", "../../../../../../../../packages/compiler/src/render3/r3_identifiers.ts", "../../../../../../../../packages/compiler/src/util.ts", "../../../../../../../../packages/compiler/src/output/source_map.ts", "../../../../../../../../packages/compiler/src/output/abstract_emitter.ts", "../../../../../../../../packages/compiler/src/render3/util.ts", "../../../../../../../../packages/compiler/src/render3/r3_factory.ts", "../../../../../../../../packages/compiler/src/render3/r3_ast.ts", "../../../../../../../../packages/compiler/src/i18n/i18n_ast.ts", "../../../../../../../../packages/compiler/src/i18n/serializers/serializer.ts", "../../../../../../../../packages/compiler/src/i18n/serializers/xml_helper.ts", "../../../../../../../../packages/compiler/src/i18n/serializers/xmb.ts", "../../../../../../../../packages/compiler/src/render3/view/i18n/util.ts", "../../../../../../../../packages/compiler/src/render3/view/util.ts", "../../../../../../../../packages/compiler/src/injectable_compiler_2.ts", "../../../../../../../../packages/compiler/src/assertions.ts", "../../../../../../../../packages/compiler/src/ml_parser/interpolation_config.ts", "../../../../../../../../packages/compiler/src/chars.ts", "../../../../../../../../packages/compiler/src/parse_util.ts", "../../../../../../../../packages/compiler/src/output/abstract_js_emitter.ts", "../../../../../../../../packages/compiler/src/output/output_jit_trusted_types.ts", "../../../../../../../../packages/compiler/src/output/output_jit.ts", "../../../../../../../../packages/compiler/src/render3/r3_injector_compiler.ts", "../../../../../../../../packages/compiler/src/render3/r3_jit.ts", "../../../../../../../../packages/compiler/src/render3/r3_module_compiler.ts", "../../../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts", "../../../../../../../../packages/compiler/src/render3/view/api.ts", "../../../../../../../../packages/compiler/src/expression_parser/ast.ts", "../../../../../../../../packages/compiler/src/compiler_util/expression_converter.ts", "../../../../../../../../packages/compiler/src/schema/dom_security_schema.ts", "../../../../../../../../packages/compiler/src/shadow_css.ts", "../../../../../../../../packages/compiler/src/ml_parser/tags.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/element.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/enums.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/traits.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/expression.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/operations.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/shared.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/create.ts", "../../../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/update.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/const_collection.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/empty_elements.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_advance.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/instruction.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/reify.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/slot_allocation.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/var_counting.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/naming.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/local_refs.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_variables.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_names.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_contexts.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/chaining.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/phases/next_context_merging.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/emit.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/compilation.ts", "../../../../../../../../packages/compiler/src/template/pipeline/src/ingest.ts", "../../../../../../../../packages/compiler/src/template/pipeline/switch/index.ts", "../../../../../../../../packages/compiler/src/render3/view/style_parser.ts", "../../../../../../../../packages/compiler/src/render3/view/styling_builder.ts", "../../../../../../../../packages/compiler/src/expression_parser/lexer.ts", "../../../../../../../../packages/compiler/src/expression_parser/parser.ts", "../../../../../../../../packages/compiler/src/ml_parser/ast.ts", "../../../../../../../../packages/compiler/src/schema/element_schema_registry.ts", "../../../../../../../../packages/compiler/src/schema/dom_element_schema_registry.ts", "../../../../../../../../packages/compiler/src/ml_parser/html_tags.ts", "../../../../../../../../packages/compiler/src/ml_parser/entities.ts", "../../../../../../../../packages/compiler/src/ml_parser/lexer.ts", "../../../../../../../../packages/compiler/src/ml_parser/parser.ts", "../../../../../../../../packages/compiler/src/ml_parser/html_parser.ts", "../../../../../../../../packages/compiler/src/ml_parser/html_whitespaces.ts", "../../../../../../../../packages/compiler/src/output/map_util.ts", "../../../../../../../../packages/compiler/src/schema/trusted_types_sinks.ts", "../../../../../../../../packages/compiler/src/template_parser/binding_parser.ts", "../../../../../../../../packages/compiler/src/style_url_resolver.ts", "../../../../../../../../packages/compiler/src/template_parser/template_preparser.ts", "../../../../../../../../packages/compiler/src/render3/r3_template_transform.ts", "../../../../../../../../packages/compiler/src/render3/view/i18n/context.ts", "../../../../../../../../packages/compiler/src/render3/view/i18n/icu_serializer.ts", "../../../../../../../../packages/compiler/src/i18n/serializers/placeholder.ts", "../../../../../../../../packages/compiler/src/i18n/i18n_parser.ts", "../../../../../../../../packages/compiler/src/i18n/parse_util.ts", "../../../../../../../../packages/compiler/src/render3/view/i18n/meta.ts", "../../../../../../../../packages/compiler/src/render3/view/i18n/get_msg_utils.ts", "../../../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts", "../../../../../../../../packages/compiler/src/render3/view/template.ts", "../../../../../../../../packages/compiler/src/render3/view/compiler.ts", "../../../../../../../../packages/compiler/src/resource_loader.ts", "../../../../../../../../packages/compiler/src/jit_compiler_facade.ts", "../../../../../../../../packages/compiler/src/version.ts", "../../../../../../../../packages/compiler/src/i18n/extractor_merger.ts", "../../../../../../../../packages/compiler/src/ml_parser/xml_tags.ts", "../../../../../../../../packages/compiler/src/ml_parser/xml_parser.ts", "../../../../../../../../packages/compiler/src/i18n/serializers/xliff.ts", "../../../../../../../../packages/compiler/src/i18n/serializers/xliff2.ts", "../../../../../../../../packages/compiler/src/i18n/message_bundle.ts", "../../../../../../../../packages/compiler/src/render3/partial/api.ts", "../../../../../../../../packages/compiler/src/render3/view/t2_binder.ts", "../../../../../../../../packages/compiler/src/render3/r3_class_metadata_compiler.ts", "../../../../../../../../packages/compiler/src/render3/partial/class_metadata.ts", "../../../../../../../../packages/compiler/src/render3/partial/util.ts", "../../../../../../../../packages/compiler/src/render3/partial/directive.ts", "../../../../../../../../packages/compiler/src/render3/partial/component.ts", "../../../../../../../../packages/compiler/src/render3/partial/factory.ts", "../../../../../../../../packages/compiler/src/render3/partial/injectable.ts", "../../../../../../../../packages/compiler/src/render3/partial/injector.ts", "../../../../../../../../packages/compiler/src/render3/partial/ng_module.ts", "../../../../../../../../packages/compiler/src/render3/partial/pipe.ts", "../../../../../../../../packages/compiler/src/compiler.ts", "../../../../../../../../packages/compiler-cli/src/version.ts", "../../../../../../../../packages/compiler-cli/src/transformers/api.ts", "../../../../../../../../packages/compiler-cli/src/transformers/compiler_host.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/program.ts", "../../../../../../../../packages/compiler-cli/src/transformers/i18n.ts", "../../../../../../../../packages/compiler-cli/src/typescript_support.ts", "../../../../../../../../packages/compiler-cli/src/version_helpers.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/core/src/compiler.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/di.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/diagnostics/src/docs.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/diagnostics/src/error.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/diagnostics/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/diagnostics/src/extended_template_diagnostic_name.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/emitter.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/util/src/typescript.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/find_export.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/alias.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/util/src/path.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/core.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/patch_alias_reference_resolution.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/default.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/references.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/resolver.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/diagnostics.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/dts.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/host.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/type_to_value.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/typescript.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/inheritance.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/registry.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/resource_registry.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/providers.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/host_directives_resolver.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/result.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/builtin.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/synthetic.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/evaluation.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/factory.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/injectable_registry.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/metadata.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/references_registry.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/common/src/schema.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/component/src/handler.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/perf/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/perf/src/noop.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/perf/src/clock.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/perf/src/recorder.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/component_scope.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/dependency.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/local.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/typecheck.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/alias.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/compilation.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/trait.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/declaration.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/context.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/import_manager.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/translator.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/type_translator.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/typescript_translator.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/utils.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/transform.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/util/src/visitor.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/directive/src/shared.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/directive/src/symbol.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/directive/src/handler.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/ng_module/src/handler.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/ng_module/src/module_with_providers.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/component/src/diagnostics.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/component/src/resources.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/component/src/symbol.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/component/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/cycles/src/analyzer.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/cycles/src/imports.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/entry_point/src/generator.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/entry_point/src/logic.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/entry_point/src/private_export_checker.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/entry_point/src/reference_graph.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/program_driver/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/program_driver/src/ts_create_program_driver.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/adapter.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/expando.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/reference_tagger.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/dependency_tracking.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/state.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/incremental.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/strategy.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/indexer/src/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/indexer/src/context.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/indexer/src/template.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/indexer/src/transform.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/ng_module_index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/resource/src/loader.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/standalone.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/completion.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/scope.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/diagnostic.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/id.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/completion.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/comments.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/context.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/dom.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/ts_util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/oob.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/shim.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/expression.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/template_semantics.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_check_file.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/line_mappings.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/source.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/api/api.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/invalid_banana_in_box/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/missing_control_flow_directive/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/missing_ngforof_let/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/nullish_coalescing_not_nullable/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/optional_chain_not_nullable/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/suffix_not_supported/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/checks/text_attribute_not_binding/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/src/extended_template_checker.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/core/api/src/public_options.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/extended/index.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/core/src/host.ts", "../../../../../../../../packages/compiler-cli/src/transformers/program.ts", "../../../../../../../../packages/compiler-cli/src/perform_compile.ts", "../../../../../../../../packages/compiler-cli/src/transformers/util.ts", "../../../../../../../../packages/compiler-cli/src/transformers/downlevel_decorators_transform/downlevel_decorators_transform.ts", "../../../../../../../../packages/compiler-cli/private/tooling.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/logging/src/logger.ts", "../../../../../../../../packages/compiler-cli/src/ngtsc/logging/src/console_logger.ts", "../../../../../../../../packages/compiler-cli/index.ts", "../../../../../../../../packages/core/schematics/utils/change_tracker.ts", "../../../../../../../../packages/core/schematics/utils/import_manager.ts", "../../../../../../../../packages/core/schematics/utils/project_tsconfig_paths.ts", "../../../../../../../../packages/core/schematics/utils/typescript/compiler_host.ts", "../../../../../../../../packages/core/schematics/utils/typescript/parse_tsconfig.ts", "../../../../../../../../packages/core/schematics/ng-generate/standalone-migration/prune-modules.ts", "../../../../../../../../packages/core/schematics/utils/typescript/decorators.ts", "../../../../../../../../packages/core/schematics/utils/typescript/imports.ts", "../../../../../../../../packages/core/schematics/utils/ng_decorators.ts", "../../../../../../../../packages/core/schematics/utils/typescript/nodes.ts", "../../../../../../../../packages/core/schematics/ng-generate/standalone-migration/util.ts", "../../../../../../../../packages/core/schematics/ng-generate/standalone-migration/standalone-bootstrap.ts", "../../../../../../../../packages/core/schematics/ng-generate/standalone-migration/to-standalone.ts", "../../../../../../../../packages/core/schematics/utils/typescript/symbol.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\nimport {createProgram, NgtscProgram} from '@angular/compiler-cli';\nimport {existsSync, statSync} from 'fs';\nimport {join, relative} from 'path';\nimport ts from 'typescript';\n\nimport {ChangesByFile, normalizePath} from '../../utils/change_tracker';\nimport {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\nimport {canMigrateFile, createProgramOptions} from '../../utils/typescript/compiler_host';\n\nimport {pruneNgModules} from './prune-modules';\nimport {toStandaloneBootstrap} from './standalone-bootstrap';\nimport {toStandalone} from './to-standalone';\nimport {knownInternalAliasRemapper} from './util';\n\nenum MigrationMode {\n  toStandalone = 'convert-to-standalone',\n  pruneModules = 'prune-ng-modules',\n  standaloneBootstrap = 'standalone-bootstrap',\n}\n\ninterface Options {\n  path: string;\n  mode: MigrationMode;\n}\n\nexport default function(options: Options): Rule {\n  return async (tree, context) => {\n    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n    const basePath = process.cwd();\n    const allPaths = [...buildPaths, ...testPaths];\n    // TS and Schematic use paths in POSIX format even on Windows. This is needed as otherwise\n    // string matching such as `sourceFile.fileName.startsWith(pathToMigrate)` might not work.\n    const pathToMigrate = normalizePath(join(basePath, options.path));\n    let migratedFiles = 0;\n\n    if (!allPaths.length) {\n      throw new SchematicsException(\n          'Could not find any tsconfig file. Cannot run the standalone migration.');\n    }\n\n    for (const tsconfigPath of allPaths) {\n      migratedFiles += standaloneMigration(tree, tsconfigPath, basePath, pathToMigrate, options);\n    }\n\n    if (migratedFiles === 0) {\n      throw new SchematicsException(`Could not find any files to migrate under the path ${\n          pathToMigrate}. Cannot run the standalone migration.`);\n    }\n\n    context.logger.info('ðŸŽ‰ Automated migration step has finished! ðŸŽ‰');\n    context.logger.info(\n        'IMPORTANT! Please verify manually that your application builds and behaves as expected.');\n    context.logger.info(`See https://angular.io/guide/standalone-migration for more information.`);\n  };\n}\n\nfunction standaloneMigration(\n    tree: Tree, tsconfigPath: string, basePath: string, pathToMigrate: string,\n    schematicOptions: Options, oldProgram?: NgtscProgram): number {\n  if (schematicOptions.path.startsWith('..')) {\n    throw new SchematicsException(\n        'Cannot run standalone migration outside of the current project.');\n  }\n\n  const {host, options, rootNames} = createProgramOptions(\n      tree, tsconfigPath, basePath, undefined, undefined,\n      {\n        _enableTemplateTypeChecker: true,  // Required for the template type checker to work.\n        compileNonExportedClasses: true,   // We want to migrate non-exported classes too.\n        // Avoid checking libraries to speed up the migration.\n        skipLibCheck: true,\n        skipDefaultLibCheck: true,\n      });\n  const referenceLookupExcludedFiles = /node_modules|\\.ngtypecheck\\.ts/;\n  const program = createProgram({rootNames, host, options, oldProgram}) as NgtscProgram;\n  const printer = ts.createPrinter();\n\n  if (existsSync(pathToMigrate) && !statSync(pathToMigrate).isDirectory()) {\n    throw new SchematicsException(`Migration path ${\n        pathToMigrate} has to be a directory. Cannot run the standalone migration.`);\n  }\n\n  const sourceFiles = program.getTsProgram().getSourceFiles().filter(\n      sourceFile => sourceFile.fileName.startsWith(pathToMigrate) &&\n          canMigrateFile(basePath, sourceFile, program.getTsProgram()));\n\n  if (sourceFiles.length === 0) {\n    return 0;\n  }\n\n  let pendingChanges: ChangesByFile;\n  let filesToRemove: Set<ts.SourceFile>|null = null;\n\n  if (schematicOptions.mode === MigrationMode.pruneModules) {\n    const result = pruneNgModules(\n        program, host, basePath, rootNames, sourceFiles, printer, undefined,\n        referenceLookupExcludedFiles);\n    pendingChanges = result.pendingChanges;\n    filesToRemove = result.filesToRemove;\n  } else if (schematicOptions.mode === MigrationMode.standaloneBootstrap) {\n    pendingChanges = toStandaloneBootstrap(\n        program, host, basePath, rootNames, sourceFiles, printer, undefined,\n        referenceLookupExcludedFiles, knownInternalAliasRemapper);\n  } else {\n    // This shouldn't happen, but default to `MigrationMode.toStandalone` just in case.\n    pendingChanges =\n        toStandalone(sourceFiles, program, printer, undefined, knownInternalAliasRemapper);\n  }\n\n  for (const [file, changes] of pendingChanges.entries()) {\n    // Don't attempt to edit a file if it's going to be deleted.\n    if (filesToRemove?.has(file)) {\n      continue;\n    }\n\n    const update = tree.beginUpdate(relative(basePath, file.fileName));\n\n    changes.forEach(change => {\n      if (change.removeLength != null) {\n        update.remove(change.start, change.removeLength);\n      }\n      update.insertRight(change.start, change.text);\n    });\n\n    tree.commitUpdate(update);\n  }\n\n  if (filesToRemove) {\n    for (const file of filesToRemove) {\n      tree.delete(relative(basePath, file.fileName));\n    }\n  }\n\n  // Run the module pruning after the standalone bootstrap to automatically remove the root module.\n  // Note that we can't run the module pruning internally without propagating the changes to disk,\n  // because there may be conflicting AST node changes.\n  if (schematicOptions.mode === MigrationMode.standaloneBootstrap) {\n    return standaloneMigration(\n               tree, tsconfigPath, basePath, pathToMigrate,\n               {...schematicOptions, mode: MigrationMode.pruneModules}, program) +\n        sourceFiles.length;\n  }\n\n  return sourceFiles.length;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"node\" />\nimport * as os from 'os';\nimport ts from 'typescript';\n\nimport {absoluteFrom} from './helpers';\nimport {FileSystem} from './types';\n\nexport class NgtscCompilerHost implements ts.CompilerHost {\n  constructor(protected fs: FileSystem, protected options: ts.CompilerOptions = {}) {}\n\n  getSourceFile(fileName: string, languageVersion: ts.ScriptTarget): ts.SourceFile|undefined {\n    const text = this.readFile(fileName);\n    return text !== undefined ? ts.createSourceFile(fileName, text, languageVersion, true) :\n                                undefined;\n  }\n\n  getDefaultLibFileName(options: ts.CompilerOptions): string {\n    return this.fs.join(this.getDefaultLibLocation(), ts.getDefaultLibFileName(options));\n  }\n\n  getDefaultLibLocation(): string {\n    return this.fs.getDefaultLibLocation();\n  }\n\n  writeFile(\n      fileName: string, data: string, writeByteOrderMark: boolean,\n      onError: ((message: string) => void)|undefined,\n      sourceFiles?: ReadonlyArray<ts.SourceFile>): void {\n    const path = absoluteFrom(fileName);\n    this.fs.ensureDir(this.fs.dirname(path));\n    this.fs.writeFile(path, data);\n  }\n\n  getCurrentDirectory(): string {\n    return this.fs.pwd();\n  }\n\n  getCanonicalFileName(fileName: string): string {\n    return this.useCaseSensitiveFileNames() ? fileName : fileName.toLowerCase();\n  }\n\n  useCaseSensitiveFileNames(): boolean {\n    return this.fs.isCaseSensitive();\n  }\n\n  getNewLine(): string {\n    switch (this.options.newLine) {\n      case ts.NewLineKind.CarriageReturnLineFeed:\n        return '\\r\\n';\n      case ts.NewLineKind.LineFeed:\n        return '\\n';\n      default:\n        return os.EOL;\n    }\n  }\n\n  fileExists(fileName: string): boolean {\n    const absPath = this.fs.resolve(fileName);\n    return this.fs.exists(absPath) && this.fs.stat(absPath).isFile();\n  }\n\n  readFile(fileName: string): string|undefined {\n    const absPath = this.fs.resolve(fileName);\n    if (!this.fileExists(absPath)) {\n      return undefined;\n    }\n    return this.fs.readFile(absPath);\n  }\n\n  realpath(path: string): string {\n    return this.fs.realpath(this.fs.resolve(path));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, FileStats, FileSystem, PathSegment, PathString} from './types';\n\n/**\n * The default `FileSystem` that will always fail.\n *\n * This is a way of ensuring that the developer consciously chooses and\n * configures the `FileSystem` before using it; particularly important when\n * considering static functions like `absoluteFrom()` which rely on\n * the `FileSystem` under the hood.\n */\nexport class InvalidFileSystem implements FileSystem {\n  exists(path: AbsoluteFsPath): boolean {\n    throw makeError();\n  }\n  readFile(path: AbsoluteFsPath): string {\n    throw makeError();\n  }\n  readFileBuffer(path: AbsoluteFsPath): Uint8Array {\n    throw makeError();\n  }\n  writeFile(path: AbsoluteFsPath, data: string|Uint8Array, exclusive?: boolean): void {\n    throw makeError();\n  }\n  removeFile(path: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  symlink(target: AbsoluteFsPath, path: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  readdir(path: AbsoluteFsPath): PathSegment[] {\n    throw makeError();\n  }\n  lstat(path: AbsoluteFsPath): FileStats {\n    throw makeError();\n  }\n  stat(path: AbsoluteFsPath): FileStats {\n    throw makeError();\n  }\n  pwd(): AbsoluteFsPath {\n    throw makeError();\n  }\n  chdir(path: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  extname(path: AbsoluteFsPath|PathSegment): string {\n    throw makeError();\n  }\n  copyFile(from: AbsoluteFsPath, to: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  moveFile(from: AbsoluteFsPath, to: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  ensureDir(path: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  removeDeep(path: AbsoluteFsPath): void {\n    throw makeError();\n  }\n  isCaseSensitive(): boolean {\n    throw makeError();\n  }\n  resolve(...paths: string[]): AbsoluteFsPath {\n    throw makeError();\n  }\n  dirname<T extends PathString>(file: T): T {\n    throw makeError();\n  }\n  join<T extends PathString>(basePath: T, ...paths: string[]): T {\n    throw makeError();\n  }\n  isRoot(path: AbsoluteFsPath): boolean {\n    throw makeError();\n  }\n  isRooted(path: string): boolean {\n    throw makeError();\n  }\n  relative<T extends PathString>(from: T, to: T): PathSegment|AbsoluteFsPath {\n    throw makeError();\n  }\n  basename(filePath: string, extension?: string): PathSegment {\n    throw makeError();\n  }\n  realpath(filePath: AbsoluteFsPath): AbsoluteFsPath {\n    throw makeError();\n  }\n  getDefaultLibLocation(): AbsoluteFsPath {\n    throw makeError();\n  }\n  normalize<T extends PathString>(path: T): T {\n    throw makeError();\n  }\n}\n\nfunction makeError() {\n  return new Error(\n      'FileSystem has not been configured. Please call `setFileSystem()` before calling this method.');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\nimport {AbsoluteFsPath, PathString} from './types';\n\nconst TS_DTS_JS_EXTENSION = /(?:\\.d)?\\.ts$|\\.js$/;\n\n/**\n * Convert Windows-style separators to POSIX separators.\n */\nexport function normalizeSeparators(path: string): string {\n  // TODO: normalize path only for OS that need it.\n  return path.replace(/\\\\/g, '/');\n}\n\n/**\n * Remove a .ts, .d.ts, or .js extension from a file name.\n */\nexport function stripExtension<T extends PathString>(path: T): T {\n  return path.replace(TS_DTS_JS_EXTENSION, '') as T;\n}\n\nexport function getSourceFileOrError(program: ts.Program, fileName: AbsoluteFsPath): ts.SourceFile {\n  const sf = program.getSourceFile(fileName);\n  if (sf === undefined) {\n    throw new Error(`Program does not contain \"${fileName}\" - available files are ${\n        program.getSourceFiles().map(sf => sf.fileName).join(', ')}`);\n  }\n  return sf;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {InvalidFileSystem} from './invalid_file_system';\nimport {AbsoluteFsPath, FileSystem, PathSegment, PathString} from './types';\nimport {normalizeSeparators} from './util';\n\nlet fs: FileSystem = new InvalidFileSystem();\nexport function getFileSystem(): FileSystem {\n  return fs;\n}\nexport function setFileSystem(fileSystem: FileSystem) {\n  fs = fileSystem;\n}\n\n/**\n * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.\n */\nexport function absoluteFrom(path: string): AbsoluteFsPath {\n  if (!fs.isRooted(path)) {\n    throw new Error(`Internal Error: absoluteFrom(${path}): path is not absolute`);\n  }\n  return fs.resolve(path);\n}\n\nconst ABSOLUTE_PATH = Symbol('AbsolutePath');\n\n/**\n * Extract an `AbsoluteFsPath` from a `ts.SourceFile`-like object.\n */\nexport function absoluteFromSourceFile(sf: {fileName: string}): AbsoluteFsPath {\n  const sfWithPatch = sf as {fileName: string, [ABSOLUTE_PATH]?: AbsoluteFsPath};\n\n  if (sfWithPatch[ABSOLUTE_PATH] === undefined) {\n    sfWithPatch[ABSOLUTE_PATH] = fs.resolve(sfWithPatch.fileName);\n  }\n\n  // Non-null assertion needed since TS doesn't narrow the type of fields that use a symbol as a key\n  // apparently.\n  return sfWithPatch[ABSOLUTE_PATH]!;\n}\n\n/**\n * Convert the path `path` to a `PathSegment`, throwing an error if it's not a relative path.\n */\nexport function relativeFrom(path: string): PathSegment {\n  const normalized = normalizeSeparators(path);\n  if (fs.isRooted(normalized)) {\n    throw new Error(`Internal Error: relativeFrom(${path}): path is not relative`);\n  }\n  return normalized as PathSegment;\n}\n\n/**\n * Static access to `dirname`.\n */\nexport function dirname<T extends PathString>(file: T): T {\n  return fs.dirname(file);\n}\n\n/**\n * Static access to `join`.\n */\nexport function join<T extends PathString>(basePath: T, ...paths: string[]): T {\n  return fs.join(basePath, ...paths);\n}\n\n/**\n * Static access to `resolve`s.\n */\nexport function resolve(basePath: string, ...paths: string[]): AbsoluteFsPath {\n  return fs.resolve(basePath, ...paths);\n}\n\n/** Returns true when the path provided is the root path. */\nexport function isRoot(path: AbsoluteFsPath): boolean {\n  return fs.isRoot(path);\n}\n\n/**\n * Static access to `isRooted`.\n */\nexport function isRooted(path: string): boolean {\n  return fs.isRooted(path);\n}\n\n/**\n * Static access to `relative`.\n */\nexport function relative<T extends PathString>(from: T, to: T): PathSegment|AbsoluteFsPath {\n  return fs.relative(from, to);\n}\n\n/**\n * Static access to `basename`.\n */\nexport function basename(filePath: PathString, extension?: string): PathSegment {\n  return fs.basename(filePath, extension) as PathSegment;\n}\n\n/**\n * Returns true if the given path is locally relative.\n *\n * This is used to work out if the given path is relative (i.e. not absolute) but also is not\n * escaping the current directory.\n */\nexport function isLocalRelativePath(relativePath: string): boolean {\n  return !isRooted(relativePath) && !relativePath.startsWith('..');\n}\n\n/**\n * Converts a path to a form suitable for use as a relative module import specifier.\n *\n * In other words it adds the `./` to the path if it is locally relative.\n */\nexport function toRelativeImport(relativePath: PathSegment|AbsoluteFsPath): PathSegment|\n    AbsoluteFsPath {\n  return isLocalRelativePath(relativePath) ? `./${relativePath}` as PathSegment : relativePath;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {absoluteFromSourceFile, dirname, isLocalRelativePath, relative, resolve, toRelativeImport} from './helpers';\nimport {AbsoluteFsPath, BrandedPath, PathSegment} from './types';\nimport {stripExtension} from './util';\n\n\n\n/**\n * A path that's relative to the logical root of a TypeScript project (one of the project's\n * rootDirs).\n *\n * Paths in the type system use POSIX format.\n */\nexport type LogicalProjectPath = BrandedPath<'LogicalProjectPath'>;\n\nexport const LogicalProjectPath = {\n  /**\n   * Get the relative path between two `LogicalProjectPath`s.\n   *\n   * This will return a `PathSegment` which would be a valid module specifier to use in `from` when\n   * importing from `to`.\n   */\n  relativePathBetween: function(from: LogicalProjectPath, to: LogicalProjectPath): PathSegment {\n    const relativePath = relative(dirname(resolve(from)), resolve(to));\n    return toRelativeImport(relativePath) as PathSegment;\n  },\n};\n\n/**\n * A utility class which can translate absolute paths to source files into logical paths in\n * TypeScript's logical file system, based on the root directories of the project.\n */\nexport class LogicalFileSystem {\n  /**\n   * The root directories of the project, sorted with the longest path first.\n   */\n  private rootDirs: AbsoluteFsPath[];\n\n  /**\n   * The same root directories as `rootDirs` but with each one converted to its\n   * canonical form for matching in case-insensitive file-systems.\n   */\n  private canonicalRootDirs: AbsoluteFsPath[];\n\n  /**\n   * A cache of file paths to project paths, because computation of these paths is slightly\n   * expensive.\n   */\n  private cache: Map<AbsoluteFsPath, LogicalProjectPath|null> = new Map();\n\n  constructor(\n      rootDirs: AbsoluteFsPath[],\n      private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>) {\n    // Make a copy and sort it by length in reverse order (longest first). This speeds up lookups,\n    // since there's no need to keep going through the array once a match is found.\n    this.rootDirs = rootDirs.concat([]).sort((a, b) => b.length - a.length);\n    this.canonicalRootDirs =\n        this.rootDirs.map(dir => this.compilerHost.getCanonicalFileName(dir) as AbsoluteFsPath);\n  }\n\n  /**\n   * Get the logical path in the project of a `ts.SourceFile`.\n   *\n   * This method is provided as a convenient alternative to calling\n   * `logicalPathOfFile(absoluteFromSourceFile(sf))`.\n   */\n  logicalPathOfSf(sf: ts.SourceFile): LogicalProjectPath|null {\n    return this.logicalPathOfFile(absoluteFromSourceFile(sf));\n  }\n\n  /**\n   * Get the logical path in the project of a source file.\n   *\n   * @returns A `LogicalProjectPath` to the source file, or `null` if the source file is not in any\n   * of the TS project's root directories.\n   */\n  logicalPathOfFile(physicalFile: AbsoluteFsPath): LogicalProjectPath|null {\n    if (!this.cache.has(physicalFile)) {\n      const canonicalFilePath =\n          this.compilerHost.getCanonicalFileName(physicalFile) as AbsoluteFsPath;\n      let logicalFile: LogicalProjectPath|null = null;\n      for (let i = 0; i < this.rootDirs.length; i++) {\n        const rootDir = this.rootDirs[i];\n        const canonicalRootDir = this.canonicalRootDirs[i];\n        if (isWithinBasePath(canonicalRootDir, canonicalFilePath)) {\n          // Note that we match against canonical paths but then create the logical path from\n          // original paths.\n          logicalFile = this.createLogicalProjectPath(physicalFile, rootDir);\n          // The logical project does not include any special \"node_modules\" nested directories.\n          if (logicalFile.indexOf('/node_modules/') !== -1) {\n            logicalFile = null;\n          } else {\n            break;\n          }\n        }\n      }\n      this.cache.set(physicalFile, logicalFile);\n    }\n    return this.cache.get(physicalFile)!;\n  }\n\n  private createLogicalProjectPath(file: AbsoluteFsPath, rootDir: AbsoluteFsPath):\n      LogicalProjectPath {\n    const logicalPath = stripExtension(file.slice(rootDir.length));\n    return (logicalPath.startsWith('/') ? logicalPath : '/' + logicalPath) as LogicalProjectPath;\n  }\n}\n\n/**\n * Is the `path` a descendant of the `base`?\n * E.g. `foo/bar/zee` is within `foo/bar` but not within `foo/car`.\n */\nfunction isWithinBasePath(base: AbsoluteFsPath, path: AbsoluteFsPath): boolean {\n  return isLocalRelativePath(relative(base, path));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <reference types=\"node\" />\nimport fs from 'fs';\nimport module from 'module';\nimport * as p from 'path';\nimport {fileURLToPath} from 'url';\n\nimport {AbsoluteFsPath, FileStats, FileSystem, PathManipulation, PathSegment, PathString, ReadonlyFileSystem} from './types';\n\n/**\n * A wrapper around the Node.js file-system that supports path manipulation.\n */\nexport class NodeJSPathManipulation implements PathManipulation {\n  pwd(): AbsoluteFsPath {\n    return this.normalize(process.cwd()) as AbsoluteFsPath;\n  }\n  chdir(dir: AbsoluteFsPath): void {\n    process.chdir(dir);\n  }\n  resolve(...paths: string[]): AbsoluteFsPath {\n    return this.normalize(p.resolve(...paths)) as AbsoluteFsPath;\n  }\n\n  dirname<T extends string>(file: T): T {\n    return this.normalize(p.dirname(file)) as T;\n  }\n  join<T extends string>(basePath: T, ...paths: string[]): T {\n    return this.normalize(p.join(basePath, ...paths)) as T;\n  }\n  isRoot(path: AbsoluteFsPath): boolean {\n    return this.dirname(path) === this.normalize(path);\n  }\n  isRooted(path: string): boolean {\n    return p.isAbsolute(path);\n  }\n  relative<T extends PathString>(from: T, to: T): PathSegment|AbsoluteFsPath {\n    return this.normalize(p.relative(from, to)) as PathSegment | AbsoluteFsPath;\n  }\n  basename(filePath: string, extension?: string): PathSegment {\n    return p.basename(filePath, extension) as PathSegment;\n  }\n  extname(path: AbsoluteFsPath|PathSegment): string {\n    return p.extname(path);\n  }\n  normalize<T extends string>(path: T): T {\n    // Convert backslashes to forward slashes\n    return path.replace(/\\\\/g, '/') as T;\n  }\n}\n\n// G3-ESM-MARKER: G3 uses CommonJS, but externally everything in ESM.\n// CommonJS/ESM interop for determining the current file name and containing dir.\nconst isCommonJS = typeof __filename !== 'undefined';\nconst currentFileUrl = isCommonJS ? null : import.meta.url;\nconst currentFileName = isCommonJS ? __filename : fileURLToPath(currentFileUrl!);\n\n/**\n * A wrapper around the Node.js file-system that supports readonly operations and path manipulation.\n */\nexport class NodeJSReadonlyFileSystem extends NodeJSPathManipulation implements ReadonlyFileSystem {\n  private _caseSensitive: boolean|undefined = undefined;\n  isCaseSensitive(): boolean {\n    if (this._caseSensitive === undefined) {\n      // Note the use of the real file-system is intentional:\n      // `this.exists()` relies upon `isCaseSensitive()` so that would cause an infinite recursion.\n      this._caseSensitive = !fs.existsSync(this.normalize(toggleCase(currentFileName)));\n    }\n    return this._caseSensitive;\n  }\n  exists(path: AbsoluteFsPath): boolean {\n    return fs.existsSync(path);\n  }\n  readFile(path: AbsoluteFsPath): string {\n    return fs.readFileSync(path, 'utf8');\n  }\n  readFileBuffer(path: AbsoluteFsPath): Uint8Array {\n    return fs.readFileSync(path);\n  }\n  readdir(path: AbsoluteFsPath): PathSegment[] {\n    return fs.readdirSync(path) as PathSegment[];\n  }\n  lstat(path: AbsoluteFsPath): FileStats {\n    return fs.lstatSync(path);\n  }\n  stat(path: AbsoluteFsPath): FileStats {\n    return fs.statSync(path);\n  }\n  realpath(path: AbsoluteFsPath): AbsoluteFsPath {\n    return this.resolve(fs.realpathSync(path));\n  }\n  getDefaultLibLocation(): AbsoluteFsPath {\n    // G3-ESM-MARKER: G3 uses CommonJS, but externally everything in ESM.\n    const requireFn = isCommonJS ? require : module.createRequire(currentFileUrl!);\n    return this.resolve(requireFn.resolve('typescript'), '..');\n  }\n}\n\n/**\n * A wrapper around the Node.js file-system (i.e. the `fs` package).\n */\nexport class NodeJSFileSystem extends NodeJSReadonlyFileSystem implements FileSystem {\n  writeFile(path: AbsoluteFsPath, data: string|Uint8Array, exclusive: boolean = false): void {\n    fs.writeFileSync(path, data, exclusive ? {flag: 'wx'} : undefined);\n  }\n  removeFile(path: AbsoluteFsPath): void {\n    fs.unlinkSync(path);\n  }\n  symlink(target: AbsoluteFsPath, path: AbsoluteFsPath): void {\n    fs.symlinkSync(target, path);\n  }\n  copyFile(from: AbsoluteFsPath, to: AbsoluteFsPath): void {\n    fs.copyFileSync(from, to);\n  }\n  moveFile(from: AbsoluteFsPath, to: AbsoluteFsPath): void {\n    fs.renameSync(from, to);\n  }\n  ensureDir(path: AbsoluteFsPath): void {\n    fs.mkdirSync(path, {recursive: true});\n  }\n  removeDeep(path: AbsoluteFsPath): void {\n    fs.rmdirSync(path, {recursive: true});\n  }\n}\n\n/**\n * Toggle the case of each character in a string.\n */\nfunction toggleCase(str: string): string {\n  return str.replace(/\\w/g, ch => ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase());\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst _SELECTOR_REGEXP = new RegExp(\n    '(\\\\:not\\\\()|' +               // 1: \":not(\"\n        '(([\\\\.\\\\#]?)[-\\\\w]+)|' +  // 2: \"tag\"; 3: \".\"/\"#\";\n        // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n        // 4: attribute; 5: attribute_string; 6: attribute_value\n        '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +  // \"[name]\", \"[name=value]\",\n                                                                        // \"[name=\"value\"]\",\n                                                                        // \"[name='value']\"\n        '(\\\\))|' +                                                      // 7: \")\"\n        '(\\\\s*,\\\\s*)',                                                  // 8: \",\"\n    'g');\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0,  // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string|null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n          cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[]|null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.slice(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n\n      if (attribute) {\n        current.addAttribute(\n            current.unescapeAttribute(attribute), match[SelectorRegexp.ATTRIBUTE_VALUE]);\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  /**\n   * Unescape `\\$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * but we might want to match an attribute that contains `$`.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to unescape.\n   * @returns the unescaped string.\n   */\n  unescapeAttribute(attr: string): string {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(\n            `Error in attribute selector \"${attr}\". ` +\n            `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n\n  /**\n   * Escape `$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * with this method we are escaping `$` with `\\$'.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to escape.\n   * @returns the escaped string.Â \n   */\n  escapeAttribute(attr: string): string {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n\n  isElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n        this.notSelectors.length === 0;\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string|null = null) {\n    this.element = element;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n      cssSelector: CssSelector, callbackCtxt: T, listContext: SelectorListContext) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, selectable: SelectorContext<T>) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n        result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n            this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n            this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n            result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n              this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n      map: Map<string, SelectorMatcher<T>>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n      public selector: CssSelector, public cbContext: T, public listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './selector';\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nexport const emitDistinctChangesOnlyDefaultValue = true;\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1\n}\n\nexport interface Input {\n  alias?: string;\n  required?: boolean;\n}\n\nexport interface Output {\n  alias?: string;\n}\n\nexport interface HostBinding {\n  hostPropertyName?: string;\n}\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n\nexport interface SchemaMetadata {\n  name: string;\n}\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\nexport interface Type extends Function {\n  new(...args: any[]): any;\n}\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n  /**\n   * This token is being injected into a pipe.\n   * @internal\n   */\n  ForPipe = 1 << 4,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string|SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT, selector.element, ...selector.attrs, ...classes\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ?\n        [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames] :\n        [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList = selector.notSelectors && selector.notSelectors.length ?\n      selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n      [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string|null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div class=\"foo bar baz\">...<d/vi>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nexport class BigInteger {\n  static zero(): BigInteger {\n    return new BigInteger([0]);\n  }\n\n  static one(): BigInteger {\n    return new BigInteger([1]);\n  }\n\n  /**\n   * Creates a big integer using its individual digits in little endian storage.\n   */\n  private constructor(private readonly digits: number[]) {}\n\n  /**\n   * Creates a clone of this instance.\n   */\n  clone(): BigInteger {\n    return new BigInteger(this.digits.slice());\n  }\n\n  /**\n   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n   * `this` but instead returns a new instance, unlike `addToSelf`.\n   */\n  add(other: BigInteger): BigInteger {\n    const result = this.clone();\n    result.addToSelf(other);\n    return result;\n  }\n\n  /**\n   * Adds `other` to the instance itself, thereby mutating its value.\n   */\n  addToSelf(other: BigInteger): void {\n    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n    let carry = 0;\n    for (let i = 0; i < maxNrOfDigits; i++) {\n      let digitSum = carry;\n      if (i < this.digits.length) {\n        digitSum += this.digits[i];\n      }\n      if (i < other.digits.length) {\n        digitSum += other.digits[i];\n      }\n\n      if (digitSum >= 10) {\n        this.digits[i] = digitSum - 10;\n        carry = 1;\n      } else {\n        this.digits[i] = digitSum;\n        carry = 0;\n      }\n    }\n\n    // Apply a remaining carry if needed.\n    if (carry > 0) {\n      this.digits[maxNrOfDigits] = 1;\n    }\n  }\n\n  /**\n   * Builds the decimal string representation of the big integer. As this is stored in\n   * little endian, the digits are concatenated in reverse order.\n   */\n  toString(): string {\n    let res = '';\n    for (let i = this.digits.length - 1; i >= 0; i--) {\n      res += this.digits[i];\n    }\n    return res;\n  }\n}\n\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nexport class BigIntForMultiplication {\n  /**\n   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n   */\n  private readonly powerOfTwos: BigInteger[];\n\n  constructor(value: BigInteger) {\n    this.powerOfTwos = [value];\n  }\n\n  /**\n   * Returns the big integer itself.\n   */\n  getValue(): BigInteger {\n    return this.powerOfTwos[0];\n  }\n\n  /**\n   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n   * value for `b` is represented by a storage model that is optimized for this computation.\n   *\n   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n   * used as exponent into the power-of-two multiplication of `b`.\n   *\n   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n   * algorithm unrolls into the following iterations:\n   *\n   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n   * -----------|------------|------|------------|------|--------\n   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n   *\n   * The computed product of 56154 is indeed the correct result.\n   *\n   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n   * power-of-two values to reduce the workload in computing those values.\n   */\n  multiplyBy(num: number): BigInteger {\n    const product = BigInteger.zero();\n    this.multiplyByAndAddTo(num, product);\n    return product;\n  }\n\n  /**\n   * See `multiplyBy()` for details. This function allows for the computed product to be added\n   * directly to the provided result big integer.\n   */\n  multiplyByAndAddTo(num: number, result: BigInteger): void {\n    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n      if (num & 1) {\n        const value = this.getMultipliedByPowerOfTwo(exponent);\n        result.addToSelf(value);\n      }\n    }\n  }\n\n  /**\n   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n   */\n  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n    // Compute the powers up until the requested exponent, where each value is computed from its\n    // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n    // added to itself) to reach `this.number * 2^exponent`.\n    for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n      const previousPower = this.powerOfTwos[i - 1];\n      this.powerOfTwos[i] = previousPower.add(previousPower);\n    }\n    return this.powerOfTwos[exponent];\n  }\n}\n\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nexport class BigIntExponentiation {\n  private readonly exponents = [new BigIntForMultiplication(BigInteger.one())];\n\n  constructor(private readonly base: number) {}\n\n  /**\n   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n   * further multiplication operations.\n   */\n  toThePowerOf(exponent: number): BigIntForMultiplication {\n    // Compute the results up until the requested exponent, where every value is computed from its\n    // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n    // to reach `this.base^exponent`.\n    for (let i = this.exponents.length; i <= exponent; i++) {\n      const value = this.exponents[i - 1].multiplyBy(this.base);\n      this.exponents[i] = new BigIntForMultiplication(value);\n    }\n    return this.exponents[exponent];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Byte} from '../util';\n\nimport {BigIntExponentiation} from './big_integer';\nimport * as i18n from './i18n_ast';\n\n/**\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\n */\nlet textEncoder: TextEncoder|undefined;\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid ?\n        `<ph tag name=\"${ph.startName}\"/>` :\n        `<ph tag name=\"${ph.startName}\">${\n            ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu, context: any): any {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Uint32Array(80);\n  let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[((len + 64 >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  // Convert the output parts to a 160-bit hexadecimal string\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\n\n/**\n * Convert and format a number as a string representing a 32-bit unsigned hexadecimal number.\n * @param value The value to format as a string.\n * @returns A hexadecimal string representing the value.\n */\nfunction toHexU32(value: number): string {\n  // unsigned right shift of zero ensures an unsigned 32-bit number\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    const meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  const hi = msgFingerprint[0];\n  const lo = msgFingerprint[1];\n\n  return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\n\nfunction hash32(view: DataView, length: number, c: number): number {\n  let a = 0x9e3779b9, b = 0x9e3779b9;\n  let index = 0;\n\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  const remainder = length - index;\n\n  // the first byte of c is reserved for the length\n  c += length;\n\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n\n      // Partial 32-bit word for c\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      // Partial 32-bit word for b\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    // Partial 32-bit word for a\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n\n  return mix(a, b, c)[2];\n}\n\n// clang-format off\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a -= b; a -= c; a ^= c >>> 13;\n  b -= c; b -= a; b ^= a << 8;\n  c -= a; c -= b; c ^= b >>> 13;\n  a -= b; a -= c; a ^= c >>> 12;\n  b -= c; b -= a; b ^= a << 16;\n  c -= a; c -= b; c ^= b >>> 5;\n  a -= b; a -= c; a ^= c >>> 3;\n  b -= c; b -= a; b ^= a << 10;\n  c -= a; c -= b; c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64(a: [number, number], b: [number, number]): [number, number] {\n  const ah = a[0], al = a[1];\n  const bh = b[0], bl = b[1];\n  const result = add32to64(al, bl);\n  const carry = result[0];\n  const l = result[1];\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64(num: [number, number], count: number): [number, number] {\n  const hi = num[0], lo = num[1];\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\n\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi: number, lo: number): string {\n  // Encode the four bytes in lo in the lower digits of the decimal number.\n  // Note: the multiplication results in lo itself but represented by a big integer using its\n  // decimal digits.\n  const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n\n  // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n  // this multiplication factor is applied.\n  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n\n  return decimal.toString();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(public name: BuiltinTypeName, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n      public value: Expression, modifiers?: TypeModifier, public typeParams: Type[]|null = null) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\n\nexport class ArrayType extends Type {\n  constructor(public of: Type, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\n\nexport class MapType extends Type {\n  public valueType: Type|null;\n  constructor(valueType: Type|null|undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T|null, other: T|null) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n    base: T[], other: T[], equivalentPredicate: (baseElement: T, otherElement: T) => boolean) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T[], other: T[]) {\n  return areAllEquivalentPredicate(\n      base, other, (baseElement: T, otherElement: T) => baseElement.isEquivalent(otherElement));\n}\n\nexport abstract class Expression {\n  public type: Type|null;\n  public sourceSpan: ParseSourceSpan|null;\n\n  constructor(type: Type|null|undefined, sourceSpan?: ParseSourceSpan|null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan|null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null, pure?: boolean):\n      InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(params: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null):\n      InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n      trueCase: Expression, falseCase: Expression|null = null,\n      sourceSpan?: ParseSourceSpan|null): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan|null, parens: boolean = true):\n      BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan|null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(public name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(public expr: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(public node: T, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public name: string, value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  toDeclStmt(type?: Type|null, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt {\n    return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n  }\n}\n\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public index: Expression, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n}\n\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public name: string, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n      public fn: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public pure = false) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n        areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n}\n\n\nexport class TaggedTemplateExpr extends Expression {\n  constructor(\n      public tag: Expression, public template: TemplateLiteral, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n        areAllEquivalentPredicate(\n               this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n        areAllEquivalent(this.template.expressions, e.template.expressions);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateExpr(this, context);\n  }\n}\n\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n      public classExpr: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n        areAllEquivalent(this.args, e.args);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n}\n\n\nexport class LiteralExpr extends Expression {\n  constructor(\n      public value: number|string|boolean|null|undefined, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n}\n\nexport class TemplateLiteral {\n  constructor(public elements: TemplateLiteralElement[], public expressions: Expression[]) {}\n}\nexport class TemplateLiteralElement {\n  rawText: string;\n  constructor(public text: string, public sourceSpan?: ParseSourceSpan, rawText?: string) {\n    // If `rawText` is not provided, try to extract the raw string from its\n    // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n    // string instead by escaping the following control sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    this.rawText =\n        rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n}\n\nexport class LiteralPiece {\n  constructor(public text: string, public sourceSpan: ParseSourceSpan) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n      public text: string, public sourceSpan: ParseSourceSpan, public associatedMessage?: Message) {\n  }\n}\n\nexport type MessagePiece = LiteralPiece|PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = 'âŸ';\n\nexport class LocalizedString extends Expression {\n  constructor(\n      readonly metaBlock: I18nMeta, readonly messageParts: LiteralPiece[],\n      readonly placeHolderNames: PlaceholderPiece[], readonly expressions: Expression[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n        metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan|null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ??\n        this.sourceSpan;\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${\n          computeMsgId(\n              placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(\n        metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan|null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n    str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n    metaBlock: string, messagePart: string, range: ParseSourceSpan|null): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n      public value: ExternalReference, type?: Type|null, public typeParams: Type[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ExternalExpr && this.value.name === e.value.name &&\n        this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n}\n\nexport class ExternalReference {\n  constructor(public moduleName: string|null, public name: string|null, public runtime?: any|null) {\n  }\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n      public condition: Expression, trueCase: Expression, public falseCase: Expression|null = null,\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n        this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n}\n\n\nexport class NotExpr extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n}\n\nexport class FnParam {\n  constructor(public name: string, public type: Type|null = null) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n}\n\n\nexport class FunctionExpr extends Expression {\n  constructor(\n      public params: FnParam[], public statements: Statement[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public name?: string|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n        areAllEquivalent(this.statements, e.statements);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n        name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n}\n\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n      public operator: UnaryOperator, public expr: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n        this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n      public operator: BinaryOperator, lhs: Expression, public rhs: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n        this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n      public receiver: Expression, public name: string, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n      public receiver: Expression, public index: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(public key: string, public value: Expression, public quoted: boolean) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type|null = null;\n  constructor(\n      public entries: LiteralMapEntry[], type?: MapType|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(public parts: Expression[], sourceSpan?: ParseSourceSpan|null) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n  visitWritePropExpr(expr: WritePropExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n}\n\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  None = 0,\n  Final = 1 << 0,\n  Private = 1 << 1,\n  Exported = 1 << 2,\n  Static = 1 << 3,\n}\n\nexport class LeadingComment {\n  constructor(public text: string, public multiline: boolean, public trailingNewline: boolean) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  override toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n      public modifiers: StmtModifier = StmtModifier.None,\n      public sourceSpan: ParseSourceSpan|null = null, public leadingComments?: LeadingComment[]) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public value?: Expression, type?: Type|null, modifiers?: StmtModifier,\n      sourceSpan?: ParseSourceSpan|null, leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n        (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public params: FnParam[], public statements: Statement[],\n      type?: Type|null, modifiers?: StmtModifier, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n        areAllEquivalent(this.statements, stmt.statements);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n      public expr: Expression, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\n\nexport class ReturnStatement extends Statement {\n  constructor(\n      public value: Expression, sourceSpan: ParseSourceSpan|null = null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class IfStmt extends Statement {\n  constructor(\n      public condition: Expression, public trueCase: Statement[],\n      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n        areAllEquivalent(this.trueCase, stmt.trueCase) &&\n        areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitWriteVarExpr(ast: WriteVarExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWritePropExpr(ast: WritePropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    this.visitAllExpressions(ast.template.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n}\n\nexport function leadingComment(\n    text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n    name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n    id: ExternalReference, typeParams: Type[]|null = null,\n    sourceSpan?: ParseSourceSpan|null): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n    id: ExternalReference, typeParams?: Type[]|null, typeModifiers?: TypeModifier): ExpressionType|\n    null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n    expr: Expression, typeModifiers?: TypeModifier, typeParams?: Type[]|null): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n    values: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n    values: {key: string, quoted: boolean, value: Expression}[],\n    type: MapType|null = null): LiteralMapExpr {\n  return new LiteralMapExpr(\n      values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n\nexport function unary(\n    operator: UnaryOperator, expr: Expression, type?: Type,\n    sourceSpan?: ParseSourceSpan|null): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan|null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function fn(\n    params: FnParam[], body: Statement[], type?: Type|null, sourceSpan?: ParseSourceSpan|null,\n    name?: string|null): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function ifStmt(\n    condition: Expression, thenClause: Statement[], elseClause?: Statement[],\n    sourceSpan?: ParseSourceSpan, leadingComments?: LeadingComment[]) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n    tag: Expression, template: TemplateLiteral, type?: Type|null,\n    sourceSpan?: ParseSourceSpan|null): TaggedTemplateExpr {\n  return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n    value: any, type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n    metaBlock: I18nMeta, messageParts: LiteralPiece[], placeholderNames: PlaceholderPiece[],\n    expressions: Expression[], sourceSpan?: ParseSourceSpan|null): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n  Suppress = 'suppress',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag = {\n  // `tagName` is e.g. \"param\" in an `@param` declaration\n  tagName: JSDocTagName|string,\n  // Any remaining text on the tag, e.g. the description\n  text?: string,\n}|{\n  // no `tagName` for plain text documentation that occurs before any `@param` lines\n  tagName?: undefined, text: string,\n};\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  shared = false;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if ((literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n        literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let definition: o.WriteVarExpr;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        definition = o.variable(name).set(new o.FunctionExpr(\n            [],  // Params.\n            [\n              // Statements.\n              new o.ReturnStatement(literal),\n            ],\n            ));\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unnecessary call.\n        definition = o.variable(name).set(literal);\n        usage = o.variable(name);\n      }\n\n      this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(o.variable(name)\n                               .set(pureFunctionDeclaration)\n                               .toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string {\n    return `${prefix}${this.nextNameIndex++}`;\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) {\n    return `VAR:${node.name}`;\n  }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitTaggedTemplateExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitUnaryOperatorExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n  visitLocalizedString = invalid;\n}\n\nfunction invalid<T>(this: o.ExpressionVisitor, arg: o.Expression|o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string' &&\n      expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  /* Methods */\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n\n  static core: o.ExternalReference = {name: null, moduleName: CORE};\n\n  /* Instructions */\n  static namespaceHTML: o.ExternalReference = {name: 'ÉµÉµnamespaceHTML', moduleName: CORE};\n\n  static namespaceMathML: o.ExternalReference = {name: 'ÉµÉµnamespaceMathML', moduleName: CORE};\n\n  static namespaceSVG: o.ExternalReference = {name: 'ÉµÉµnamespaceSVG', moduleName: CORE};\n\n  static element: o.ExternalReference = {name: 'ÉµÉµelement', moduleName: CORE};\n\n  static elementStart: o.ExternalReference = {name: 'ÉµÉµelementStart', moduleName: CORE};\n\n  static elementEnd: o.ExternalReference = {name: 'ÉµÉµelementEnd', moduleName: CORE};\n\n  static advance: o.ExternalReference = {name: 'ÉµÉµadvance', moduleName: CORE};\n\n  static syntheticHostProperty:\n      o.ExternalReference = {name: 'ÉµÉµsyntheticHostProperty', moduleName: CORE};\n\n  static syntheticHostListener:\n      o.ExternalReference = {name: 'ÉµÉµsyntheticHostListener', moduleName: CORE};\n\n  static attribute: o.ExternalReference = {name: 'ÉµÉµattribute', moduleName: CORE};\n\n  static attributeInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate1', moduleName: CORE};\n  static attributeInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate2', moduleName: CORE};\n  static attributeInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate3', moduleName: CORE};\n  static attributeInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate4', moduleName: CORE};\n  static attributeInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate5', moduleName: CORE};\n  static attributeInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate6', moduleName: CORE};\n  static attributeInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate7', moduleName: CORE};\n  static attributeInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate8', moduleName: CORE};\n  static attributeInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolateV', moduleName: CORE};\n\n  static classProp: o.ExternalReference = {name: 'ÉµÉµclassProp', moduleName: CORE};\n\n  static elementContainerStart:\n      o.ExternalReference = {name: 'ÉµÉµelementContainerStart', moduleName: CORE};\n\n  static elementContainerEnd:\n      o.ExternalReference = {name: 'ÉµÉµelementContainerEnd', moduleName: CORE};\n\n  static elementContainer: o.ExternalReference = {name: 'ÉµÉµelementContainer', moduleName: CORE};\n\n  static styleMap: o.ExternalReference = {name: 'ÉµÉµstyleMap', moduleName: CORE};\n\n  static styleMapInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate1', moduleName: CORE};\n  static styleMapInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate2', moduleName: CORE};\n  static styleMapInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate3', moduleName: CORE};\n  static styleMapInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate4', moduleName: CORE};\n  static styleMapInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate5', moduleName: CORE};\n  static styleMapInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate6', moduleName: CORE};\n  static styleMapInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate7', moduleName: CORE};\n  static styleMapInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate8', moduleName: CORE};\n  static styleMapInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolateV', moduleName: CORE};\n\n  static classMap: o.ExternalReference = {name: 'ÉµÉµclassMap', moduleName: CORE};\n\n  static classMapInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate1', moduleName: CORE};\n  static classMapInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate2', moduleName: CORE};\n  static classMapInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate3', moduleName: CORE};\n  static classMapInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate4', moduleName: CORE};\n  static classMapInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate5', moduleName: CORE};\n  static classMapInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate6', moduleName: CORE};\n  static classMapInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate7', moduleName: CORE};\n  static classMapInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate8', moduleName: CORE};\n  static classMapInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolateV', moduleName: CORE};\n\n  static styleProp: o.ExternalReference = {name: 'ÉµÉµstyleProp', moduleName: CORE};\n\n  static stylePropInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate1', moduleName: CORE};\n  static stylePropInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate2', moduleName: CORE};\n  static stylePropInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate3', moduleName: CORE};\n  static stylePropInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate4', moduleName: CORE};\n  static stylePropInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate5', moduleName: CORE};\n  static stylePropInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate6', moduleName: CORE};\n  static stylePropInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate7', moduleName: CORE};\n  static stylePropInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate8', moduleName: CORE};\n  static stylePropInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolateV', moduleName: CORE};\n\n  static nextContext: o.ExternalReference = {name: 'ÉµÉµnextContext', moduleName: CORE};\n\n  static resetView: o.ExternalReference = {name: 'ÉµÉµresetView', moduleName: CORE};\n\n  static templateCreate: o.ExternalReference = {name: 'ÉµÉµtemplate', moduleName: CORE};\n\n  static text: o.ExternalReference = {name: 'ÉµÉµtext', moduleName: CORE};\n\n  static enableBindings: o.ExternalReference = {name: 'ÉµÉµenableBindings', moduleName: CORE};\n\n  static disableBindings: o.ExternalReference = {name: 'ÉµÉµdisableBindings', moduleName: CORE};\n\n  static getCurrentView: o.ExternalReference = {name: 'ÉµÉµgetCurrentView', moduleName: CORE};\n\n  static textInterpolate: o.ExternalReference = {name: 'ÉµÉµtextInterpolate', moduleName: CORE};\n  static textInterpolate1: o.ExternalReference = {name: 'ÉµÉµtextInterpolate1', moduleName: CORE};\n  static textInterpolate2: o.ExternalReference = {name: 'ÉµÉµtextInterpolate2', moduleName: CORE};\n  static textInterpolate3: o.ExternalReference = {name: 'ÉµÉµtextInterpolate3', moduleName: CORE};\n  static textInterpolate4: o.ExternalReference = {name: 'ÉµÉµtextInterpolate4', moduleName: CORE};\n  static textInterpolate5: o.ExternalReference = {name: 'ÉµÉµtextInterpolate5', moduleName: CORE};\n  static textInterpolate6: o.ExternalReference = {name: 'ÉµÉµtextInterpolate6', moduleName: CORE};\n  static textInterpolate7: o.ExternalReference = {name: 'ÉµÉµtextInterpolate7', moduleName: CORE};\n  static textInterpolate8: o.ExternalReference = {name: 'ÉµÉµtextInterpolate8', moduleName: CORE};\n  static textInterpolateV: o.ExternalReference = {name: 'ÉµÉµtextInterpolateV', moduleName: CORE};\n\n  static restoreView: o.ExternalReference = {name: 'ÉµÉµrestoreView', moduleName: CORE};\n\n  static pureFunction0: o.ExternalReference = {name: 'ÉµÉµpureFunction0', moduleName: CORE};\n  static pureFunction1: o.ExternalReference = {name: 'ÉµÉµpureFunction1', moduleName: CORE};\n  static pureFunction2: o.ExternalReference = {name: 'ÉµÉµpureFunction2', moduleName: CORE};\n  static pureFunction3: o.ExternalReference = {name: 'ÉµÉµpureFunction3', moduleName: CORE};\n  static pureFunction4: o.ExternalReference = {name: 'ÉµÉµpureFunction4', moduleName: CORE};\n  static pureFunction5: o.ExternalReference = {name: 'ÉµÉµpureFunction5', moduleName: CORE};\n  static pureFunction6: o.ExternalReference = {name: 'ÉµÉµpureFunction6', moduleName: CORE};\n  static pureFunction7: o.ExternalReference = {name: 'ÉµÉµpureFunction7', moduleName: CORE};\n  static pureFunction8: o.ExternalReference = {name: 'ÉµÉµpureFunction8', moduleName: CORE};\n  static pureFunctionV: o.ExternalReference = {name: 'ÉµÉµpureFunctionV', moduleName: CORE};\n\n  static pipeBind1: o.ExternalReference = {name: 'ÉµÉµpipeBind1', moduleName: CORE};\n  static pipeBind2: o.ExternalReference = {name: 'ÉµÉµpipeBind2', moduleName: CORE};\n  static pipeBind3: o.ExternalReference = {name: 'ÉµÉµpipeBind3', moduleName: CORE};\n  static pipeBind4: o.ExternalReference = {name: 'ÉµÉµpipeBind4', moduleName: CORE};\n  static pipeBindV: o.ExternalReference = {name: 'ÉµÉµpipeBindV', moduleName: CORE};\n\n  static hostProperty: o.ExternalReference = {name: 'ÉµÉµhostProperty', moduleName: CORE};\n\n  static property: o.ExternalReference = {name: 'ÉµÉµproperty', moduleName: CORE};\n\n  static propertyInterpolate:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate', moduleName: CORE};\n  static propertyInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate1', moduleName: CORE};\n  static propertyInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate2', moduleName: CORE};\n  static propertyInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate3', moduleName: CORE};\n  static propertyInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate4', moduleName: CORE};\n  static propertyInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate5', moduleName: CORE};\n  static propertyInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate6', moduleName: CORE};\n  static propertyInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate7', moduleName: CORE};\n  static propertyInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate8', moduleName: CORE};\n  static propertyInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolateV', moduleName: CORE};\n\n  static i18n: o.ExternalReference = {name: 'ÉµÉµi18n', moduleName: CORE};\n  static i18nAttributes: o.ExternalReference = {name: 'ÉµÉµi18nAttributes', moduleName: CORE};\n  static i18nExp: o.ExternalReference = {name: 'ÉµÉµi18nExp', moduleName: CORE};\n  static i18nStart: o.ExternalReference = {name: 'ÉµÉµi18nStart', moduleName: CORE};\n  static i18nEnd: o.ExternalReference = {name: 'ÉµÉµi18nEnd', moduleName: CORE};\n  static i18nApply: o.ExternalReference = {name: 'ÉµÉµi18nApply', moduleName: CORE};\n  static i18nPostprocess: o.ExternalReference = {name: 'ÉµÉµi18nPostprocess', moduleName: CORE};\n\n  static pipe: o.ExternalReference = {name: 'ÉµÉµpipe', moduleName: CORE};\n\n  static projection: o.ExternalReference = {name: 'ÉµÉµprojection', moduleName: CORE};\n  static projectionDef: o.ExternalReference = {name: 'ÉµÉµprojectionDef', moduleName: CORE};\n\n  static reference: o.ExternalReference = {name: 'ÉµÉµreference', moduleName: CORE};\n\n  static inject: o.ExternalReference = {name: 'ÉµÉµinject', moduleName: CORE};\n\n  static injectAttribute: o.ExternalReference = {name: 'ÉµÉµinjectAttribute', moduleName: CORE};\n\n  static directiveInject: o.ExternalReference = {name: 'ÉµÉµdirectiveInject', moduleName: CORE};\n  static invalidFactory: o.ExternalReference = {name: 'ÉµÉµinvalidFactory', moduleName: CORE};\n  static invalidFactoryDep: o.ExternalReference = {name: 'ÉµÉµinvalidFactoryDep', moduleName: CORE};\n\n  static templateRefExtractor:\n      o.ExternalReference = {name: 'ÉµÉµtemplateRefExtractor', moduleName: CORE};\n\n  static forwardRef: o.ExternalReference = {name: 'forwardRef', moduleName: CORE};\n  static resolveForwardRef: o.ExternalReference = {name: 'resolveForwardRef', moduleName: CORE};\n\n  static ÉµÉµdefineInjectable: o.ExternalReference = {name: 'ÉµÉµdefineInjectable', moduleName: CORE};\n  static declareInjectable: o.ExternalReference = {name: 'ÉµÉµngDeclareInjectable', moduleName: CORE};\n  static InjectableDeclaration:\n      o.ExternalReference = {name: 'ÉµÉµInjectableDeclaration', moduleName: CORE};\n\n  static resolveWindow: o.ExternalReference = {name: 'ÉµÉµresolveWindow', moduleName: CORE};\n  static resolveDocument: o.ExternalReference = {name: 'ÉµÉµresolveDocument', moduleName: CORE};\n  static resolveBody: o.ExternalReference = {name: 'ÉµÉµresolveBody', moduleName: CORE};\n\n  static defineComponent: o.ExternalReference = {name: 'ÉµÉµdefineComponent', moduleName: CORE};\n  static declareComponent: o.ExternalReference = {name: 'ÉµÉµngDeclareComponent', moduleName: CORE};\n\n  static setComponentScope: o.ExternalReference = {name: 'ÉµÉµsetComponentScope', moduleName: CORE};\n\n  static ChangeDetectionStrategy: o.ExternalReference = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n  };\n  static ViewEncapsulation: o.ExternalReference = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n  };\n\n  static ComponentDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµComponentDeclaration',\n    moduleName: CORE,\n  };\n\n  static FactoryDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµFactoryDeclaration',\n    moduleName: CORE,\n  };\n  static declareFactory: o.ExternalReference = {name: 'ÉµÉµngDeclareFactory', moduleName: CORE};\n  static FactoryTarget: o.ExternalReference = {name: 'ÉµÉµFactoryTarget', moduleName: CORE};\n\n  static defineDirective: o.ExternalReference = {name: 'ÉµÉµdefineDirective', moduleName: CORE};\n  static declareDirective: o.ExternalReference = {name: 'ÉµÉµngDeclareDirective', moduleName: CORE};\n\n  static DirectiveDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµDirectiveDeclaration',\n    moduleName: CORE,\n  };\n\n  static InjectorDef: o.ExternalReference = {name: 'ÉµÉµInjectorDef', moduleName: CORE};\n  static InjectorDeclaration:\n      o.ExternalReference = {name: 'ÉµÉµInjectorDeclaration', moduleName: CORE};\n\n  static defineInjector: o.ExternalReference = {name: 'ÉµÉµdefineInjector', moduleName: CORE};\n  static declareInjector: o.ExternalReference = {name: 'ÉµÉµngDeclareInjector', moduleName: CORE};\n\n  static NgModuleDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµNgModuleDeclaration',\n    moduleName: CORE,\n  };\n\n  static ModuleWithProviders: o.ExternalReference = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n  };\n\n  static defineNgModule: o.ExternalReference = {name: 'ÉµÉµdefineNgModule', moduleName: CORE};\n  static declareNgModule: o.ExternalReference = {name: 'ÉµÉµngDeclareNgModule', moduleName: CORE};\n  static setNgModuleScope: o.ExternalReference = {name: 'ÉµÉµsetNgModuleScope', moduleName: CORE};\n  static registerNgModuleType:\n      o.ExternalReference = {name: 'ÉµÉµregisterNgModuleType', moduleName: CORE};\n\n\n  static PipeDeclaration: o.ExternalReference = {name: 'ÉµÉµPipeDeclaration', moduleName: CORE};\n\n  static definePipe: o.ExternalReference = {name: 'ÉµÉµdefinePipe', moduleName: CORE};\n  static declarePipe: o.ExternalReference = {name: 'ÉµÉµngDeclarePipe', moduleName: CORE};\n\n  static declareClassMetadata:\n      o.ExternalReference = {name: 'ÉµÉµngDeclareClassMetadata', moduleName: CORE};\n  static setClassMetadata: o.ExternalReference = {name: 'ÉµsetClassMetadata', moduleName: CORE};\n\n  static queryRefresh: o.ExternalReference = {name: 'ÉµÉµqueryRefresh', moduleName: CORE};\n  static viewQuery: o.ExternalReference = {name: 'ÉµÉµviewQuery', moduleName: CORE};\n  static loadQuery: o.ExternalReference = {name: 'ÉµÉµloadQuery', moduleName: CORE};\n  static contentQuery: o.ExternalReference = {name: 'ÉµÉµcontentQuery', moduleName: CORE};\n\n  static NgOnChangesFeature: o.ExternalReference = {name: 'ÉµÉµNgOnChangesFeature', moduleName: CORE};\n\n  static InheritDefinitionFeature:\n      o.ExternalReference = {name: 'ÉµÉµInheritDefinitionFeature', moduleName: CORE};\n\n  static CopyDefinitionFeature:\n      o.ExternalReference = {name: 'ÉµÉµCopyDefinitionFeature', moduleName: CORE};\n\n  static StandaloneFeature: o.ExternalReference = {name: 'ÉµÉµStandaloneFeature', moduleName: CORE};\n\n  static ProvidersFeature: o.ExternalReference = {name: 'ÉµÉµProvidersFeature', moduleName: CORE};\n\n  static HostDirectivesFeature:\n      o.ExternalReference = {name: 'ÉµÉµHostDirectivesFeature', moduleName: CORE};\n\n  static listener: o.ExternalReference = {name: 'ÉµÉµlistener', moduleName: CORE};\n\n  static getInheritedFactory: o.ExternalReference = {\n    name: 'ÉµÉµgetInheritedFactory',\n    moduleName: CORE,\n  };\n\n  // sanitization-related functions\n  static sanitizeHtml: o.ExternalReference = {name: 'ÉµÉµsanitizeHtml', moduleName: CORE};\n  static sanitizeStyle: o.ExternalReference = {name: 'ÉµÉµsanitizeStyle', moduleName: CORE};\n  static sanitizeResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµsanitizeResourceUrl', moduleName: CORE};\n  static sanitizeScript: o.ExternalReference = {name: 'ÉµÉµsanitizeScript', moduleName: CORE};\n  static sanitizeUrl: o.ExternalReference = {name: 'ÉµÉµsanitizeUrl', moduleName: CORE};\n  static sanitizeUrlOrResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµsanitizeUrlOrResourceUrl', moduleName: CORE};\n  static trustConstantHtml: o.ExternalReference = {name: 'ÉµÉµtrustConstantHtml', moduleName: CORE};\n  static trustConstantResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµtrustConstantResourceUrl', moduleName: CORE};\n  static validateIframeAttribute:\n      o.ExternalReference = {name: 'ÉµÉµvalidateIframeAttribute', moduleName: CORE};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function noUndefined<T>(val: T|undefined): T {\n  return val === undefined ? null! : val;\n}\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nexport type Byte = number;\n\nexport function utf8Encode(str: string): Byte[] {\n  let encoded: Byte[] = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any;\n\n// Check `global` first, because in Node tests both `global` and `window` may be defined and our\n// `_global` variable should point to the NodeJS `global` in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global: {[name: string]: any} = (/* @__PURE__ */ (\n    () => (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n        (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n         self instanceof WorkerGlobalScope && self))());\n\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nexport function partitionArray<T, F = T>(\n    arr: (T|F)[], conditionFn: (value: T|F) => boolean): [T[], F[]] {\n  const truthy: T[] = [];\n  const falsy: F[] = [];\n  for (const item of arr) {\n    (conditionFn(item) ? truthy : falsy).push(item as any);\n  }\n  return [truthy, falsy];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n      sourceRoot: string,\n      sources: string[],\n      sourcesContent: (string|null)[],\n      mappings: string,\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string|null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string|null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get currentLine(): Segment[]|null {\n    return this.lines.slice(-1)[0];\n  }\n\n  toJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string|null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the â€œsourcesâ€ list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl)! - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl)!;\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0! - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0!;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0! - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0!;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext {\n    return new EmitterVisitorContext(0);\n  }\n\n  private _lines: _EmittedLine[];\n\n  constructor(private _indent: number) {\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine {\n    return this._lines[this._lines.length - 1];\n  }\n\n  println(from?: {sourceSpan: ParseSourceSpan|null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean {\n    return this._currentLine.parts.length === 0;\n  }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan|null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx]!;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof o.JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach((line) => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    expr.tag.visitExpression(this, ctx);\n    ctx.print(expr, '`' + expr.template.elements[0].rawText);\n    for (let i = 1; i < expr.template.elements.length; i++) {\n      ctx.print(expr, '${');\n      expr.template.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n    }\n    ctx.print(expr, '`');\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase!.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      case o.BinaryOperator.NullishCoalesce:\n        opStr = '??';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers} from './r3_identifiers';\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\n/**\n * Result of compilation of a render3 code unit, e.g. component, directive, pipe, etc.\n */\nexport interface R3CompiledExpression {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nconst ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Identical, new o.TypeofExpr(guardExpr), o.literal('undefined'));\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined,\n      /* sourceSpan */ undefined, true);\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n\nexport function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n}\n\n\n/**\n * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n *\n * This is used when describing expressions that can refer to types that may eagerly reference types\n * that have not yet been defined.\n */\nexport interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n  /**\n   * The unwrapped expression.\n   */\n  expression: T;\n  /**\n   * Specified whether the `expression` contains a reference to something that has not yet been\n   * defined, and whether the expression is still wrapped in a `forwardRef()` call.\n   *\n   * If this value is `ForwardRefHandling.None` then the `expression` is safe to use as-is.\n   *\n   * Otherwise the `expression` was wrapped in a call to `forwardRef()` and must not be eagerly\n   * evaluated. Instead it must be wrapped in a function closure that will be evaluated lazily to\n   * allow the definition of the expression to be evaluated first.\n   *\n   * In full AOT compilation it can be safe to unwrap the `forwardRef()` call up front if the\n   * expression will actually be evaluated lazily inside a function call after the value of\n   * `expression` has been defined.\n   *\n   * But in other cases, such as partial AOT compilation or JIT compilation the expression will be\n   * evaluated eagerly in top level code so will need to continue to be wrapped in a `forwardRef()`\n   * call.\n   *\n   */\n  forwardRef: ForwardRefHandling;\n}\n\nexport function createMayBeForwardRefExpression<T extends o.Expression>(\n    expression: T, forwardRef: ForwardRefHandling): MaybeForwardRefExpression<T> {\n  return {expression, forwardRef};\n}\n\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nexport function convertFromMaybeForwardRefExpression(\n    {expression, forwardRef}: MaybeForwardRefExpression): o.Expression {\n  switch (forwardRef) {\n    case ForwardRefHandling.None:\n    case ForwardRefHandling.Wrapped:\n      return expression;\n    case ForwardRefHandling.Unwrapped:\n      return generateForwardRef(expression);\n  }\n}\n\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nexport function generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n}\n\n/**\n * Specifies how a forward ref has been handled in a MaybeForwardRefExpression\n */\nexport const enum ForwardRefHandling {\n  /** The expression was not wrapped in a `forwardRef()` call in the first place. */\n  None,\n  /** The expression is still wrapped in a `forwardRef()` call. */\n  Wrapped,\n  /** The expression was wrapped in a `forwardRef()` call but has since been unwrapped. */\n  Unwrapped,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags} from '../core';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\n\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class = 0,\n  Function = 1,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n    R3ConstructorFactoryMetadata|R3DelegatedFnOrClassMetadata|R3ExpressionFactoryMetadata;\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   * Or `null` if the dependency could not be resolved - making it invalid.\n   */\n  token: o.Expression|null;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Otherwise it is null;\n   */\n  attributeNameType: o.Expression|null;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const t = o.variable('t');\n  let baseFactoryVar: o.ReadVarExpr|null = null;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n      new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.type.value) :\n      t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = o.variable(`Éµ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n                                         o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `ÉµÉµinvalidFactory()` call.\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `ÉµÉµgetInheritedFactory()` to compute it.\n    const getInheritedFactoryCall = o.importExpr(R3.getInheritedFactory).callFn([meta.type.value]);\n    // Memoize the base factoryFn: `baseFactory || (baseFactory = ÉµÉµgetInheritedFactory(...))`\n    const baseFactory = new o.BinaryOperatorExpr(\n        o.BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new o.ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new o.ReturnStatement(retExpr));\n  }\n\n  let factoryFn: o.Expression = o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined,\n      `${meta.name}_Factory`);\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = o.fn([], [\n                   new o.DeclareVarStmt(baseFactoryVar.name!), new o.ReturnStatement(factoryFn)\n                 ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n\nexport function createFactoryType(meta: R3FactoryMetadata) {\n  const ctorDepsType =\n      meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : o.NONE_TYPE;\n  return o.expressionType(o.importExpr(\n      R3.FactoryDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\n\nfunction injectDependencies(deps: R3DependencyMetadata[], target: FactoryTarget): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, target: FactoryTarget, index: number): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n        (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n        (dep.optional ? InjectFlags.Optional : 0) |\n        (target === FactoryTarget.Pipe ? InjectFlags.ForPipe : 0);\n\n    // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n    let flagsParam: o.LiteralExpr|null =\n        (flags !== InjectFlags.Default || dep.optional) ? o.literal(flags) : null;\n\n    // Build up the arguments to the injectFn call.\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return o.importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `ÉµÉµinjectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr|null {\n  const entries: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({key: 'attribute', value: dep.attributeNameType, quoted: false});\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\nexport function isDelegatedFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nexport function isExpressionFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n\nfunction getInjectFn(target: FactoryTarget): o.ExternalReference {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return R3.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return R3.inject;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AST, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType} from '../expression_parser/ast';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit<Result>(visitor: Visitor<Result>): Result;\n}\n\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nexport class Comment implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(_visitor: Visitor<Result>): Result {\n    throw new Error('visit() not implemented for Comment');\n  }\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitText(this);\n  }\n}\n\nexport class BoundText implements Node {\n  constructor(public value: AST, public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundText(this);\n  }\n}\n\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nexport class TextAttribute implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan?: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTextAttribute(this);\n  }\n}\n\nexport class BoundAttribute implements Node {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan: ParseSourceSpan|undefined,\n      public i18n: I18nMeta|undefined) {}\n\n  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta): BoundAttribute {\n    if (prop.keySpan === undefined) {\n      throw new Error(\n          `Unexpected state: keySpan must be defined for bound attributes but was not for ${\n              prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(\n        prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan,\n        prop.keySpan, prop.valueSpan, i18n);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundAttribute(this);\n  }\n}\n\nexport class BoundEvent implements Node {\n  constructor(\n      public name: string, public type: ParsedEventType, public handler: AST,\n      public target: string|null, public phase: string|null, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${\n          event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(\n        event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan,\n        event.keySpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundEvent(this);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n      public name: string, public attributes: TextAttribute[], public inputs: BoundAttribute[],\n      public outputs: BoundEvent[], public children: Node[], public references: Reference[],\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitElement(this);\n  }\n}\n\nexport class Template implements Node {\n  constructor(\n      // tagName is the name of the container element, if applicable.\n      // `null` is a special case for when there is a structural directive on an `ng-template` so\n      // the renderer can differentiate between the synthetic template and the one written in the\n      // file.\n      public tagName: string|null,\n      public attributes: TextAttribute[],\n      public inputs: BoundAttribute[],\n      public outputs: BoundEvent[],\n      public templateAttrs: (BoundAttribute|TextAttribute)[],\n      public children: Node[],\n      public references: Reference[],\n      public variables: Variable[],\n      public sourceSpan: ParseSourceSpan,\n      public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null,\n      public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class Content implements Node {\n  readonly name = 'ng-content';\n\n  constructor(\n      public selector: string, public attributes: TextAttribute[],\n      public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitContent(this);\n  }\n}\n\nexport class Variable implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitVariable(this);\n  }\n}\n\nexport class Reference implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitReference(this);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public vars: {[name: string]: BoundText},\n      public placeholders: {[name: string]: Text|BoundText}, public sourceSpan: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIcu(this);\n  }\n}\n\nexport interface Visitor<Result = any> {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node): Result;\n\n  visitElement(element: Element): Result;\n  visitTemplate(template: Template): Result;\n  visitContent(content: Content): Result;\n  visitVariable(variable: Variable): Result;\n  visitReference(reference: Reference): Result;\n  visitTextAttribute(attribute: TextAttribute): Result;\n  visitBoundAttribute(attribute: BoundAttribute): Result;\n  visitBoundEvent(attribute: BoundEvent): Result;\n  visitText(text: Text): Result;\n  visitBoundText(text: BoundText): Result;\n  visitIcu(icu: Icu): Result;\n}\n\nexport class NullVisitor implements Visitor<void> {\n  visitElement(element: Element): void {}\n  visitTemplate(template: Template): void {}\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class RecursiveVisitor implements Visitor<void> {\n  visitElement(element: Element): void {\n    visitAll(this, element.attributes);\n    visitAll(this, element.inputs);\n    visitAll(this, element.outputs);\n    visitAll(this, element.children);\n    visitAll(this, element.references);\n  }\n  visitTemplate(template: Template): void {\n    visitAll(this, template.attributes);\n    visitAll(this, template.inputs);\n    visitAll(this, template.outputs);\n    visitAll(this, template.children);\n    visitAll(this, template.references);\n    visitAll(this, template.variables);\n  }\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class TransformVisitor implements Visitor<Node> {\n  visitElement(element: Element): Node {\n    const newAttributes = transformAll(this, element.attributes);\n    const newInputs = transformAll(this, element.inputs);\n    const newOutputs = transformAll(this, element.outputs);\n    const newChildren = transformAll(this, element.children);\n    const newReferences = transformAll(this, element.references);\n    if (newAttributes != element.attributes || newInputs != element.inputs ||\n        newOutputs != element.outputs || newChildren != element.children ||\n        newReferences != element.references) {\n      return new Element(\n          element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n    return element;\n  }\n\n  visitTemplate(template: Template): Node {\n    const newAttributes = transformAll(this, template.attributes);\n    const newInputs = transformAll(this, template.inputs);\n    const newOutputs = transformAll(this, template.outputs);\n    const newTemplateAttrs = transformAll(this, template.templateAttrs);\n    const newChildren = transformAll(this, template.children);\n    const newReferences = transformAll(this, template.references);\n    const newVariables = transformAll(this, template.variables);\n    if (newAttributes != template.attributes || newInputs != template.inputs ||\n        newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n        newChildren != template.children || newReferences != template.references ||\n        newVariables != template.variables) {\n      return new Template(\n          template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren,\n          newReferences, newVariables, template.sourceSpan, template.startSourceSpan,\n          template.endSourceSpan);\n    }\n    return template;\n  }\n\n  visitContent(content: Content): Node {\n    return content;\n  }\n\n  visitVariable(variable: Variable): Node {\n    return variable;\n  }\n  visitReference(reference: Reference): Node {\n    return reference;\n  }\n  visitTextAttribute(attribute: TextAttribute): Node {\n    return attribute;\n  }\n  visitBoundAttribute(attribute: BoundAttribute): Node {\n    return attribute;\n  }\n  visitBoundEvent(attribute: BoundEvent): Node {\n    return attribute;\n  }\n  visitText(text: Text): Node {\n    return text;\n  }\n  visitBoundText(text: BoundText): Node {\n    return text;\n  }\n  visitIcu(icu: Icu): Node {\n    return icu;\n  }\n}\n\nexport function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[] {\n  const result: Result[] = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      const newNode = visitor.visit(node) || node.visit(visitor);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n\nexport function transformAll<Result extends Node>(\n    visitor: Visitor<Node>, nodes: Result[]): Result[] {\n  const result: Result[] = [];\n  let changed = false;\n  for (const node of nodes) {\n    const newNode = node.visit(visitor);\n    if (newNode) {\n      result.push(newNode as Result);\n    }\n    changed = changed || newNode != node;\n  }\n  return changed ? result : nodes;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\n/**\n * Describes the text contents of a placeholder as it appears in an ICU expression, including its\n * source span information.\n */\nexport interface MessagePlaceholder {\n  /** The text contents of the placeholder */\n  text: string;\n\n  /** The source span of the placeholder */\n  sourceSpan: ParseSourceSpan;\n}\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  messageString: string;\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content and their source spans\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n      public nodes: Node[], public placeholders: {[phName: string]: MessagePlaceholder},\n      public placeholderToMessage: {[phName: string]: Message}, public meaning: string,\n      public description: string, public customId: string) {\n    this.id = this.customId;\n    this.messageString = serializeMessage(this.nodes);\n\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public expression: string, public type: string, public cases: {[k: string]: Node},\n      public sourceSpan: ParseSourceSpan, public expressionPlaceholder?: string) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n      public tag: string, public attrs: {[k: string]: string}, public startName: string,\n      public closeName: string, public children: Node[], public isVoid: boolean,\n      // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message|Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan, icu.expressionPlaceholder);\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(\n        ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n\n\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes: Node[]): string {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\n\nclass LocalizeMessageStringVisitor implements Visitor {\n  visitText(text: Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: Icu): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder): any {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n\n  visitPlaceholder(ph: Placeholder): any {\n    return `{$${ph.name}}`;\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder): any {\n    return `{$${ph.name}}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string|null): string;\n\n  abstract load(content: string, url: string):\n      {locale: string|null, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper|null {\n    return null;\n  }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string|null;\n\n  toInternalName(publicName: string): string|null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string|null {\n    return this.internalToPublic.hasOwnProperty(internalName) ?\n        this.internalToPublic[internalName] :\n        null;\n  }\n\n  toInternalName(publicName: string): string|null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n                                                              null;\n  }\n\n  override visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface IVisitor {\n  visitTag(tag: Tag): any;\n  visitText(text: Text): any;\n  visitDeclaration(decl: Declaration): any;\n  visitDoctype(doctype: Doctype): any;\n}\n\nclass _Visitor implements IVisitor {\n  visitTag(tag: Tag): string {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n\n  visitText(text: Text): string {\n    return text.value;\n  }\n\n  visitDeclaration(decl: Declaration): string {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n\n  private _serializeAttributes(attrs: {[k: string]: string}) {\n    const strAttrs = Object.keys(attrs).map((name: string) => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n\n  visitDoctype(doctype: Doctype): any {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n}\n\nconst _visitor = new _Visitor();\n\nexport function serialize(nodes: Node[]): string {\n  return nodes.map((node: Node): string => node.visit(_visitor)).join('');\n}\n\nexport interface Node {\n  visit(visitor: IVisitor): any;\n}\n\nexport class Declaration implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(unescapedAttrs: {[k: string]: string}) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDeclaration(this);\n  }\n}\n\nexport class Doctype implements Node {\n  constructor(public rootTag: string, public dtd: string) {}\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDoctype(this);\n  }\n}\n\nexport class Tag implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(\n      public name: string, unescapedAttrs: {[k: string]: string} = {},\n      public children: Node[] = []) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitTag(this);\n  }\n}\n\nexport class Text implements Node {\n  value: string;\n  constructor(unescapedValue: string) {\n    this.value = escapeXml(unescapedValue);\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitText(this);\n  }\n}\n\nexport class CR extends Text {\n  constructor(ws: number = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;'],\n];\n\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nexport function escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n      (text: string, entry: [RegExp, string]) => text.replace(entry[0], entry[1]), text);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG = 'source';\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class Xmb extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor();\n    let rootNode = new xml.Tag(_MESSAGES_TAG);\n\n    messages.forEach(message => {\n      const attrs: {[k: string]: string} = {id: message.id};\n\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n\n      let sourceTags: xml.Tag[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        sourceTags.push(new xml.Tag(\n            _SOURCE_TAG, {},\n            [new xml.Text(`${source.filePath}:${source.startLine}${\n                source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n\n      rootNode.children.push(\n          new xml.CR(2),\n          new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n\n    rootNode.children.push(new xml.CR());\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n      new xml.CR(),\n      exampleVisitor.addDefaultExamples(rootNode),\n      new xml.CR(),\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    throw new Error('Unsupported');\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nclass _Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startTagAsText = new xml.Text(`<${ph.tag}>`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeTagAsText = new xml.Text(`</${ph.tag}>`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx, closeTagAsText]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const interpolationAsText = new xml.Text(`{{${ph.value}}}`);\n    // Example tag needs to be not-empty for TC.\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, interpolationAsText])\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const icuAsText = new xml.Text(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, icuAsText])\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../r3_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nexport const TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = 'ï¿½';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n  return !!node.i18n;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function wrapI18nPlaceholder(content: string|number, contextId: number = 0): string {\n  const blockId = contextId > 0 ? `:${contextId}` : '';\n  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\n\nexport function assembleI18nBoundString(\n    strings: string[], bindingStartIndex: number = 0, contextId: number = 0): string {\n  if (!strings.length) return '';\n  let acc = '';\n  const lastIdx = strings.length - 1;\n  for (let i = 0; i < lastIdx; i++) {\n    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n  }\n  acc += strings[lastIdx];\n  return acc;\n}\n\nexport function getSeqNumberGenerator(startsAt: number = 0): () => number {\n  let current = startsAt;\n  return () => current++;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>):\n    {[name: string]: o.LiteralExpr} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\nexport function updatePlaceholderMap(map: Map<string, any[]>, name: string, ...values: any[]) {\n  const current = map.get(name) || [];\n  current.push(...values);\n  map.set(name, current);\n}\n\nexport function assembleBoundTextPlaceholders(\n    meta: i18n.I18nMeta, bindingStartIndex: number = 0, contextId: number = 0): Map<string, any[]> {\n  const startIdx = bindingStartIndex;\n  const placeholders = new Map<string, any>();\n  const node =\n      meta instanceof i18n.Message ? meta.nodes.find(node => node instanceof i18n.Container) : meta;\n  if (node) {\n    (node as i18n.Container)\n        .children\n        .filter((child: i18n.Node): child is i18n.Placeholder => child instanceof i18n.Placeholder)\n        .forEach((child: i18n.Placeholder, idx: number) => {\n          const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n          updatePlaceholderMap(placeholders, child.name, content);\n        });\n  }\n  return placeholders;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function formatI18nPlaceholderNamesInMap(\n    params: {[name: string]: o.Expression} = {}, useCamelCase: boolean) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n        key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift()!.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n      variable.name!, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport {BindingType, Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {ForwardRefHandling} from '../util';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18nAttribute} from './i18n/util';\n\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/** Name for the variable keeping track of the context returned by `ÉµÉµrestoreView`. */\nexport const RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n\n/**\n * Maximum length of a single instruction chain. Because our output AST uses recursion, we're\n * limited in how many expressions we can nest before we reach the call stack limit. This\n * length is set very conservatively in order to reduce the chance of problems.\n */\nconst MAX_CHAIN_LENGTH = 500;\n\n/** Instructions that support chaining. */\nconst CHAINABLE_INSTRUCTIONS = new Set([\n  R3.element,\n  R3.elementStart,\n  R3.elementEnd,\n  R3.elementContainer,\n  R3.elementContainerStart,\n  R3.elementContainerEnd,\n  R3.i18nExp,\n  R3.listener,\n  R3.classProp,\n  R3.syntheticHostListener,\n  R3.hostProperty,\n  R3.syntheticHostProperty,\n  R3.property,\n  R3.propertyInterpolate1,\n  R3.propertyInterpolate2,\n  R3.propertyInterpolate3,\n  R3.propertyInterpolate4,\n  R3.propertyInterpolate5,\n  R3.propertyInterpolate6,\n  R3.propertyInterpolate7,\n  R3.propertyInterpolate8,\n  R3.propertyInterpolateV,\n  R3.attribute,\n  R3.attributeInterpolate1,\n  R3.attributeInterpolate2,\n  R3.attributeInterpolate3,\n  R3.attributeInterpolate4,\n  R3.attributeInterpolate5,\n  R3.attributeInterpolate6,\n  R3.attributeInterpolate7,\n  R3.attributeInterpolate8,\n  R3.attributeInterpolateV,\n  R3.styleProp,\n  R3.stylePropInterpolate1,\n  R3.stylePropInterpolate2,\n  R3.stylePropInterpolate3,\n  R3.stylePropInterpolate4,\n  R3.stylePropInterpolate5,\n  R3.stylePropInterpolate6,\n  R3.stylePropInterpolate7,\n  R3.stylePropInterpolate8,\n  R3.stylePropInterpolateV,\n  R3.textInterpolate,\n  R3.textInterpolate1,\n  R3.textInterpolate2,\n  R3.textInterpolate3,\n  R3.textInterpolate4,\n  R3.textInterpolate5,\n  R3.textInterpolate6,\n  R3.textInterpolate7,\n  R3.textInterpolate8,\n  R3.textInterpolateV,\n]);\n\n/**\n * Possible types that can be used to generate the parameters of an instruction call.\n * If the parameters are a function, the function will be invoked at the time the instruction\n * is generated.\n */\nexport type InstructionParams = (o.Expression|o.Expression[])|(() => (o.Expression|o.Expression[]));\n\n/** Necessary information to generate a call to an instruction function. */\nexport interface Instruction {\n  span: ParseSourceSpan|null;\n  reference: o.ExternalReference;\n  paramsOrFn?: InstructionParams;\n}\n\n/** Generates a call to a single instruction. */\nexport function invokeInstruction(\n    span: ParseSourceSpan|null, reference: o.ExternalReference,\n    params: o.Expression[]): o.Expression {\n  return o.importExpr(reference, null, span).callFn(params, span);\n}\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression|o.Statement|t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateDirectiveBindingLiteral(\n    map: Record<string, string|{\n      classPropertyName: string;\n      bindingPropertyName: string;\n    }>, keepDeclared?: boolean): o.Expression|null {\n  const keys = Object.getOwnPropertyNames(map);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  return o.literalMap(keys.map(key => {\n    const value = map[key];\n    let declaredName: string;\n    let publicName: string;\n    let minifiedName: string;\n    let needsDeclaredName: boolean;\n    if (typeof value === 'string') {\n      // canonical syntax: `dirProp: publicProp`\n      declaredName = key;\n      minifiedName = key;\n      publicName = value;\n      needsDeclaredName = false;\n    } else {\n      minifiedName = key;\n      declaredName = value.classPropertyName;\n      publicName = value.bindingPropertyName;\n      needsDeclaredName = publicName !== declaredName;\n    }\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: (keepDeclared && needsDeclaredName) ?\n          o.literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n          asLiteral(publicName)\n    };\n  }));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    // The original predicate may have been wrapped in a `forwardRef()` call.\n    switch (query.predicate.forwardRef) {\n      case ForwardRefHandling.None:\n      case ForwardRefHandling.Unwrapped:\n        return query.predicate.expression;\n      case ForwardRefHandling.Wrapped:\n        return o.importExpr(R3.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key: key as string, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element|\n                                             t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach(i => {\n      if (i.type === BindingType.Property) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nexport function getInterpolationArgsLength(interpolation: Interpolation) {\n  const {expressions, strings} = interpolation;\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n\n/**\n * Generates the final instruction call statements based on the passed in configuration.\n * Will try to chain instructions as much as possible, if chaining is supported.\n */\nexport function getInstructionStatements(instructions: Instruction[]): o.Statement[] {\n  const statements: o.Statement[] = [];\n  let pendingExpression: o.Expression|null = null;\n  let pendingExpressionType: o.ExternalReference|null = null;\n  let chainLength = 0;\n\n  for (const current of instructions) {\n    const resolvedParams =\n        (typeof current.paramsOrFn === 'function' ? current.paramsOrFn() : current.paramsOrFn) ??\n        [];\n    const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];\n\n    // If the current instruction is the same as the previous one\n    // and it can be chained, add another call to the chain.\n    if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference &&\n        CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {\n      // We'll always have a pending expression when there's a pending expression type.\n      pendingExpression = pendingExpression!.callFn(params, pendingExpression!.sourceSpan);\n      chainLength++;\n    } else {\n      if (pendingExpression !== null) {\n        statements.push(pendingExpression.toStmt());\n      }\n      pendingExpression = invokeInstruction(current.span, current.reference, params);\n      pendingExpressionType = current.reference;\n      chainLength = 0;\n    }\n  }\n\n  // Since the current instruction adds the previous one to the statements,\n  // we may be left with the final one at the end that is still pending.\n  if (pendingExpression !== null) {\n    statements.push(pendingExpression.toStmt());\n  }\n\n  return statements;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {compileFactoryFunction, FactoryTarget, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata} from './render3/r3_factory';\nimport {Identifiers} from './render3/r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, ForwardRefHandling, generateForwardRef, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, typeWithParameters} from './render3/util';\nimport {DefinitionMap} from './render3/view/util';\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  typeArgumentCount: number;\n  providedIn: MaybeForwardRefExpression;\n  useClass?: MaybeForwardRefExpression;\n  useFactory?: o.Expression;\n  useExisting?: MaybeForwardRefExpression;\n  useValue?: MaybeForwardRefExpression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(\n    meta: R3InjectableMetadata, resolveForwardRefs: boolean): R3CompiledExpression {\n  let result: {expression: o.Expression, statements: o.Statement[]}|null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.type.value);\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(\n            meta.type.value as o.WrappedNodeExpr<any>,\n            meta.useClass.expression as o.WrappedNodeExpr<any>, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting.expression]),\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>, meta.type.value as o.WrappedNodeExpr<any>,\n          resolveForwardRefs)\n    };\n  }\n\n  const token = meta.type.value;\n\n  const injectableProps =\n      new DefinitionMap<{token: o.Expression, factory: o.Expression, providedIn: o.Expression}>();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn.expression as o.LiteralExpr).value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n\n  const expression = o.importExpr(Identifiers.ÉµÉµdefineInjectable)\n                         .callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements,\n  };\n}\n\nexport function createInjectableType(meta: R3InjectableMetadata) {\n  return new o.ExpressionType(o.importExpr(\n      Identifiers.InjectableDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\n\nfunction delegateToFactory(\n    type: o.WrappedNodeExpr<any>, useType: o.WrappedNodeExpr<any>,\n    unwrapForwardRefs: boolean): o.Expression {\n  if (type.node === useType.node) {\n    // The types are the same, so we can simply delegate directly to the type's factory.\n    // ```\n    // factory: type.Éµfac\n    // ```\n    return useType.prop('Éµfac');\n  }\n\n  if (!unwrapForwardRefs) {\n    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n    // accepts a sub-type as an argument.\n    // ```\n    // factory: function(t) { return useType.Éµfac(t); }\n    // ```\n    return createFactoryFunction(useType);\n  }\n\n  // The useType is actually wrapped in a `forwardRef()` so we need to resolve that before\n  // calling its factory.\n  // ```\n  // factory: function(t) { return core.resolveForwardRef(type).Éµfac(t); }\n  // ```\n  const unwrappedType = o.importExpr(Identifiers.resolveForwardRef).callFn([useType]);\n  return createFactoryFunction(unwrappedType);\n}\n\nfunction createFactoryFunction(type: o.Expression): o.FunctionExpr {\n  return o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)],\n      [new o.ReturnStatement(type.prop('Éµfac').callFn([o.variable('t')]))]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n  /^\\s*$/,        // empty\n  /[<>]/,         // html tag\n  /^[{}]$/,       // i18n expansion\n  /&(#|[a-z])/i,  // character reference,\n  /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0] as string;\n    const end = value[1] as string;\n    // Check for unusable interpolation symbols\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from '../assertions';\n\nexport class InterpolationConfig {\n  static fromArray(markers: [string, string]|null): InterpolationConfig {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $BSPACE = 8;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $7 = 55;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $b = 98;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nexport function isNewLine(code: number): boolean {\n  return code === $LF || code === $CR;\n}\n\nexport function isOctalDigit(code: number): boolean {\n  return $0 <= code && code <= $7;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {stringify} from './util';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine =\n            source.substring(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n      public start: ParseLocation, public end: ParseLocation,\n      public fullStart: ParseLocation = start, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n    kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(compileIdentifier: CompileIdentifierMetadata|null|undefined): string|\n    null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport interface CompileIdentifierMetadata {\n  reference: any;\n}\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AbstractEmitterVisitor, EmitterVisitorContext, escapeIdentifier} from './abstract_emitter';\nimport * as o from './output_ast';\n\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill =\n    '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\n\nexport abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  override visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // tag`...`\n    // ```\n    // which is effectively like:\n    // ```\n    // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  override visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  override visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // $localize `...`\n    // ```\n    // which is effectively like:\n    // ```\n    // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(policyName: string, policyOptions: {\n    createScript?: (input: string) => string,\n  }): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy =\n            (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular#unsafe-jit', {\n              createScript: (s: string) => s,\n            });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {identifierName} from '../parse_util';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\nimport {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n\nexport interface ExternalReferenceResolver {\n  resolveExternalReference(ref: o.ExternalReference): unknown;\n}\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param refResolver Resolves `o.ExternalReference`s into values.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n      sourceUrl: string, statements: o.Statement[], refResolver: ExternalReferenceResolver,\n      createSourceMaps: boolean): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [\n        o.literal('use strict').toStmt(),\n        ...statements,\n      ];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n      sourceUrl: string, ctx: EmitterVisitorContext, vars: {[key: string]: any},\n      createSourceMap: boolean): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) {\n    return fn(...args);\n  }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private refResolver: ExternalReferenceResolver) {\n    super();\n  }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(\n        resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(ast: o.Expression, value: any, ctx: EmitterVisitorContext):\n      void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference} from './util';\nimport {DefinitionMap} from './view/util';\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  providers: o.Expression|null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<{providers: o.Expression; imports: o.Expression;}>();\n\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  const expression =\n      o.importExpr(R3.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {expression, type, statements: []};\n}\n\nexport function createInjectorType(meta: R3InjectorMetadata): o.Type {\n  return new o.ExpressionType(\n      o.importExpr(R3.InjectorDeclaration, [new o.ExpressionType(meta.type.type)]));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\nimport {ExternalReferenceResolver} from '../output/output_jit';\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nexport class R3JitReflector implements ExternalReferenceResolver {\n  constructor(private context: {[key: string]: unknown}) {}\n\n  resolveExternalReference(ref: o.ExternalReference): unknown {\n    // This reflector only handles @angular/core imports.\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${\n          ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name!)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name!}'.`);\n    }\n    return this.context[ref.name!];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DeclareNgModuleFacade} from '../compiler_facade_interface';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, R3CompiledExpression, R3Reference, refsToArray} from './util';\nimport {DefinitionMap} from './view/util';\n\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nexport enum R3SelectorScopeMode {\n  /**\n   * Emit the declarations inline into the module definition.\n   *\n   * This option is useful in certain contexts where it's known that JIT support is required. The\n   * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n   * they are unused, but the NgModule is used.\n   */\n  Inline,\n\n  /**\n   * Emit the declarations using a side effectful function call, `ÉµÉµsetNgModuleScope`, that is\n   * guarded with the `ngJitMode` flag.\n   *\n   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n   * false, which allows unused directives and pipes to be tree-shaken.\n   */\n  SideEffect,\n\n  /**\n   * Don't generate selector scopes at all.\n   *\n   * This is useful for contexts where JIT support is known to be unnecessary.\n   */\n  Omit,\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`Éµmod`) for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * Those declarations which should be visible to downstream consumers. If not specified, all\n   * declarations are made visible to downstream consumers.\n   */\n  publicDeclarationTypes: o.Expression[]|null;\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * Whether or not to include `imports` in generated type declarations.\n   */\n  includeImportTypes: boolean;\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * How to emit the selector scope values (declarations, imports, exports).\n   */\n  selectorScopeMode: R3SelectorScopeMode;\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * The shape of the object literal that is passed to the `ÉµÉµdefineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const {\n    type: moduleType,\n    bootstrap,\n    declarations,\n    imports,\n    exports,\n    schemas,\n    containsForwardDecls,\n    selectorScopeMode,\n    id\n  } = meta;\n\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', moduleType.value);\n\n  if (bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n  }\n\n  if (selectorScopeMode === R3SelectorScopeMode.Inline) {\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and\n    // `exports` to the `ÉµÉµdefineNgModule()` call directly.\n\n    if (declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n\n    if (imports.length > 0) {\n      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n\n    if (exports.length > 0) {\n      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n  } else if (selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    // In this mode, scope information is not passed into `ÉµÉµdefineNgModule` as it\n    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n    // patched onto the NgModule definition with a `ÉµÉµsetNgModuleScope` call that's guarded by the\n    // `ngJitMode` flag.\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else {\n    // Selector scope emit was not requested, so skip it.\n  }\n\n  if (schemas !== null && schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(schemas.map(ref => ref.value)));\n  }\n\n  if (id !== null) {\n    definitionMap.set('id', id);\n\n    // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n    // NgModule ids.\n    statements.push(o.importExpr(R3.registerNgModuleType).callFn([moduleType.value, id]).toStmt());\n  }\n\n  const expression =\n      o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `ÉµÉµdefineNgModule()` from a call to\n * `ÉµÉµngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(\n    {type: moduleType, declarations, exports, imports, includeImportTypes, publicDeclarationTypes}:\n        R3NgModuleMetadata): o.ExpressionType {\n  return new o.ExpressionType(o.importExpr(R3.NgModuleDeclaration, [\n    new o.ExpressionType(moduleType.type),\n    publicDeclarationTypes === null ? tupleTypeOf(declarations) :\n                                      tupleOfTypes(publicDeclarationTypes),\n    includeImportTypes ? tupleTypeOf(imports) : o.NONE_TYPE,\n    tupleTypeOf(exports),\n  ]));\n}\n\n/**\n * Generates a function call to `ÉµÉµsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const {type: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n\n  const scopeMap = new DefinitionMap<\n      {declarations: o.Expression, imports: o.Expression, exports: o.Expression}>();\n\n  if (declarations.length > 0) {\n    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n  }\n\n  if (imports.length > 0) {\n    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n  }\n\n  if (exports.length > 0) {\n    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[moduleType.value, scopeMap.toLiteralMap()]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /* statements */[guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(\n      /* fn */ iife,\n      /* args */[]);\n\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction tupleOfTypes(types: o.Expression[]): o.Type {\n  const typeofTypes = types.map(type => o.typeofExpr(type));\n  return types.length > 0 ? o.expressionType(o.literalArr(typeofTypes)) : o.NONE_TYPE;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../output/output_ast';\n\nimport {R3DependencyMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\nexport interface R3PipeMetadata {\n  /**\n   * Name of the pipe type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the pipe itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * Name of the pipe.\n   */\n  pipeName: string;\n\n  /**\n   * Dependencies of the pipe's constructor.\n   */\n  deps: R3DependencyMetadata[]|null;\n\n  /**\n   * Whether the pipe is marked as pure.\n   */\n  pure: boolean;\n\n  /**\n   * Whether the pipe is standalone.\n   */\n  isStandalone: boolean;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata): R3CompiledExpression {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({key: 'name', value: o.literal(metadata.pipeName), quoted: false});\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type.value, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  if (metadata.isStandalone) {\n    definitionMapValues.push({key: 'standalone', value: o.literal(true), quoted: false});\n  }\n\n  const expression =\n      o.importExpr(R3.definePipe).callFn([o.literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n\n  return {expression, type, statements: []};\n}\n\nexport function createPipeType(metadata: R3PipeMetadata): o.Type {\n  return new o.ExpressionType(o.importExpr(R3.PipeDeclaration, [\n    typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n    new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n    new o.ExpressionType(new o.LiteralExpr(metadata.isStandalone)),\n  ]));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport {InterpolationConfig} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {MaybeForwardRefExpression, R3Reference} from '../util';\n\n\n/**\n * Information needed to compile a directive for the render3 runtime.\n */\nexport interface R3DirectiveMetadata {\n  /**\n   * Name of the directive type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the directive itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * A source span for the directive type.\n   */\n  typeSourceSpan: ParseSourceSpan;\n\n  /**\n   * Dependencies of the directive's constructor.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Unparsed selector of the directive, or `null` if there was no selector.\n   */\n  selector: string|null;\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries: R3QueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries: R3QueryMetadata[];\n\n  /**\n   * Mappings indicating how the directive interacts with its host element (host bindings,\n   * listeners, etc).\n   */\n  host: R3HostMetadata;\n\n  /**\n   * Information about usage of specific lifecycle events which require special treatment in the\n   * code generator.\n   */\n  lifecycle: {\n    /**\n     * Whether the directive uses NgOnChanges.\n     */\n    usesOnChanges: boolean;\n  };\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs: {[field: string]: R3InputMetadata};\n\n  /**\n   * A mapping of outputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  outputs: {[field: string]: string};\n\n  /**\n   * Whether or not the component or directive inherits from another class\n   */\n  usesInheritance: boolean;\n\n  /**\n   * Whether or not the component or directive inherits its entire decorator from its base class.\n   */\n  fullInheritance: boolean;\n\n  /**\n   * Reference name under which to export the directive's type in a template,\n   * if any.\n   */\n  exportAs: string[]|null;\n\n  /**\n   * The list of providers defined in the directive.\n   */\n  providers: o.Expression|null;\n\n  /**\n   * Whether or not the component or directive is standalone.\n   */\n  isStandalone: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives: R3HostDirectiveMetadata[]|null;\n}\n\n/**\n * Specifies how a list of declaration type references should be emitted into the generated code.\n */\nexport const enum DeclarationListEmitMode {\n  /**\n   * The list of declarations is emitted into the generated code as is.\n   *\n   * ```\n   * directives: [MyDir],\n   * ```\n   */\n  Direct,\n\n  /**\n   * The list of declarations is emitted into the generated code wrapped inside a closure, which\n   * is needed when at least one declaration is a forward reference.\n   *\n   * ```\n   * directives: function () { return [MyDir, ForwardDir]; },\n   * ```\n   */\n  Closure,\n\n  /**\n   * Similar to `Closure`, with the addition that the list of declarations can contain individual\n   * items that are themselves forward references. This is relevant for JIT compilations, as\n   * unwrapping the forwardRef cannot be done statically so must be deferred. This mode emits\n   * the declaration list using a mapping transform through `resolveForwardRef` to ensure that\n   * any forward references within the list are resolved when the outer closure is invoked.\n   *\n   * Consider the case where the runtime has captured two declarations in two distinct values:\n   * ```\n   * const dirA = MyDir;\n   * const dirB = forwardRef(function() { return ForwardRef; });\n   * ```\n   *\n   * This mode would emit the declarations captured in `dirA` and `dirB` as follows:\n   * ```\n   * directives: function () { return [dirA, dirB].map(ng.resolveForwardRef); },\n   * ```\n   */\n  ClosureResolved,\n}\n\n/**\n * Information needed to compile a component for the render3 runtime.\n */\nexport interface R3ComponentMetadata<DeclarationT extends R3TemplateDependency> extends\n    R3DirectiveMetadata {\n  /**\n   * Information about the component's template.\n   */\n  template: {\n    /**\n     * Parsed nodes of the template.\n     */\n    nodes: t.Node[];\n\n    /**\n     * Any ng-content selectors extracted from the template. Contains `*` when an ng-content\n     * element without selector is present.\n     */\n    ngContentSelectors: string[];\n  };\n\n  declarations: DeclarationT[];\n\n  /**\n   * Specifies how the 'directives' and/or `pipes` array, if generated, need to be emitted.\n   */\n  declarationListEmitMode: DeclarationListEmitMode;\n\n  /**\n   * A collection of styling data that will be applied and scoped to the component.\n   */\n  styles: string[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   */\n  encapsulation: ViewEncapsulation;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations: o.Expression|null;\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders: o.Expression|null;\n\n  /**\n   * Path to the .ts file in which this template's generated code will be included, relative to\n   * the compilation root. This will be used to generate identifiers that need to be globally\n   * unique in certain contexts (such as g3).\n   */\n  relativeContextFilePath: string;\n\n  /**\n   * Whether translation variable name should contain external message id\n   * (used by Closure Compiler's output of `goog.getMsg` for transition period).\n   */\n  i18nUseExternalIds: boolean;\n\n  /**\n   * Overrides the default interpolation start and end delimiters ({{ and }}).\n   */\n  interpolation: InterpolationConfig;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n}\n\n/**\n * Metadata for an individual input on a directive.\n */\nexport interface R3InputMetadata {\n  classPropertyName: string;\n  bindingPropertyName: string;\n  required: boolean;\n}\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\n/**\n * A dependency that's used within a component template.\n */\nexport interface R3TemplateDependency {\n  kind: R3TemplateDependencyKind;\n\n  /**\n   * The type of the dependency as an expression.\n   */\n  type: o.Expression;\n}\n\n/**\n * A dependency that's used within a component template\n */\nexport type R3TemplateDependencyMetadata =\n    R3DirectiveDependencyMetadata|R3PipeDependencyMetadata|R3NgModuleDependencyMetadata;\n\n/**\n * Information about a directive that is used in a component template. Only the stable, public\n * facing information of the directive is stored here.\n */\nexport interface R3DirectiveDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Directive;\n\n  /**\n   * The selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * The binding property names of the inputs of the directive.\n   */\n  inputs: string[];\n\n  /**\n   * The binding property names of the outputs of the directive.\n   */\n  outputs: string[];\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular). Null otherwise.\n   */\n  exportAs: string[]|null;\n\n  /**\n   * If true then this directive is actually a component; otherwise it is not.\n   */\n  isComponent: boolean;\n}\n\nexport interface R3PipeDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Pipe;\n\n  name: string;\n}\n\nexport interface R3NgModuleDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.NgModule;\n}\n\n/**\n * Information needed to compile a query (view or content).\n */\nexport interface R3QueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results.\n   */\n  first: boolean;\n\n  /**\n   * Either an expression representing a type or `InjectionToken` for the query\n   * predicate, or a set of string selectors.\n   */\n  predicate: MaybeForwardRefExpression|string[];\n\n  /**\n   * Whether to include only direct children or all descendants.\n   */\n  descendants: boolean;\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read: o.Expression|null;\n\n  /**\n   * Whether or not this query should collect only static results.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   */\n  static: boolean;\n}\n\n/**\n * Mappings indicating how the class interacts with its\n * host element (host bindings, listeners, etc).\n */\nexport interface R3HostMetadata {\n  /**\n   * A mapping of attribute binding keys to `o.Expression`s.\n   */\n  attributes: {[key: string]: o.Expression};\n\n  /**\n   * A mapping of event binding keys to unparsed expressions.\n   */\n  listeners: {[key: string]: string};\n\n  /**\n   * A mapping of property binding keys to unparsed expressions.\n   */\n  properties: {[key: string]: string};\n\n  specialAttributes: {styleAttr?: string; classAttr?: string;};\n}\n\n/**\n * Information needed to compile a host directive for the render3 runtime.\n */\nexport interface R3HostDirectiveMetadata {\n  /** An expression representing the host directive class itself. */\n  directive: R3Reference;\n\n  /** Whether the expression referring to the host directive is a forward reference. */\n  isForwardReference: boolean;\n\n  /** Inputs from the host directive that will be exposed on the host. */\n  inputs: {[publicName: string]: string}|null;\n\n  /** Outputs from the host directive that will be exposed on the host. */\n  outputs: {[publicName: string]: string}|null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class ParserError {\n  public message: string;\n  constructor(\n      message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport abstract class AST {\n  constructor(\n      public span: ParseSpan,\n      /**\n       * Absolute location of the expression AST in a source code file.\n       */\n      public sourceSpan: AbsoluteSourceSpan) {}\n\n  abstract visit(visitor: AstVisitor, context?: any): any;\n\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n}\n\nexport class EmptyExpr extends AST {\n  override visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public condition: AST, public trueExp: AST,\n      public falseExp: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public value: AST) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class SafeKeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public exp: AST, public name: string,\n      public args: any[], nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public value: any) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string; quoted: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public keys: LiteralMapKey[],\n      public values: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public strings: any[],\n      public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operation: string, public left: AST,\n      public right: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  override left: never = null as never;\n  override right: never = null as never;\n  override operation: never = null as never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operator: string, public expr: AST,\n      binaryOp: string, binaryLeft: AST, binaryRight: AST) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class Call extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitCall(this, context);\n  }\n}\n\nexport class SafeCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeCall(this, context);\n  }\n}\n\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public readonly start: number, public readonly end: number) {}\n}\n\nexport class ASTWithSource extends AST {\n  constructor(\n      public ast: AST, public source: string|null, public location: string, absoluteOffset: number,\n      public errors: ParserError[]) {\n    super(\n        new ParseSpan(0, source === null ? 0 : source.length),\n        new AbsoluteSourceSpan(\n            absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  override toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding|ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier,\n      public readonly value: TemplateBindingIdentifier|null) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier, public readonly value: ASTWithSource|null) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n  visitCall(ast: Call, context: any): any;\n  visitSafeCall(ast: SafeCall, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n    this.visit(ast.value, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.value, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast: Call, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast: SafeCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    switch (ast.operator) {\n      case '+':\n        return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      case '-':\n        return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      default:\n        throw new Error(`Unknown unary operator ${ast.operator}`);\n    }\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(\n        ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(\n        ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this),\n        ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(\n        ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args),\n        ast.nameSpan);\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this),\n        ast.value.visit(this));\n  }\n\n  visitCall(ast: Call, context: any): AST {\n    return new Call(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    return new SafeCall(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    return new SafeKeyedRead(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n}\n\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nexport class AstMemoryEfficientTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): Interpolation {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions)\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n    return ast;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return ast;\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const value = ast.value.visit(this);\n    if (receiver !== ast.receiver || value !== ast.value) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n    }\n    return ast;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    const values = this.visitAll(ast.values);\n    if (values !== ast.values) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n    }\n    return ast;\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    const expr = ast.expr.visit(this);\n    if (expr !== ast.expr) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n        default:\n          throw new Error(`Unknown unary operator ${ast.operator}`);\n      }\n    }\n    return ast;\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    const left = ast.left.visit(this);\n    const right = ast.right.visit(this);\n    if (left !== ast.left || right !== ast.right) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n    }\n    return ast;\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new PrefixNot(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    const condition = ast.condition.visit(this);\n    const trueExp = ast.trueExp.visit(this);\n    const falseExp = ast.falseExp.visit(this);\n    if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n      return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n    }\n    return ast;\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    const exp = ast.exp.visit(this);\n    const args = this.visitAll(ast.args);\n    if (exp !== ast.exp || args !== ast.args) {\n      return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n    }\n    return ast;\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    const value = ast.value.visit(this);\n    if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n    }\n    return ast;\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    let modified = false;\n    for (let i = 0; i < asts.length; ++i) {\n      const original = asts[i];\n      const value = original.visit(this);\n      res[i] = value;\n      modified = modified || value !== original;\n    }\n    return modified ? res : asts;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new Chain(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n\n  visitCall(ast: Call, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n      public sourceSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan,\n      public valueSpan: ParseSourceSpan|undefined) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  ANIMATION\n}\n\nexport const enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Animation events have a phase\n  constructor(\n      public name: string, public targetOrPhase: string, public type: ParsedEventType,\n      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n      public readonly name: string, public readonly value: string,\n      public readonly sourceSpan: ParseSourceSpan, public readonly keySpan: ParseSourceSpan,\n      public readonly valueSpan?: ParseSourceSpan) {}\n}\n\nexport const enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: ASTWithSource, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined) {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class EventHandlerVars {\n  static event = o.variable('$event');\n}\n\nexport interface LocalResolver {\n  getLocal(name: string): o.Expression|null;\n  notifyImplicitReceiverUse(): void;\n  globals?: Set<string>;\n  maybeRestoreView(): void;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, baseSourceSpan?: ParseSourceSpan, implicitReceiverAccesses?: Set<string>,\n    globals?: Set<string>): o.Statement[] {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver(globals);\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false, baseSourceSpan,\n      implicitReceiverAccesses);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const lastIndex = actionStmts.length - 1;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    // Ensure that the value of the last expression statement is returned\n    if (lastStatement instanceof o.ExpressionStatement) {\n      actionStmts[lastIndex] = new o.ReturnStatement(lastStatement.expr);\n    }\n  }\n  return actionStmts;\n}\n\nexport interface BuiltinConverter {\n  (args: o.Expression[]): o.Expression;\n}\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  const stmts: o.Statement[] = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nexport function convertUpdateArguments(\n    localResolver: LocalResolver, contextVariableExpression: o.Expression,\n    expressionWithArgumentsToExtract: cdAst.Interpolation, bindingId: string) {\n  const visitor = new _AstToIrVisitor(\n      localResolver, contextVariableExpression, bindingId, /* supportsInterpolation */ true);\n  const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const stmts = getStatementsFromVisitor(visitor, bindingId);\n  const args = outputExpr.args;\n  return {stmts, args};\n}\n\nfunction getStatementsFromVisitor(visitor: _AstToIrVisitor, bindingId: string) {\n  const stmts: o.Statement[] = [];\n  for (let i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nfunction temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) {\n    super();\n  }\n  override visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  override visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  override visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n  public usesImplicitReceiver: boolean = false;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private supportsInterpolation: boolean,\n      private baseSourceSpan?: ParseSourceSpan, private implicitReceiverAccesses?: Set<string>) {}\n\n  visitUnary(ast: cdAst.Unary, mode: _Mode): any {\n    let op: o.UnaryOperator;\n    switch (ast.operator) {\n      case '+':\n        op = o.UnaryOperator.Plus;\n        break;\n      case '-':\n        op = o.UnaryOperator.Minus;\n        break;\n      default:\n        throw new Error(`Unsupported operator ${ast.operator}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.UnaryOperatorExpr(\n            op, this._visit(ast.expr, _Mode.Expression), undefined,\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      case '??':\n        return this.convertNullishCoalesce(ast, mode);\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression),\n            undefined, this.convertSourceSpan(ast.span)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression),\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    this.usesImplicitReceiver = true;\n    return this._implicitReceiver;\n  }\n\n  visitThisReceiver(ast: cdAst.ThisReceiver, mode: _Mode): any {\n    return this.visitImplicitReceiver(ast, mode);\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): InterpolationExpression {\n    if (!this.supportsInterpolation) {\n      throw new Error('Unexpected interpolation');\n    }\n\n    ensureExpressionMode(mode, ast);\n    let args: o.Expression[] = [];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    const strings = ast.strings;\n    if (strings.length === 2 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (ast.expressions.length >= 9) {\n      // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [o.literalArr(args)];\n    }\n\n    return new InterpolationExpression(args);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode,\n          this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n\n    if (obj === this._implicitReceiver) {\n      this._localResolver.maybeRestoreView();\n    }\n\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string, receiver: cdAst.AST): o.Expression|null {\n    if (this._localResolver.globals?.has(name) && receiver instanceof cdAst.ThisReceiver) {\n      return null;\n    }\n\n    return this._localResolver.getLocal(name);\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name, ast.receiver);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name, ast.receiver);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(`Cannot assign value \"${value}\" to template variable \"${\n              receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeKeyedRead(ast: cdAst.SafeKeyedRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any {\n    return asts.map(ast => this._visit(ast, mode));\n  }\n\n  visitCall(ast: cdAst.Call, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    }\n\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n\n    if (ast instanceof BuiltinFunctionCall) {\n      return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n    }\n\n    const receiver = ast.receiver;\n    if (receiver instanceof cdAst.PropertyRead &&\n        receiver.receiver instanceof cdAst.ImplicitReceiver &&\n        !(receiver.receiver instanceof cdAst.ThisReceiver) && receiver.name === '$any') {\n      if (convertedArgs.length !== 1) {\n        throw new Error(`Invalid call to $any, expected 1 argument but received ${\n            convertedArgs.length || 'none'}`);\n      }\n      return convertToStatementIfNeeded(mode, convertedArgs[0] as o.Expression);\n    }\n\n    const call = this._visit(receiver, _Mode.Expression)\n                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n    return convertToStatementIfNeeded(mode, call);\n  }\n\n  visitSafeCall(ast: cdAst.SafeCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafePropertyRead|cdAst.SafeKeyedRead|cdAst.SafeCall,\n      mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  .   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr|undefined = undefined;\n    if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.Call(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args,\n              leftMostSafe.argumentSpan));\n    } else if (leftMostSafe instanceof cdAst.SafeKeyedRead) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.KeyedRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n              leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.NULL_EXPR, access));\n  }\n\n  private convertNullishCoalesce(ast: cdAst.Binary, mode: _Mode): any {\n    const left: o.Expression = this._visit(ast.left, _Mode.Expression);\n    const right: o.Expression = this._visit(ast.right, _Mode.Expression);\n    const temporary = this.allocateTemporary();\n    this.releaseTemporary(temporary);\n\n    // Generate the following expression. It is identical to how TS\n    // transpiles binary expressions with a nullish coalescing operator.\n    // let temp;\n    // (temp = a) !== null && temp !== undefined ? temp : b;\n    return convertToStatementIfNeeded(\n        mode,\n        temporary.set(left)\n            .notIdentical(o.NULL_EXPR)\n            .and(temporary.notIdentical(o.literal(undefined)))\n            .conditional(temporary, right));\n  }\n\n  // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs to be transformed initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeKeyedRead {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary) {\n        return null;\n      },\n      visitBinary(ast: cdAst.Binary) {\n        return null;\n      },\n      visitChain(ast: cdAst.Chain) {\n        return null;\n      },\n      visitConditional(ast: cdAst.Conditional) {\n        return null;\n      },\n      visitCall(ast: cdAst.Call) {\n        return visit(this, ast.receiver);\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return null;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return null;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return null;\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return visit(this, ast.receiver);\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return null;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return null;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return null;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return null;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return null;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return null;\n      },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return visit(this, ast.receiver);\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return null;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporaryInSafeAccess(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary): boolean {\n        return visit(this, ast.expr);\n      },\n      visitBinary(ast: cdAst.Binary): boolean {\n        return visit(this, ast.left) || visit(this, ast.right);\n      },\n      visitChain(ast: cdAst.Chain) {\n        return false;\n      },\n      visitConditional(ast: cdAst.Conditional): boolean {\n        return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n      },\n      visitCall(ast: cdAst.Call) {\n        return true;\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return true;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return false;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return false;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return visitSome(this, ast.expressions);\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return false;\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return false;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return true;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return true;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return false;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return true;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitNonNullAssert(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return false;\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return false;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return false;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return false;\n      }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n\n  /**\n   * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n   *\n   * `ParseSpan` objects are relative to the start of the expression.\n   * This method converts these to full `ParseSourceSpan` objects that\n   * show where the span is within the overall source file.\n   *\n   * @param span the relative span to convert.\n   * @returns a `ParseSourceSpan` for the given span or null if no\n   * `baseSourceSpan` was provided to this class.\n   */\n  private convertSourceSpan(span: cdAst.ParseSpan) {\n    if (this.baseSourceSpan) {\n      const start = this.baseSourceSpan.start.moveBy(span.start);\n      const end = this.baseSourceSpan.start.moveBy(span.end);\n      const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n      return new ParseSourceSpan(start, end, fullStart);\n    } else {\n      return null;\n    }\n  }\n\n  /** Adds the name of an AST to the list of implicit receiver accesses. */\n  private addImplicitReceiverAccess(name: string) {\n    if (this.implicitReceiverAccesses) {\n      this.implicitReceiverAccesses.add(name);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nfunction unsupported(): never {\n  throw new Error('Unsupported operation');\n}\n\nclass InterpolationExpression extends o.Expression {\n  constructor(public args: o.Expression[]) {\n    super(null, null);\n  }\n\n  override isConstant = unsupported;\n  override isEquivalent = unsupported;\n  override visitExpression = unsupported;\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  constructor(public globals?: Set<string>) {}\n  notifyImplicitReceiverUse(): void {}\n  maybeRestoreView(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nexport class BuiltinFunctionCall extends cdAst.Call {\n  constructor(\n      span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, args: cdAst.AST[],\n      public converter: BuiltinConverter) {\n    super(span, sourceSpan, new cdAst.EmptyExpr(span, sourceSpan), args, null!);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA!: {[k: string]: SecurityContext};\n\nexport function SECURITY_SCHEMA(): {[k: string]: SecurityContext} {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n\n    registerContext(SecurityContext.HTML, [\n      'iframe|srcdoc',\n      '*|innerHTML',\n      '*|outerHTML',\n    ]);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n    registerContext(SecurityContext.URL, [\n      '*|formAction',\n      'area|href',\n      'area|ping',\n      'audio|src',\n      'a|href',\n      'a|ping',\n      'blockquote|cite',\n      'body|background',\n      'del|cite',\n      'form|action',\n      'img|src',\n      'input|src',\n      'ins|cite',\n      'q|cite',\n      'source|src',\n      'track|src',\n      'video|poster',\n      'video|src',\n    ]);\n    registerContext(SecurityContext.RESOURCE_URL, [\n      'applet|code',\n      'applet|codebase',\n      'base|href',\n      'embed|src',\n      'frame|src',\n      'head|profile',\n      'html|manifest',\n      'iframe|src',\n      'link|href',\n      'media|src',\n      'object|codebase',\n      'object|data',\n      'script|src',\n    ]);\n  }\n  return _SECURITY_SCHEMA;\n}\n\nfunction registerContext(ctx: SecurityContext, specs: string[]) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n\n/**\n * The set of security-sensitive attributes of an `<iframe>` that *must* be\n * applied as a static attribute only. This ensures that all security-sensitive\n * attributes are taken into account while creating an instance of an `<iframe>`\n * at runtime.\n *\n * Note: avoid using this set directly, use the `isIframeSecuritySensitiveAttr` function\n * in the code instead.\n */\nexport const IFRAME_SECURITY_SENSITIVE_ATTRS =\n    new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']);\n\n/**\n * Checks whether a given attribute name might represent a security-sensitive\n * attribute of an <iframe>.\n */\nexport function isIframeSecuritySensitiveAttr(attrName: string): boolean {\n  // The `setAttribute` DOM API is case-insensitive, so we lowercase the value\n  // before checking it against a known security-sensitive attributes.\n  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The following set contains all keywords that can be used in the animation css shorthand\n * property and is used during the scoping of keyframes to make sure such keywords\n * are not modified.\n */\nconst animationKeywords = new Set([\n  // global values\n  'inherit', 'initial', 'revert', 'unset',\n  // animation-direction\n  'alternate', 'alternate-reverse', 'normal', 'reverse',\n  // animation-fill-mode\n  'backwards', 'both', 'forwards', 'none',\n  // animation-play-state\n  'paused', 'running',\n  // animation-timing-function\n  'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end',\n  // `steps()` function\n  'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start'\n]);\n\n/**\n * The following class has its origin from a port of shadowCSS from webcomponents.js to TypeScript.\n * It has since diverge in many ways to tailor Angular's needs.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM.\n  The selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nexport class ShadowCss {\n  /*\n   * Shim some cssText with the given selector. Returns cssText that can be included in the document\n   *\n   * The selector is the attribute added to all elements inside the host,\n   * The hostSelector is the attribute added to the host itself.\n   */\n  shimCssText(cssText: string, selector: string, hostSelector: string = ''): string {\n    const commentsWithHash = extractCommentsWithHash(cssText);\n    cssText = stripComments(cssText);\n    cssText = this._insertDirectives(cssText);\n\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    return [scopedCssText, ...commentsWithHash].join('\\n');\n  }\n\n  private _insertDirectives(cssText: string): string {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n\n  /**\n   * Process styles to add scope to keyframes.\n   *\n   * Modify both the names of the keyframes defined in the component styles and also the css\n   * animation rules using them.\n   *\n   * Animation rules using keyframes defined elsewhere are not modified to allow for globally\n   * defined keyframes.\n   *\n   * For example, we convert this css:\n   *\n   * ```\n   * .box {\n   *   animation: box-animation 1s forwards;\n   * }\n   *\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * to this:\n   *\n   * ```\n   * .box {\n   *   animation: scopeName_box-animation 1s forwards;\n   * }\n   *\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * @param cssText the component's css text that needs to be scoped.\n   * @param scopeSelector the component's scope selector.\n   *\n   * @returns the scoped css text.\n   */\n  private _scopeKeyframesRelatedCss(cssText: string, scopeSelector: string): string {\n    const unscopedKeyframesSet = new Set<string>();\n    const scopedKeyframesCssText = processRules(\n        cssText,\n        rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n    return processRules(\n        scopedKeyframesCssText,\n        rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n  }\n\n  /**\n   * Scopes local keyframes names, returning the updated css rule and it also\n   * adds the original keyframe name to a provided set to collect all keyframes names\n   * so that it can later be used to scope the animation rules.\n   *\n   * For example, it takes a rule such as:\n   *\n   * ```\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * and returns:\n   *\n   * ```\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   * and as a side effect it adds \"box-animation\" to the `unscopedKeyframesSet` set\n   *\n   * @param cssRule the css rule to process.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names (which can be\n   * modified as a side effect)\n   *\n   * @returns the css rule modified with the scoped keyframes name.\n   */\n  private _scopeLocalKeyframeDeclarations(\n      rule: CssRule, scopeSelector: string, unscopedKeyframesSet: Set<string>): CssRule {\n    return {\n      ...rule,\n      selector: rule.selector.replace(\n          /(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/,\n          (_, start, quote, keyframeName, endSpaces) => {\n            unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n            return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n          }),\n    };\n  }\n\n  /**\n   * Function used to scope a keyframes name (obtained from an animation declaration)\n   * using an existing set of unscopedKeyframes names to discern if the scoping needs to be\n   * performed (keyframes names of keyframes not defined in the component's css need not to be\n   * scoped).\n   *\n   * @param keyframe the keyframes name to check.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the scoped name of the keyframe, or the original name is the name need not to be\n   * scoped.\n   */\n  private _scopeAnimationKeyframe(\n      keyframe: string, scopeSelector: string, unscopedKeyframesSet: ReadonlySet<string>): string {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${\n          name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n\n  /**\n   * Regular expression used to extrapolate the possible keyframes from an\n   * animation declaration (with possibly multiple animation definitions)\n   *\n   * The regular expression can be divided in three parts\n   *  - (^|\\s+)\n   *    simply captures how many (if any) leading whitespaces are present\n   *  - (?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))\n   *    captures two different possible keyframes, ones which are quoted or ones which are valid css\n   * idents (custom properties excluded)\n   *  - (?=[,\\s;]|$)\n   *    simply matches the end of the possible keyframe, valid endings are: a comma, a space, a\n   * semicolon or the end of the string\n   */\n  private _animationDeclarationKeyframesRe =\n      /(^|\\s+)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n\n  /**\n   * Scope an animation rule so that the keyframes mentioned in such rule\n   * are scoped if defined in the component's css and left untouched otherwise.\n   *\n   * It can scope values of both the 'animation' and 'animation-name' properties.\n   *\n   * @param rule css rule to scope.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the updated css rule.\n   **/\n  private _scopeAnimationRule(\n      rule: CssRule, scopeSelector: string, unscopedKeyframesSet: ReadonlySet<string>): CssRule {\n    let content = rule.content.replace(\n        /((?:^|\\s+|;)(?:-webkit-)?animation(?:\\s*):(?:\\s*))([^;]+)/g,\n        (_, start, animationDeclarations) => start +\n            animationDeclarations.replace(\n                this._animationDeclarationKeyframesRe,\n                (original: string, leadingSpaces: string, quote = '', quotedName: string,\n                 nonQuotedName: string) => {\n                  if (quotedName) {\n                    return `${leadingSpaces}${\n                        this._scopeAnimationKeyframe(\n                            `${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n                  } else {\n                    return animationKeywords.has(nonQuotedName) ?\n                        original :\n                        `${leadingSpaces}${\n                            this._scopeAnimationKeyframe(\n                                nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n                  }\n                }));\n    content = content.replace(\n        /((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g,\n        (_match, start, commaSeparatedKeyframes) => `${start}${\n            commaSeparatedKeyframes.split(',')\n                .map(\n                    (keyframe: string) =>\n                        this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet))\n                .join(',')}`);\n    return {...rule, content};\n  }\n\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   *\n   * to this:\n   *\n   * scopeName menu-item {\n   *\n   **/\n  private _insertPolyfillDirectivesInCssText(cssText: string): string {\n    return cssText.replace(_cssContentNextSelectorRe, function(...m: string[]) {\n      return m[2] + '{';\n    });\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   *\n   * to this:\n   *\n   * scopeName menu-item {...}\n   *\n   **/\n  private _insertPolyfillRulesInCssText(cssText: string): string {\n    return cssText.replace(_cssContentRuleRe, (...m: string[]) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   *\n   *  .foo {... }\n   *\n   *  and converts this to\n   *\n   *  scopeName .foo { ... }\n   */\n  private _scopeCssText(cssText: string, scopeSelector: string, hostSelector: string): string {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   *\n   * @polyfill-unscoped-rule {\n   *   content: 'menu-item';\n   * ... }\n   *\n   * to this:\n   *\n   * menu-item {...}\n   *\n   **/\n  private _extractUnscopedRulesFromCssText(cssText: string): string {\n    let r = '';\n    let m: RegExpExecArray|null;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar\n   */\n  private _convertColonHost(cssText: string): string {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n      if (hostSelectors) {\n        const convertedSelectors: string[] = [];\n        const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n        for (const hostSelector of hostSelectorArray) {\n          if (!hostSelector) break;\n          const convertedSelector =\n              _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n   *\n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   *\n   * to\n   *\n   * .foo<scopeName> .bar { ... }\n   */\n  private _convertColonHostContext(cssText: string): string {\n    return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n      // We have captured a selector that contains a `:host-context` rule.\n\n      // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n      // Each context selector group will contain a list of host-context selectors that must match\n      // an ancestor of the host.\n      // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n      const contextSelectorGroups: string[][] = [[]];\n\n      // There may be more than `:host-context` in this selector so `selectorText` could look like:\n      // `:host-context(.one):host-context(.two)`.\n      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n      // `:host-context` selectors from this selector.\n      let match: RegExpExecArray|null;\n      while (match = _cssColonHostContextRe.exec(selectorText)) {\n        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n\n        // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n        const newContextSelectors =\n            (match[1] ?? '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\n\n        // We must duplicate the current selector group for each of these new selectors.\n        // For example if the current groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c'],\n        //   ['x', 'y', 'z'],\n        // ]\n        // ```\n        // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n        // groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c', 'm'],\n        //   ['x', 'y', 'z', 'm'],\n        //   ['a', 'b', 'c', 'n'],\n        //   ['x', 'y', 'z', 'n'],\n        // ]\n        // ```\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(\n                newContextSelectors[i]);\n          }\n        }\n\n        // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n        selectorText = match[2];\n      }\n\n      // The context selectors now must be combined with each other to capture all the possible\n      // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n      // info about how this is done.\n      return contextSelectorGroups\n          .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\n          .join(', ');\n    });\n  }\n\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n   */\n  private _convertShadowDOMSelectors(cssText: string): string {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n\n  // change a selector like 'div' to 'name div'\n  private _scopeSelectors(cssText: string, scopeSelector: string, hostSelector: string): string {\n    return processRules(cssText, (rule: CssRule) => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector = this._scopeSelector(rule.selector, scopeSelector, hostSelector);\n      } else if (\n          rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n          rule.selector.startsWith('@document') || rule.selector.startsWith('@layer') ||\n          rule.selector.startsWith('@container')) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n\n  /**\n   * Handle a css text that is within a rule that should not contain scope selectors by simply\n   * removing them! An example of such a rule is `@font-face`.\n   *\n   * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n   * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n   * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n   * can end up with broken css if the imported styles happen to contain @font-face rules.\n   *\n   * For example:\n   *\n   * ```\n   * :host ::ng-deep {\n   *   import 'some/lib/containing/font-face';\n   * }\n   *\n   * Similar logic applies to `@page` rules which can contain a particular set of properties,\n   * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n   * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n   * ```\n   */\n  private _stripScopingSelectors(cssText: string): string {\n    return processRules(cssText, rule => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                           .replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n\n  private _scopeSelector(selector: string, scopeSelector: string, hostSelector: string): string {\n    return selector.split(',')\n        .map(part => part.trim().split(_shadowDeepSelectors))\n        .map((deepParts) => {\n          const [shallowPart, ...otherParts] = deepParts;\n          const applyScope = (shallowPart: string) => {\n            if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n              return this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n            } else {\n              return shallowPart;\n            }\n          };\n          return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n        .join(', ');\n  }\n\n  private _selectorNeedsScoping(selector: string, scopeSelector: string): boolean {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n\n  private _makeScopeMatcher(scopeSelector: string): RegExp {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n\n  // scope via name and [is=name]\n  private _applySimpleSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = `[${hostSelector}]`;\n      return selector\n          .replace(\n              _polyfillHostNoCombinatorRe,\n              (hnc, selector) => {\n                return selector.replace(\n                    /([^:]*)(:*)(.*)/,\n                    (_: string, before: string, colon: string, after: string) => {\n                      return before + replaceBy + colon + after;\n                    });\n              })\n          .replace(_polyfillHostRe, replaceBy + ' ');\n    }\n\n    return scopeSelector + ' ' + selector;\n  }\n\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n  private _applySelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_: string, ...parts: string[]) => parts[0]);\n\n    const attrName = '[' + scopeSelector + ']';\n\n    const _scopeSelectorPart = (p: string) => {\n      let scopedP = p.trim();\n\n      if (!scopedP) {\n        return '';\n      }\n\n      if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n      } else {\n        // remove :host since it should be unnecessary\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)(.*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n\n      return scopedP;\n    };\n\n    const safeContent = new SafeSelector(selector);\n    selector = safeContent.content();\n\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res: RegExpExecArray|null;\n    const sep = /( |>|\\+|~(?!=))\\s*/g;\n\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n    let shouldScope = !hasHost;\n\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index).trim();\n\n      // A space following an escaped hex value and followed by another hex character\n      // (ie: \".\\fc ber\" for \".Ã¼ber\") is not a separator between 2 selectors\n      // also keep in mind that backslashes are replaced by a placeholder by SafeSelector\n      // These escaped selectors happen for example when esbuild runs with optimization.minify.\n      if (part.match(_placeholderRe) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n        continue;\n      }\n\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n\n    const part = selector.substring(startIndex);\n    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n\n    // replace the placeholders with their original values\n    return safeContent.restore(scopedSelector);\n  }\n\n  private _insertPolyfillHostInCssText(selector: string): string {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext)\n        .replace(_colonHostRe, _polyfillHost);\n  }\n}\n\nclass SafeSelector {\n  private placeholders: string[] = [];\n  private index = 0;\n  private _content: string;\n\n  constructor(selector: string) {\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n\n    // CSS allows for certain special characters to be used in selectors if they're escaped.\n    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n    // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n    // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n    // that our handling of pseudo-selectors doesn't mess with them.\n    selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(exp);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  restore(content: string): string {\n    return content.replace(_placeholderRe, (_ph, index) => this.placeholders[+index]);\n  }\n\n  content(): string {\n    return this._content;\n  }\n\n  /**\n   * Replaces all of the substrings that match a regex within a\n   * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n   */\n  private _escapeRegexMatches(content: string, pattern: RegExp): string {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\n\nconst _cssContentNextSelectorRe =\n    /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe =\n    /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n  /::shadow/g,\n  /::content/g,\n  // Deprecated selectors\n  /\\/shadow-deep\\//g,\n  /\\/shadow\\//g,\n];\n\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\n\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\n\nconst _placeholderRe = /__ph-(\\d+)__/g;\n\nfunction stripComments(input: string): string {\n  return input.replace(_commentRe, '');\n}\n\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\n\nfunction extractCommentsWithHash(input: string): string[] {\n  return input.match(_commentWithHashRe) || [];\n}\n\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst CONTENT_PAIRS = new Map([['{', '}']]);\n\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\n\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\n\nexport class CssRule {\n  constructor(public selector: string, public content: string) {}\n}\n\nexport function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m: string[]) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\n\nclass StringWithEscapedBlocks {\n  constructor(public escapedString: string, public blocks: string[]) {}\n}\n\nfunction escapeBlocks(\n    input: string, charPairs: Map<string, string>, placeholder: string): StringWithEscapedBlocks {\n  const resultParts: string[] = [];\n  const escapedBlocks: string[] = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar: string|undefined;\n  let closeChar: string|undefined;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * Object containing as keys characters that should be substituted by placeholders\n * when found in strings during the css text parsing, and as values the respective\n * placeholders\n */\nconst ESCAPE_IN_STRING_MAP: {[key: string]: string} = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER\n};\n\n/**\n * Parse the provided css text and inside strings (meaning, inside pairs of unescaped single or\n * double quotes) replace specific characters with their respective placeholders as indicated\n * by the `ESCAPE_IN_STRING_MAP` map.\n *\n * For example convert the text\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n * to\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n *\n * This is necessary in order to remove the meaning of some characters when found inside strings\n * (for example `;` indicates the end of a css declaration, `,` the sequence of values and `:` the\n * division between property and value during a declaration, none of these meanings apply when such\n * characters are within strings and so in order to prevent parsing issues they need to be replaced\n * with placeholder text for the duration of the css manipulation process).\n *\n * @param input the original css text.\n *\n * @returns the css text with specific characters in strings replaced by placeholders.\n **/\nfunction escapeInStrings(input: string): string {\n  let result = input;\n  let currentQuoteChar: string|null = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        // index i is inside a quoted sub-string\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder: string|undefined = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === '\\'' || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Replace in a string all occurrences of keys in the `ESCAPE_IN_STRING_MAP` map with their\n * original representation, this is simply used to revert the changes applied by the\n * escapeInStrings function.\n *\n * For example it reverts the text:\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n * to it's original form of:\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n *\n * Note: For the sake of simplicity this function does not check that the placeholders are\n * actually inside strings as it would anyway be extremely unlikely to find them outside of strings.\n *\n * @param input the css text containing the placeholders.\n *\n * @returns the css text without the placeholders.\n */\nfunction unescapeInStrings(input: string): string {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\n\n/**\n * Unescape all quotes present in a string, but only if the string was actually already\n * quoted.\n *\n * This generates a \"canonical\" representation of strings which can be used to match strings\n * which would otherwise only differ because of differently escaped quotes.\n *\n * For example it converts the string (assumed to be quoted):\n *  `this \\\\\"is\\\\\" a \\\\'\\\\\\\\'test`\n * to:\n *  `this \"is\" a '\\\\\\\\'test`\n * (note that the latter backslashes are not removed as they are not actually escaping the single\n * quote)\n *\n *\n * @param input the string possibly containing escaped quotes.\n * @param isQuoted boolean indicating whether the string was quoted inside a bigger string (if not\n * then it means that it doesn't represent an inner string and thus no unescaping is required)\n *\n * @returns the string in the \"canonical\" representation without escaped quotes.\n */\nfunction unescapeQuotes(str: string, isQuoted: boolean): string {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\n\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param hostMarker the string that selects the host element.\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors: string[], otherSelectors: string): string {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;  // reset the regex to ensure we get an accurate test\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n\n  // If there are no context selectors then just output a host marker\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n\n  const combined: string[] = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      // Add the new selector as a descendant of the previous selectors\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      // Add the new selector as an ancestor of the previous selectors\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      // Add the new selector to act on the same element as the previous selectors\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n  return combined\n      .map(\n          s => otherSelectorsHasHost ?\n              `${s}${otherSelectors}` :\n              `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n      .join(',');\n}\n\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nexport function repeatGroups(groups: string[][], multiples: number): void {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + (i * length)] = groups[j].slice(0);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  isClosedByChild(name: string): boolean;\n  getContentType(prefix?: string): TagContentType;\n}\n\nexport function splitNsName(elementName: string): [string|null, string] {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string|null): string|null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as core from '../../../../core';\nimport {splitNsName} from '../../../../ml_parser/tags';\nimport * as o from '../../../../output/output_ast';\n\n/**\n * Enumeration of the types of attributes which can be applied to an element.\n */\nexport enum ElementAttributeKind {\n  /**\n   * Static attributes.\n   */\n  Attribute,\n\n  /**\n   * Class bindings.\n   */\n  Class,\n\n  /**\n   * Style bindings.\n   */\n  Style,\n\n  /**\n   * Dynamic property or attribute bindings.\n   */\n  Binding,\n\n  /**\n   * Attributes on a template node.\n   */\n  Template,\n\n  /**\n   * Internationalized attributes.\n   */\n  I18n,\n}\n\nconst FLYWEIGHT_ARRAY: ReadonlyArray<o.Expression> = Object.freeze<o.Expression[]>([]);\n\n/**\n * Container for all of the various kinds of attributes which are applied on an element.\n */\nexport class ElementAttributes {\n  private known = new Set<string>();\n  private byKind = new Map<ElementAttributeKind, o.Expression[]>;\n\n  projectAs: string|null = null;\n\n  get attributes(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ElementAttributeKind.Attribute) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get classes(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ElementAttributeKind.Class) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get styles(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ElementAttributeKind.Style) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get bindings(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ElementAttributeKind.Binding) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get template(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ElementAttributeKind.Template) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get i18n(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ElementAttributeKind.I18n) ?? FLYWEIGHT_ARRAY;\n  }\n\n  add(kind: ElementAttributeKind, name: string, value: o.Expression|null): void {\n    if (this.known.has(name)) {\n      return;\n    }\n    this.known.add(name);\n    const array = this.arrayFor(kind);\n    array.push(...getAttributeNameLiterals(name));\n    if (value !== null) {\n      array.push(value);\n    }\n  }\n\n  private arrayFor(kind: ElementAttributeKind): o.Expression[] {\n    if (!this.byKind.has(kind)) {\n      this.byKind.set(kind, []);\n    }\n    return this.byKind.get(kind)!;\n  }\n}\n\nfunction getAttributeNameLiterals(name: string): o.LiteralExpr[] {\n  const [attributeNamespace, attributeName] = splitNsName(name);\n  const nameLiteral = o.literal(attributeName);\n\n  if (attributeNamespace) {\n    return [\n      o.literal(core.AttributeMarker.NamespaceURI), o.literal(attributeNamespace), nameLiteral\n    ];\n  }\n\n  return [nameLiteral];\n}\n\nexport function assertIsElementAttributes(attrs: any): asserts attrs is ElementAttributes {\n  if (!(attrs instanceof ElementAttributes)) {\n    throw new Error(\n        `AssertionError: ElementAttributes has already been coalesced into the view constants`);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Distinguishes different kinds of IR operations.\n *\n * Includes both creation and update operations.\n */\nexport enum OpKind {\n  /**\n   * A special operation type which is used to represent the beginning and end nodes of a linked\n   * list of operations.\n   */\n  ListEnd,\n\n  /**\n   * An operation which wraps an output AST statement.\n   */\n  Statement,\n\n  /**\n   * An operation which declares and initializes a `SemanticVariable`.\n   */\n  Variable,\n\n  /**\n   * An operation to begin rendering of an element.\n   */\n  ElementStart,\n\n  /**\n   * An operation to render an element with no children.\n   */\n  Element,\n\n  /**\n   * An operation which declares an embedded view.\n   */\n  Template,\n\n  /**\n   * An operation to end rendering of an element previously started with `ElementStart`.\n   */\n  ElementEnd,\n\n  /**\n   * An operation to render a text node.\n   */\n  Text,\n\n  /**\n   * An operation declaring an event listener for an element.\n   */\n  Listener,\n\n  /**\n   * An operation to interpolate text into a text node.\n   */\n  InterpolateText,\n\n  /**\n   * An operation to bind an expression to a property of an element.\n   */\n  Property,\n\n  /**\n   * An operation to advance the runtime's implicit slot context during the update phase of a view.\n   */\n  Advance,\n}\n\n/**\n * Distinguishes different kinds of IR expressions.\n */\nexport enum ExpressionKind {\n  /**\n   * Read of a variable in a lexical scope.\n   */\n  LexicalRead,\n\n  /**\n   * A reference to the current view context.\n   */\n  Context,\n\n  /**\n   * Read of a variable declared in a `VariableOp`.\n   */\n  ReadVariable,\n\n  /**\n   * Runtime operation to navigate to the next view context in the view hierarchy.\n   */\n  NextContext,\n\n  /**\n   * Runtime operation to retrieve the value of a local reference.\n   */\n  Reference,\n\n  /**\n   * Runtime operation to snapshot the current view context.\n   */\n  GetCurrentView,\n\n  /**\n   * Runtime operation to restore a snapshotted view.\n   */\n  RestoreView,\n\n  /**\n   * Runtime operation to reset the current view context after `RestoreView`.\n   */\n  ResetView,\n}\n\n/**\n * Distinguishes between different kinds of `SemanticVariable`s.\n */\nexport enum SemanticVariableKind {\n  /**\n   * Represents the context of a particular view.\n   */\n  Context,\n\n  /**\n   * Represents an identifier declared in the lexical scope of a view.\n   */\n  Identifier,\n\n  /**\n   * Represents a saved state that can be used to restore a view in a listener handler function.\n   */\n  SavedView,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport type {Op, XrefId} from './operations';\nimport type {Expression} from './expression';\n\n/**\n * Marker symbol for `ConsumesSlotOpTrait`.\n */\nexport const ConsumesSlot = Symbol('ConsumesSlot');\n\n/**\n * Marker symbol for `DependsOnSlotContextOpTrait`.\n */\nexport const DependsOnSlotContext = Symbol('DependsOnSlotContext');\n\n/**\n * Marker symbol for `UsesSlotIndex` trait.\n */\nexport const UsesSlotIndex = Symbol('UsesSlotIndex');\n\n/**\n * Marker symbol for `ConsumesVars` trait.\n */\nexport const ConsumesVarsTrait = Symbol('UsesVars');\n\n/**\n * Marks an operation as requiring allocation of one or more data slots for storage.\n */\nexport interface ConsumesSlotOpTrait {\n  readonly[ConsumesSlot]: true;\n\n  /**\n   * Assigned data slot (the starting index, if more than one slot is needed) for this operation, or\n   * `null` if slots have not yet been assigned.\n   */\n  slot: number|null;\n\n  /**\n   * The number of slots which will be used by this operation. By default 1, but can be increased if\n   * necessary.\n   */\n  numSlotsUsed: number;\n\n  /**\n   * `XrefId` of this operation (e.g. the element stored in the assigned slot). This `XrefId` is\n   * used to link this `ConsumesSlotOpTrait` operation with `DependsOnSlotContextTrait` or\n   * `UsesSlotIndexExprTrait` implementors and ensure that the assigned slot is propagated through\n   * the IR to all consumers.\n   */\n  xref: XrefId;\n}\n\n\n/**\n * Marks an operation as depending on the runtime's implicit slot context being set to a particular\n * slot.\n *\n * The runtime has an implicit slot context which is adjusted using the `advance()` instruction\n * during the execution of template update functions. This trait marks an operation as requiring\n * this implicit context to be `advance()`'d to point at a particular slot prior to execution.\n */\nexport interface DependsOnSlotContextOpTrait {\n  readonly[DependsOnSlotContext]: true;\n\n  /**\n   * `XrefId` of the `ConsumesSlotOpTrait` which the implicit slot context must reference before\n   * this operation can be executed.\n   */\n  target: XrefId;\n}\n\n\n/**\n * Marks an expression which requires knowledge of the assigned slot of a given\n * `ConsumesSlotOpTrait` implementor (e.g. an element slot).\n *\n * During IR processing, assigned slots of `ConsumesSlotOpTrait` implementors will be propagated to\n * `UsesSlotIndexTrait` implementors by matching their `XrefId`s.\n */\nexport interface UsesSlotIndexTrait {\n  readonly[UsesSlotIndex]: true;\n\n  /**\n   * `XrefId` of the `ConsumesSlotOpTrait` which this expression needs to reference by its assigned\n   * slot index.\n   */\n  target: XrefId;\n\n  /**\n   * The slot index of `target`, or `null` if slots have not yet been assigned.\n   */\n  slot: number|null;\n}\n\n/**\n * Marker trait indicating that an operation or expression consumes variable storage space.\n */\nexport interface ConsumesVarsTrait {\n  [ConsumesVarsTrait]: true;\n}\n\n/**\n * Default values for most `ConsumesSlotOpTrait` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_CONSUMES_SLOT: Omit<ConsumesSlotOpTrait, 'xref'> = {\n  [ConsumesSlot]: true,\n  slot: null,\n  numSlotsUsed: 1,\n} as const;\n\n/**\n * Default values for most `UsesSlotIndexTrait` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_USES_SLOT_INDEX: Omit<UsesSlotIndexTrait, 'target'> = {\n  [UsesSlotIndex]: true,\n  slot: null,\n} as const;\n\n/**\n * Default values for most `DependsOnSlotContextOpTrait` fields (used with the spread operator to\n * initialize implementors of the trait).\n */\nexport const TRAIT_DEPENDS_ON_SLOT_CONTEXT: Omit<DependsOnSlotContextOpTrait, 'target'> = {\n  [DependsOnSlotContext]: true,\n} as const;\n\n/**\n * Default values for `UsesVars` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_CONSUMES_VARS: ConsumesVarsTrait = {\n  [ConsumesVarsTrait]: true,\n} as const;\n\n/**\n * Test whether an operation implements `ConsumesSlotOpTrait`.\n */\nexport function hasConsumesSlotTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&ConsumesSlotOpTrait {\n  return (op as Partial<ConsumesSlotOpTrait>)[ConsumesSlot] === true;\n}\n\n/**\n * Test whether an operation implements `DependsOnSlotContextOpTrait`.\n */\nexport function hasDependsOnSlotContextTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&\n    DependsOnSlotContextOpTrait {\n  return (op as Partial<DependsOnSlotContextOpTrait>)[DependsOnSlotContext] === true;\n}\n\n/**\n * Test whether an operation implements `ConsumesVarsTrait`.\n */\nexport function hasConsumesVarsTrait<ExprT extends Expression>(expr: ExprT): expr is ExprT&\n    ConsumesVarsTrait;\nexport function hasConsumesVarsTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&ConsumesVarsTrait;\nexport function hasConsumesVarsTrait(value: any): boolean {\n  return (value as Partial<ConsumesVarsTrait>)[ConsumesVarsTrait] === true;\n}\n\n/**\n * Test whether an operation or expression implements `UsesSlotIndexTrait`.\n */\nexport function hasUsesSlotIndexTrait<ExprT extends Expression>(expr: ExprT): expr is ExprT&\n    UsesSlotIndexTrait;\nexport function hasUsesSlotIndexTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&UsesSlotIndexTrait;\nexport function hasUsesSlotIndexTrait(value: any): boolean {\n  return (value as Partial<UsesSlotIndexTrait>)[UsesSlotIndex] === true;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport type {ParseSourceSpan} from '../../../../parse_util';\n\nimport {ExpressionKind, OpKind} from './enums';\nimport {UsesSlotIndex, UsesSlotIndexTrait} from './traits';\n\nimport type {XrefId} from './operations';\nimport type {CreateOp} from './ops/create';\nimport type {UpdateOp} from './ops/update';\n\n/**\n * An `o.Expression` subtype representing a logical expression in the intermediate representation.\n */\nexport type Expression = LexicalReadExpr|ReferenceExpr|ContextExpr|NextContextExpr|\n    GetCurrentViewExpr|RestoreViewExpr|ResetViewExpr|ReadVariableExpr;\n\n/**\n * Transformer type which converts IR expressions into general `o.Expression`s (which may be an\n * identity transformation).\n */\nexport type ExpressionTransform = (expr: Expression, flags: VisitorContextFlag) => o.Expression;\n\n/**\n * Check whether a given `o.Expression` is a logical IR expression type.\n */\nexport function isIrExpression(expr: o.Expression): boolean {\n  return expr instanceof ExpressionBase;\n}\n\n/**\n * Base type used for all logical IR expressions.\n */\nexport abstract class ExpressionBase extends o.Expression {\n  abstract readonly kind: ExpressionKind;\n\n  constructor(sourceSpan: ParseSourceSpan|null = null) {\n    super(null, sourceSpan);\n  }\n\n  /**\n   * Run the transformer against any nested expressions which may be present in this IR expression\n   * subtype.\n   */\n  abstract transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void;\n}\n\n/**\n * Logical expression representing a lexical read of a variable name.\n */\nexport class LexicalReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.LexicalRead;\n\n  constructor(readonly name: string) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {}\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * Runtime operation to retrieve the value of a local reference.\n */\nexport class ReferenceExpr extends ExpressionBase implements UsesSlotIndexTrait {\n  override readonly kind = ExpressionKind.Reference;\n\n  readonly[UsesSlotIndex] = true;\n\n  slot: number|null = null;\n\n  constructor(readonly target: XrefId, readonly offset: number) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * A reference to the current view context (usually the `ctx` variable in a template function).\n */\nexport class ContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.Context;\n\n  constructor(readonly view: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * Runtime operation to navigate to the next view context in the view hierarchy.\n */\nexport class NextContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.NextContext;\n\n  steps = 1;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * Runtime operation to snapshot the current view context.\n *\n * The result of this operation can be stored in a variable and later used with the `RestoreView`\n * operation.\n */\nexport class GetCurrentViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.GetCurrentView;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof GetCurrentViewExpr;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * Runtime operation to restore a snapshotted view.\n */\nexport class RestoreViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.RestoreView;\n\n  constructor(public view: XrefId|o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view as o.Expression);\n    }\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n}\n\n/**\n * Runtime operation to reset the current view context after `RestoreView`.\n */\nexport class ResetViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ResetView;\n\n  constructor(public expr: o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n}\n\n/**\n * Read of a variable declared as an `ir.VariableOp` and referenced through its `ir.XrefId`.\n */\nexport class ReadVariableExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadVariable;\n  name: string|null = null;\n  constructor(readonly xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * Visits all `Expression`s in the AST of `op` with the `visitor` function.\n */\nexport function visitExpressionsInOp(\n    op: CreateOp|UpdateOp, visitor: (expr: Expression, flags: VisitorContextFlag) => void): void {\n  transformExpressionsInOp(op, (expr, flags) => {\n    visitor(expr, flags);\n    return expr;\n  }, VisitorContextFlag.None);\n}\n\nexport enum VisitorContextFlag {\n  None = 0b0000,\n  InChildOperation = 0b0001,\n}\n\n/**\n * Transform all `Expression`s in the AST of `op` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInOp(\n    op: CreateOp|UpdateOp, transform: ExpressionTransform, flags: VisitorContextFlag): void {\n  switch (op.kind) {\n    case OpKind.Property:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      for (let i = 0; i < op.expressions.length; i++) {\n        op.expressions[i] = transformExpressionsInExpression(op.expressions[i], transform, flags);\n      }\n      break;\n    case OpKind.Listener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.Element:\n    case OpKind.ElementStart:\n    case OpKind.ElementEnd:\n    case OpKind.Template:\n    case OpKind.Text:\n    case OpKind.Advance:\n      // These operations contain no expressions.\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `expr` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInExpression(\n    expr: o.Expression, transform: ExpressionTransform, flags: VisitorContextFlag): o.Expression {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n    return transform(expr as Expression, flags);\n  } else if (expr instanceof o.BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof o.ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof o.InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (\n      expr instanceof o.ReadVarExpr || expr instanceof o.ExternalExpr ||\n      expr instanceof o.LiteralExpr) {\n    // No action for these types.\n  } else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return expr;\n}\n\n/**\n * Transform all `Expression`s in the AST of `stmt` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInStatement(\n    stmt: o.Statement, transform: ExpressionTransform, flags: VisitorContextFlag): void {\n  if (stmt instanceof o.ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof o.ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OpKind} from './enums';\n\n/**\n * Branded type for a cross-reference ID. During ingest, `XrefId`s are generated to link together\n * different IR operations which need to reference each other.\n */\nexport type XrefId = number&{__brand: 'XrefId'};\n\n/**\n * Base interface for semantic operations being performed within a template.\n *\n * @param OpT a specific narrower type of `Op` (for example, creation operations) which this\n *     specific subtype of `Op` can be linked with in a linked list.\n */\nexport interface Op<OpT extends Op<OpT>> {\n  /**\n   * All operations have a distinct kind.\n   */\n  kind: OpKind;\n\n  /**\n   * The previous operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  prev: OpT|null;\n\n  /**\n   * The next operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  next: OpT|null;\n\n  /**\n   * Debug id of the list to which this node currently belongs, or `null` if this node is not part\n   * of a list.\n   */\n  debugListId: number|null;\n}\n\n/**\n * A linked list of `Op` nodes of a given subtype.\n *\n * @param OpT specific subtype of `Op` nodes which this list contains.\n */\nexport class OpList<OpT extends Op<OpT>> {\n  static nextListId = 0;\n\n  /**\n   * Debug ID of this `OpList` instance.\n   */\n  readonly debugListId = OpList.nextListId++;\n\n  // OpList uses static head/tail nodes of a special `ListEnd` type.\n  // This avoids the need for special casing of the first and last list\n  // elements in all list operations.\n  readonly head: OpT = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n  readonly tail = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n\n  constructor() {\n    // Link `head` and `tail` together at the start (list is empty).\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  /**\n   * Push a new operation to the tail of the list.\n   */\n  push(op: OpT): void {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = this.debugListId;\n\n    // The old \"previous\" node (which might be the head, if the list is empty).\n    const oldLast = this.tail.prev!;\n\n    // Insert `op` following the old last node.\n    op.prev = oldLast;\n    oldLast.next = op;\n\n    // Connect `op` with the list tail.\n    op.next = this.tail;\n    this.tail.prev = op;\n  }\n\n  /**\n   * Prepend one or more nodes to the start of the list.\n   */\n  prepend(ops: OpT[]): void {\n    if (ops.length === 0) {\n      return;\n    }\n\n    for (const op of ops) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n\n      op.debugListId = this.debugListId;\n    }\n\n    const first = this.head.next!;\n\n    let prev = this.head;\n    for (const op of ops) {\n      prev.next = op;\n      op.prev = prev;\n\n      prev = op;\n    }\n\n    prev.next = first;\n    first.prev = prev;\n  }\n\n  /**\n   * `OpList` is iterable via the iteration protocol.\n   *\n   * It's safe to mutate the part of the list that has already been returned by the iterator, up to\n   * and including the last operation returned. Mutations beyond that point _may_ be safe, but may\n   * also corrupt the iteration position and should be avoided.\n   */\n  * [Symbol.iterator](): Generator<OpT> {\n    let current = this.head.next!;\n    while (current !== this.tail) {\n      // Guards against corruption of the iterator state by mutations to the tail of the list during\n      // iteration.\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const next = current.next!;\n      yield current;\n      current = next;\n    }\n  }\n\n  * reversed(): Generator<OpT> {\n    let current = this.tail.prev!;\n    while (current !== this.head) {\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const prev = current.prev!;\n      yield current;\n      current = prev;\n    }\n  }\n\n  /**\n   * Replace `oldOp` with `newOp` in the list.\n   */\n  static replace<OpT extends Op<OpT>>(oldOp: OpT, newOp: OpT): void {\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsNotEnd(newOp);\n\n    OpList.assertIsOwned(oldOp);\n    OpList.assertIsUnowned(newOp);\n\n    newOp.debugListId = oldOp.debugListId;\n    if (oldOp.prev !== null) {\n      oldOp.prev.next = newOp;\n      newOp.prev = oldOp.prev;\n    }\n    if (oldOp.next !== null) {\n      oldOp.next.prev = newOp;\n      newOp.next = oldOp.next;\n    }\n    oldOp.debugListId = null;\n    oldOp.prev = null;\n    oldOp.next = null;\n  }\n\n  /**\n   * Replace `oldOp` with some number of new operations in the list (which may include `oldOp`).\n   */\n  static replaceWithMany<OpT extends Op<OpT>>(oldOp: OpT, newOps: OpT[]): void {\n    if (newOps.length === 0) {\n      // Replacing with an empty list -> pure removal.\n      OpList.remove(oldOp);\n      return;\n    }\n\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsOwned(oldOp);\n\n    const listId = oldOp.debugListId;\n    oldOp.debugListId = null;\n\n    for (const newOp of newOps) {\n      OpList.assertIsNotEnd(newOp);\n\n      // `newOp` might be `oldOp`, but at this point it's been marked as unowned.\n      OpList.assertIsUnowned(newOp);\n    }\n\n    // It should be safe to reuse `oldOp` in the `newOps` list - maybe you want to sandwich an\n    // operation between two new ops.\n    const {prev: oldPrev, next: oldNext} = oldOp;\n    oldOp.prev = null;\n    oldOp.next = null;\n\n    let prev: OpT = oldPrev!;\n    for (const newOp of newOps) {\n      this.assertIsUnowned(newOp);\n      newOp.debugListId = listId;\n\n      prev!.next = newOp;\n      newOp.prev = prev;\n\n      // This _should_ be the case, but set it just in case.\n      newOp.next = null;\n\n      prev = newOp;\n    }\n    // At the end of iteration, `prev` holds the last node in the list.\n    const first = newOps[0]!;\n    const last = prev!;\n\n    // Replace `oldOp` with the chain `first` -> `last`.\n    if (oldPrev !== null) {\n      oldPrev.next = first;\n      first.prev = oldOp.prev;\n    }\n\n    if (oldNext !== null) {\n      oldNext.prev = last;\n      last.next = oldNext;\n    }\n  }\n\n  /**\n   * Remove the given node from the list which contains it.\n   */\n  static remove<OpT extends Op<OpT>>(op: OpT): void {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsOwned(op);\n\n    op.prev!.next = op.next;\n    op.next!.prev = op.prev;\n\n    // Break any link between the node and this list to safeguard against its usage in future\n    // operations.\n    op.debugListId = null;\n    op.prev = null;\n    op.next = null;\n  }\n\n  /**\n   * Insert `op` before `before`.\n   */\n  static insertBefore<OpT extends Op<OpT>>(op: OpT, before: OpT): void {\n    OpList.assertIsNotEnd(before);\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n    OpList.assertIsOwned(before);\n\n    op.debugListId = before.debugListId;\n\n    // Just in case.\n    op.prev = null;\n\n    before.prev!.next = op;\n    op.prev = before.prev;\n\n    op.next = before;\n    before.prev = op;\n  }\n\n  /**\n   * Asserts that `op` does not currently belong to a list.\n   */\n  static assertIsUnowned<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.debugListId !== null) {\n      throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n    }\n  }\n\n  /**\n   * Asserts that `op` currently belongs to a list. If `byList` is passed, `op` is asserted to\n   * specifically belong to that list.\n   */\n  static assertIsOwned<OpT extends Op<OpT>>(op: OpT, byList?: number): void {\n    if (op.debugListId === null) {\n      throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n    } else if (byList !== undefined && op.debugListId !== byList) {\n      throw new Error(`AssertionError: node belongs to the wrong list (expected ${byList}, actual ${\n          op.debugListId})`);\n    }\n  }\n\n  /**\n   * Asserts that `op` is not a special `ListEnd` node.\n   */\n  static assertIsNotEnd<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.kind === OpKind.ListEnd) {\n      throw new Error(`AssertionError: illegal operation on list head or tail`);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../../output/output_ast';\nimport {OpKind} from '../enums';\nimport {Op, XrefId} from '../operations';\nimport {SemanticVariable} from '../variable';\n\n/**\n * A special `Op` which is used internally in the `OpList` linked list to represent the head and\n * tail nodes of the list.\n *\n * `ListEndOp` is created internally in the `OpList` and should not be instantiated directly.\n */\nexport interface ListEndOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.ListEnd;\n}\n\n/**\n * An `Op` which directly wraps an output `Statement`.\n *\n * Often `StatementOp`s are the final result of IR processing.\n */\nexport interface StatementOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.Statement;\n\n  /**\n   * The output statement.\n   */\n  statement: o.Statement;\n}\n\n/**\n * Create a `StatementOp`.\n */\nexport function createStatementOp<OpT extends Op<OpT>>(statement: o.Statement): StatementOp<OpT> {\n  return {\n    kind: OpKind.Statement,\n    statement,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Operation which declares and initializes a `SemanticVariable`, that is valid either in create or\n * update IR.\n */\nexport interface VariableOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.Variable;\n\n  /**\n   * `XrefId` which identifies this specific variable, and is used to reference this variable from\n   * other parts of the IR.\n   */\n  xref: XrefId;\n\n  /**\n   * The `SemanticVariable` which describes the meaning behind this variable.\n   */\n  variable: SemanticVariable;\n\n  /**\n   * Expression representing the value of the variable.\n   */\n  initializer: o.Expression;\n}\n\n/**\n * Create a `VariableOp`.\n */\nexport function createVariableOp<OpT extends Op<OpT>>(\n    xref: XrefId, variable: SemanticVariable, initializer: o.Expression): VariableOp<OpT> {\n  return {\n    kind: OpKind.Variable,\n    xref,\n    variable,\n    initializer,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Static structure shared by all operations.\n *\n * Used as a convenience via the spread operator (`...NEW_OP`) when creating new operations, and\n * ensures the fields are always in the same order.\n */\nexport const NEW_OP: Pick<Op<any>, 'debugListId'|'prev'|'next'> = {\n  debugListId: null,\n  prev: null,\n  next: null,\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementAttributes} from '../element';\nimport {OpKind} from '../enums';\nimport {Op, OpList, XrefId} from '../operations';\nimport {ConsumesSlotOpTrait, TRAIT_CONSUMES_SLOT, TRAIT_USES_SLOT_INDEX, UsesSlotIndexTrait} from '../traits';\n\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\nimport type {UpdateOp} from './update';\n\n/**\n * An operation usable on the creation side of the IR.\n */\nexport type CreateOp = ListEndOp<CreateOp>|StatementOp<CreateOp>|ElementOp|ElementStartOp|\n    ElementEndOp|TemplateOp|TextOp|ListenerOp|VariableOp<CreateOp>;\n\n/**\n * Representation of a local reference on an element.\n */\nexport interface LocalRef {\n  /**\n   * User-defined name of the local ref variable.\n   */\n  name: string;\n\n  /**\n   * Target of the local reference variable (often `''`).\n   */\n  target: string;\n}\n\n/**\n * Base interface for `Element`, `ElementStart`, and `Template` operations, containing common fields\n * used to represent their element-like nature.\n */\nexport interface ElementOpBase extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Element|OpKind.ElementStart|OpKind.Template;\n\n  /**\n   * `XrefId` allocated for this element.\n   *\n   * This ID is used to reference this element from other IR structures.\n   */\n  xref: XrefId;\n\n  /**\n   * The HTML tag name for this element.\n   */\n  tag: string;\n\n  /**\n   * Attributes of various kinds on this element.\n   *\n   * Before attribute processing, this is an `ElementAttributes` structure representing the\n   * attributes on this element.\n   *\n   * After processing, it's a `ConstIndex` pointer into the shared `consts` array of the component\n   * compilation.\n   */\n  attributes: ElementAttributes|ConstIndex|null;\n\n  /**\n   * Local references to this element.\n   *\n   * Before local ref processing, this is an array of `LocalRef` declarations.\n   *\n   * After processing, it's a `ConstIndex` pointer into the shared `consts` array of the component\n   * compilation.\n   */\n  localRefs: LocalRef[]|ConstIndex|null;\n}\n\n/**\n * Logical operation representing the start of an element in the creation IR.\n */\nexport interface ElementStartOp extends ElementOpBase {\n  kind: OpKind.ElementStart;\n}\n\n/**\n * Create an `ElementStartOp`.\n */\nexport function createElementStartOp(tag: string, xref: XrefId): ElementStartOp {\n  return {\n    kind: OpKind.ElementStart,\n    xref,\n    tag,\n    attributes: new ElementAttributes(),\n    localRefs: [],\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing an element with no children in the creation IR.\n */\nexport interface ElementOp extends ElementOpBase {\n  kind: OpKind.Element;\n}\n\n/**\n * Logical operation representing an embedded view declaration in the creation IR.\n */\nexport interface TemplateOp extends ElementOpBase {\n  kind: OpKind.Template;\n\n  /**\n   * The number of declaration slots used by this template, or `null` if slots have not yet been\n   * assigned.\n   */\n  decls: number|null;\n\n  /**\n   * The number of binding variable slots used by this template, or `null` if binding variables have\n   * not yet been counted.\n   */\n  vars: number|null;\n}\n\n/**\n * Create a `TemplateOp`.\n */\nexport function createTemplateOp(xref: XrefId, tag: string): TemplateOp {\n  return {\n    kind: OpKind.Template,\n    xref,\n    attributes: new ElementAttributes(),\n    tag,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing the end of an element structure in the creation IR.\n *\n * Pairs with an `ElementStart` operation.\n */\nexport interface ElementEndOp extends Op<CreateOp> {\n  kind: OpKind.ElementEnd;\n\n  /**\n   * The `XrefId` of the element declared via `ElementStart`.\n   */\n  xref: XrefId;\n}\n\n/**\n * Create an `ElementEndOp`.\n */\nexport function createElementEndOp(xref: XrefId): ElementEndOp {\n  return {\n    kind: OpKind.ElementEnd,\n    xref,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing a text node in the creation IR.\n */\nexport interface TextOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Text;\n\n  /**\n   * `XrefId` used to reference this text node in other IR structures.\n   */\n  xref: XrefId;\n\n  /**\n   * The static initial value of the text node.\n   */\n  initialValue: string;\n}\n\n/**\n * Create a `TextOp`.\n */\nexport function createTextOp(xref: XrefId, initialValue: string): TextOp {\n  return {\n    kind: OpKind.Text,\n    xref,\n    initialValue,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing an event listener on an element in the creation IR.\n */\nexport interface ListenerOp extends Op<CreateOp>, UsesSlotIndexTrait {\n  kind: OpKind.Listener;\n\n  /**\n   * Name of the event which is being listened to.\n   */\n  name: string;\n\n  /**\n   * Tag name of the element on which this listener is placed.\n   */\n  tag: string;\n\n  /**\n   * A list of `UpdateOp`s representing the body of the event listener.\n   */\n  handlerOps: OpList<UpdateOp>;\n\n  /**\n   * Name of the function\n   */\n  handlerFnName: string|null;\n}\n\n/**\n * Create a `ListenerOp`.\n */\nexport function createListenerOp(target: XrefId, name: string, tag: string): ListenerOp {\n  return {\n    kind: OpKind.Listener,\n    target,\n    tag,\n    name,\n    handlerOps: new OpList(),\n    handlerFnName: null,\n    ...NEW_OP,\n    ...TRAIT_USES_SLOT_INDEX,\n  };\n}\n\n/**\n * An index into the `consts` array which is shared across the compilation of all views in a\n * component.\n */\nexport type ConstIndex = number&{__brand: 'ConstIndex'};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../../output/output_ast';\nimport {OpKind} from '../enums';\nimport {Op, XrefId} from '../operations';\nimport {ConsumesVarsTrait, DependsOnSlotContextOpTrait, TRAIT_CONSUMES_VARS, TRAIT_DEPENDS_ON_SLOT_CONTEXT} from '../traits';\n\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\n\n/**\n * An operation usable on the update side of the IR.\n */\nexport type UpdateOp = ListEndOp<UpdateOp>|StatementOp<UpdateOp>|PropertyOp|InterpolateTextOp|\n    AdvanceOp|VariableOp<UpdateOp>;\n\n/**\n * A logical operation to perform string interpolation on a text node.\n *\n * Interpolation inputs are stored as static `string`s and dynamic `o.Expression`s, in separate\n * arrays. Thus, the interpolation `A{{b}}C{{d}}E` is stored as 3 static strings `['A', 'C', 'E']`\n * and 2 dynamic expressions `[b, d]`.\n */\nexport interface InterpolateTextOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.InterpolateText;\n\n  /**\n   * Reference to the text node to which the interpolation is bound.\n   */\n  target: XrefId;\n\n  /**\n   * All of the literal strings in the text interpolation, in order.\n   *\n   * Conceptually interwoven around the `expressions`.\n   */\n  strings: string[];\n\n  /**\n   * All of the dynamic expressions in the text interpolation, in order.\n   *\n   * Conceptually interwoven in between the `strings`.\n   */\n  expressions: o.Expression[];\n}\n\n/**\n * Create an `InterpolationTextOp`.\n */\nexport function createInterpolateTextOp(\n    xref: XrefId, strings: string[], expressions: o.Expression[]): InterpolateTextOp {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    strings,\n    expressions,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a property in the update IR.\n */\nexport interface PropertyOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.Property;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression;\n}\n\n/**\n * Create a `PropertyOp`.\n */\nexport function createPropertyOp(xref: XrefId, name: string, expression: o.Expression): PropertyOp {\n  return {\n    kind: OpKind.Property,\n    target: xref,\n    name,\n    expression,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation to advance the runtime's internal slot pointer in the update IR.\n */\nexport interface AdvanceOp extends Op<UpdateOp> {\n  kind: OpKind.Advance;\n\n  /**\n   * Delta by which to advance the pointer.\n   */\n  delta: number;\n}\n\n/**\n * Create an `AdvanceOp`.\n */\nexport function createAdvanceOp(delta: number): AdvanceOp {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    ...NEW_OP,\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as core from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ElementAttributes} from '../../ir/src/element';\nimport {ComponentCompilation} from '../compilation';\n\n/**\n * Converts the semantic attributes of element-like operations (elements, templates) into constant\n * array expressions, and lifts them into the overall component `consts`.\n */\nexport function phaseConstCollection(cpl: ComponentCompilation): void {\n  for (const [_, view] of cpl.views) {\n    for (const op of view.create) {\n      if (op.kind !== ir.OpKind.ElementStart && op.kind !== ir.OpKind.Element &&\n          op.kind !== ir.OpKind.Template) {\n        continue;\n      } else if (!(op.attributes instanceof ElementAttributes)) {\n        continue;\n      }\n\n      const attrArray = serializeAttributes(op.attributes);\n      if (attrArray.entries.length > 0) {\n        op.attributes = cpl.addConst(attrArray);\n      } else {\n        op.attributes = null;\n      }\n    }\n  }\n}\n\nfunction serializeAttributes({attributes, bindings, classes, i18n, projectAs, styles, template}:\n                                 ElementAttributes): o.LiteralArrayExpr {\n  const attrArray = [...attributes];\n\n  if (projectAs !== null) {\n    attrArray.push(o.literal(core.AttributeMarker.ProjectAs), o.literal(projectAs));\n  }\n  if (classes.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Classes), ...classes);\n  }\n  if (styles.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Styles), ...styles);\n  }\n  if (bindings.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Bindings), ...bindings);\n  }\n  if (template.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Template), ...template);\n  }\n  if (i18n.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.I18n), ...i18n);\n  }\n  return o.literalArr(attrArray);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport {ComponentCompilation} from '../compilation';\n\n/**\n * Replace sequences of `ElementStart` followed by `ElementEnd` with a condensed `Element`\n * instruction.\n */\nexport function phaseEmptyElements(cpl: ComponentCompilation): void {\n  for (const [_, view] of cpl.views) {\n    for (const op of view.create) {\n      if (op.kind === ir.OpKind.ElementEnd && op.prev !== null &&\n          op.prev.kind === ir.OpKind.ElementStart) {\n        // Transmute the `ElementStart` instruction to `Element`. This is safe as they're designed\n        // to be identical apart from the `kind`.\n        (op.prev as unknown as ir.ElementOp).kind = ir.OpKind.Element;\n\n        // Remove the `ElementEnd` instruction.\n        ir.OpList.remove<ir.CreateOp>(op);\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport {ComponentCompilation} from '../compilation';\n\n/**\n * Generate `ir.AdvanceOp`s in between `ir.UpdateOp`s that ensure the runtime's implicit slot\n * context will be advanced correctly.\n */\nexport function phaseGenerateAdvance(cpl: ComponentCompilation): void {\n  for (const [_, view] of cpl.views) {\n    // First build a map of all of the declarations in the view that have assigned slots.\n    const slotMap = new Map<ir.XrefId, number>();\n    for (const op of view.create) {\n      if (!ir.hasConsumesSlotTrait(op)) {\n        continue;\n      } else if (op.slot === null) {\n        throw new Error(\n            `AssertionError: expected slots to have been allocated before generating advance() calls`);\n      }\n\n      slotMap.set(op.xref, op.slot);\n    }\n\n    // Next, step through the update operations and generate `ir.AdvanceOp`s as required to ensure\n    // the runtime's implicit slot counter will be set to the correct slot before executing each\n    // update operation which depends on it.\n    //\n    // To do that, we track what the runtime's slot counter will be through the update operations.\n    let slotContext = 0;\n    for (const op of view.update) {\n      if (!ir.hasDependsOnSlotContextTrait(op)) {\n        // `op` doesn't depend on the slot counter, so it can be skipped.\n        continue;\n      } else if (!slotMap.has(op.target)) {\n        // We expect ops that _do_ depend on the slot counter to point at declarations that exist in\n        // the `slotMap`.\n        throw new Error(`AssertionError: reference to unknown slot for var ${op.target}`);\n      }\n\n      const slot = slotMap.get(op.target)!;\n\n      // Does the slot counter need to be adjusted?\n      if (slotContext !== slot) {\n        // If so, generate an `ir.AdvanceOp` to advance the counter.\n        const delta = slot - slotContext;\n        if (delta < 0) {\n          throw new Error(`AssertionError: slot counter should never need to move backwards`);\n        }\n\n        ir.OpList.insertBefore<ir.UpdateOp>(ir.createAdvanceOp(delta), op);\n        slotContext = slot;\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../output/output_ast';\nimport {Identifiers} from '../../../render3/r3_identifiers';\nimport * as ir from '../ir';\n\n// This file contains helpers for generating calls to Ivy instructions. In particular, each\n// instruction type is represented as a function, which may select a specific instruction variant\n// depending on the exact arguments.\n\nexport function element(\n    slot: number, tag: string, constIndex: number|null, localRefIndex: number|null): ir.CreateOp {\n  return elementStartBase(Identifiers.element, slot, tag, constIndex, localRefIndex);\n}\n\n\nexport function elementStart(\n    slot: number, tag: string, constIndex: number|null, localRefIndex: number|null): ir.CreateOp {\n  return elementStartBase(Identifiers.elementStart, slot, tag, constIndex, localRefIndex);\n}\n\nfunction elementStartBase(\n    instruction: o.ExternalReference, slot: number, tag: string, constIndex: number|null,\n    localRefIndex: number|null): ir.CreateOp {\n  const args: o.Expression[] = [\n    o.literal(slot),\n    o.literal(tag),\n  ];\n  if (localRefIndex !== null) {\n    args.push(\n        o.literal(constIndex),  // might be null, but that's okay.\n        o.literal(localRefIndex),\n    );\n  } else if (constIndex !== null) {\n    args.push(o.literal(constIndex));\n  }\n\n  return call(instruction, args);\n}\n\nexport function elementEnd(): ir.CreateOp {\n  return call(Identifiers.elementEnd, []);\n}\n\nexport function template(\n    slot: number, templateFnRef: o.Expression, decls: number, vars: number, tag: string,\n    constIndex: number): ir.CreateOp {\n  return call(Identifiers.templateCreate, [\n    o.literal(slot),\n    templateFnRef,\n    o.literal(decls),\n    o.literal(vars),\n    o.literal(tag),\n    o.literal(constIndex),\n  ]);\n}\n\nexport function listener(name: string, handlerFn: o.Expression): ir.CreateOp {\n  return call(Identifiers.listener, [\n    o.literal(name),\n    handlerFn,\n  ]);\n}\n\nexport function advance(delta: number): ir.UpdateOp {\n  return call(Identifiers.advance, [\n    o.literal(delta),\n  ]);\n}\n\nexport function reference(slot: number): o.Expression {\n  return o.importExpr(Identifiers.reference).callFn([\n    o.literal(slot),\n  ]);\n}\n\nexport function nextContext(steps: number): o.Expression {\n  return o.importExpr(Identifiers.nextContext).callFn(steps === 1 ? [] : [o.literal(steps)]);\n}\n\n\nexport function getCurrentView(): o.Expression {\n  return o.importExpr(Identifiers.getCurrentView).callFn([]);\n}\n\n\nexport function restoreView(savedView: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.restoreView).callFn([\n    savedView,\n  ]);\n}\n\n\nexport function resetView(returnValue: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.resetView).callFn([\n    returnValue,\n  ]);\n}\n\nexport function text(slot: number, initialValue: string): ir.CreateOp {\n  const args: o.Expression[] = [o.literal(slot)];\n  if (initialValue !== '') {\n    args.push(o.literal(initialValue));\n  }\n  return call(Identifiers.text, args);\n}\n\nexport function property(name: string, expression: o.Expression): ir.UpdateOp {\n  return call(Identifiers.property, [\n    o.literal(name),\n    expression,\n  ]);\n}\n\nexport function textInterpolate(strings: string[], expressions: o.Expression[]): ir.UpdateOp {\n  if (strings.length < 1 || expressions.length !== strings.length - 1) {\n    throw new Error(\n        `AssertionError: expected specific shape of args for strings/expressions in interpolation`);\n  }\n  const interpolationArgs: o.Expression[] = [];\n\n  if (expressions.length === 1 && strings[0] === '' && strings[1] === '') {\n    interpolationArgs.push(expressions[0]);\n  } else {\n    let idx: number;\n    for (idx = 0; idx < expressions.length; idx++) {\n      interpolationArgs.push(o.literal(strings[idx]), expressions[idx]);\n    }\n    // idx points at the last string.\n    interpolationArgs.push(o.literal(strings[idx]));\n  }\n\n  return callInterpolation(TEXT_INTERPOLATE_CONFIG, [], interpolationArgs);\n}\n\n\n\nfunction call<OpT extends ir.CreateOp|ir.UpdateOp>(\n    instruction: o.ExternalReference, args: o.Expression[]): OpT {\n  return ir.createStatementOp(o.importExpr(instruction).callFn(args).toStmt()) as OpT;\n}\n\n/**\n * Describes a specific flavor of instruction used to represent interpolations, which have some\n * number of variants for specific argument counts.\n */\ninterface InterpolationConfig {\n  constant: o.ExternalReference[];\n  variable: o.ExternalReference;\n}\n\n/**\n * `InterpolationConfig` for the `textInterpolate` instruction.\n */\nconst TEXT_INTERPOLATE_CONFIG: InterpolationConfig = {\n  constant: [\n    Identifiers.textInterpolate,\n    Identifiers.textInterpolate1,\n    Identifiers.textInterpolate2,\n    Identifiers.textInterpolate3,\n    Identifiers.textInterpolate4,\n    Identifiers.textInterpolate5,\n    Identifiers.textInterpolate6,\n    Identifiers.textInterpolate7,\n    Identifiers.textInterpolate8,\n  ],\n  variable: Identifiers.textInterpolateV,\n};\n\nfunction callInterpolation(\n    config: InterpolationConfig, baseArgs: o.Expression[],\n    interpolationArgs: o.Expression[]): ir.UpdateOp {\n  if (interpolationArgs.length % 2 === 0) {\n    throw new Error(`Expected odd number of interpolation arguments`);\n  }\n  const n = (interpolationArgs.length - 1) / 2;\n  if (n < config.constant.length) {\n    // Constant calling pattern.\n    return call(config.constant[n], [...baseArgs, ...interpolationArgs]);\n  } else {\n    // Variable calling pattern.\n    return call(config.variable, [...baseArgs, o.literalArr(interpolationArgs)]);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilation, ViewCompilation} from '../compilation';\nimport * as ng from '../instruction';\n\n/**\n * Compiles semantic operations across all views and generates output `o.Statement`s with actual\n * runtime calls in their place.\n *\n * Reification replaces semantic operations with selected Ivy instructions and other generated code\n * structures. After reification, the create/update operation lists of all views should only contain\n * `ir.StatementOp`s (which wrap generated `o.Statement`s).\n */\nexport function phaseReify(cpl: ComponentCompilation): void {\n  for (const [_, view] of cpl.views) {\n    reifyCreateOperations(view, view.create);\n    reifyUpdateOperations(view, view.update);\n  }\n}\n\nfunction reifyCreateOperations(view: ViewCompilation, ops: ir.OpList<ir.CreateOp>): void {\n  for (const op of ops) {\n    ir.transformExpressionsInOp(op, reifyIrExpression, ir.VisitorContextFlag.None);\n\n    switch (op.kind) {\n      case ir.OpKind.Text:\n        ir.OpList.replace(op, ng.text(op.slot!, op.initialValue));\n        break;\n      case ir.OpKind.ElementStart:\n        ir.OpList.replace(\n            op,\n            ng.elementStart(\n                op.slot!, op.tag, op.attributes as number | null, op.localRefs as number | null));\n        break;\n      case ir.OpKind.Element:\n        ir.OpList.replace(\n            op,\n            ng.element(\n                op.slot!, op.tag, op.attributes as number | null, op.localRefs as number | null));\n        break;\n      case ir.OpKind.ElementEnd:\n        ir.OpList.replace(op, ng.elementEnd());\n        break;\n      case ir.OpKind.Template:\n        const childView = view.tpl.views.get(op.xref)!;\n        ir.OpList.replace(\n            op,\n            ng.template(\n                op.slot!,\n                o.variable(childView.fnName!),\n                childView.decls!,\n                childView.vars!,\n                op.tag,\n                op.attributes as number,\n                ),\n        );\n        break;\n      case ir.OpKind.Listener:\n        const listenerFn = reifyListenerHandler(view, op.handlerFnName!, op.handlerOps);\n        ir.OpList.replace(\n            op,\n            ng.listener(\n                op.name,\n                listenerFn,\n                ));\n        break;\n      case ir.OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        ir.OpList.replace<ir.CreateOp>(\n            op,\n            ir.createStatementOp(new o.DeclareVarStmt(\n                op.variable.name, op.initializer, undefined, o.StmtModifier.Final)));\n        break;\n      case ir.OpKind.Statement:\n        // Pass statement operations directly through.\n        break;\n      default:\n        throw new Error(\n            `AssertionError: Unsupported reification of create op ${ir.OpKind[op.kind]}`);\n    }\n  }\n}\n\nfunction reifyUpdateOperations(_view: ViewCompilation, ops: ir.OpList<ir.UpdateOp>): void {\n  for (const op of ops) {\n    ir.transformExpressionsInOp(op, reifyIrExpression, ir.VisitorContextFlag.None);\n\n    switch (op.kind) {\n      case ir.OpKind.Advance:\n        ir.OpList.replace(op, ng.advance(op.delta));\n        break;\n      case ir.OpKind.Property:\n        ir.OpList.replace(op, ng.property(op.name, op.expression));\n        break;\n      case ir.OpKind.InterpolateText:\n        ir.OpList.replace(op, ng.textInterpolate(op.strings, op.expressions));\n        break;\n      case ir.OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        ir.OpList.replace<ir.UpdateOp>(\n            op,\n            ir.createStatementOp(new o.DeclareVarStmt(\n                op.variable.name, op.initializer, undefined, o.StmtModifier.Final)));\n        break;\n      case ir.OpKind.Statement:\n        // Pass statement operations directly through.\n        break;\n      default:\n        throw new Error(\n            `AssertionError: Unsupported reification of update op ${ir.OpKind[op.kind]}`);\n    }\n  }\n}\n\nfunction reifyIrExpression(expr: ir.Expression): o.Expression {\n  switch (expr.kind) {\n    case ir.ExpressionKind.NextContext:\n      return ng.nextContext(expr.steps);\n    case ir.ExpressionKind.Reference:\n      return ng.reference(expr.slot! + 1 + expr.offset);\n    case ir.ExpressionKind.LexicalRead:\n      throw new Error(`AssertionError: unresolved LexicalRead of ${expr.name}`);\n    case ir.ExpressionKind.RestoreView:\n      if (typeof expr.view === 'number') {\n        throw new Error(`AssertionError: unresolved RestoreView`);\n      }\n      return ng.restoreView(expr.view);\n    case ir.ExpressionKind.ResetView:\n      return ng.resetView(expr.expr);\n    case ir.ExpressionKind.GetCurrentView:\n      return ng.getCurrentView();\n    case ir.ExpressionKind.ReadVariable:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed variable ${expr.xref}`);\n      }\n      return o.variable(expr.name);\n    default:\n      throw new Error(`AssertionError: Unsupported reification of ir.Expression kind: ${\n          ir.ExpressionKind[(expr as ir.Expression).kind]}`);\n  }\n}\n\n/**\n * Listeners get turned into a function expression, which may or may not have the `$event`\n * parameter defined.\n */\nfunction reifyListenerHandler(\n    view: ViewCompilation, name: string, handlerOps: ir.OpList<ir.UpdateOp>): o.FunctionExpr {\n  const lookForEvent = new LookForEventVisitor();\n\n  // First, reify all instruction calls within `handlerOps`.\n  reifyUpdateOperations(view, handlerOps);\n\n  // Next, extract all the `o.Statement`s from the reified operations. We can expect that at this\n  // point, all operations have been converted to statements.\n  const handlerStmts: o.Statement[] = [];\n  for (const op of handlerOps) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(\n          `AssertionError: expected reified statements, but found op ${ir.OpKind[op.kind]}`);\n    }\n    handlerStmts.push(op.statement);\n  }\n\n  // Scan the statement list for usages of `$event`. If referenced, we need to generate it as a\n  // parameter.\n  lookForEvent.visitAllStatements(handlerStmts, null);\n\n  const params: o.FnParam[] = [];\n  if (lookForEvent.seenEventRead) {\n    // We need the `$event` parameter.\n    params.push(new o.FnParam('$event'));\n  }\n\n  return o.fn(params, handlerStmts, undefined, undefined, name);\n}\n\n/**\n * Visitor which scans for reads of the `$event` special variable.\n */\nclass LookForEventVisitor extends o.RecursiveAstVisitor {\n  seenEventRead = false;\n\n  override visitReadVarExpr(ast: o.ReadVarExpr, context: any) {\n    if (ast.name === '$event') {\n      this.seenEventRead = true;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport type {ComponentCompilation} from '../compilation';\n\n/**\n * Assign data slots for all operations which implement `ConsumesSlotOpTrait`, and propagate the\n * assigned data slots of those operations to any expressions which reference them via\n * `UsesSlotIndexTrait`.\n *\n * This phase is also responsible for counting the number of slots used for each view (its `decls`)\n * and propagating that number into the `Template` operations which declare embedded views.\n */\nexport function phaseSlotAllocation(cpl: ComponentCompilation): void {\n  // Map of all declarations in all views within the component which require an assigned slot index.\n  // This map needs to be global (across all views within the component) since it's possible to\n  // reference a slot from one view from an expression within another (e.g. local references work\n  // this way).\n  const slotMap = new Map<ir.XrefId, number>();\n\n  // Process all views in the component and assign slot indexes.\n  for (const [_, view] of cpl.views) {\n    // Slot indices start at 0 for each view (and are not unique between views).\n    let slotCount = 0;\n\n    for (const op of view.create) {\n      // Only consider declarations which consume data slots.\n      if (!ir.hasConsumesSlotTrait(op)) {\n        continue;\n      }\n\n      // Assign slots to this declaration starting at the current `slotCount`.\n      op.slot = slotCount;\n\n      // And track its assigned slot in the `slotMap`.\n      slotMap.set(op.xref, op.slot);\n\n      // Each declaration may use more than 1 slot, so increment `slotCount` to reserve the number\n      // of slots required.\n      slotCount += op.numSlotsUsed;\n    }\n\n    // Record the total number of slots used on the view itself. This will later be propagated into\n    // `ir.TemplateOp`s which declare those views (except for the root view).\n    view.decls = slotCount;\n  }\n\n  // After slot assignment, `slotMap` now contains slot assignments for every declaration in the\n  // whole template, across all views. Next, look for expressions which implement\n  // `UsesSlotIndexExprTrait` and propagate the assigned slot indexes into them.\n  // Additionally, this second scan allows us to find `ir.TemplateOp`s which declare views and\n  // propagate the number of slots used for each view into the operation which declares it.\n  for (const [_, view] of cpl.views) {\n    for (const op of view.ops()) {\n      if (op.kind === ir.OpKind.Template) {\n        // Record the number of slots used by the view this `ir.TemplateOp` declares in the\n        // operation itself, so it can be emitted later.\n        const childView = cpl.views.get(op.xref)!;\n        op.decls = childView.decls;\n      }\n\n      if (ir.hasUsesSlotIndexTrait(op) && op.slot === null) {\n        if (!slotMap.has(op.target)) {\n          // We do expect to find a slot allocated for everything which might be referenced.\n          throw new Error(\n              `AssertionError: no slot allocated for ${ir.OpKind[op.kind]} target ${op.target}`);\n        }\n\n        op.slot = slotMap.get(op.target)!;\n      }\n\n      // Process all `ir.Expression`s within this view, and look for `usesSlotIndexExprTrait`.\n      ir.visitExpressionsInOp(op, expr => {\n        if (!ir.hasUsesSlotIndexTrait(expr) || expr.slot !== null) {\n          return;\n        }\n\n        // The `UsesSlotIndexExprTrait` indicates that this expression references something declared\n        // in this component template by its slot index. Use the `target` `ir.XrefId` to find the\n        // allocated slot for that declaration in `slotMap`.\n\n        if (!slotMap.has(expr.target)) {\n          // We do expect to find a slot allocated for everything which might be referenced.\n          throw new Error(`AssertionError: no slot allocated for ${expr.constructor.name} target ${\n              expr.target}`);\n        }\n\n        // Record the allocated slot on the expression.\n        expr.slot = slotMap.get(expr.target)!;\n      });\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport {ComponentCompilation} from '../compilation';\n\n/**\n * Counts the number of variable slots used within each view, and stores that on the view itself, as\n * well as propagates it to the `ir.TemplateOp` for embedded views.\n */\nexport function phaseVarCounting(cpl: ComponentCompilation): void {\n  // First, count the vars used in each view, and update the view-level counter.\n  for (const [_, view] of cpl.views) {\n    let varCount = 0;\n    for (const op of view.ops()) {\n      if (ir.hasConsumesVarsTrait(op)) {\n        varCount += varsUsedByOp(op);\n      }\n\n      ir.visitExpressionsInOp(op, expr => {\n        if (ir.hasConsumesVarsTrait(expr)) {\n          varCount += varsUsedByIrExpression(expr);\n        }\n      });\n    }\n\n    view.vars = varCount;\n  }\n\n  // Add var counts for each view to the `ir.TemplateOp` which declares that view (if the view is an\n  // embedded view).\n  for (const [_, view] of cpl.views) {\n    for (const op of view.create) {\n      if (op.kind !== ir.OpKind.Template) {\n        continue;\n      }\n\n      const childView = cpl.views.get(op.xref)!;\n      op.vars = childView.vars;\n    }\n  }\n}\n\n/**\n * Different operations that implement `ir.UsesVarsTrait` use different numbers of variables, so\n * count the variables used by any particular `op`.\n */\nfunction varsUsedByOp(op: (ir.CreateOp|ir.UpdateOp)&ir.ConsumesVarsTrait): number {\n  switch (op.kind) {\n    case ir.OpKind.Property:\n      // Property bindings use 1 variable slot.\n      return 1;\n    case ir.OpKind.InterpolateText:\n      // `ir.InterpolateTextOp`s use a variable slot for each dynamic expression.\n      return op.expressions.length;\n    default:\n      throw new Error(`Unhandled op: ${ir.OpKind[op.kind]}`);\n  }\n}\n\nfunction varsUsedByIrExpression(expr: ir.Expression&ir.ConsumesVarsTrait): number {\n  return 0;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilation, ViewCompilation} from '../compilation';\n\n/**\n * Generate names for functions and variables across all views.\n *\n * This includes propagating those names into any `ir.ReadVariableExpr`s of those variables, so that\n * the reads can be emitted correctly.\n */\nexport function phaseNaming(cpl: ComponentCompilation): void {\n  addNamesToView(cpl.root, cpl.componentName, {index: 0});\n}\n\nfunction addNamesToView(view: ViewCompilation, baseName: string, state: {index: number}): void {\n  if (view.fnName === null) {\n    view.fnName = `${baseName}_Template`;\n  }\n\n  // Keep track of the names we assign to variables in the view. We'll need to propagate these\n  // into reads of those variables afterwards.\n  const varNames = new Map<ir.XrefId, string>();\n\n  for (const op of view.ops()) {\n    switch (op.kind) {\n      case ir.OpKind.Listener:\n        if (op.handlerFnName === null) {\n          // TODO(alxhub): convert this temporary name to match how the\n          // `TemplateDefinitionBuilder` names listener functions.\n          if (op.slot === null) {\n            throw new Error(`Expected a slot to be assigned`);\n          }\n          op.handlerFnName = `${view.fnName}_${op.tag}_${op.name}_${op.slot}_listener`;\n        }\n        break;\n      case ir.OpKind.Variable:\n        varNames.set(op.xref, getVariableName(op.variable, state));\n        break;\n      case ir.OpKind.Template:\n        const childView = view.tpl.views.get(op.xref)!;\n        if (op.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        // TODO: properly escape the tag name.\n        const safeTagName = op.tag.replace('-', '_');\n        addNamesToView(childView, `${baseName}_${safeTagName}_${op.slot}`, state);\n        break;\n    }\n  }\n\n  // Having named all variables declared in the view, now we can push those names into the\n  // `ir.ReadVariableExpr` expressions which represent reads of those variables.\n  for (const op of view.ops()) {\n    ir.visitExpressionsInOp(op, expr => {\n      if (!(expr instanceof ir.ReadVariableExpr) || expr.name !== null) {\n        return;\n      }\n      if (!varNames.has(expr.xref)) {\n        throw new Error(`Variable ${expr.xref} not yet named`);\n      }\n      expr.name = varNames.get(expr.xref)!;\n    });\n  }\n}\n\nfunction getVariableName(variable: ir.SemanticVariable, state: {index: number}): string {\n  if (variable.name === null) {\n    switch (variable.kind) {\n      case ir.SemanticVariableKind.Identifier:\n        variable.name = `${variable.identifier}_${state.index++}`;\n        break;\n      default:\n        variable.name = `_r${state.index++}`;\n        break;\n    }\n  }\n  return variable.name;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilation} from '../compilation';\n\n/**\n * Lifts local reference declarations on element-like structures within each view into an entry in\n * the `consts` array for the whole component.\n */\nexport function phaseLocalRefs(cpl: ComponentCompilation): void {\n  for (const view of cpl.views.values()) {\n    for (const op of view.create) {\n      switch (op.kind) {\n        case ir.OpKind.ElementStart:\n        case ir.OpKind.Element:\n        case ir.OpKind.Template:\n          if (!Array.isArray(op.localRefs)) {\n            throw new Error(`AssertionError: expected localRefs to be an array still`);\n          }\n          op.numSlotsUsed += op.localRefs.length;\n\n          if (op.localRefs.length > 0) {\n            const localRefs = serializeLocalRefs(op.localRefs);\n            op.localRefs = cpl.addConst(localRefs);\n          } else {\n            op.localRefs = null;\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction serializeLocalRefs(refs: ir.LocalRef[]): o.Expression {\n  const constRefs: o.Expression[] = [];\n  for (const ref of refs) {\n    constRefs.push(o.literal(ref.name), o.literal(ref.target));\n  }\n  return o.literalArr(constRefs);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilation, ViewCompilation} from '../compilation';\n\n/**\n * Generate a preamble sequence for each view creation block and listener function which declares\n * any variables that be referenced in other operations in the block.\n *\n * Variables generated include:\n *   * a saved view context to be used to restore the current view in event listeners.\n *   * the context of the restored view within event listener handlers.\n *   * context variables from the current view as well as all parent views (including the root\n *     context if needed).\n *   * local references from elements within the current view and any lexical parents.\n *\n * Variables are generated here unconditionally, and may optimized away in future operations if it\n * turns out their values (and any side effects) are unused.\n */\nexport function phaseGenerateVariables(cpl: ComponentCompilation): void {\n  recursivelyProcessView(cpl.root, /* there is no parent scope for the root view */ null);\n}\n\n/**\n * Process the given `ViewCompilation` and generate preambles for it and any listeners that it\n * declares.\n *\n * @param `parentScope` a scope extracted from the parent view which captures any variables which\n *     should be inherited by this view. `null` if the current view is the root view.\n */\nfunction recursivelyProcessView(view: ViewCompilation, parentScope: Scope|null): void {\n  // Extract a `Scope` from this view.\n  const scope = getScopeForView(view, parentScope);\n\n  // Start the view creation block with an operation to save the current view context. This may be\n  // used to restore the view context in any listeners that may be present.\n  view.create.prepend([\n    ir.createVariableOp<ir.CreateOp>(\n        view.tpl.allocateXrefId(), scope.savedViewVariable, new ir.GetCurrentViewExpr()),\n  ]);\n\n  for (const op of view.create) {\n    switch (op.kind) {\n      case ir.OpKind.Template:\n        // Descend into child embedded views.\n        recursivelyProcessView(view.tpl.views.get(op.xref)!, scope);\n        break;\n      case ir.OpKind.Listener:\n        // Listeners get a preamble which starts with a call to restore the view.\n        const preambleOps = [\n          ir.createVariableOp<ir.UpdateOp>(\n              view.tpl.allocateXrefId(), scope.viewContextVariable,\n              new ir.RestoreViewExpr(view.xref)),\n          // And includes all variables available to this view.\n          ...generateVariablesInScopeForView(view, scope)\n        ];\n\n        op.handlerOps.prepend(preambleOps);\n\n        // The \"restore view\" operation in listeners requires a call to `resetView` to reset the\n        // context prior to returning from the listener operation. Find any `return` statements in\n        // the listener body and wrap them in a call to reset the view.\n        for (const handlerOp of op.handlerOps) {\n          if (handlerOp.kind === ir.OpKind.Statement &&\n              handlerOp.statement instanceof o.ReturnStatement) {\n            handlerOp.statement.value = new ir.ResetViewExpr(handlerOp.statement.value);\n          }\n        }\n        break;\n    }\n  }\n\n  // Prepend the declarations for all available variables in scope to the `update` block.\n  const preambleOps = generateVariablesInScopeForView(view, scope);\n  view.update.prepend(preambleOps);\n}\n\n/**\n * Lexical scope of a view, including a reference to its parent view's scope, if any.\n */\ninterface Scope {\n  /**\n   * `XrefId` of the view to which this scope corresponds.\n   */\n  view: ir.XrefId;\n\n  viewContextVariable: ir.SemanticVariable;\n\n  savedViewVariable: ir.SemanticVariable;\n\n  contextVariables: Map<string, ir.SemanticVariable>;\n\n  /**\n   * Local references collected from elements within the view.\n   */\n  references: Reference[];\n\n  /**\n   * `Scope` of the parent view, if any.\n   */\n  parent: Scope|null;\n}\n\n/**\n * Information needed about a local reference collected from an element within a view.\n */\ninterface Reference {\n  /**\n   * Name given to the local reference variable within the template.\n   *\n   * This is not the name which will be used for the variable declaration in the generated\n   * template code.\n   */\n  name: string;\n\n  /**\n   * `XrefId` of the element-like node which this reference targets.\n   *\n   * The reference may be either to the element (or template) itself, or to a directive on it.\n   */\n  targetId: ir.XrefId;\n\n  /**\n   * A generated offset of this reference among all the references on a specific element.\n   */\n  offset: number;\n\n  variable: ir.SemanticVariable;\n}\n\n/**\n * Process a view and generate a `Scope` representing the variables available for reference within\n * that view.\n */\nfunction getScopeForView(view: ViewCompilation, parent: Scope|null): Scope {\n  const scope: Scope = {\n    view: view.xref,\n    viewContextVariable: {\n      kind: ir.SemanticVariableKind.Context,\n      name: null,\n      view: view.xref,\n    },\n    savedViewVariable: {\n      kind: ir.SemanticVariableKind.SavedView,\n      name: null,\n      view: view.xref,\n    },\n    contextVariables: new Map<string, ir.SemanticVariable>(),\n    references: [],\n    parent,\n  };\n\n  for (const identifier of view.contextVariables.keys()) {\n    scope.contextVariables.set(identifier, {\n      kind: ir.SemanticVariableKind.Identifier,\n      name: null,\n      identifier,\n    });\n  }\n\n  for (const op of view.create) {\n    switch (op.kind) {\n      case ir.OpKind.Element:\n      case ir.OpKind.ElementStart:\n      case ir.OpKind.Template:\n        if (!Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: expected localRefs to be an array`);\n        }\n\n        // Record available local references from this element.\n        for (let offset = 0; offset < op.localRefs.length; offset++) {\n          scope.references.push({\n            name: op.localRefs[offset].name,\n            targetId: op.xref,\n            offset,\n            variable: {\n              kind: ir.SemanticVariableKind.Identifier,\n              name: null,\n              identifier: op.localRefs[offset].name,\n            },\n          });\n        }\n        break;\n    }\n  }\n\n  return scope;\n}\n\n/**\n * Generate declarations for all variables that are in scope for a given view.\n *\n * This is a recursive process, as views inherit variables available from their parent view, which\n * itself may have inherited variables, etc.\n */\nfunction generateVariablesInScopeForView(\n    view: ViewCompilation, scope: Scope): ir.VariableOp<ir.UpdateOp>[] {\n  const newOps: ir.VariableOp<ir.UpdateOp>[] = [];\n\n  if (scope.view !== view.xref) {\n    // Before generating variables for a parent view, we need to switch to the context of the parent\n    // view with a `nextContext` expression. This context switching operation itself declares a\n    // variable, because the context of the view may be referenced directly.\n    newOps.push(ir.createVariableOp(\n        view.tpl.allocateXrefId(), scope.viewContextVariable, new ir.NextContextExpr()));\n  }\n\n  // Add variables for all context variables available in this scope's view.\n  for (const [name, value] of view.tpl.views.get(scope.view)!.contextVariables) {\n    newOps.push(ir.createVariableOp(\n        view.tpl.allocateXrefId(), scope.contextVariables.get(name)!,\n        new o.ReadPropExpr(new ir.ContextExpr(scope.view), value)));\n  }\n\n  // Add variables for all local references declared for elements in this scope.\n  for (const ref of scope.references) {\n    newOps.push(ir.createVariableOp(\n        view.tpl.allocateXrefId(), ref.variable, new ir.ReferenceExpr(ref.targetId, ref.offset)));\n  }\n\n  if (scope.parent !== null) {\n    // Recursively add variables from the parent scope.\n    newOps.push(...generateVariablesInScopeForView(view, scope.parent));\n  }\n  return newOps;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilation, ViewCompilation} from '../compilation';\n\n/**\n * Resolves lexical references in views (`ir.LexicalReadExpr`) to either a target variable or to\n * property reads on the top-level component context.\n *\n * Also matches `ir.RestoreViewExpr` expressions with the variables of their corresponding saved\n * views.\n */\nexport function phaseResolveNames(cpl: ComponentCompilation): void {\n  for (const [_, view] of cpl.views) {\n    processLexicalScope(view, view.create, null);\n    processLexicalScope(view, view.update, null);\n  }\n}\n\nfunction processLexicalScope(\n    view: ViewCompilation, ops: ir.OpList<ir.CreateOp>|ir.OpList<ir.UpdateOp>,\n    savedView: SavedView|null): void {\n  // Maps names defined in the lexical scope of this template to the `ir.XrefId`s of the variable\n  // declarations which represent those values.\n  //\n  // Since variables are generated in each view for the entire lexical scope (including any\n  // identifiers from parent templates) only local variables need be considered here.\n  const scope = new Map<string, ir.XrefId>();\n\n  // First, step through the operations list and:\n  // 1) build up the `scope` mapping\n  // 2) recurse into any listener functions\n  for (const op of ops) {\n    switch (op.kind) {\n      case ir.OpKind.Variable:\n        switch (op.variable.kind) {\n          case ir.SemanticVariableKind.Identifier:\n            // This variable represents some kind of identifier which can be used in the template.\n            if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case ir.SemanticVariableKind.SavedView:\n            // This variable represents a snapshot of the current view context, and can be used to\n            // restore that context within listener functions.\n            savedView = {\n              view: op.variable.view,\n              variable: op.xref,\n            };\n            break;\n        }\n        break;\n      case ir.OpKind.Listener:\n        // Listener functions have separate variable declarations, so process them as a separate\n        // lexical scope.\n        processLexicalScope(view, op.handlerOps, savedView);\n        break;\n    }\n  }\n\n  // Next, use the `scope` mapping to match `ir.LexicalReadExpr` with defined names in the lexical\n  // scope. Also, look for `ir.RestoreViewExpr`s and match them with the snapshotted view context\n  // variable.\n  for (const op of ops) {\n    ir.transformExpressionsInOp(op, expr => {\n      if (expr instanceof ir.LexicalReadExpr) {\n        // `expr` is a read of a name within the lexical scope of this view.\n        // Either that name is defined within the current view, or it represents a property from the\n        // main component context.\n        if (scope.has(expr.name)) {\n          // This was a defined variable in the current scope.\n          return new ir.ReadVariableExpr(scope.get(expr.name)!);\n        } else {\n          // Reading from the component context.\n          return new o.ReadPropExpr(new ir.ContextExpr(view.tpl.root.xref), expr.name);\n        }\n      } else if (expr instanceof ir.RestoreViewExpr && typeof expr.view === 'number') {\n        // `ir.RestoreViewExpr` happens in listener functions and restores a saved view from the\n        // parent creation list. We expect to find that we captured the `savedView` previously, and\n        // that it matches the expected view to be restored.\n        if (savedView === null || savedView.view !== expr.view) {\n          throw new Error(`AssertionError: no saved view ${expr.view} from view ${view.xref}`);\n        }\n        expr.view = new ir.ReadVariableExpr(savedView.variable);\n        return expr;\n      } else {\n        return expr;\n      }\n    }, ir.VisitorContextFlag.None);\n  }\n}\n\n/**\n * Information about a `SavedView` variable.\n */\ninterface SavedView {\n  /**\n   * The view `ir.XrefId` which was saved into this variable.\n   */\n  view: ir.XrefId;\n\n  /**\n   * The `ir.XrefId` of the variable into which the view was saved.\n   */\n  variable: ir.XrefId;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilation, ViewCompilation} from '../compilation';\n\n/**\n * Resolves `ir.ContextExpr` expressions (which represent embedded view or component contexts) to\n * either the `ctx` parameter to component functions (for the current view context) or to variables\n * that store those contexts (for contexts accessed via the `nextContext()` instruction).\n */\nexport function phaseResolveContexts(cpl: ComponentCompilation): void {\n  for (const view of cpl.views.values()) {\n    processLexicalScope(view, view.create);\n    processLexicalScope(view, view.update);\n  }\n}\n\nfunction processLexicalScope(view: ViewCompilation, ops: ir.OpList<ir.CreateOp|ir.UpdateOp>): void {\n  // Track the expressions used to access all available contexts within the current view, by the\n  // view `ir.XrefId`.\n  const scope = new Map<ir.XrefId, o.Expression>();\n\n  // The current view's context is accessible via the `ctx` parameter.\n  scope.set(view.xref, o.variable('ctx'));\n\n  for (const op of ops) {\n    switch (op.kind) {\n      case ir.OpKind.Variable:\n        switch (op.variable.kind) {\n          case ir.SemanticVariableKind.Context:\n            scope.set(op.variable.view, new ir.ReadVariableExpr(op.xref));\n            break;\n        }\n        break;\n      case ir.OpKind.Listener:\n        processLexicalScope(view, op.handlerOps);\n        break;\n    }\n  }\n\n  for (const op of ops) {\n    ir.transformExpressionsInOp(op, expr => {\n      if (expr instanceof ir.ContextExpr) {\n        if (!scope.has(expr.view)) {\n          throw new Error(\n              `No context found for reference to view ${expr.view} from view ${view.xref}`);\n        }\n        return scope.get(expr.view)!;\n      } else {\n        return expr;\n      }\n    }, ir.VisitorContextFlag.None);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilation} from '../compilation';\n\nexport interface VariableOptimizationOptions {\n  conservative: boolean;\n}\n\n/**\n * Optimize variables declared and used in the IR.\n *\n * Variables are eagerly generated by pipeline stages for all possible values that could be\n * referenced. This stage processes the list of declared variables and all variable usages,\n * and optimizes where possible. It performs 3 main optimizations:\n *\n *   * It transforms variable declarations to side effectful expressions when the\n *     variable is not used, but its initializer has global effects which other\n *     operations rely upon.\n *   * It removes variable declarations if those variables are not referenced and\n *     either they do not have global effects, or nothing relies on them.\n *   * It inlines variable declarations when those variables are only used once\n *     and the inlining is semantically safe.\n *\n * To guarantee correctness, analysis of \"fences\" in the instruction lists is used to determine\n * which optimizations are safe to perform.\n */\nexport function phaseVariableOptimization(\n    cpl: ComponentCompilation, options: VariableOptimizationOptions): void {\n  for (const [_, view] of cpl.views) {\n    optimizeVariablesInOpList(view.create, options);\n    optimizeVariablesInOpList(view.update, options);\n\n    for (const op of view.create) {\n      if (op.kind === ir.OpKind.Listener) {\n        optimizeVariablesInOpList(op.handlerOps, options);\n      }\n    }\n  }\n}\n\n/**\n * A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates\n * how that expression can be optimized in relation to other expressions or instructions.\n *\n * `Fence`s are a bitfield, so multiple flags may be set on a single expression.\n */\nenum Fence {\n  /**\n   * Empty flag (no fence exists).\n   */\n  None = 0b000,\n\n  /**\n   * A context read fence, meaning that the expression in question reads from the \"current view\"\n   * context of the runtime.\n   */\n  ViewContextRead = 0b001,\n\n  /**\n   * A context write fence, meaning that the expression in question writes to the \"current view\"\n   * context of the runtime.\n   *\n   * Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which\n   * change the view context do so based on the current one.\n   */\n  ViewContextWrite = 0b011,\n\n  /**\n   * Indicates that a call is required for its side-effects, even if nothing reads its result.\n   *\n   * This is also true of `ViewContextWrite` operations **if** they are followed by a\n   * `ViewContextRead`.\n   */\n  SideEffectful = 0b100,\n}\n\n/**\n * Summary data collected for each `Op` in a list.\n *\n * Tracking this data per operation allows the optimizer to process operations at a higher level\n * than always scanning expressions.\n */\ninterface OpInfo {\n  /**\n   * A `Set` of variables referenced by expressions in this operation.\n   */\n  variablesUsed: Set<ir.XrefId>;\n\n  /**\n   * Flags indicating any `Fence`s present for this operation.\n   */\n  fences: Fence;\n}\n\n/**\n * Process a list of operations and optimize variables within that list.\n */\nfunction optimizeVariablesInOpList(\n    ops: ir.OpList<ir.CreateOp|ir.UpdateOp>, options: VariableOptimizationOptions): void {\n  const varDecls = new Map<ir.XrefId, ir.VariableOp<ir.CreateOp|ir.UpdateOp>>();\n  const varUsages = new Map<ir.XrefId, number>();\n\n  // Track variables that are used outside of the immediate operation list. For example, within\n  // `ListenerOp` handler operations of listeners in the current operation list.\n  const varRemoteUsages = new Set<ir.XrefId>();\n  const opMap = new Map<ir.CreateOp|ir.UpdateOp, OpInfo>();\n\n  // First, extract information about variables declared or used within the whole list.\n  for (const op of ops) {\n    if (op.kind === ir.OpKind.Variable) {\n      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {\n        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);\n      }\n      varDecls.set(op.xref, op);\n      varUsages.set(op.xref, 0);\n    }\n\n    opMap.set(op, collectOpInfo(op));\n    countVariableUsages(op, varUsages, varRemoteUsages);\n  }\n\n  // The next step is to remove any variable declarations for variables that aren't used. The\n  // variable initializer expressions may be side-effectful, so they may need to be retained as\n  // expression statements.\n\n  // Track whether we've seen an operation which reads from the view context yet. This is used to\n  // determine whether a write to the view context in a variable initializer can be observed.\n  let contextIsUsed = false;\n\n  // Note that iteration through the list happens in reverse, which guarantees that we'll process\n  // all reads of a variable prior to processing its declaration.\n  for (const op of ops.reversed()) {\n    const opInfo = opMap.get(op)!;\n\n    if (op.kind === ir.OpKind.Variable && varUsages.get(op.xref)! === 0) {\n      // This variable is unused and can be removed. We might need to keep the initializer around,\n      // though, if something depends on it running.\n      if ((contextIsUsed && opInfo.fences & Fence.ViewContextWrite) ||\n          (opInfo.fences & Fence.SideEffectful)) {\n        // This variable initializer has a side effect which must be retained. Either:\n        //  * it writes to the view context, and we know there is a future operation which depends\n        //    on that write, or\n        //  * it's an operation which is inherently side-effectful.\n        // We can't remove the initializer, but we can remove the variable declaration itself and\n        // replace it with a side-effectful statement.\n        const stmtOp = ir.createStatementOp(op.initializer.toStmt()) as ir.UpdateOp;\n        opMap.set(stmtOp, opInfo);\n        ir.OpList.replace(op as ir.UpdateOp, stmtOp);\n      } else {\n        // It's safe to delete this entire variable declaration as nothing depends on it, even\n        // side-effectfully. Note that doing this might make other variables unused. Since we're\n        // iterating in reverse order, we should always be processing usages before declarations\n        // and therefore by the time we get to a declaration, all removable usages will have been\n        // removed.\n        uncountVariableUsages(op, varUsages);\n        ir.OpList.remove(op as ir.UpdateOp);\n      }\n\n      opMap.delete(op);\n      varDecls.delete(op.xref);\n      varUsages.delete(op.xref);\n      continue;\n    }\n\n    // Does this operation depend on the view context?\n    if (opInfo.fences & Fence.ViewContextRead) {\n      contextIsUsed = true;\n    }\n  }\n\n  // Next, inline any remaining variables with exactly one usage.\n  const toInline: ir.XrefId[] = [];\n  for (const [id, count] of varUsages) {\n    // We can inline variables that:\n    //  - are used once\n    //  - are not used remotely\n    if (count !== 1) {\n      // We can't inline this variable as it's used more than once.\n      continue;\n    }\n\n    if (varRemoteUsages.has(id)) {\n      // This variable is used once, but across an operation boundary, so it can't be inlined.\n      continue;\n    }\n\n    toInline.push(id);\n  }\n\n  let candidate: ir.XrefId|undefined;\n  while (candidate = toInline.pop()) {\n    // We will attempt to inline this variable. If inlining fails (due to fences for example),\n    // no future operation will make inlining legal.\n    const decl = varDecls.get(candidate)!;\n    const varInfo = opMap.get(decl as ir.CreateOp | ir.UpdateOp)!;\n\n    // Scan operations following the variable declaration and look for the point where that variable\n    // is used. There should only be one usage given the precondition above.\n    for (let targetOp = decl.next!; targetOp.kind !== ir.OpKind.ListEnd;\n         targetOp = targetOp.next!) {\n      const opInfo = opMap.get(targetOp)!;\n\n      // Is the variable used in this operation?\n      if (opInfo.variablesUsed.has(candidate)) {\n        if (options.conservative && !allowConservativeInlining(decl, targetOp)) {\n          // We're in conservative mode, and this variable is not eligible for inlining into the\n          // target operation in this mode.\n          break;\n        }\n\n        // Yes, try to inline it. Inlining may not be successful if fences in this operation before\n        // the variable's usage cannot be safely crossed.\n        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {\n          // Inlining was successful! Update the tracking structures to reflect the inlined\n          // variable.\n          opInfo.variablesUsed.delete(candidate);\n\n          // Add all variables used in the variable's initializer to its new usage site.\n          for (const id of varInfo.variablesUsed) {\n            opInfo.variablesUsed.add(id);\n          }\n\n          // Merge fences in the variable's initializer into its new usage site.\n          opInfo.fences |= varInfo.fences;\n\n          // Delete tracking info related to the declaration.\n          varDecls.delete(candidate);\n          varUsages.delete(candidate);\n          opMap.delete(decl as ir.CreateOp | ir.UpdateOp);\n\n          // And finally, delete the original declaration from the operation list.\n          ir.OpList.remove(decl as ir.UpdateOp);\n        }\n\n        // Whether inlining succeeded or failed, we're done processing this variable.\n        break;\n      }\n\n      // If the variable is not used in this operation, then we'd need to inline across it. Check if\n      // that's safe to do.\n      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {\n        // We can't safely inline this variable beyond this operation, so don't proceed with\n        // inlining this variable.\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Given an `ir.Expression`, returns the `Fence` flags for that expression type.\n */\nfunction fencesForIrExpression(expr: ir.Expression): Fence {\n  switch (expr.kind) {\n    case ir.ExpressionKind.NextContext:\n      return Fence.ViewContextWrite;\n    case ir.ExpressionKind.RestoreView:\n      return Fence.ViewContextWrite | Fence.SideEffectful;\n    case ir.ExpressionKind.Reference:\n      return Fence.ViewContextRead;\n    default:\n      return Fence.None;\n  }\n}\n\n/**\n * Build the `OpInfo` structure for the given `op`. This performs two operations:\n *\n *  * It tracks which variables are used in the operation's expressions.\n *  * It rolls up fence flags for expressions within the operation.\n */\nfunction collectOpInfo(op: ir.CreateOp|ir.UpdateOp): OpInfo {\n  let fences = Fence.None;\n  const variablesUsed = new Set<ir.XrefId>();\n  ir.visitExpressionsInOp(op, expr => {\n    switch (expr.kind) {\n      case ir.ExpressionKind.ReadVariable:\n        variablesUsed.add(expr.xref);\n        break;\n      default:\n        fences |= fencesForIrExpression(expr);\n    }\n  });\n  return {fences, variablesUsed};\n}\n\n/**\n * Count the number of usages of each variable, being careful to track whether those usages are\n * local or remote.\n */\nfunction countVariableUsages(\n    op: ir.CreateOp|ir.UpdateOp, varUsages: Map<ir.XrefId, number>,\n    varRemoteUsage: Set<ir.XrefId>): void {\n  ir.visitExpressionsInOp(op, (expr, flags) => {\n    if (expr.kind !== ir.ExpressionKind.ReadVariable) {\n      return;\n    }\n\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      // This variable is declared outside the current scope of optimization.\n      return;\n    }\n    varUsages.set(expr.xref, count + 1);\n\n    if (flags & ir.VisitorContextFlag.InChildOperation) {\n      varRemoteUsage.add(expr.xref);\n    }\n  });\n}\n\n/**\n * Remove usages of a variable in `op` from the `varUsages` tracking.\n */\nfunction uncountVariableUsages(\n    op: ir.CreateOp|ir.UpdateOp, varUsages: Map<ir.XrefId, number>): void {\n  ir.visitExpressionsInOp(op, expr => {\n    if (expr.kind !== ir.ExpressionKind.ReadVariable) {\n      return;\n    }\n\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      // This variable is declared outside the current scope of optimization.\n      return;\n    } else if (count === 0) {\n      throw new Error(\n          `Inaccurate variable count: ${expr.xref} - found another read but count is already 0`);\n    }\n    varUsages.set(expr.xref, count - 1);\n  });\n}\n\n/**\n * Checks whether it's safe to inline a variable across a particular operation.\n *\n * @param fences the fences of the operation which the inlining will cross\n * @param declFences the fences of the variable being inlined.\n */\nfunction safeToInlinePastFences(fences: Fence, declFences: Fence): boolean {\n  if (fences & Fence.ViewContextWrite) {\n    // It's not safe to inline context reads across context writes.\n    if (declFences & Fence.ViewContextRead) {\n      return false;\n    }\n  } else if (fences & Fence.ViewContextRead) {\n    // It's not safe to inline context writes across context reads.\n    if (declFences & Fence.ViewContextWrite) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Attempt to inline the initializer of a variable into a target operation's expressions.\n *\n * This may or may not be safe to do. For example, the variable could be read following the\n * execution of an expression with fences that don't permit the variable to be inlined across them.\n */\nfunction tryInlineVariableInitializer(\n    id: ir.XrefId, initializer: o.Expression, target: ir.CreateOp|ir.UpdateOp,\n    declFences: Fence): boolean {\n  // We use `ir.transformExpressionsInOp` to walk the expressions and inline the variable if\n  // possible. Since this operation is callback-based, once inlining succeeds or fails we can't\n  // \"stop\" the expression processing, and have to keep track of whether inlining has succeeded or\n  // is no longer allowed.\n  let inlined = false;\n  let inliningAllowed = true;\n\n  ir.transformExpressionsInOp(target, (expr, flags) => {\n    if (inlined || !inliningAllowed) {\n      // Either the inlining has already succeeded, or we've passed a fence that disallows inlining\n      // at this point, so don't try.\n      return expr;\n    } else if (\n        (flags & ir.VisitorContextFlag.InChildOperation) && (declFences & Fence.ViewContextRead)) {\n      // We cannot inline variables that are sensitive to the current context across operation\n      // boundaries.\n      return expr;\n    }\n\n    switch (expr.kind) {\n      case ir.ExpressionKind.ReadVariable:\n        if (expr.xref === id) {\n          // This is the usage site of the variable. Since nothing has disallowed inlining, it's\n          // safe to inline the initializer here.\n          inlined = true;\n          return initializer;\n        }\n        break;\n      default:\n        // For other types of `ir.Expression`s, whether inlining is allowed depends on their fences.\n        const exprFences = fencesForIrExpression(expr);\n        inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);\n        break;\n    }\n    return expr;\n  }, ir.VisitorContextFlag.None);\n  return inlined;\n}\n\n/**\n * Determines whether inlining of `decl` should be allowed in \"conservative\" mode.\n *\n * In conservative mode, inlining behavior is limited to those operations which the\n * `TemplateDefinitionBuilder` supported, with the goal of producing equivalent output.\n */\nfunction allowConservativeInlining(\n    decl: ir.VariableOp<ir.CreateOp|ir.UpdateOp>, target: ir.Op<ir.CreateOp|ir.UpdateOp>): boolean {\n  // TODO(alxhub): understand exactly how TemplateDefinitionBuilder approaches inlining, and record\n  // that behavior here.\n  switch (decl.variable.kind) {\n    case ir.SemanticVariableKind.Identifier:\n      return false;\n    case ir.SemanticVariableKind.Context:\n      // Context can only be inlined into other variables.\n      return target.kind === ir.OpKind.Variable;\n    default:\n      return true;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers as R3} from '../../../../render3/r3_identifiers';\nimport * as ir from '../../ir';\nimport {ComponentCompilation} from '../compilation';\n\nconst CHAINABLE = new Set([\n  R3.elementStart,\n  R3.elementEnd,\n  R3.property,\n]);\n\n/**\n * Post-process a reified view compilation and convert sequential calls to chainable instructions\n * into chain calls.\n *\n * For example, two `elementStart` operations in sequence:\n *\n * ```typescript\n * elementStart(0, 'div');\n * elementStart(1, 'span');\n * ```\n *\n * Can be called as a chain instead:\n *\n * ```typescript\n * elementStart(0, 'div')(1, 'span');\n * ```\n */\nexport function phaseChaining(cpl: ComponentCompilation): void {\n  for (const [_, view] of cpl.views) {\n    chainOperationsInList(view.create);\n    chainOperationsInList(view.update);\n  }\n}\n\nfunction chainOperationsInList(opList: ir.OpList<ir.CreateOp|ir.UpdateOp>): void {\n  let chain: Chain|null = null;\n  for (const op of opList) {\n    if (op.kind !== ir.OpKind.Statement || !(op.statement instanceof o.ExpressionStatement)) {\n      // This type of statement isn't chainable.\n      chain = null;\n      continue;\n    }\n    if (!(op.statement.expr instanceof o.InvokeFunctionExpr) ||\n        !(op.statement.expr.fn instanceof o.ExternalExpr)) {\n      // This is a statement, but not an instruction-type call, so not chainable.\n      chain = null;\n      continue;\n    }\n\n    const instruction = op.statement.expr.fn.value;\n    if (!CHAINABLE.has(instruction)) {\n      // This instruction isn't chainable.\n      chain = null;\n      continue;\n    }\n\n    // This instruction can be chained. It can either be added on to the previous chain (if\n    // compatible) or it can be the start of a new chain.\n    if (chain !== null && chain.instruction === instruction) {\n      // This instruction can be added onto the previous chain.\n      const expression = chain.expression.callFn(\n          op.statement.expr.args, op.statement.expr.sourceSpan, op.statement.expr.pure);\n      chain.expression = expression;\n      chain.op.statement = expression.toStmt();\n      ir.OpList.remove(op as ir.Op<ir.CreateOp|ir.UpdateOp>);\n    } else {\n      // Leave this instruction alone for now, but consider it the start of a new chain.\n      chain = {\n        op,\n        instruction,\n        expression: op.statement.expr,\n      };\n    }\n  }\n}\n\n/**\n * Structure representing an in-progress chain.\n */\ninterface Chain {\n  /**\n   * The statement which holds the entire chain.\n   */\n  op: ir.StatementOp<ir.CreateOp|ir.UpdateOp>;\n\n  /**\n   * The expression representing the whole current chained call.\n   *\n   * This should be the same as `op.statement.expression`, but is extracted here for convenience\n   * since the `op` type doesn't capture the fact that `op.statement` is an `o.ExpressionStatement`.\n   */\n  expression: o.Expression;\n\n  /**\n   * The instruction that is being chained.\n   */\n  instruction: o.ExternalReference;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilation} from '../compilation';\n\n/**\n * Merges logically sequential `NextContextExpr` operations.\n *\n * `NextContextExpr` can be referenced repeatedly, \"popping\" the runtime's context stack each time.\n * When two such expressions appear back-to-back, it's possible to merge them together into a single\n * `NextContextExpr` that steps multiple contexts. This merging is possible if all conditions are\n * met:\n *\n *   * The result of the `NextContextExpr` that's folded into the subsequent one is not stored (that\n *     is, the call is purely side-effectful).\n *   * No operations in between them uses the implicit context.\n */\nexport function phaseMergeNextContext(cpl: ComponentCompilation): void {\n  for (const view of cpl.views.values()) {\n    for (const op of view.create) {\n      if (op.kind === ir.OpKind.Listener) {\n        mergeNextContextsInOps(op.handlerOps);\n      }\n    }\n    mergeNextContextsInOps(view.update);\n  }\n}\n\nfunction mergeNextContextsInOps(ops: ir.OpList<ir.UpdateOp>): void {\n  for (const op of ops) {\n    // Look for a candidate operation to maybe merge.\n    if (op.kind !== ir.OpKind.Statement || !(op.statement instanceof o.ExpressionStatement) ||\n        !(op.statement.expr instanceof ir.NextContextExpr)) {\n      continue;\n    }\n\n    const mergeSteps = op.statement.expr.steps;\n\n    // Try to merge this `ir.NextContextExpr`.\n    let tryToMerge = true;\n    for (let candidate = op.next!; candidate.kind !== ir.OpKind.ListEnd && tryToMerge;\n         candidate = candidate.next!) {\n      ir.visitExpressionsInOp(candidate, (expr, flags) => {\n        if (!tryToMerge) {\n          // Either we've already merged, or failed to merge.\n          return;\n        }\n\n        if (flags & ir.VisitorContextFlag.InChildOperation) {\n          // We cannot merge into child operations.\n          return;\n        }\n\n        switch (expr.kind) {\n          case ir.ExpressionKind.NextContext:\n            // Merge the previous `ir.NextContextExpr` into this one.\n            expr.steps += mergeSteps;\n            ir.OpList.remove(op as ir.UpdateOp);\n            tryToMerge = false;\n            break;\n          case ir.ExpressionKind.GetCurrentView:\n          case ir.ExpressionKind.Reference:\n            // Can't merge past a dependency on the context.\n            tryToMerge = false;\n            break;\n        }\n      });\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../src/output/output_ast';\nimport {ConstantPool} from '../../../constant_pool';\nimport * as ir from '../ir';\n\nimport type {ComponentCompilation, ViewCompilation} from './compilation';\n\nimport {phaseConstCollection} from './phases/const_collection';\nimport {phaseEmptyElements} from './phases/empty_elements';\nimport {phaseGenerateAdvance} from './phases/generate_advance';\nimport {phaseReify} from './phases/reify';\nimport {phaseSlotAllocation} from './phases/slot_allocation';\nimport {phaseVarCounting} from './phases/var_counting';\nimport {phaseNaming} from './phases/naming';\nimport {phaseLocalRefs} from './phases/local_refs';\nimport {phaseGenerateVariables} from './phases/generate_variables';\nimport {phaseResolveNames} from './phases/resolve_names';\nimport {phaseResolveContexts} from './phases/resolve_contexts';\nimport {phaseVariableOptimization} from './phases/variable_optimization';\nimport {phaseChaining} from './phases/chaining';\nimport {phaseMergeNextContext} from './phases/next_context_merging';\n\n/**\n * Run all transformation phases in the correct order against a `ComponentCompilation`. After this\n * processing, the compilation should be in a state where it can be emitted via `emitTemplateFn`.s\n */\nexport function transformTemplate(cpl: ComponentCompilation): void {\n  phaseGenerateVariables(cpl);\n  phaseResolveNames(cpl);\n  phaseResolveContexts(cpl);\n  phaseLocalRefs(cpl);\n  phaseEmptyElements(cpl);\n  phaseConstCollection(cpl);\n  phaseSlotAllocation(cpl);\n  phaseVarCounting(cpl);\n  phaseGenerateAdvance(cpl);\n  phaseNaming(cpl);\n  phaseVariableOptimization(cpl, {conservative: true});\n  phaseMergeNextContext(cpl);\n  phaseReify(cpl);\n  phaseChaining(cpl);\n}\n\n/**\n * Compile all views in the given `ComponentCompilation` into the final template function, which may\n * reference constants defined in a `ConstantPool`.\n */\nexport function emitTemplateFn(tpl: ComponentCompilation, pool: ConstantPool): o.FunctionExpr {\n  const rootFn = emitView(tpl.root);\n  emitChildViews(tpl.root, pool);\n  return rootFn;\n}\n\nfunction emitChildViews(parent: ViewCompilation, pool: ConstantPool): void {\n  for (const view of parent.tpl.views.values()) {\n    if (view.parent !== parent.xref) {\n      continue;\n    }\n\n    // Child views are emitted depth-first.\n    emitChildViews(view, pool);\n\n    const viewFn = emitView(view);\n    pool.statements.push(viewFn.toDeclStmt(viewFn.name!));\n  }\n}\n\n/**\n * Emit a template function for an individual `ViewCompilation` (which may be either the root view\n * or an embedded view).\n */\nfunction emitView(view: ViewCompilation): o.FunctionExpr {\n  if (view.fnName === null) {\n    throw new Error(`AssertionError: view ${view.xref} is unnamed`);\n  }\n\n  const createStatements: o.Statement[] = [];\n  for (const op of view.create) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${\n          ir.OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements: o.Statement[] = [];\n  for (const op of view.update) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${\n          ir.OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return o.fn(\n      [\n        new o.FnParam('rf'),\n        new o.FnParam('ctx'),\n      ],\n      [\n        ...createCond,\n        ...updateCond,\n      ],\n      /* type */ undefined, /* sourceSpan */ undefined, view.fnName);\n}\n\nfunction maybeGenerateRfBlock(flag: number, statements: o.Statement[]): o.Statement[] {\n  if (statements.length === 0) {\n    return [];\n  }\n\n  return [\n    o.ifStmt(\n        new o.BinaryOperatorExpr(o.BinaryOperator.BitwiseAnd, o.variable('rf'), o.literal(flag)),\n        statements),\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../output/output_ast';\nimport * as ir from '../ir';\n\n/**\n * Compilation-in-progress of a whole component's template, including the main template and any\n * embedded views or host bindings.\n */\nexport class ComponentCompilation {\n  /**\n   * Tracks the next `ir.XrefId` which can be assigned as template structures are ingested.\n   */\n  private nextXrefId: ir.XrefId = 0 as ir.XrefId;\n\n  /**\n   * Map of view IDs to `ViewCompilation`s.\n   */\n  readonly views = new Map<ir.XrefId, ViewCompilation>();\n\n  /**\n   * Constant expressions used by operations within this component's compilation.\n   *\n   * This will eventually become the `consts` array in the component definition.\n   */\n  readonly consts: o.Expression[] = [];\n\n  /**\n   * The root view, representing the component's template.\n   */\n  readonly root: ViewCompilation;\n\n  constructor(readonly componentName: string) {\n    // Allocate the root view.\n    const root = new ViewCompilation(this, this.allocateXrefId(), null);\n    this.views.set(root.xref, root);\n    this.root = root;\n  }\n\n  /**\n   * Add a `ViewCompilation` for a new embedded view to this compilation.\n   */\n  allocateView(parent: ir.XrefId): ViewCompilation {\n    const view = new ViewCompilation(this, this.allocateXrefId(), parent);\n    this.views.set(view.xref, view);\n    return view;\n  }\n\n  /**\n   * Generate a new unique `ir.XrefId`.\n   */\n  allocateXrefId(): ir.XrefId {\n    return this.nextXrefId++ as ir.XrefId;\n  }\n\n  /**\n   * Add a constant `o.Expression` to the compilation and return its index in the `consts` array.\n   */\n  addConst(newConst: o.Expression): ir.ConstIndex {\n    for (let idx = 0; idx < this.consts.length; idx++) {\n      if (this.consts[idx].isEquivalent(newConst)) {\n        return idx as ir.ConstIndex;\n      }\n    }\n    const idx = this.consts.length;\n    this.consts.push(newConst);\n    return idx as ir.ConstIndex;\n  }\n}\n\n/**\n * Compilation-in-progress of an individual view within a template.\n */\nexport class ViewCompilation {\n  constructor(\n      readonly tpl: ComponentCompilation, readonly xref: ir.XrefId,\n      readonly parent: ir.XrefId|null) {}\n\n  /**\n   * Name of the function which will be generated for this view.\n   *\n   * May be `null` if not yet determined.\n   */\n  fnName: string|null = null;\n\n  /**\n   * List of creation operations for this view.\n   *\n   * Creation operations may internally contain other operations, including update operations.\n   */\n  readonly create = new ir.OpList<ir.CreateOp>();\n\n  /**\n   * List of update operations for this view.\n   */\n  readonly update = new ir.OpList<ir.UpdateOp>();\n\n  /**\n   * Map of declared variables available within this view to the property on the context object\n   * which they alias.\n   */\n  readonly contextVariables = new Map<string, string>();\n\n  /**\n   * Number of declaration slots used within this view, or `null` if slots have not yet been\n   * allocated.\n   */\n  decls: number|null = null;\n\n  /**\n   * Number of variable slots used within this view, or `null` if variables have not yet been\n   * counted.\n   */\n  vars: number|null = null;\n\n  /**\n   * Iterate over all `ir.Op`s within this view.\n   *\n   * Some operations may have child operations, which this iterator will visit.\n   */\n  * ops(): Generator<ir.CreateOp|ir.UpdateOp> {\n    for (const op of this.create) {\n      yield op;\n      if (op.kind === ir.OpKind.Listener) {\n        for (const listenerOp of op.handlerOps) {\n          yield listenerOp;\n        }\n      }\n    }\n    for (const op of this.update) {\n      yield op;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as e from '../../../expression_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../../render3/r3_ast';\nimport * as ir from '../ir';\n\nimport {ComponentCompilation, ViewCompilation} from './compilation';\n\n/**\n * Process a template AST and convert it into a `ComponentCompilation` in the intermediate\n * representation.\n */\nexport function ingest(componentName: string, template: t.Node[]): ComponentCompilation {\n  const cpl = new ComponentCompilation(componentName);\n  ingestNodes(cpl.root, template);\n  return cpl;\n}\n\n/**\n * Ingest the nodes of a template AST into the given `ViewCompilation`.\n */\nfunction ingestNodes(view: ViewCompilation, template: t.Node[]): void {\n  for (const node of template) {\n    if (node instanceof t.Element) {\n      ingestElement(view, node);\n    } else if (node instanceof t.Template) {\n      ingestTemplate(view, node);\n    } else if (node instanceof t.Text) {\n      ingestText(view, node);\n    } else if (node instanceof t.BoundText) {\n      ingestBoundText(view, node);\n    } else {\n      throw new Error(`Unsupported template node: ${node.constructor.name}`);\n    }\n  }\n}\n\n/**\n * Ingest an element AST from the template into the given `ViewCompilation`.\n */\nfunction ingestElement(view: ViewCompilation, element: t.Element): void {\n  const staticAttributes: Record<string, string> = {};\n  for (const attr of element.attributes) {\n    staticAttributes[attr.name] = attr.value;\n  }\n  const id = view.tpl.allocateXrefId();\n\n  const startOp = ir.createElementStartOp(element.name, id);\n  view.create.push(startOp);\n\n  ingestAttributes(startOp, element);\n  ingestBindings(view, startOp, element);\n  ingestReferences(startOp, element);\n\n  ingestNodes(view, element.children);\n  view.create.push(ir.createElementEndOp(id));\n}\n\n/**\n * Ingest an `ng-template` node from the AST into the given `ViewCompilation`.\n */\nfunction ingestTemplate(view: ViewCompilation, tmpl: t.Template): void {\n  const childView = view.tpl.allocateView(view.xref);\n\n  // TODO: validate the fallback tag name here.\n  const tplOp = ir.createTemplateOp(childView.xref, tmpl.tagName ?? 'ng-template');\n  view.create.push(tplOp);\n\n  ingestAttributes(tplOp, tmpl);\n  ingestBindings(view, tplOp, tmpl);\n  ingestReferences(tplOp, tmpl);\n\n  ingestNodes(childView, tmpl.children);\n\n  for (const {name, value} of tmpl.variables) {\n    childView.contextVariables.set(name, value);\n  }\n}\n\n/**\n * Ingest a literal text node from the AST into the given `ViewCompilation`.\n */\nfunction ingestText(view: ViewCompilation, text: t.Text): void {\n  view.create.push(ir.createTextOp(view.tpl.allocateXrefId(), text.value));\n}\n\n/**\n * Ingest an interpolated text node from the AST into the given `ViewCompilation`.\n */\nfunction ingestBoundText(view: ViewCompilation, text: t.BoundText): void {\n  let value = text.value;\n  if (value instanceof e.ASTWithSource) {\n    value = value.ast;\n  }\n  if (!(value instanceof e.Interpolation)) {\n    throw new Error(\n        `AssertionError: expected Interpolation for BoundText node, got ${value.constructor.name}`);\n  }\n\n  const textXref = view.tpl.allocateXrefId();\n  view.create.push(ir.createTextOp(textXref, ''));\n  view.update.push(ir.createInterpolateTextOp(\n      textXref, value.strings, value.expressions.map(expr => convertAst(expr, view.tpl))));\n}\n\n/**\n * Convert a template AST expression into an output AST expression.\n */\nfunction convertAst(ast: e.AST, cpl: ComponentCompilation): o.Expression {\n  if (ast instanceof e.ASTWithSource) {\n    return convertAst(ast.ast, cpl);\n  } else if (ast instanceof e.PropertyRead) {\n    if (ast.receiver instanceof e.ImplicitReceiver) {\n      return new ir.LexicalReadExpr(ast.name);\n    } else {\n      return new o.ReadPropExpr(convertAst(ast.receiver, cpl), ast.name);\n    }\n  } else if (ast instanceof e.Call) {\n    if (ast.receiver instanceof e.ImplicitReceiver) {\n      throw new Error(`Unexpected ImplicitReceiver`);\n    } else {\n      return new o.InvokeFunctionExpr(\n          convertAst(ast.receiver, cpl), ast.args.map(arg => convertAst(arg, cpl)));\n    }\n  } else if (ast instanceof e.LiteralPrimitive) {\n    return o.literal(ast.value);\n  } else if (ast instanceof e.ThisReceiver) {\n    return new ir.ContextExpr(cpl.root.xref);\n  } else {\n    throw new Error(`Unhandled expression type: ${ast.constructor.name}`);\n  }\n}\n\n/**\n * Process all of the attributes on an element-like structure in the template AST and convert them\n * to their IR representation.\n */\nfunction ingestAttributes(op: ir.ElementOpBase, element: t.Element|t.Template): void {\n  ir.assertIsElementAttributes(op.attributes);\n  for (const attr of element.attributes) {\n    op.attributes.add(ir.ElementAttributeKind.Attribute, attr.name, o.literal(attr.value));\n  }\n\n  for (const input of element.inputs) {\n    op.attributes.add(ir.ElementAttributeKind.Binding, input.name, null);\n  }\n  for (const output of element.outputs) {\n    op.attributes.add(ir.ElementAttributeKind.Binding, output.name, null);\n  }\n\n  if (element instanceof t.Template) {\n    for (const attr of element.templateAttrs) {\n      // TODO: what do we do about the value here?\n      op.attributes.add(ir.ElementAttributeKind.Template, attr.name, null);\n    }\n  }\n}\n\n/**\n * Process all of the bindings on an element-like structure in the template AST and convert them\n * to their IR representation.\n */\nfunction ingestBindings(\n    view: ViewCompilation, op: ir.ElementOpBase, element: t.Element|t.Template): void {\n  if (element instanceof t.Template) {\n    for (const attr of element.templateAttrs) {\n      if (typeof attr.value === 'string') {\n        // TODO: do we need to handle static attribute bindings here?\n      } else {\n        view.update.push(ir.createPropertyOp(op.xref, attr.name, convertAst(attr.value, view.tpl)));\n      }\n    }\n  } else {\n    for (const input of element.inputs) {\n      view.update.push(ir.createPropertyOp(op.xref, input.name, convertAst(input.value, view.tpl)));\n    }\n\n    for (const output of element.outputs) {\n      const listenerOp = ir.createListenerOp(op.xref, output.name, op.tag);\n      listenerOp.handlerOps.push(\n          ir.createStatementOp(new o.ReturnStatement(convertAst(output.handler, view.tpl))));\n      view.create.push(listenerOp);\n    }\n  }\n}\n\n/**\n * Process all of the local references on an element-like structure in the template AST and convert\n * them to their IR representation.\n */\nfunction ingestReferences(op: ir.ElementOpBase, element: t.Element|t.Template): void {\n  assertIsArray<ir.LocalRef>(op.localRefs);\n  for (const {name, value} of element.references) {\n    op.localRefs.push({\n      name,\n      target: value,\n    });\n  }\n}\n\n/**\n * Assert that the given value is an array.\n */\nfunction assertIsArray<T>(value: any): asserts value is Array<T> {\n  if (!Array.isArray(value)) {\n    throw new Error(`AssertionError: expected an array`);\n  }\n}\n", "export const USE_TEMPLATE_PIPELINE = false;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Any changes here should be ported to the Angular Domino fork.\n// https://github.com/angular/domino/blob/main/lib/style_parser.js\n\nconst enum Char {\n  OpenParen = 40,\n  CloseParen = 41,\n  Colon = 58,\n  Semicolon = 59,\n  BackSlash = 92,\n  QuoteNone = 0,  // indicating we are not inside a quote\n  QuoteDouble = 34,\n  QuoteSingle = 39,\n}\n\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nexport function parse(value: string): string[] {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  const styles: string[] = [];\n\n  let i = 0;\n  let parenDepth = 0;\n  let quote: Char = Char.QuoteNone;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp: string|null = null;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++) as Char;\n    switch (token) {\n      case Char.OpenParen:\n        parenDepth++;\n        break;\n      case Char.CloseParen:\n        parenDepth--;\n        break;\n      case Char.QuoteSingle:\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteSingle;\n        } else if (quote === Char.QuoteSingle && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.QuoteDouble:\n        // same logic as above\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteDouble;\n        } else if (quote === Char.QuoteDouble && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.Colon:\n        if (!currentProp && parenDepth === 0 && quote === Char.QuoteNone) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case Char.Semicolon:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === Char.QuoteNone) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n        }\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, styleVal);\n  }\n\n  return styles;\n}\n\nexport function hyphenate(value: string): string {\n  return value\n      .replace(\n          /[a-z][A-Z]/g,\n          v => {\n            return v.charAt(0) + '-' + v.charAt(1);\n          })\n      .toLowerCase();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AttributeMarker} from '../../core';\nimport {AST, ASTWithSource, BindingPipe, BindingType, EmptyExpr, Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\n\nimport {hyphenate, parse as parseStyle} from './style_parser';\nimport {ValueConverter} from './template';\nimport {DefinitionMap, getInterpolationArgsLength} from './util';\n\nconst IMPORTANT_FLAG = '!important';\n\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nexport const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n\n/**\n * A styling expression summary that is to be processed by the compiler\n */\nexport interface StylingInstruction {\n  reference: o.ExternalReference;\n  /** Calls to individual styling instructions. Used when chaining calls to the same instruction. */\n  calls: StylingInstructionCall[];\n}\n\nexport interface StylingInstructionCall {\n  sourceSpan: ParseSourceSpan|null;\n  supportsInterpolation: boolean;\n  allocateBindingSlots: number;\n  params: ((convertFn: (value: any) => o.Expression | o.Expression[]) => o.Expression[]);\n}\n\n/**\n * An internal record of the input data for a styling binding\n */\ninterface BoundStylingEntry {\n  hasOverrideFlag: boolean;\n  name: string|null;\n  suffix: string|null;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nexport class StylingBuilder {\n  /** Whether or not there are any static styling values present */\n  private _hasInitialValues = false;\n  /**\n   *  Whether or not there are any styling bindings present\n   *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n   */\n  public hasBindings = false;\n  public hasBindingsWithPipes = false;\n\n  /** the input for [class] (if it exists) */\n  private _classMapInput: BoundStylingEntry|null = null;\n  /** the input for [style] (if it exists) */\n  private _styleMapInput: BoundStylingEntry|null = null;\n  /** an array of each [style.prop] input */\n  private _singleStyleInputs: BoundStylingEntry[]|null = null;\n  /** an array of each [class.name] input */\n  private _singleClassInputs: BoundStylingEntry[]|null = null;\n  private _lastStylingInput: BoundStylingEntry|null = null;\n  private _firstStylingInput: BoundStylingEntry|null = null;\n\n  // maps are used instead of hash maps because a Map will\n  // retain the ordering of the keys\n\n  /**\n   * Represents the location of each style binding in the template\n   * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n   * that `width=0` and `height=1`)\n   */\n  private _stylesIndex = new Map<string, number>();\n\n  /**\n   * Represents the location of each class binding in the template\n   * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n   * that `big=0` and `hidden=1`)\n   */\n  private _classesIndex = new Map<string, number>();\n  private _initialStyleValues: string[] = [];\n  private _initialClassValues: string[] = [];\n\n  constructor(private _directiveExpr: o.Expression|null) {}\n\n  /**\n   * Registers a given input to the styling builder to be later used when producing AOT code.\n   *\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\n   * style/class bindings or static style/class attributes).\n   */\n  registerBoundInput(input: t.BoundAttribute): boolean {\n    // [attr.style] or [attr.class] are skipped in the code below,\n    // they should not be treated as styling-based bindings since\n    // they are intended to be written directly to the attr and\n    // will therefore skip all style/class resolution that is present\n    // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n    // [class.prop]=\"\". [class]=\"\" assignments\n    let binding: BoundStylingEntry|null = null;\n    let name = input.name;\n    switch (input.type) {\n      case BindingType.Property:\n        binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n        break;\n      case BindingType.Style:\n        binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n        break;\n      case BindingType.Class:\n        binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n        break;\n    }\n    return binding ? true : false;\n  }\n\n  registerInputBasedOnName(name: string, expression: AST, sourceSpan: ParseSourceSpan) {\n    let binding: BoundStylingEntry|null = null;\n    const prefix = name.substring(0, 6);\n    const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n    const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n    if (isStyle || isClass) {\n      const isMapBased = name.charAt(5) !== '.';        // style.prop or class.prop makes this a no\n      const property = name.slice(isMapBased ? 5 : 6);  // the dot explains why there's a +1\n      if (isStyle) {\n        binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n      } else {\n        binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n      }\n    }\n    return binding;\n  }\n\n  registerStyleInput(\n      name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan,\n      suffix?: string|null): BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    // CSS custom properties are case-sensitive so we shouldn't normalize them.\n    // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n    if (!isCssCustomProperty(name)) {\n      name = hyphenate(name);\n    }\n    const {property, hasOverrideFlag, suffix: bindingSuffix} = parseProperty(name);\n    suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n    const entry:\n        BoundStylingEntry = {name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag};\n    if (isMapBased) {\n      this._styleMapInput = entry;\n    } else {\n      (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n      registerIntoMap(this._stylesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  registerClassInput(name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan):\n      BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    const {property, hasOverrideFlag} = parseProperty(name);\n    const entry:\n        BoundStylingEntry = {name: property, value, sourceSpan, hasOverrideFlag, suffix: null};\n    if (isMapBased) {\n      this._classMapInput = entry;\n    } else {\n      (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n      registerIntoMap(this._classesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  private _checkForPipes(value: AST) {\n    if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n      this.hasBindingsWithPipes = true;\n    }\n  }\n\n  /**\n   * Registers the element's static style string value to the builder.\n   *\n   * @param value the style string (e.g. `width:100px; height:200px;`)\n   */\n  registerStyleAttr(value: string) {\n    this._initialStyleValues = parseStyle(value);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Registers the element's static class string value to the builder.\n   *\n   * @param value the className string (e.g. `disabled gold zoom`)\n   */\n  registerClassAttr(value: string) {\n    this._initialClassValues = value.trim().split(/\\s+/g);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Appends all styling-related expressions to the provided attrs array.\n   *\n   * @param attrs an existing array where each of the styling expressions\n   * will be inserted into.\n   */\n  populateInitialStylingAttrs(attrs: o.Expression[]): void {\n    // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n    if (this._initialClassValues.length) {\n      attrs.push(o.literal(AttributeMarker.Classes));\n      for (let i = 0; i < this._initialClassValues.length; i++) {\n        attrs.push(o.literal(this._initialClassValues[i]));\n      }\n    }\n\n    // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n    if (this._initialStyleValues.length) {\n      attrs.push(o.literal(AttributeMarker.Styles));\n      for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n        attrs.push(\n            o.literal(this._initialStyleValues[i]), o.literal(this._initialStyleValues[i + 1]));\n      }\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n   *\n   * The instruction generation code below is used for producing the AOT statement code which is\n   * responsible for registering initial styles (within a directive hostBindings' creation block),\n   * as well as any of the provided attribute values, to the directive host element.\n   */\n  assignHostAttrs(attrs: o.Expression[], definitionMap: DefinitionMap): void {\n    if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n      this.populateInitialStylingAttrs(attrs);\n      definitionMap.set('hostAttrs', o.literalArr(attrs));\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `classMap`.\n   *\n   * The instruction data will contain all expressions for `classMap` to function\n   * which includes the `[class]` expression params.\n   */\n  buildClassMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._classMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n    }\n    return null;\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `styleMap`.\n   *\n   * The instruction data will contain all expressions for `styleMap` to function\n   * which includes the `[style]` expression params.\n   */\n  buildStyleMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._styleMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n    }\n    return null;\n  }\n\n  private _buildMapBasedInstruction(\n      valueConverter: ValueConverter, isClassBased: boolean,\n      stylingInput: BoundStylingEntry): StylingInstruction {\n    // each styling binding value is stored in the LView\n    // map-based bindings allocate two slots: one for the\n    // previous binding value and another for the previous\n    // className or style attribute value.\n    let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n    // these values must be outside of the update block so that they can\n    // be evaluated (the AST visit call) during creation time so that any\n    // pipes can be picked up in time before the template is built\n    const mapValue = stylingInput.value.visit(valueConverter);\n    let reference: o.ExternalReference;\n    if (mapValue instanceof Interpolation) {\n      totalBindingSlotsRequired += mapValue.expressions.length;\n      reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                                 getStyleMapInterpolationExpression(mapValue);\n    } else {\n      reference = isClassBased ? R3.classMap : R3.styleMap;\n    }\n\n    return {\n      reference,\n      calls: [{\n        supportsInterpolation: true,\n        sourceSpan: stylingInput.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        params: (convertFn: (value: any) => o.Expression|o.Expression[]) => {\n          const convertResult = convertFn(mapValue);\n          const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n          return params;\n        }\n      }]\n    };\n  }\n\n  private _buildSingleInputs(\n      reference: o.ExternalReference, inputs: BoundStylingEntry[], valueConverter: ValueConverter,\n      getInterpolationExpressionFn: ((value: Interpolation) => o.ExternalReference)|null,\n      isClassBased: boolean): StylingInstruction[] {\n    const instructions: StylingInstruction[] = [];\n\n    inputs.forEach(input => {\n      const previousInstruction: StylingInstruction|undefined =\n          instructions[instructions.length - 1];\n      const value = input.value.visit(valueConverter);\n      let referenceForCall = reference;\n\n      // each styling binding value is stored in the LView\n      // but there are two values stored for each binding:\n      //   1) the value itself\n      //   2) an intermediate value (concatenation of style up to this point).\n      //      We need to store the intermediate value so that we don't allocate\n      //      the strings on each CD.\n      let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n      if (value instanceof Interpolation) {\n        totalBindingSlotsRequired += value.expressions.length;\n\n        if (getInterpolationExpressionFn) {\n          referenceForCall = getInterpolationExpressionFn(value);\n        }\n      }\n\n      const call = {\n        sourceSpan: input.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        supportsInterpolation: !!getInterpolationExpressionFn,\n        params: (convertFn: (value: any) => o.Expression | o.Expression[]) => {\n          // params => stylingProp(propName, value, suffix)\n          const params: o.Expression[] = [];\n          params.push(o.literal(input.name));\n\n          const convertResult = convertFn(value);\n          if (Array.isArray(convertResult)) {\n            params.push(...convertResult);\n          } else {\n            params.push(convertResult);\n          }\n\n          // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n          // if that is detected then we need to pass that in as an optional param.\n          if (!isClassBased && input.suffix !== null) {\n            params.push(o.literal(input.suffix));\n          }\n\n          return params;\n        }\n      };\n\n      // If we ended up generating a call to the same instruction as the previous styling property\n      // we can chain the calls together safely to save some bytes, otherwise we have to generate\n      // a separate instruction call. This is primarily a concern with interpolation instructions\n      // where we may start off with one `reference`, but end up using another based on the\n      // number of interpolations.\n      if (previousInstruction && previousInstruction.reference === referenceForCall) {\n        previousInstruction.calls.push(call);\n      } else {\n        instructions.push({reference: referenceForCall, calls: [call]});\n      }\n    });\n\n    return instructions;\n  }\n\n  private _buildClassInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleClassInputs) {\n      return this._buildSingleInputs(\n          R3.classProp, this._singleClassInputs, valueConverter, null, true);\n    }\n    return [];\n  }\n\n  private _buildStyleInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleStyleInputs) {\n      return this._buildSingleInputs(\n          R3.styleProp, this._singleStyleInputs, valueConverter,\n          getStylePropInterpolationExpression, false);\n    }\n    return [];\n  }\n\n  /**\n   * Constructs all instructions which contain the expressions that will be placed\n   * into the update block of a template function or a directive hostBindings function.\n   */\n  buildUpdateLevelInstructions(valueConverter: ValueConverter) {\n    const instructions: StylingInstruction[] = [];\n    if (this.hasBindings) {\n      const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n      if (styleMapInstruction) {\n        instructions.push(styleMapInstruction);\n      }\n      const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n      if (classMapInstruction) {\n        instructions.push(classMapInstruction);\n      }\n      instructions.push(...this._buildStyleInputs(valueConverter));\n      instructions.push(...this._buildClassInputs(valueConverter));\n    }\n    return instructions;\n  }\n}\n\nfunction registerIntoMap(map: Map<string, number>, key: string) {\n  if (!map.has(key)) {\n    map.set(key, map.size);\n  }\n}\n\nexport function parseProperty(name: string):\n    {property: string, suffix: string|null, hasOverrideFlag: boolean} {\n  let hasOverrideFlag = false;\n  const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n    hasOverrideFlag = true;\n  }\n\n  let suffix: string|null = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.slice(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {property, suffix, hasOverrideFlag};\n}\n\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.classMap;\n    case 3:\n      return R3.classMapInterpolate1;\n    case 5:\n      return R3.classMapInterpolate2;\n    case 7:\n      return R3.classMapInterpolate3;\n    case 9:\n      return R3.classMapInterpolate4;\n    case 11:\n      return R3.classMapInterpolate5;\n    case 13:\n      return R3.classMapInterpolate6;\n    case 15:\n      return R3.classMapInterpolate7;\n    case 17:\n      return R3.classMapInterpolate8;\n    default:\n      return R3.classMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleMap;\n    case 3:\n      return R3.styleMapInterpolate1;\n    case 5:\n      return R3.styleMapInterpolate2;\n    case 7:\n      return R3.styleMapInterpolate3;\n    case 9:\n      return R3.styleMapInterpolate4;\n    case 11:\n      return R3.styleMapInterpolate5;\n    case 13:\n      return R3.styleMapInterpolate6;\n    case 15:\n      return R3.styleMapInterpolate7;\n    case 17:\n      return R3.styleMapInterpolate8;\n    default:\n      return R3.styleMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleProp;\n    case 3:\n      return R3.stylePropInterpolate1;\n    case 5:\n      return R3.stylePropInterpolate2;\n    case 7:\n      return R3.stylePropInterpolate3;\n    case 9:\n      return R3.stylePropInterpolate4;\n    case 11:\n      return R3.stylePropInterpolate5;\n    case 13:\n      return R3.stylePropInterpolate6;\n    case 15:\n      return R3.stylePropInterpolate7;\n    case 17:\n      return R3.stylePropInterpolate8;\n    default:\n      return R3.stylePropInterpolateV;\n  }\n}\n\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name: string): boolean {\n  return name.startsWith('--');\n}\n\nfunction isEmptyExpression(ast: AST): boolean {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n  return ast instanceof EmptyExpr;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  PrivateIdentifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new _Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(\n      public index: number, public end: number, public type: TokenType, public numValue: number,\n      public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n\n  isNumber(): boolean {\n    return this.type == TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type == TokenType.String;\n  }\n\n  isOperator(operator: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operator;\n  }\n\n  isIdentifier(): boolean {\n    return this.type == TokenType.Identifier;\n  }\n\n  isPrivateIdentifier(): boolean {\n    return this.type == TokenType.PrivateIdentifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type == TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'let';\n  }\n\n  isKeywordAs(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'as';\n  }\n\n  isKeywordNull(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'null';\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'true';\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'false';\n  }\n\n  isKeywordThis(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'this';\n  }\n\n  isError(): boolean {\n    return this.type == TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type == TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, end: number, code: number): Token {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\n\nfunction newPrivateIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, end: number, n: number): Token {\n  return new Token(index, end, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, end: number, message: string): Token {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, -1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token|null {\n    const input = this.input, length = this.length;\n    let peek = this.peek, index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, this.index, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n        return this.scanPrivateIdentifier();\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanQuestion(start);\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n                                        newIdentifierToken(start, this.index, str);\n  }\n\n  /** Scans an ECMAScript private identifier. */\n  scanPrivateIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName: string = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n\n  scanNumber(start: number): Token {\n    let simple = (this.index === start);\n    let hasSeparators = false;\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$_) {\n        // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n        // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n        // point or another separator either. Note that it's unlikely that we'll hit a case where\n        // the underscore is at the start, because that's a valid identifier and it will be picked\n        // up earlier in the parsing. We validate for it anyway just in case.\n        if (!chars.isDigit(this.input.charCodeAt(this.index - 1)) ||\n            !chars.isDigit(this.input.charCodeAt(this.index + 1))) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let buffer: string = '';\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        let unescapedCode: number;\n        this.advance();  // mutates this.peek\n        // @ts-expect-error see microsoft/TypeScript#9998\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, this.index, buffer + last);\n  }\n\n  scanQuestion(start: number): Token {\n    this.advance();\n    let str: string = '?';\n    // Either `a ?? b` or 'a?.b'.\n    if (this.peek === chars.$QUESTION || this.peek === chars.$PERIOD) {\n      str += this.peek === chars.$PERIOD ? '.' : '?';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(\n        position, this.index,\n        `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {InterpolatedAttributeToken, InterpolatedTextToken, TokenType as MlParserTokenType} from '../ml_parser/tokens';\n\nimport {AbsoluteSourceSpan, AST, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafeCall, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType} from './lexer';\n\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n      public strings: InterpolationPiece[], public expressions: InterpolationPiece[],\n      public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\n/**\n * Represents the possible parse modes to be used as a bitmask.\n */\nexport const enum ParseFlags {\n  None = 0,\n\n  /**\n   * Whether an output binding is being parsed.\n   */\n  Action = 1 << 0,\n\n  /**\n   * Whether an assignment event is being parsed, i.e. an expression originating from\n   * two-way-binding aka banana-in-a-box syntax.\n   */\n  AssignmentEvent = 1 << 1,\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, isAssignmentEvent: boolean, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    let flags = ParseFlags.Action;\n    if (isAssignmentEvent) {\n      flags |= ParseFlags.AssignmentEvent;\n    }\n    const ast =\n        new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  parseSimpleBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    const errors = this.checkSimpleExpression(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: string) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig): AST {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(input, location, absoluteOffset, tokens, ParseFlags.None, this.errors, 0)\n        .parseChain();\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items\">\n   *         ^      ^ absoluteValueOffset for `templateValue`\n   *         absoluteKeyOffset for `templateKey`\n   * ```\n   * contains three bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   *\n   * This is apparent from the de-sugared template:\n   * ```\n   *   <ng-template ngFor let-item [ngForOf]=\"items\">\n   * ```\n   *\n   * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n   * @param templateValue RHS of the microsyntax attribute\n   * @param templateUrl template filename if it's external, component filename if it's inline\n   * @param absoluteKeyOffset start of the `templateKey`\n   * @param absoluteValueOffset start of the `templateValue`\n   */\n  parseTemplateBindings(\n      templateKey: string, templateValue: string, templateUrl: string, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(templateValue);\n    const parser = new _ParseAST(\n        templateValue, templateUrl, absoluteValueOffset, tokens, ParseFlags.None, this.errors,\n        0 /* relative offset */);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n    });\n  }\n\n  parseInterpolation(\n      input: string, location: string, absoluteOffset: number,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const {strings, expressions, offsets} =\n        this.splitInterpolation(input, location, interpolatedTokens, interpolationConfig);\n    if (expressions.length === 0) return null;\n\n    const expressionNodes: AST[] = [];\n\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionText = expressions[i].text;\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast =\n          new _ParseAST(\n              input, location, absoluteOffset, tokens, ParseFlags.None, this.errors, offsets[i])\n              .parseChain();\n      expressionNodes.push(ast);\n    }\n\n    return this.createInterpolationAst(\n        strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const sourceToLex = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast =\n        new _ParseAST(expression, location, absoluteOffset, tokens, ParseFlags.None, this.errors, 0)\n            .parseChain();\n    const strings = ['', ''];  // The prefix and suffix strings are both empty\n    return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n  }\n\n  private createInterpolationAst(\n      strings: string[], expressions: AST[], input: string, location: string,\n      absoluteOffset: number): ASTWithSource {\n    const span = new ParseSpan(0, input.length);\n    const interpolation =\n        new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n  }\n\n  /**\n   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n   * the string.\n   * Returns `null` if there are no interpolations, otherwise a\n   * `SplitInterpolation` with splits that look like\n   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n   */\n  splitInterpolation(\n      input: string, location: string,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n    const strings: InterpolationPiece[] = [];\n    const expressions: InterpolationPiece[] = [];\n    const offsets: number[] = [];\n    const inputToTemplateIndexMap =\n        interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    let {start: interpStart, end: interpEnd} = interpolationConfig;\n    while (i < input.length) {\n      if (!atInterpolation) {\n        // parse until starting {{\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({text, start, end: i});\n\n        atInterpolation = true;\n      } else {\n        // parse from starting {{ to ending }} while ignoring content inside quotes.\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          // Could not find the end of the interpolation; do not parse an expression.\n          // Instead we should extend the content on the last raw string.\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          this._reportError(\n              'Blank expressions are not allowed in interpolated strings', input,\n              `at column ${i} in`, location);\n        }\n        expressions.push({text, start: fullStart, end: fullEnd});\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      // If we are now at a text section, add the remaining content as a raw string.\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({text: input.substring(i), start: i, end: input.length});\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string|null, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(\n        new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location,\n        absoluteOffset, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i) : input;\n  }\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && chars.isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: string, {start, end}: InterpolationConfig):\n      void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      this._reportError(\n          `Got interpolation (${start}${end}) where expression was expected`, input,\n          `at column ${startIndex} in`, location);\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n   * @param input String to loop through.\n   * @param start Index within the string at which to start.\n   */\n  private * _forEachUnquotedChar(input: string, start: number) {\n    let currentQuote: string|null = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      // Skip the characters inside quotes. Note that we only care about the outer-most\n      // quotes matching up and we need to account for escape characters.\n      if (chars.isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n          escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\n\n/** Describes a stateful context an expression parser is in. */\nenum ParseContextFlags {\n  None = 0,\n  /**\n   * A Writable context is one in which a value may be written to an lvalue.\n   * For example, after we see a property access, we may expect a write to the\n   * property via the \"=\" operator.\n   *   prop\n   *        ^ possible \"=\" after\n   */\n  Writable = 1,\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n  private context = ParseContextFlags.None;\n\n  // Cache of expression start and input indeces to the absolute source span they map to, used to\n  // prevent creating superfluous source spans in `sourceSpan`.\n  // A serial of the expression start and input index is used for mapping because both are stateful\n  // and may change for subsequent expressions visited by the parser.\n  private sourceSpanCache = new Map<string, AbsoluteSourceSpan>();\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: string, public absoluteOffset: number,\n      public tokens: Token[], public parseFlags: ParseFlags, private errors: ParserError[],\n      private offset: number) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n\n    // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n    // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n    // appears to be a deep-seated parser bug.\n    //\n    // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n    // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n\n    return new ParseSpan(start, endIndex);\n  }\n\n  sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n          serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n\n  consumeOptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  /**\n   * Consumes an expected character, otherwise emits an error about the missing expected character\n   * and skips over the token stream until reaching a recoverable point.\n   *\n   * See `this.error` and `this.skip` for more details.\n   */\n  expectCharacter(code: number) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  consumeOptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  prettyPrintToken(tok: Token): string {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n\n  expectIdentifierOrKeyword(): string|null {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(\n            `Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        // The `error` call above will skip ahead to the next recovery point in an attempt to\n        // recover part of the expression, but that might be the token we started from which will\n        // lead to an infinite loop. If that's the case, break the loop assuming that we can't\n        // parse further.\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      // We have no expressions so create an empty expression that spans the entire input length\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr(\n          this.span(artificialStart, artificialEnd),\n          this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n\n  parsePipe(): AST {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & ParseFlags.Action) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan: AbsoluteSourceSpan;\n        let fullSpanEnd: number|undefined = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          // No valid identifier was found, so we'll assume an empty pipe name ('').\n          nameId = '';\n\n          // However, there may have been whitespace present between the pipe character and the next\n          // token in the sequence (or the end of input). We want to track this whitespace so that\n          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n          // is assumed to be at the end of any whitespace beyond the pipe character.\n          //\n          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n          // beginning of the next token, or until the end of input if the next token is EOF.\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n\n          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n          // beyond the pipe character.\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n\n        const args: AST[] = [];\n        while (this.consumeOptionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n\n          // If there are additional expressions beyond the name, then the artificial end for the\n          // name is no longer relevant.\n        }\n        result = new BindingPipe(\n            this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.consumeOptionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseNullishCoalescing(): AST {\n    // '??'\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter(chars.$LBRACKET) ?\n              this.parseKeyedReadOrWrite(result, start, true) :\n              this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(\n          new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n\n        // Properties with quoted keys can't use the shorthand syntax.\n        if (quoted) {\n          this.expectCharacter(chars.$COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter(chars.$COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(new PropertyRead(\n              span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n        }\n      } while (this.consumeOptionalCharacter(chars.$COMMA) &&\n               !this.next.isCharacter(chars.$RBRACE));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n\n  parseAccessMember(readReceiver: AST, start: number, isSafe: boolean): AST {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n    let receiver: AST;\n\n    if (isSafe) {\n      if (this.consumeOptionalAssignment()) {\n        this.error('The \\'?.\\' operator cannot be used in the assignment');\n        receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        receiver = new SafePropertyRead(\n            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    } else {\n      if (this.consumeOptionalAssignment()) {\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n\n        const value = this.parseConditional();\n        receiver = new PropertyWrite(\n            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n      } else {\n        receiver =\n            new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    }\n\n    return receiver;\n  }\n\n  parseCall(receiver: AST, start: number, isSafe: boolean): AST {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter(chars.$RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) :\n                    new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n\n  private consumeOptionalAssignment(): boolean {\n    // When parsing assignment events (originating from two-way-binding aka banana-in-a-box syntax),\n    // it is valid for the primary expression to be terminated by the non-null operator. This\n    // primary expression is substituted as LHS of the assignment operator to achieve\n    // two-way-binding, such that the LHS could be the non-null operator. The grammar doesn't\n    // naturally allow for this syntax, so assignment events are parsed specially.\n    if ((this.parseFlags & ParseFlags.AssignmentEvent) && this.next.isOperator('!') &&\n        this.peek(1).isOperator('=')) {\n      // First skip over the ! operator.\n      this.advance();\n      // Then skip over the = operator, to fully consume the optional assignment operator.\n      this.advance();\n      return true;\n    }\n\n    return this.consumeOptionalOperator('=');\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * Parses an identifier, a keyword, a string with an optional `-` in between,\n   * and returns the string along with its absolute source span.\n   */\n  expectTemplateBindingKey(): TemplateBindingIdentifier {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length),\n    };\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n   * ```\n   * contains five bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   * 4. i -> NgForOfContext.index\n   * 5. ngForTrackBy -> func\n   *\n   * For a full description of the microsyntax grammar, see\n   * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n   *\n   * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n   * without the *, along with its absolute span.\n   */\n  parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n\n    // The first binding is for the template key itself\n    // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n    // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n\n    while (this.index < this.tokens.length) {\n      // If it starts with 'let', then this must be variable declaration\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        // Two possible cases here, either `value \"as\" key` or\n        // \"directive-keyword expression\". We don't know which case, but both\n        // \"value\" and \"directive-keyword\" are template binding key, so consume\n        // the key first.\n        const key = this.expectTemplateBindingKey();\n        // Peek at the next token, if it is \"as\" then this must be variable\n        // declaration.\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          // Otherwise the key must be a directive keyword, like \"of\". Transform\n          // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n          key.source =\n              templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n\n    return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n  }\n\n  parseKeyedReadOrWrite(receiver: AST, start: number, isSafe: boolean): AST {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      if (this.consumeOptionalOperator('=')) {\n        if (isSafe) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n        } else {\n          const value = this.parseConditional();\n          return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\n        }\n      } else {\n        return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\n                        new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    });\n  }\n\n  /**\n   * Parse a directive keyword, followed by a mandatory expression.\n   * For example, \"of items\", \"trackBy: func\".\n   * The bindings are: ngForOf -> items, ngForTrackBy -> func\n   * There could be an optional \"as\" binding that follows the expression.\n   * For example,\n   * ```\n   *   *ngFor=\"let item of items | slice:0:1 as collection\".\n   *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n   *               keyword    bound target   optional 'as' binding\n   * ```\n   *\n   * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n   * absolute span.\n   */\n  private parseDirectiveKeywordBindings(key: TemplateBindingIdentifier): TemplateBinding[] {\n    const bindings: TemplateBinding[] = [];\n    this.consumeOptionalCharacter(chars.$COLON);  // trackBy: trackByFunction\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    // The binding could optionally be followed by \"as\". For example,\n    // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n    // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n    // 'key' in the current context now becomes the \"value\" in the next binding.\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n\n  /**\n   * Return the expression AST for the bound target of a directive keyword\n   * binding. For example,\n   * ```\n   *   *ngIf=\"condition | pipe\"\n   *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n   *   *ngFor=\"let item of items\"\n   *                       ^^^^^ bound target for \"ngForOf\"\n   * ```\n   */\n  private getDirectiveBoundTarget(): ASTWithSource|null {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();  // example: \"condition | async\"\n    const {start, end} = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n  }\n\n  /**\n   * Return the binding for a variable declared using `as`. Note that the order\n   * of the key-value pair in this declaration is reversed. For example,\n   * ```\n   *   *ngFor=\"let item of items; index as i\"\n   *                              ^^^^^    ^\n   *                              value    key\n   * ```\n   *\n   * @param value name of the value in the declaration, \"ngIf\" in the example\n   * above, along with its absolute span.\n   */\n  private parseAsBinding(value: TemplateBindingIdentifier): TemplateBinding|null {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();  // consume the 'as' keyword\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Return the binding for a variable declared using `let`. For example,\n   * ```\n   *   *ngFor=\"let item of items; let i=index;\"\n   *           ^^^^^^^^           ^^^^^^^^^^^\n   * ```\n   * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n   * In the second binding, `i` is bound to `NgForOfContext.index`.\n   */\n  private parseLetBinding(): TemplateBinding|null {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();  // consume the 'let' keyword\n    const key = this.expectTemplateBindingKey();\n    let value: TemplateBindingIdentifier|null = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Consume the optional statement terminator: semicolon or comma.\n   */\n  private consumeStatementTerminator() {\n    this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n  }\n\n  /**\n   * Records an error and skips over the token stream until reaching a recoverable point. See\n   * `this.skip` for more details on token skipping.\n   */\n  error(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  /**\n   * Records an error for an unexpected private identifier being discovered.\n   * @param token Token representing a private identifier.\n   * @param extraMessage Optional additional message being appended to the error.\n   */\n  private _reportErrorForPrivateIdentifier(token: Token, extraMessage: string|null) {\n    let errorMessage =\n        `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n\n  /**\n   * Error recovery should skip tokens until it encounters a recovery point.\n   *\n   * The following are treated as unconditional recovery points:\n   *   - end of input\n   *   - ';' (parseChain() is always the root production, and it expects a ';')\n   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n   *\n   * The following are conditional recovery points:\n   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n   *       an '(' <expr> ')' production).\n   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n   *       none of the calling productions are not expecting the closing token else we will never\n   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n   *       That is, we skip a closing symbol if we are not in a grouping production.\n   *   - '=' in a `Writable` context\n   *     - In this context, we are able to recover after seeing the `=` operator, which\n   *       signals the presence of an independent rvalue expression following the `=` operator.\n   *\n   * If a production expects one of these token it increments the corresponding nesting count,\n   * and then decrements it just prior to checking if the token is in the input.\n   */\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n           (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n      if (this.next.isError()) {\n        this.errors.push(\n            new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors: string[] = [];\n\n  override visitPipe() {\n    this.errors.push('pipes');\n  }\n}\n/**\n * Computes the real offset in the original template for indexes in an interpolation.\n *\n * Because templates can have encoded HTML entities and the input passed to the parser at this stage\n * of the compiler is the _decoded_ value, we need to compute the real offset using the original\n * encoded values in the interpolated tokens. Note that this is only a special case handling for\n * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to\n * have parts which exactly match the input string for parsing the interpolation.\n *\n * @param interpolatedTokens The tokens for the interpolated value.\n *\n * @returns A map of index locations in the decoded template to indexes in the original template\n */\nfunction getIndexMapForOriginalTemplate(interpolatedTokens: InterpolatedAttributeToken[]|\n                                        InterpolatedTextToken[]): Map<number, number> {\n  let offsetMap = new Map<number, number>();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === MlParserTokenType.ENCODED_ENTITY) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from './tokens';\n\ninterface BaseNode {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport type Node = Attribute|Comment|Element|Expansion|ExpansionCase|Text;\n\nexport abstract class NodeWithI18n implements BaseNode {\n  constructor(public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  abstract visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text extends NodeWithI18n {\n  constructor(\n      public value: string, sourceSpan: ParseSourceSpan, public tokens: InterpolatedTextToken[],\n      i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion extends NodeWithI18n {\n  constructor(\n      public switchValue: string, public type: string, public cases: ExpansionCase[],\n      sourceSpan: ParseSourceSpan, public switchValueSourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements BaseNode {\n  constructor(\n      public value: string, public expression: Node[], public sourceSpan: ParseSourceSpan,\n      public valueSourceSpan: ParseSourceSpan, public expSourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute extends NodeWithI18n {\n  constructor(\n      public name: string, public value: string, sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined,\n      public valueTokens: InterpolatedAttributeToken[]|undefined, i18n: I18nMeta|undefined) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element extends NodeWithI18n {\n  constructor(\n      public name: string, public attrs: Attribute[], public children: Node[],\n      sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null = null, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements BaseNode {\n  constructor(public value: string|null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit ?\n      (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context) :\n      (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport class RecursiveVisitor implements Visitor {\n  constructor() {}\n\n  visitElement(ast: Element, context: any): any {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.children);\n    });\n  }\n\n  visitAttribute(ast: Attribute, context: any): any {}\n  visitText(ast: Text, context: any): any {}\n  visitComment(ast: Comment, context: any): any {}\n\n  visitExpansion(ast: Expansion, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n\n  visitExpansionCase(ast: ExpansionCase, context: any): any {}\n\n  private visitChildren<T extends Node>(\n      context: any, cb: (visit: (<V extends Node>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends Node>(children: T[]|undefined) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SchemaMetadata, SecurityContext} from '../core';\n\nexport abstract class ElementSchemaRegistry {\n  abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;\n  abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;\n  abstract securityContext(elementName: string, propName: string, isAttribute: boolean):\n      SecurityContext;\n  abstract allKnownElementNames(): string[];\n  abstract getMappedPropName(propName: string): string;\n  abstract getDefaultComponentElementName(): string;\n  abstract validateProperty(name: string): {error: boolean, msg?: string};\n  abstract validateAttribute(name: string): {error: boolean, msg?: string};\n  abstract normalizeAnimationStyleProperty(propName: string): string;\n  abstract normalizeAnimationStyleValue(\n      camelCaseProp: string, userProvidedProp: string,\n      val: string|number): {error: string, value: string};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata, SecurityContext} from '../core';\nimport {isNgContainer, isNgContent} from '../ml_parser/tags';\nimport {dashCaseToCamelCase} from '../util';\n\nimport {SECURITY_SCHEMA} from './dom_security_schema';\nimport {ElementSchemaRegistry} from './element_schema_registry';\n\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\n\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\n\nconst SCHEMA: string[] = [\n  '[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' +\n      /* added manually to avoid breaking changes */\n      ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n  '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n  'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n  'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume',\n  ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex',\n  ':svg:graphics^:svg:|',\n  ':svg:animation^:svg:|*begin,*end,*repeat',\n  ':svg:geometry^:svg:|',\n  ':svg:componentTransferFunction^:svg:|',\n  ':svg:gradient^:svg:|',\n  ':svg:textContent^:svg:graphics|',\n  ':svg:textPositioning^:svg:textContent|',\n  'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username',\n  'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username',\n  'audio^media|',\n  'br^[HTMLElement]|clear',\n  'base^[HTMLElement]|href,target',\n  'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n  'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n  'canvas^[HTMLElement]|#height,#width',\n  'content^[HTMLElement]|select',\n  'dl^[HTMLElement]|!compact',\n  'data^[HTMLElement]|value',\n  'datalist^[HTMLElement]|',\n  'details^[HTMLElement]|!open',\n  'dialog^[HTMLElement]|!open,returnValue',\n  'dir^[HTMLElement]|!compact',\n  'div^[HTMLElement]|align',\n  'embed^[HTMLElement]|align,height,name,src,type,width',\n  'fieldset^[HTMLElement]|!disabled,name',\n  'font^[HTMLElement]|color,face,size',\n  'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n  'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n  'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n  'hr^[HTMLElement]|align,color,!noShade,size,width',\n  'head^[HTMLElement]|',\n  'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n  'html^[HTMLElement]|version',\n  'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n  'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n  'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n  'li^[HTMLElement]|type,#value',\n  'label^[HTMLElement]|htmlFor',\n  'legend^[HTMLElement]|align',\n  'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n  'map^[HTMLElement]|name',\n  'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n  'menu^[HTMLElement]|!compact',\n  'meta^[HTMLElement]|content,httpEquiv,media,name,scheme',\n  'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n  'ins,del^[HTMLElement]|cite,dateTime',\n  'ol^[HTMLElement]|!compact,!reversed,#start,type',\n  'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n  'optgroup^[HTMLElement]|!disabled,label',\n  'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n  'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n  'p^[HTMLElement]|align',\n  'param^[HTMLElement]|name,type,value,valueType',\n  'picture^[HTMLElement]|',\n  'pre^[HTMLElement]|#width',\n  'progress^[HTMLElement]|#max,#value',\n  'q,blockquote,cite^[HTMLElement]|',\n  'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type',\n  'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n  'slot^[HTMLElement]|name',\n  'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width',\n  'span^[HTMLElement]|',\n  'style^[HTMLElement]|!disabled,media,type',\n  'caption^[HTMLElement]|align',\n  'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n  'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n  'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n  'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n  'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n  'template^[HTMLElement]|',\n  'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n  'time^[HTMLElement]|dateTime',\n  'title^[HTMLElement]|text',\n  'track^[HTMLElement]|!default,kind,label,src,srclang',\n  'ul^[HTMLElement]|!compact,type',\n  'unknown^[HTMLElement]|',\n  'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width',\n  ':svg:a^:svg:graphics|',\n  ':svg:animate^:svg:animation|',\n  ':svg:animateMotion^:svg:animation|',\n  ':svg:animateTransform^:svg:animation|',\n  ':svg:circle^:svg:geometry|',\n  ':svg:clipPath^:svg:graphics|',\n  ':svg:defs^:svg:graphics|',\n  ':svg:desc^:svg:|',\n  ':svg:discard^:svg:|',\n  ':svg:ellipse^:svg:geometry|',\n  ':svg:feBlend^:svg:|',\n  ':svg:feColorMatrix^:svg:|',\n  ':svg:feComponentTransfer^:svg:|',\n  ':svg:feComposite^:svg:|',\n  ':svg:feConvolveMatrix^:svg:|',\n  ':svg:feDiffuseLighting^:svg:|',\n  ':svg:feDisplacementMap^:svg:|',\n  ':svg:feDistantLight^:svg:|',\n  ':svg:feDropShadow^:svg:|',\n  ':svg:feFlood^:svg:|',\n  ':svg:feFuncA^:svg:componentTransferFunction|',\n  ':svg:feFuncB^:svg:componentTransferFunction|',\n  ':svg:feFuncG^:svg:componentTransferFunction|',\n  ':svg:feFuncR^:svg:componentTransferFunction|',\n  ':svg:feGaussianBlur^:svg:|',\n  ':svg:feImage^:svg:|',\n  ':svg:feMerge^:svg:|',\n  ':svg:feMergeNode^:svg:|',\n  ':svg:feMorphology^:svg:|',\n  ':svg:feOffset^:svg:|',\n  ':svg:fePointLight^:svg:|',\n  ':svg:feSpecularLighting^:svg:|',\n  ':svg:feSpotLight^:svg:|',\n  ':svg:feTile^:svg:|',\n  ':svg:feTurbulence^:svg:|',\n  ':svg:filter^:svg:|',\n  ':svg:foreignObject^:svg:graphics|',\n  ':svg:g^:svg:graphics|',\n  ':svg:image^:svg:graphics|decoding',\n  ':svg:line^:svg:geometry|',\n  ':svg:linearGradient^:svg:gradient|',\n  ':svg:mpath^:svg:|',\n  ':svg:marker^:svg:|',\n  ':svg:mask^:svg:|',\n  ':svg:metadata^:svg:|',\n  ':svg:path^:svg:geometry|',\n  ':svg:pattern^:svg:|',\n  ':svg:polygon^:svg:geometry|',\n  ':svg:polyline^:svg:geometry|',\n  ':svg:radialGradient^:svg:gradient|',\n  ':svg:rect^:svg:geometry|',\n  ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n  ':svg:script^:svg:|type',\n  ':svg:set^:svg:animation|',\n  ':svg:stop^:svg:|',\n  ':svg:style^:svg:|!disabled,media,title,type',\n  ':svg:switch^:svg:graphics|',\n  ':svg:symbol^:svg:|',\n  ':svg:tspan^:svg:textPositioning|',\n  ':svg:text^:svg:textPositioning|',\n  ':svg:textPath^:svg:textContent|',\n  ':svg:title^:svg:|',\n  ':svg:use^:svg:graphics|',\n  ':svg:view^:svg:|#zoomAndPan',\n  'data^[HTMLElement]|value',\n  'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n  'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n  'summary^[HTMLElement]|',\n  'time^[HTMLElement]|dateTime',\n  ':svg:cursor^:svg:|',\n];\n\nconst _ATTR_TO_PROP = new Map(Object.entries({\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n}));\n\n// Invert _ATTR_TO_PROP.\nconst _PROP_TO_ATTR =\n    Array.from(_ATTR_TO_PROP).reduce((inverted, [propertyName, attributeName]) => {\n      inverted.set(propertyName, attributeName);\n      return inverted;\n    }, new Map<string, string>());\n\nexport class DomElementSchemaRegistry extends ElementSchemaRegistry {\n  private _schema = new Map<string, Map<string, string>>();\n  // We don't allow binding to events for security reasons. Allowing event bindings would almost\n  // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.\n  private _eventSchema = new Map<string, Set<string>>;\n\n  constructor() {\n    super();\n    SCHEMA.forEach(encodedType => {\n      const type = new Map<string, string>();\n      const events: Set<string> = new Set();\n      const [strType, strProperties] = encodedType.split('|');\n      const properties = strProperties.split(',');\n      const [typeNames, superName] = strType.split('^');\n      typeNames.split(',').forEach(tag => {\n        this._schema.set(tag.toLowerCase(), type);\n        this._eventSchema.set(tag.toLowerCase(), events);\n      });\n      const superType = superName && this._schema.get(superName.toLowerCase());\n      if (superType) {\n        for (const [prop, value] of superType) {\n          type.set(prop, value);\n        }\n        for (const superEvent of this._eventSchema.get(superName.toLowerCase())!) {\n          events.add(superEvent);\n        }\n      }\n      properties.forEach((property: string) => {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              events.add(property.substring(1));\n              break;\n            case '!':\n              type.set(property.substring(1), BOOLEAN);\n              break;\n            case '#':\n              type.set(property.substring(1), NUMBER);\n              break;\n            case '%':\n              type.set(property.substring(1), OBJECT);\n              break;\n            default:\n              type.set(property, STRING);\n          }\n        }\n      });\n    });\n  }\n\n  override hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean {\n    if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return false;\n      }\n\n      if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        // Can't tell now as we don't know which properties a custom element will get\n        // once it is instantiated\n        return true;\n      }\n    }\n\n    const elementProperties =\n        this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown')!;\n    return elementProperties.has(propName);\n  }\n\n  override hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean {\n    if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return true;\n      }\n\n      if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        // Allow any custom elements\n        return true;\n      }\n    }\n\n    return this._schema.has(tagName.toLowerCase());\n  }\n\n  /**\n   * securityContext returns the security context for the given property on the given DOM tag.\n   *\n   * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n   * possible to bind a value into a changing attribute or tag name.\n   *\n   * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n   * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n   * string values. Only specific well known attack vectors are assigned their appropriate context.\n   */\n  override securityContext(tagName: string, propName: string, isAttribute: boolean):\n      SecurityContext {\n    if (isAttribute) {\n      // NB: For security purposes, use the mapped property name, not the attribute name.\n      propName = this.getMappedPropName(propName);\n    }\n\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\n    // property names do not have a security impact.\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n    if (ctx) {\n      return ctx;\n    }\n    ctx = SECURITY_SCHEMA()['*|' + propName];\n    return ctx ? ctx : SecurityContext.NONE;\n  }\n\n  override getMappedPropName(propName: string): string {\n    return _ATTR_TO_PROP.get(propName) ?? propName;\n  }\n\n  override getDefaultComponentElementName(): string {\n    return 'ng-component';\n  }\n\n  override validateProperty(name: string): {error: boolean, msg?: string} {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n          `please use (${name.slice(2)})=...` +\n          `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n          ` current module.`;\n      return {error: true, msg: msg};\n    } else {\n      return {error: false};\n    }\n  }\n\n  override validateAttribute(name: string): {error: boolean, msg?: string} {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n          `please use (${name.slice(2)})=...`;\n      return {error: true, msg: msg};\n    } else {\n      return {error: false};\n    }\n  }\n\n  override allKnownElementNames(): string[] {\n    return Array.from(this._schema.keys());\n  }\n\n  allKnownAttributesOfElement(tagName: string): string[] {\n    const elementProperties =\n        this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown')!;\n    // Convert properties to attributes.\n    return Array.from(elementProperties.keys()).map(prop => _PROP_TO_ATTR.get(prop) ?? prop);\n  }\n\n  allKnownEventsOfElement(tagName: string): string[] {\n    return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n  }\n\n  override normalizeAnimationStyleProperty(propName: string): string {\n    return dashCaseToCamelCase(propName);\n  }\n\n  override normalizeAnimationStyleValue(\n      camelCaseProp: string, userProvidedProp: string,\n      val: string|number): {error: string, value: string} {\n    let unit: string = '';\n    const strVal = val.toString().trim();\n    let errorMsg: string = null!;\n\n    if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n      if (typeof val === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n        }\n      }\n    }\n    return {error: errorMsg, value: strVal + unit};\n  }\n}\n\nfunction _isPixelDimensionStyle(prop: string): boolean {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DomElementSchemaRegistry} from '../schema/dom_element_schema_registry';\n\nimport {getNsPrefix, TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n  private contentType: TagContentType|\n      {default: TagContentType, [namespace: string]: TagContentType};\n\n  closedByParent = false;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false,\n    canSelfClose = false,\n  }: {\n    closedByChildren?: string[],\n    closedByParent?: boolean,\n    implicitNamespacePrefix?: string,\n    contentType?: TagContentType|{default: TagContentType, [namespace: string]: TagContentType},\n    isVoid?: boolean,\n    ignoreFirstLf?: boolean,\n    preventNamespaceInheritance?: boolean,\n    canSelfClose?: boolean\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n    this.canSelfClose = canSelfClose ?? isVoid;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n\n  getContentType(prefix?: string): TagContentType {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\n\nlet DEFAULT_TAG_DEFINITION!: HtmlTagDefinition;\n\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS!: {[key: string]: HtmlTagDefinition};\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  if (!TAG_DEFINITIONS) {\n    DEFAULT_TAG_DEFINITION = new HtmlTagDefinition({canSelfClose: true});\n    TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({isVoid: true}),\n      'meta': new HtmlTagDefinition({isVoid: true}),\n      'area': new HtmlTagDefinition({isVoid: true}),\n      'embed': new HtmlTagDefinition({isVoid: true}),\n      'link': new HtmlTagDefinition({isVoid: true}),\n      'img': new HtmlTagDefinition({isVoid: true}),\n      'input': new HtmlTagDefinition({isVoid: true}),\n      'param': new HtmlTagDefinition({isVoid: true}),\n      'hr': new HtmlTagDefinition({isVoid: true}),\n      'br': new HtmlTagDefinition({isVoid: true}),\n      'source': new HtmlTagDefinition({isVoid: true}),\n      'track': new HtmlTagDefinition({isVoid: true}),\n      'wbr': new HtmlTagDefinition({isVoid: true}),\n      'p': new HtmlTagDefinition({\n        closedByChildren: [\n          'address', 'article', 'aside',   'blockquote', 'div',  'dl',  'fieldset',\n          'footer',  'form',    'h1',      'h2',         'h3',   'h4',  'h5',\n          'h6',      'header',  'hgroup',  'hr',         'main', 'nav', 'ol',\n          'p',       'pre',     'section', 'table',      'ul'\n        ],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n      'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n      'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n      'tr': new HtmlTagDefinition({closedByChildren: ['tr'], closedByParent: true}),\n      'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'col': new HtmlTagDefinition({isVoid: true}),\n      'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n      'foreignObject': new HtmlTagDefinition({\n        // Usually the implicit namespace here would be redundant since it will be inherited from\n        // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n        // works is that the parent node of an end tag is its own start tag which means that\n        // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n        // implicit namespace which is `html`, unless specified otherwise.\n        implicitNamespacePrefix: 'svg',\n        // We want to prevent children of foreignObject from inheriting its namespace, because\n        // the point of the element is to allow nodes from other namespaces to be inserted.\n        preventNamespaceInheritance: true,\n      }),\n      'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n      'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n      'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n      'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n      'rb': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rt': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n      'rp': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n      'option':\n          new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n      'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'title': new HtmlTagDefinition({\n        // The browser supports two separate `title` tags which have to use\n        // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n        contentType: {default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA}\n      }),\n      'textarea': new HtmlTagDefinition(\n          {contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n    };\n\n    new DomElementSchemaRegistry().allKnownElementNames().forEach(knownTagName => {\n      if (!TAG_DEFINITIONS.hasOwnProperty(knownTagName) && getNsPrefix(knownTagName) === null) {\n        TAG_DEFINITIONS[knownTagName] = new HtmlTagDefinition({canSelfClose: false});\n      }\n    });\n  }\n  // We have to make both a case-sensitive and a case-insensitive lookup, because\n  // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n  return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ??\n      DEFAULT_TAG_DEFINITION;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nexport const NAMED_ENTITIES: Record<string, string> = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCCE',\n  'yucy': '\\u044E',\n  'yuml': '\\u00FF',\n  'zacute': '\\u017A',\n  'zcaron': '\\u017E',\n  'zcy': '\\u0437',\n  'zdot': '\\u017C',\n  'zeta': '\\u03B6',\n  'zfr': '\\uD835\\uDD37',\n  'zhcy': '\\u0436',\n  'zigrarr': '\\u21DD',\n  'zopf': '\\uD835\\uDD6B',\n  'zscr': '\\uD835\\uDCCF',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C'\n};\n\n\n// The &ngsp; pseudo-entity is denoting a space.\n// 0xE500 is a PUA (Private Use Areas) unicode character\n// This is inspired by the Angular Dart implementation.\nexport const NGSP_UNICODE = '\\uE500';\n\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {NAMED_ENTITIES} from './entities';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation_config';\nimport {TagContentType, TagDefinition} from './tags';\nimport {IncompleteTagOpenToken, TagOpenStartToken, Token, TokenType} from './tokens';\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType|null, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(\n      public tokens: Token[], public errors: TokenError[],\n      public nonNormalizedIcuExpressions: Token[]) {}\n}\n\nexport interface LexerRange {\n  startPos: number;\n  startLine: number;\n  startCol: number;\n  endPos: number;\n}\n\n/**\n * Options that modify how the text is tokenized.\n */\nexport interface TokenizeOptions {\n  /** Whether to tokenize ICU messages (considered as text nodes when false). */\n  tokenizeExpansionForms?: boolean;\n  /** How to tokenize interpolation markers. */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n  /**\n   * If true, do not convert CRLF to LF.\n   */\n  preserveLineEndings?: boolean;\n}\n\nexport function tokenize(\n    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,\n    options: TokenizeOptions = {}): TokenizeResult {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(\n      mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nfunction _unparsableEntityErrorMsg(type: CharacterReferenceType, entityStr: string): string {\n  return `Unable to parse entity \"${entityStr}\" - ${\n      type} character reference entities must end with \";\"`;\n}\n\nenum CharacterReferenceType {\n  HEX = 'hexadecimal',\n  DEC = 'decimal',\n}\n\nclass _ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n  private _cursor: CharacterCursor;\n  private _tokenizeIcu: boolean;\n  private _interpolationConfig: InterpolationConfig;\n  private _leadingTriviaCodePoints: number[]|undefined;\n  private _currentTokenStart: CharacterCursor|null = null;\n  private _currentTokenType: TokenType|null = null;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation: boolean = false;\n  private readonly _preserveLineEndings: boolean;\n  private readonly _escapedString: boolean;\n  private readonly _i18nNormalizeLineEndingsInICUs: boolean;\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n  nonNormalizedIcuExpressions: Token[] = [];\n\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  constructor(\n      _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,\n      options: TokenizeOptions) {\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints =\n        options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range =\n        options.range || {endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0};\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n                                           new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._escapedString = options.escapedString || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  private _processCarriageReturns(content: string): string {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): void {\n    while (this._cursor.peek() !== chars.$EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n          // the premature end of an interpolation is given by the start of a new HTML element.\n          this._consumeWithInterpolation(\n              TokenType.TEXT, TokenType.INTERPOLATION, () => this._isTextEnd(),\n              () => this._isTagStart());\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._cursor.peek() === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _beginToken(type: TokenType, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end?: CharacterCursor): Token {\n    if (this._currentTokenStart === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token when there was no start to the token',\n          this._currentTokenType, this._cursor.getSpan(end));\n    }\n    if (this._currentTokenType === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token which has no token type', null,\n          this._cursor.getSpan(this._currentTokenStart));\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan:\n          (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),\n    } as Token;\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): _ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return new _ControlFlowError(error);\n  }\n\n  private handleError(e: any) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof _ControlFlowError) {\n      this.errors.push(e.error);\n    } else {\n      throw e;\n    }\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n\n  private _readChar(): string {\n    // Don't rely upon reading directly from `_input` as the actual char value\n    // may have been generated from an escape sequence.\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n\n  private _consumeEntity(textTokenType: TokenType): void {\n    this._beginToken(TokenType.ENCODED_ENTITY);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // Advance cursor to include the peeked character in the string provided to the error\n        // message.\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(\n            _unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)),\n            this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(\n            _unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // No semicolon was found so abort the encoded entity token that was in progress, and treat\n        // this as a text token\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n\n  private _consumeRawText(consumeEntities: boolean, endMarkerPredicate: () => boolean): void {\n    this._beginToken(consumeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n    const parts: string[] = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(TokenType.ESCAPABLE_RAW_TEXT);\n        this._beginToken(TokenType.ESCAPABLE_RAW_TEXT);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _consumeComment(start: CharacterCursor) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(TokenType.COMMENT_END);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: CharacterCursor) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(TokenType.CDATA_END);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: CharacterCursor) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar(chars.$GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix: string = '';\n    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart: CharacterCursor;\n    if (this._cursor.peek() === chars.$COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: CharacterCursor) {\n    let tagName: string;\n    let prefix: string;\n    let openTagToken: TagOpenStartToken|IncompleteTagOpenToken|undefined;\n    try {\n      if (!chars.isAsciiLetter(this._cursor.peek())) {\n        throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n\n      openTagToken = this._consumeTagOpenStart(start);\n      prefix = openTagToken.parts[0];\n      tagName = openTagToken.parts[1];\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&\n             this._cursor.peek() !== chars.$LT && this._cursor.peek() !== chars.$EOF) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof _ControlFlowError) {\n        if (openTagToken) {\n          // We errored before we could close the opening tag, so it is incomplete.\n          openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\n        } else {\n          // When the start tag is invalid, assume we want a \"<\" as text.\n          // Back to back text tokens are merged at the end.\n          this._beginToken(TokenType.TEXT, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(prefix: string, tagName: string, consumeEntities: boolean) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode(chars.$LT)) return false;\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE);\n    this._requireCharCodeUntilFn(code => code === chars.$GT, 3);\n    this._cursor.advance();  // Consume the `>`\n    this._endToken([prefix, tagName]);\n  }\n\n  private _consumeTagOpenStart(start: CharacterCursor): TagOpenStartToken {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    return this._endToken(parts) as TagOpenStartToken;\n  }\n\n  private _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    let value: string;\n    if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      // In an attribute then end of the attribute value and the premature end to an interpolation\n      // are both triggered by the `quoteChar`.\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(\n          TokenType.ATTR_VALUE_TEXT, TokenType.ATTR_VALUE_INTERPOLATION, endPredicate,\n          endPredicate);\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(\n          TokenType.ATTR_VALUE_TEXT, TokenType.ATTR_VALUE_INTERPOLATION, endPredicate,\n          endPredicate);\n    }\n  }\n\n  private _consumeQuote(quoteChar: number) {\n    this._beginToken(TokenType.ATTR_QUOTE);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType =\n        this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: CharacterCursor) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const condition = this._readUntil(chars.$COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      // We explicitly want to normalize line endings for this text.\n      this._endToken([normalizedCondition]);\n    } else {\n      // We are not normalizing line endings.\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  /**\n   * Consume a string that may contain interpolation expressions.\n   *\n   * The first token consumed will be of `tokenType` and then there will be alternating\n   * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n   *\n   * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n   *\n   * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n   * @param interpolationTokenType the kind of tokens that contain interpolation.\n   * @param endPredicate a function that should return true when we should stop consuming.\n   * @param endInterpolation a function that should return true if there is a premature end to an\n   *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n   */\n  private _consumeWithInterpolation(\n      textTokenType: TokenType, interpolationTokenType: TokenType, endPredicate: () => boolean,\n      endInterpolation: () => boolean) {\n    this._beginToken(textTokenType);\n    const parts: string[] = [];\n\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n\n    // It is possible that an interpolation was started but not ended inside this text token.\n    // Make sure that we reset the state of the lexer correctly.\n    this._inInterpolation = false;\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  /**\n   * Consume a block of text that has been interpreted as an Angular interpolation.\n   *\n   * @param interpolationTokenType the type of the interpolation token to generate.\n   * @param interpolationStart a cursor that points to the start of this interpolation.\n   * @param prematureEndPredicate a function that should return true if the next characters indicate\n   *     an end to the interpolation before its normal closing marker.\n   */\n  private _consumeInterpolation(\n      interpolationTokenType: TokenType, interpolationStart: CharacterCursor,\n      prematureEndPredicate: (() => boolean)|null): void {\n    const parts: string[] = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(this._interpolationConfig.start);\n\n    // Find the end of the interpolation, ignoring content inside quotes.\n    const expressionStart = this._cursor.clone();\n    let inQuote: number|null = null;\n    let inComment = false;\n    while (this._cursor.peek() !== chars.$EOF &&\n           (prematureEndPredicate === null || !prematureEndPredicate())) {\n      const current = this._cursor.clone();\n\n      if (this._isTagStart()) {\n        // We are starting what looks like an HTML element in the middle of this interpolation.\n        // Reset the cursor to before the `<` character and end the interpolation token.\n        // (This is actually wrong but here for backward compatibility).\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n\n      if (inQuote === null) {\n        if (this._attemptStr(this._interpolationConfig.end)) {\n          // We are not in a string, and we hit the end interpolation marker\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(this._interpolationConfig.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          // Once we are in a comment we ignore any quotes\n          inComment = true;\n        }\n      }\n\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === chars.$BACKSLASH) {\n        // Skip the next character because it was escaped.\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        // Exiting the current quoted string\n        inQuote = null;\n      } else if (!inComment && inQuote === null && chars.isQuote(char)) {\n        // Entering a new quoted string\n        inQuote = char;\n      }\n    }\n\n    // We hit EOF without finding a closing interpolation marker\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n\n  private _getProcessedChars(start: CharacterCursor, end: CharacterCursor): string {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._isTagStart() || this._cursor.peek() === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the current cursor is pointing to the start of a tag\n   * (opening/closing/comments/cdata/etc).\n   */\n  private _isTagStart(): boolean {\n    if (this._cursor.peek() === chars.$LT) {\n      // We assume that `<` followed by whitespace is not the start of an HTML element.\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      // If the next character is alphabetic, ! nor / then it is a tag start\n      const code = tmp.peek();\n      if ((chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n          code === chars.$SLASH || code === chars.$BANG) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n\n  private _isInExpansionCase(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START;\n  }\n\n  private _isInExpansionForm(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START;\n  }\n\n  private isExpansionFormStart(): boolean {\n    if (this._cursor.peek() !== chars.$LBRACE) {\n      return false;\n    }\n    if (this._interpolationConfig) {\n      const start = this._cursor.clone();\n      const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n      this._cursor = start;\n      return !isInterpolation;\n    }\n    return true;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$LT ||\n      code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ ||\n      code === chars.$EOF;\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n      (code < chars.$0 || code > chars.$9);\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek !== chars.$RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token|undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if ((lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) ||\n        (lastDstToken && lastDstToken.type === TokenType.ATTR_VALUE_TEXT &&\n         token.type === TokenType.ATTR_VALUE_TEXT)) {\n      lastDstToken.parts[0]! += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\n\n/**\n * The _Tokenizer uses objects of this type to move through the input text,\n * extracting \"parsed characters\". These could be more than one actual character\n * if the text contains escape sequences.\n */\ninterface CharacterCursor {\n  /** Initialize the cursor. */\n  init(): void;\n  /** The parsed character at the current cursor position. */\n  peek(): number;\n  /** Advance the cursor by one parsed character. */\n  advance(): void;\n  /** Get a span from the marked start point to the current point. */\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan;\n  /** Get the parsed characters from the marked start point to the current point. */\n  getChars(start: this): string;\n  /** The number of characters left before the end of the cursor. */\n  charsLeft(): number;\n  /** The number of characters between `this` cursor and `other` cursor. */\n  diff(other: this): number;\n  /** Make a copy of this cursor */\n  clone(): CharacterCursor;\n}\n\ninterface CursorState {\n  peek: number;\n  offset: number;\n  line: number;\n  column: number;\n}\n\nclass PlainCharacterCursor implements CharacterCursor {\n  protected state: CursorState;\n  protected file: ParseSourceFile;\n  protected input: string;\n  protected end: number;\n\n  constructor(fileOrCursor: PlainCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|PlainCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n\n      const state = fileOrCursor.state;\n      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column,\n      };\n    } else {\n      if (!range) {\n        throw new Error(\n            'Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol,\n      };\n    }\n  }\n\n  clone(): PlainCharacterCursor {\n    return new PlainCharacterCursor(this);\n  }\n\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other: this) {\n    return this.state.offset - other.state.offset;\n  }\n\n  advance(): void {\n    this.advanceState(this.state);\n  }\n\n  init(): void {\n    this.updatePeek(this.state);\n  }\n\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone() as this;\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation =\n        fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n\n  getChars(start: this): string {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n\n  charAt(pos: number): number {\n    return this.input.charCodeAt(pos);\n  }\n\n  protected advanceState(state: CursorState) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === chars.$LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!chars.isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n\n  protected updatePeek(state: CursorState): void {\n    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n  }\n\n  private locationFromCursor(cursor: this): ParseLocation {\n    return new ParseLocation(\n        cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n  }\n}\n\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  protected internalState: CursorState;\n\n  constructor(fileOrCursor: EscapedCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|EscapedCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {...fileOrCursor.internalState};\n    } else {\n      super(fileOrCursor, range!);\n      this.internalState = this.state;\n    }\n  }\n\n  override advance(): void {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n\n  override init(): void {\n    super.init();\n    this.processEscapeSequence();\n  }\n\n  override clone(): EscapedCharacterCursor {\n    return new EscapedCharacterCursor(this);\n  }\n\n  override getChars(start: this): string {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n\n  /**\n   * Process the escape sequence that starts at the current position in the text.\n   *\n   * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n   */\n  protected processEscapeSequence(): void {\n    const peek = () => this.internalState.peek;\n\n    if (peek() === chars.$BACKSLASH) {\n      // We have hit an escape sequence so we need the internal state to become independent\n      // of the external state.\n      this.internalState = {...this.state};\n\n      // Move past the backslash\n      this.advanceState(this.internalState);\n\n      // First check for standard control char sequences\n      if (peek() === chars.$n) {\n        this.state.peek = chars.$LF;\n      } else if (peek() === chars.$r) {\n        this.state.peek = chars.$CR;\n      } else if (peek() === chars.$v) {\n        this.state.peek = chars.$VTAB;\n      } else if (peek() === chars.$t) {\n        this.state.peek = chars.$TAB;\n      } else if (peek() === chars.$b) {\n        this.state.peek = chars.$BSPACE;\n      } else if (peek() === chars.$f) {\n        this.state.peek = chars.$FF;\n      }\n\n      // Now consider more complex sequences\n      else if (peek() === chars.$u) {\n        // Unicode code-point sequence\n        this.advanceState(this.internalState);  // advance past the `u` char\n        if (peek() === chars.$LBRACE) {\n          // Variable length Unicode, e.g. `\\x{123}`\n          this.advanceState(this.internalState);  // advance past the `{` char\n          // Advance past the variable number of hex digits until we hit a `}` char\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== chars.$RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          // Fixed length Unicode, e.g. `\\u1234`\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      }\n\n      else if (peek() === chars.$x) {\n        // Hex char code, e.g. `\\x2F`\n        this.advanceState(this.internalState);  // advance past the `x` char\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      }\n\n      else if (chars.isOctalDigit(peek())) {\n        // Octal char code, e.g. `\\012`,\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (chars.isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        // Backup one char\n        this.internalState = previous.internalState;\n      }\n\n      else if (chars.isNewLine(this.internalState.peek)) {\n        // Line continuation `\\` followed by a new line\n        this.advanceState(this.internalState);  // advance over the newline\n        this.state = this.internalState;\n      }\n\n      else {\n        // If none of the `if` blocks were executed then we just have an escaped normal character.\n        // In that case we just, effectively, skip the backslash from the character.\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n\n  protected decodeHexDigits(start: EscapedCharacterCursor, length: number): number {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\n\nexport class CursorError {\n  constructor(public msg: string, public cursor: CharacterCursor) {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseLocation, ParseSourceSpan} from '../parse_util';\n\nimport * as html from './ast';\nimport {NAMED_ENTITIES} from './entities';\nimport {tokenize, TokenizeOptions} from './lexer';\nimport {getNsPrefix, mergeNsAndName, splitNsName, TagDefinition} from './tags';\nimport {AttributeNameToken, AttributeQuoteToken, CdataStartToken, CommentStartToken, ExpansionCaseExpressionEndToken, ExpansionCaseExpressionStartToken, ExpansionCaseValueToken, ExpansionFormStartToken, IncompleteTagOpenToken, InterpolatedAttributeToken, InterpolatedTextToken, TagCloseToken, TagOpenStartToken, TextToken, Token, TokenType} from './tokens';\n\nexport class TreeError extends ParseError {\n  static create(elementName: string|null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(public elementName: string|null, span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(public rootNodes: html.Node[], public errors: ParseError[]) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(\n        parser.rootNodes,\n        (tokenizeResult.errors as ParseError[]).concat(parser.errors),\n    );\n  }\n}\n\nclass _TreeBuilder {\n  private _index: number = -1;\n  // `_peek` will be initialized by the call to `_advance()` in the constructor.\n  private _peek!: Token;\n  private _elementStack: html.Element[] = [];\n\n  rootNodes: html.Node[] = [];\n  errors: TreeError[] = [];\n\n  constructor(\n      private tokens: Token[], private getTagDefinition: (tagName: string) => TagDefinition) {\n    this._advance();\n  }\n\n  build(): void {\n    while (this._peek.type !== TokenType.EOF) {\n      if (this._peek.type === TokenType.TAG_OPEN_START ||\n          this._peek.type === TokenType.INCOMPLETE_TAG_OPEN) {\n        this._consumeStartTag(this._advance<TagOpenStartToken|IncompleteTagOpenToken>());\n      } else if (this._peek.type === TokenType.TAG_CLOSE) {\n        this._consumeEndTag(this._advance<TagCloseToken>());\n      } else if (this._peek.type === TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance<CdataStartToken>());\n      } else if (this._peek.type === TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance<CommentStartToken>());\n      } else if (\n          this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT ||\n          this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\n        this._closeVoidElement();\n        this._consumeText(this._advance<TextToken>());\n      } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance<ExpansionFormStartToken>());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n  }\n\n  private _advance<T extends Token>(): T {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev as T;\n  }\n\n  private _advanceIf<T extends TokenType>(type: T): (Token&{type: T})|null {\n    if (this._peek.type === type) {\n      return this._advance<Token&{type: T}>();\n    }\n    return null;\n  }\n\n  private _consumeCdata(_startToken: CdataStartToken) {\n    this._consumeText(this._advance<TextToken>());\n    this._advanceIf(TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: CommentStartToken) {\n    const text = this._advanceIf(TokenType.RAW_TEXT);\n    this._advanceIf(TokenType.COMMENT_END);\n    const value = text != null ? text.parts[0].trim() : null;\n    this._addToParent(new html.Comment(value, token.sourceSpan));\n  }\n\n  private _consumeExpansion(token: ExpansionFormStartToken) {\n    const switchValue = this._advance<TextToken>();\n\n    const type = this._advance<TextToken>();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return;  // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n      this.errors.push(\n          TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(\n        token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new html.Expansion(\n        switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase|null {\n    const value = this._advance<ExpansionCaseValueToken>();\n\n    // read {\n    if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n      this.errors.push(\n          TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n\n    // read until }\n    const start = this._advance<ExpansionCaseExpressionStartToken>();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n\n    const end = this._advance<ExpansionCaseExpressionEndToken>();\n    exp.push({type: TokenType.EOF, parts: [], sourceSpan: end.sourceSpan});\n\n    // parse everything in between { and }\n    const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n\n    const sourceSpan =\n        new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n    const expSourceSpan =\n        new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n    return new html.ExpansionCase(\n        value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n\n  private _collectExpansionExpTokens(start: Token): Token[]|null {\n    const exp: Token[] = [];\n    const expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (this._peek.type === TokenType.EXPANSION_FORM_START ||\n          this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n\n        } else {\n          this.errors.push(\n              TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(\n              TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EOF) {\n        this.errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: InterpolatedTextToken) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getParentElement();\n      if (parent != null && parent.children.length === 0 &&\n          this.getTagDefinition(parent.name).ignoreFirstLf) {\n        text = text.substring(1);\n        tokens[0] = {type: token.type, sourceSpan: token.sourceSpan, parts: [text]} as typeof token;\n      }\n    }\n\n    while (this._peek.type === TokenType.INTERPOLATION || this._peek.type === TokenType.TEXT ||\n           this._peek.type === TokenType.ENCODED_ENTITY) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === TokenType.INTERPOLATION) {\n        // For backward compatibility we decode HTML entities that appear in interpolation\n        // expressions. This is arguably a bug, but it could be a considerable breaking change to\n        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n        // chain after View Engine has been removed.\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === TokenType.ENCODED_ENTITY) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(new html.Text(\n          text,\n          new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details),\n          tokens));\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getParentElement();\n    if (el && this.getTagDefinition(el.name).isVoid) {\n      this._elementStack.pop();\n    }\n  }\n\n  private _consumeStartTag(startTagToken: TagOpenStartToken|IncompleteTagOpenToken) {\n    const [prefix, name] = startTagToken.parts;\n    const attrs: html.Attribute[] = [];\n    while (this._peek.type === TokenType.ATTR_NAME) {\n      attrs.push(this._consumeAttr(this._advance<AttributeNameToken>()));\n    }\n    const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      const tagDef = this.getTagDefinition(fullName);\n      if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n        this.errors.push(TreeError.create(\n            fullName, startTagToken.sourceSpan,\n            `Only void, custom and foreign elements can be self closed \"${\n                startTagToken.parts[1]}\"`));\n      }\n    } else if (this._peek.type === TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n        startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(\n        startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const el = new html.Element(fullName, attrs, [], span, startSpan, undefined);\n    this._pushElement(el);\n    if (selfClosing) {\n      // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n      // element start tag also represents the end tag.\n      this._popElement(fullName, span);\n    } else if (startTagToken.type === TokenType.INCOMPLETE_TAG_OPEN) {\n      // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n      // close tag. Let's optimistically parse it as a full element and emit an error.\n      this._popElement(fullName, null);\n      this.errors.push(\n          TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n\n  private _pushElement(el: html.Element) {\n    const parentEl = this._getParentElement();\n\n    if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n      this._elementStack.pop();\n    }\n\n    this._addToParent(el);\n    this._elementStack.push(el);\n  }\n\n  private _consumeEndTag(endTagToken: TagCloseToken) {\n    const fullName = this._getElementFullName(\n        endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n    if (this.getTagDefinition(fullName).isVoid) {\n      this.errors.push(TreeError.create(\n          fullName, endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n    } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${\n          fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  /**\n   * Closes the nearest element with the tag name `fullName` in the parse tree.\n   * `endSourceSpan` is the span of the closing tag, or null if the element does\n   * not have a closing tag (for example, this happens when an incomplete\n   * opening tag is recovered).\n   */\n  private _popElement(fullName: string, endSourceSpan: ParseSourceSpan|null): boolean {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const el = this._elementStack[stackIndex];\n      if (el.name === fullName) {\n        // Record the parse span with the element that is being closed. Any elements that are\n        // removed from the element stack at this point are closed implicitly, so they won't get\n        // an end source span (as there is no explicit closing element).\n        el.endSourceSpan = endSourceSpan;\n        el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n\n        this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n\n      if (!this.getTagDefinition(el.name).closedByParent) {\n        // Note that we encountered an unexpected close tag but continue processing the element\n        // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n        // end tag in the stack.\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: AttributeNameToken): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      this._advance();\n    }\n\n    // Consume the attribute value\n    let value = '';\n    const valueTokens: InterpolatedAttributeToken[] = [];\n    let valueStartSpan: ParseSourceSpan|undefined = undefined;\n    let valueEnd: ParseLocation|undefined = undefined;\n    // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n    // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n    // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n    // able to see that `_advance()` will actually mutate `_peek`.\n    const nextTokenType = this._peek.type as TokenType;\n    if (nextTokenType === TokenType.ATTR_VALUE_TEXT) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (this._peek.type === TokenType.ATTR_VALUE_TEXT ||\n             this._peek.type === TokenType.ATTR_VALUE_INTERPOLATION ||\n             this._peek.type === TokenType.ENCODED_ENTITY) {\n        const valueToken = this._advance<InterpolatedAttributeToken>();\n        valueTokens.push(valueToken);\n        if (valueToken.type === TokenType.ATTR_VALUE_INTERPOLATION) {\n          // For backward compatibility we decode HTML entities that appear in interpolation\n          // expressions. This is arguably a bug, but it could be a considerable breaking change to\n          // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n          // chain after View Engine has been removed.\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === TokenType.ENCODED_ENTITY) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      const quoteToken = this._advance<AttributeQuoteToken>();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n\n    const valueSpan = valueStartSpan && valueEnd &&\n        new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new html.Attribute(\n        fullName, value,\n        new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart),\n        attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined,\n        undefined);\n  }\n\n  private _getParentElement(): html.Element|null {\n    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getParentElement();\n    if (parent != null) {\n      parent.children.push(node);\n    } else {\n      this.rootNodes.push(node);\n    }\n  }\n\n  private _getElementFullName(prefix: string, localName: string, parentElement: html.Element|null):\n      string {\n    if (prefix === '') {\n      prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n      if (prefix === '' && parentElement != null) {\n        const parentTagName = splitNsName(parentElement.name)[1];\n        const parentTagDefinition = this.getTagDefinition(parentTagName);\n        if (!parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentElement.name);\n        }\n      }\n    }\n\n    return mergeNsAndName(prefix, localName);\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match: string, entity: string): string {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './html_tags';\nimport {TokenizeOptions} from './lexer';\nimport {Parser, ParseTreeResult} from './parser';\n\nexport class HtmlParser extends Parser {\n  constructor() {\n    super(getHtmlTagDefinition);\n  }\n\n  override parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    return super.parse(source, url, options);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from './ast';\nimport {NGSP_UNICODE} from './entities';\nimport {ParseTreeResult} from './parser';\nimport {TextToken, TokenType} from './tokens';\n\nexport const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\n\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\n\nfunction hasPreserveWhitespacesAttr(attrs: html.Attribute[]): boolean {\n  return attrs.some((attr: html.Attribute) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n\n/**\n * &ngsp; is a placeholder for non-removable space\n * &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space.\n */\nexport function replaceNgsp(value: string): string {\n  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nexport class WhitespaceVisitor implements html.Visitor {\n  visitElement(element: html.Element, context: any): any {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      // don't descent into elements where we need to preserve whitespaces\n      // but still visit all attributes to eliminate one used as a market to preserve WS\n      return new html.Element(\n          element.name, html.visitAll(this, element.attrs), element.children, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n\n    return new html.Element(\n        element.name, element.attrs, visitAllWithSiblings(this, element.children),\n        element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n\n  visitText(text: html.Text, context: SiblingVisitorContext|null): any {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling = context &&\n        (context.prev instanceof html.Expansion || context.next instanceof html.Expansion);\n\n    if (isNotBlank || hasExpansionSibling) {\n      // Process the whitespace in the tokens of this Text node\n      const tokens = text.tokens.map(\n          token =>\n              token.type === TokenType.TEXT ? createWhitespaceProcessedTextToken(token) : token);\n      // Process the whitespace of the value of this Text node\n      const value = processWhitespace(text.value);\n      return new html.Text(value, text.sourceSpan, tokens, text.i18n);\n    }\n\n    return null;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return comment;\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    return expansion;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return expansionCase;\n  }\n}\n\nfunction createWhitespaceProcessedTextToken({type, parts, sourceSpan}: TextToken): TextToken {\n  return {type, parts: [processWhitespace(parts[0])], sourceSpan};\n}\n\nfunction processWhitespace(text: string): string {\n  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\n\nexport function removeWhitespaces(htmlAstWithErrors: ParseTreeResult): ParseTreeResult {\n  return new ParseTreeResult(\n      html.visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes),\n      htmlAstWithErrors.errors);\n}\n\ninterface SiblingVisitorContext {\n  prev: html.Node|undefined;\n  next: html.Node|undefined;\n}\n\nfunction visitAllWithSiblings(visitor: WhitespaceVisitor, nodes: html.Node[]): any[] {\n  const result: any[] = [];\n\n  nodes.forEach((ast, i) => {\n    const context: SiblingVisitorContext = {prev: nodes[i - 1], next: nodes[i + 1]};\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output_ast';\n\nexport type MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\n\nexport type MapLiteral = MapEntry[];\n\nexport function mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport function mapLiteral(\n    obj: {[key: string]: o.Expression}, quoted: boolean = false): o.Expression {\n  return o.literalMap(Object.keys(obj).map(key => ({\n                                             key,\n                                             quoted,\n                                             value: obj[key],\n                                           })));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\n * tags use '*'.\n *\n * Extracted from, and should be kept in sync with\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\n */\nconst TRUSTED_TYPES_SINKS = new Set<string>([\n  // NOTE: All strings in this set *must* be lowercase!\n\n  // TrustedHTML\n  'iframe|srcdoc',\n  '*|innerhtml',\n  '*|outerhtml',\n\n  // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n\n  // TrustedScriptURL\n  'embed|src',\n  'object|codebase',\n  'object|data',\n]);\n\n/**\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\n * Trusted Type is required for values passed to the sink:\n * - SecurityContext.HTML corresponds to TrustedHTML\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\n */\nexport function isTrustedTypesSink(tagName: string, propName: string): boolean {\n  // Make sure comparisons are case insensitive, so that case differences between attribute and\n  // property names do not have a security impact.\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n\n  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||\n      TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AbsoluteSourceSpan, ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding, VariableBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseLocation, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\nexport interface HostProperties {\n  [key: string]: string;\n}\n\nexport interface HostListeners {\n  [key: string]: string;\n}\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, public errors: ParseError[]) {}\n\n  get interpolationConfig(): InterpolationConfig {\n    return this._interpolationConfig;\n  }\n\n  createBoundHostProperties(properties: HostProperties, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    const boundProps: ParsedProperty[] = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(\n            propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n            // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n            // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n            // source of the host binding (which doesn't exist in the template). Regardless,\n            // neither of these values are used in Ivy but are only here to satisfy the function\n            // signature. This should likely be refactored in the future so that `sourceSpan`\n            // isn't being used inaccurately.\n            boundProps, sourceSpan);\n      } else {\n        this._reportError(\n            `Value of the host property binding \"${\n                propName}\" needs to be a string representing an expression but got \"${\n                expression}\" (${typeof expression})`,\n            sourceSpan);\n      }\n    }\n    return boundProps;\n  }\n\n  createDirectiveHostEventAsts(hostListeners: HostListeners, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    const targetEvents: ParsedEvent[] = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n        // rather than the source of the host binding (which doesn't exist in the template).\n        // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n        // function signature. This should likely be refactored in the future so that `sourceSpan`\n        // isn't being used inaccurately.\n        this.parseEvent(\n            propName, expression, /* isAssignmentEvent */ false, sourceSpan, sourceSpan, [],\n            targetEvents, sourceSpan);\n      } else {\n        this._reportError(\n            `Value of the host listener \"${\n                propName}\" needs to be a string representing an expression but got \"${\n                expression}\" (${typeof expression})`,\n            sourceSpan);\n      }\n    }\n    return targetEvents;\n  }\n\n  parseInterpolation(\n      value: string, sourceSpan: ParseSourceSpan,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|\n      null): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n    const absoluteOffset = sourceSpan.fullStart.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolation(\n          value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig)!;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n    const absoluteOffset = sourceSpan.start.offset;\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, and converts them to\n   * `ParsedProperty` or `ParsedVariable`.\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   * @param targetMatchableAttrs potential attributes to match in the template\n   * @param targetProps target property bindings in the template\n   * @param targetVars target variables in the template\n   */\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteValueOffset: number,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], targetVars: ParsedVariable[],\n      isIvyAst: boolean) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n    const bindings = this._parseTemplateBindings(\n        tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n\n    for (const binding of bindings) {\n      // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n      // binding within the microsyntax expression so it's more narrow than sourceSpan.\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan =\n            binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(\n            key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([key, '' /* value */]);\n        // Since this is a literal attribute with no RHS, source span should be\n        // just the key span.\n        this.parseLiteralAttr(\n            key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */,\n            targetMatchableAttrs, targetProps, keySpan);\n      }\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, e.g.\n   * ```\n   *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n   * ```\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteKeyOffset start of the `tplKey`\n   * @param absoluteValueOffset start of the `tplValue`\n   */\n  private _parseTemplateBindings(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(\n          tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.warnings.forEach((warning) => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[], keySpan: ParseSourceSpan) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(\n          name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n          ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], keySpan: ParseSourceSpan) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan,\n            new AbsoluteSourceSpan(\n                keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n      }\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(\n          name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n          sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[], keySpan: ParseSourceSpan,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null): boolean {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(\n          name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n        new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      keySpan: ParseSourceSpan, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(\n        expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(new ParsedProperty(\n        name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n\n  private _parseBinding(\n      value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n          this._exprParser.parseBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  createBoundElementProperty(\n      elementSelector: string, boundProp: ParsedProperty, skipValidation: boolean = false,\n      mapPropertyName: boolean = true): BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined!;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined!;\n\n    // Check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n  }\n\n  // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n  parseEvent(\n      name: string, expression: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan,\n      handlerSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: ParsedEvent[],\n      keySpan: ParseSourceSpan) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n\n    if (isAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      this._parseAnimationEvent(\n          name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);\n    } else {\n      this._parseRegularEvent(\n          name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs,\n          targetEvents, keySpan);\n    }\n  }\n\n  calcPossibleSecurityContexts(selector: string, propName: string, isAttribute: boolean):\n      SecurityContext[] {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan,\n      handlerSpan: ParseSourceSpan, targetEvents: ParsedEvent[], keySpan: ParseSourceSpan) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n    targetEvents.push(new ParsedEvent(\n        eventName, phase, ParsedEventType.Animation, ast, sourceSpan, handlerSpan, keySpan));\n\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(\n            `The provided animation output phase value \"${phase}\" for \"@${\n                eventName}\" is not supported (use start or done)`,\n            sourceSpan);\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${\n              eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan,\n      handlerSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: ParsedEvent[],\n      keySpan: ParseSourceSpan) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null!, name]);\n    const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n    targetMatchableAttrs.push([name!, ast.source!]);\n    targetEvents.push(new ParsedEvent(\n        eventName, target, ParsedEventType.Regular, ast, sourceSpan, handlerSpan, keySpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n    const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n\n    try {\n      const ast = this._exprParser.parseAction(\n          value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg!, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  override visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(\n    sourceSpan: ParseSourceSpan, absoluteSpan: AbsoluteSourceSpan): ParseSourceSpan {\n  // The difference of two absolute offsets provide the relative offset\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(\n      sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff),\n      sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\n\nexport function isStyleUrlResolvable(url: string|null): url is string {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {isNgContent} from '../ml_parser/tags';\n\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\n\nexport function preparseElement(ast: html.Element): PreparsedElement {\n  let selectAttr: string|null = null;\n  let hrefAttr: string|null = null;\n  let relAttr: string|null = null;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach(attr => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  const nodeName = ast.name.toLowerCase();\n  let type = PreparsedElementType.OTHER;\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\n\nexport enum PreparsedElementType {\n  NG_CONTENT,\n  STYLE,\n  STYLESHEET,\n  SCRIPT,\n  OTHER\n}\n\nexport class PreparsedElement {\n  constructor(\n      public type: PreparsedElementType, public selectAttr: string, public hrefAttr: string|null,\n      public nonBindable: boolean, public projectAs: string) {}\n}\n\n\nfunction normalizeNgContentSelect(selectAttr: string|null): string {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n  return selectAttr;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParsedEvent, ParsedProperty, ParsedVariable} from '../expression_parser/ast';\nimport * as i18n from '../i18n/i18n_ast';\nimport * as html from '../ml_parser/ast';\nimport {replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {isNgTemplate} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {BindingParser} from '../template_parser/binding_parser';\nimport {PreparsedElementType, preparseElement} from '../template_parser/template_preparser';\n\nimport * as t from './r3_ast';\nimport {I18N_ICU_VAR_PREFIX, isI18nRootNode} from './view/i18n/util';\n\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n\nconst BINDING_DELIMS = {\n  BANANA_BOX: {start: '[(', end: ')]'},\n  PROPERTY: {start: '[', end: ']'},\n  EVENT: {start: '(', end: ')'},\n};\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\n// Result of the html AST to Ivy AST transformation\nexport interface Render3ParseResult {\n  nodes: t.Node[];\n  errors: ParseError[];\n  styles: string[];\n  styleUrls: string[];\n  ngContentSelectors: string[];\n  // Will be defined if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes?: t.Comment[];\n}\n\ninterface Render3ParseOptions {\n  collectCommentNodes: boolean;\n}\n\nexport function htmlAstToRender3Ast(\n    htmlNodes: html.Node[], bindingParser: BindingParser,\n    options: Render3ParseOptions): Render3ParseResult {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = html.visitAll(transformer, htmlNodes);\n\n  // Errors might originate in either the binding parser or the html to ivy transformer\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n\n  const result: Render3ParseResult = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\n\nclass HtmlAstToIvyAst implements html.Visitor {\n  errors: ParseError[] = [];\n  styles: string[] = [];\n  styleUrls: string[] = [];\n  ngContentSelectors: string[] = [];\n  // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes: t.Comment[] = [];\n  private inI18nBlock: boolean = false;\n\n  constructor(private bindingParser: BindingParser, private options: Render3ParseOptions) {}\n\n  // HTML visitor\n  visitElement(element: html.Element): t.Node|null {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError(\n            'Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.',\n            element.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (\n        preparsedElement.type === PreparsedElementType.STYLESHEET &&\n        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n\n    // Whether the element is a `<ng-template>`\n    const isTemplateElement = isNgTemplate(element.name);\n\n    const parsedProperties: ParsedProperty[] = [];\n    const boundEvents: t.BoundEvent[] = [];\n    const variables: t.Variable[] = [];\n    const references: t.Reference[] = [];\n    const attributes: t.TextAttribute[] = [];\n    const i18nAttrsMeta: {[key: string]: i18n.I18nMeta} = {};\n\n    const templateParsedProperties: ParsedProperty[] = [];\n    const templateVariables: t.Variable[] = [];\n\n    // Whether the element has any *-attribute\n    let elementHasInlineTemplate = false;\n\n    for (const attribute of element.attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n\n      // `*attr` defines template bindings\n      let isTemplateBinding = false;\n\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        // *-attributes\n        if (elementHasInlineTemplate) {\n          this.reportError(\n              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n              attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n\n        const parsedVariables: ParsedVariable[] = [];\n        const absoluteValueOffset = attribute.valueSpan ?\n            attribute.valueSpan.start.offset :\n            // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.start.offset + attribute.name.length;\n\n        this.bindingParser.parseInlineTemplateBinding(\n            templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [],\n            templateParsedProperties, parsedVariables, true /* isIvyAst */);\n        templateVariables.push(...parsedVariables.map(\n            v => new t.Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n      } else {\n        // Check for variables, events, property bindings, interpolation\n        hasBinding = this.parseAttribute(\n            isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n      }\n\n      if (!hasBinding && !isTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n\n    const children: t.Node[] =\n        html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n\n    let parsedElement: t.Content|t.Template|t.Element|undefined;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      // `<ng-content>`\n      if (element.children &&\n          !element.children.every(\n              (node: html.Node) => isEmptyTextNode(node) || isCommentNode(node))) {\n        this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n      }\n      const selector = preparsedElement.selectAttr;\n      const attrs: t.TextAttribute[] = element.attrs.map(attr => this.visitAttribute(attr));\n      parsedElement = new t.Content(selector, attrs, element.sourceSpan, element.i18n);\n\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      // `<ng-template>`\n      const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n      parsedElement = new t.Template(\n          element.name, attributes, attrs.bound, boundEvents, [/* no template attributes */],\n          children, references, variables, element.sourceSpan, element.startSourceSpan,\n          element.endSourceSpan, element.i18n);\n    } else {\n      const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      parsedElement = new t.Element(\n          element.name, attributes, attrs.bound, boundEvents, children, references,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n\n    if (elementHasInlineTemplate) {\n      // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n      // node that contains this node.\n      // Moreover, if the node is an element, then we need to hoist its attributes to the template\n      // node for matching against content projection selectors.\n      const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n      const templateAttrs: (t.TextAttribute|t.BoundAttribute)[] = [];\n      attrs.literal.forEach(attr => templateAttrs.push(attr));\n      attrs.bound.forEach(attr => templateAttrs.push(attr));\n      const hoistedAttrs = parsedElement instanceof t.Element ?\n          {\n            attributes: parsedElement.attributes,\n            inputs: parsedElement.inputs,\n            outputs: parsedElement.outputs,\n          } :\n          {attributes: [], inputs: [], outputs: []};\n\n      // For <ng-template>s with structural directives on them, avoid passing i18n information to\n      // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n      // necessary i18n meta information will be extracted from child elements.\n      const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n      const name = parsedElement instanceof t.Template ? null : parsedElement.name;\n\n      parsedElement = new t.Template(\n          name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs,\n          [parsedElement], [/* no references */], templateVariables, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan, i18n);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan,\n        attribute.valueSpan, attribute.i18n);\n  }\n\n  visitText(text: html.Text): t.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n  }\n\n  visitExpansion(expansion: html.Expansion): t.Icu|null {\n    if (!expansion.i18n) {\n      // do not generate Icu in case it was created\n      // outside of i18n block in a template\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${\n          expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n    }\n    const message = expansion.i18n;\n    const vars: {[name: string]: t.BoundText} = {};\n    const placeholders: {[name: string]: t.Text|t.BoundText} = {};\n    // extract VARs from ICUs - we process them separately while\n    // assembling resulting message via goog.getMsg function, since\n    // we need to pass them to top-level goog.getMsg call\n    Object.keys(message.placeholders).forEach(key => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n        // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n        // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n        // converted into `_` symbols while normalizing placeholder names, which might lead to\n        // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n        const formattedKey = key.trim();\n\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n\n        vars[formattedKey] = new t.BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n      }\n    });\n    return new t.Icu(vars, placeholders, expansion.sourceSpan, message);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): null {\n    return null;\n  }\n\n  visitComment(comment: html.Comment): null {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new t.Comment(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n\n  // convert view engine `ParsedProperty` to a format suitable for IVY\n  private extractAttributes(\n      elementName: string, properties: ParsedProperty[],\n      i18nPropsMeta: {[key: string]: i18n.I18nMeta}):\n      {bound: t.BoundAttribute[], literal: t.TextAttribute[]} {\n    const bound: t.BoundAttribute[] = [];\n    const literal: t.TextAttribute[] = [];\n\n    properties.forEach(prop => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(new t.TextAttribute(\n            prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan,\n            i18n));\n      } else {\n        // Note that validation is skipped and property mapping is disabled\n        // due to the fact that we need to make sure a given prop is not an\n        // input of a directive and directive matching happens at runtime.\n        const bep = this.bindingParser.createBoundElementProperty(\n            elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n        bound.push(t.BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n\n    return {bound, literal};\n  }\n\n  private parseAttribute(\n      isTemplateElement: boolean, attribute: html.Attribute, matchableAttributes: string[][],\n      parsedProperties: ParsedProperty[], boundEvents: t.BoundEvent[], variables: t.Variable[],\n      references: t.Reference[]) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset =\n        attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n\n    function createKeySpan(srcSpan: ParseSourceSpan, prefix: string, identifier: string) {\n      // We need to adjust the start location for the keySpan to account for the removed 'data-'\n      // prefix from `normalizeAttributeName`.\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n\n    const bindParts = name.match(BIND_NAME_REGEXP);\n\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events: ParsedEvent[] = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(\n            identifier, value, /* isAssignmentEvent */ false, srcSpan,\n            attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(\n            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents,\n            keySpan);\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(\n            name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes,\n            parsedProperties, keySpan);\n      }\n      return true;\n    }\n\n    // We didn't see a kw-prefixed property binding, but we have not yet checked\n    // for the []/()/[()] syntax.\n    let delims: {start: string, end: string}|null = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (delims !== null &&\n        // NOTE: older versions of the parser would match a start/end delimited\n        // binding iff the property name was terminated by the ending delimiter\n        // and the identifier in the binding was non-empty.\n        // TODO(ayazhafiz): update this to handle malformed bindings.\n        name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(\n            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents,\n            keySpan);\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n      } else {\n        const events: ParsedEvent[] = [];\n        this.bindingParser.parseEvent(\n            identifier, value, /* isAssignmentEvent */ false, srcSpan,\n            attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      }\n\n      return true;\n    }\n\n    // No explicit binding found.\n    const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(\n        name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan,\n        attribute.valueTokens ?? null);\n    return hasBinding;\n  }\n\n  private _visitTextWithInterpolation(\n      value: string, sourceSpan: ParseSourceSpan,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null,\n      i18n?: i18n.I18nMeta): t.Text|t.BoundText {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n    return expr ? new t.BoundText(expr, sourceSpan, i18n) : new t.Text(valueNoNgsp, sourceSpan);\n  }\n\n  private parseVariable(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, variables: t.Variable[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n\n    variables.push(new t.Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseReference(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, references: t.Reference[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some(reference => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n\n    references.push(new t.Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseAssignmentEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      boundEvents: t.BoundEvent[], keySpan: ParseSourceSpan) {\n    const events: ParsedEvent[] = [];\n    this.bindingParser.parseEvent(\n        `${name}Change`, `${expression} =$event`, /* isAssignmentEvent */ true, sourceSpan,\n        valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n    addEvents(events, boundEvents);\n  }\n\n  private reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element): t.Element|null {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE ||\n        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const children: t.Node[] = html.visitAll(this, ast.children, null);\n    return new t.Element(\n        ast.name, html.visitAll(this, ast.attrs) as t.TextAttribute[],\n        /* inputs */[], /* outputs */[], children,Â  /* references */[], ast.sourceSpan,\n        ast.startSourceSpan, ast.endSourceSpan);\n  }\n\n  visitComment(comment: html.Comment): any {\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan,\n        attribute.valueSpan, attribute.i18n);\n  }\n\n  visitText(text: html.Text): t.Text {\n    return new t.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(expansion: html.Expansion): any {\n    return null;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return null;\n  }\n}\n\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction normalizeAttributeName(attrName: string): string {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events: ParsedEvent[], boundEvents: t.BoundEvent[]) {\n  boundEvents.push(...events.map(e => t.BoundEvent.fromParsedEvent(e)));\n}\n\nfunction isEmptyTextNode(node: html.Node): boolean {\n  return node instanceof html.Text && node.value.trim().length == 0;\n}\n\nfunction isCommentNode(node: html.Node): boolean {\n  return node instanceof html.Comment;\n}\n\nfunction textContents(node: html.Element): string|null {\n  if (node.children.length !== 1 || !(node.children[0] instanceof html.Text)) {\n    return null;\n  } else {\n    return (node.children[0] as html.Text).value;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST} from '../../../expression_parser/ast';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\n\nimport {assembleBoundTextPlaceholders, getSeqNumberGenerator, updatePlaceholderMap, wrapI18nPlaceholder} from './util';\n\nenum TagType {\n  ELEMENT,\n  TEMPLATE,\n}\n\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n  return {getUniqueId: getSeqNumberGenerator(), icus: new Map<string, any[]>()};\n}\n\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nesting level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nexport class I18nContext {\n  public readonly id: number;\n  public bindings = new Set<AST>();\n  public placeholders = new Map<string, any[]>();\n  public isEmitted: boolean = false;\n\n  private _registry!: any;\n  private _unresolvedCtxCount: number = 0;\n\n  constructor(\n      readonly index: number, readonly ref: o.ReadVarExpr, readonly level: number = 0,\n      readonly templateIndex: number|null = null, readonly meta: i18n.I18nMeta,\n      private registry?: any) {\n    this._registry = registry || setupRegistry();\n    this.id = this._registry.getUniqueId();\n  }\n\n  private appendTag(type: TagType, node: i18n.TagPlaceholder, index: number, closed?: boolean) {\n    if (node.isVoid && closed) {\n      return;  // ignore \"close\" for void tags\n    }\n    const ph = node.isVoid || !closed ? node.startName : node.closeName;\n    const content = {type, index, ctx: this.id, isVoid: node.isVoid, closed};\n    updatePlaceholderMap(this.placeholders, ph, content);\n  }\n\n  get icus() {\n    return this._registry.icus;\n  }\n  get isRoot() {\n    return this.level === 0;\n  }\n  get isResolved() {\n    return this._unresolvedCtxCount === 0;\n  }\n\n  getSerializedPlaceholders() {\n    const result = new Map<string, any[]>();\n    this.placeholders.forEach(\n        (values, key) => result.set(key, values.map(serializePlaceholderValue)));\n    return result;\n  }\n\n  // public API to accumulate i18n-related content\n  appendBinding(binding: AST) {\n    this.bindings.add(binding);\n  }\n  appendIcu(name: string, ref: o.Expression) {\n    updatePlaceholderMap(this._registry.icus, name, ref);\n  }\n  appendBoundText(node: i18n.I18nMeta) {\n    const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n    phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\n  }\n  appendTemplate(node: i18n.I18nMeta, index: number) {\n    // add open and close tags at the same time,\n    // since we process nested templates separately\n    this.appendTag(TagType.TEMPLATE, node as i18n.TagPlaceholder, index, false);\n    this.appendTag(TagType.TEMPLATE, node as i18n.TagPlaceholder, index, true);\n    this._unresolvedCtxCount++;\n  }\n  appendElement(node: i18n.I18nMeta, index: number, closed?: boolean) {\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, closed);\n  }\n  appendProjection(node: i18n.I18nMeta, index: number) {\n    // Add open and close tags at the same time, since `<ng-content>` has no content,\n    // so when we come across `<ng-content>` we can register both open and close tags.\n    // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n    // regular element tag placeholders, so we generate element placeholders for both types.\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, false);\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, true);\n  }\n\n  /**\n   * Generates an instance of a child context based on the root one,\n   * when we enter a nested template within I18n section.\n   *\n   * @param index Instruction index of corresponding i18nStart, which initiates this context\n   * @param templateIndex Instruction index of a template which this context belongs to\n   * @param meta Meta information (id, meaning, description, etc) associated with this context\n   *\n   * @returns I18nContext instance\n   */\n  forkChildContext(index: number, templateIndex: number, meta: i18n.I18nMeta) {\n    return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n  }\n\n  /**\n   * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n   *\n   * @param context Child I18nContext instance to be reconciled with parent context.\n   */\n  reconcileChildContext(context: I18nContext) {\n    // set the right context id for open and close\n    // template tags, so we can use it as sub-block ids\n    ['start', 'close'].forEach((op: string) => {\n      const key = (context.meta as any)[`${op}Name`];\n      const phs = this.placeholders.get(key) || [];\n      const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\n      if (tag) {\n        tag.ctx = context.id;\n      }\n    });\n\n    // reconcile placeholders\n    const childPhs = context.placeholders;\n    childPhs.forEach((values: any[], key: string) => {\n      const phs = this.placeholders.get(key);\n      if (!phs) {\n        this.placeholders.set(key, values);\n        return;\n      }\n      // try to find matching template...\n      const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n      if (tmplIdx >= 0) {\n        // ... if found - replace it with nested template content\n        const isCloseTag = key.startsWith('CLOSE');\n        const isTemplateTag = key.endsWith('NG-TEMPLATE');\n        if (isTemplateTag) {\n          // current template's content is placed before or after\n          // parent template tag, depending on the open/close attribute\n          phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\n        } else {\n          const idx = isCloseTag ? values.length - 1 : 0;\n          values[idx].tmpl = phs[tmplIdx];\n          phs.splice(tmplIdx, 1, ...values);\n        }\n      } else {\n        // ... otherwise just append content to placeholder value\n        phs.push(...values);\n      }\n      this.placeholders.set(key, phs);\n    });\n    this._unresolvedCtxCount--;\n  }\n}\n\n//\n// Helper methods\n//\n\nfunction wrap(symbol: string, index: number, contextId: number, closed?: boolean): string {\n  const state = closed ? '/' : '';\n  return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\n}\n\nfunction wrapTag(symbol: string, {index, ctx, isVoid}: any, closed?: boolean): string {\n  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n                  wrap(symbol, index, ctx, closed);\n}\n\nfunction findTemplateFn(ctx: number, templateIndex: number|null) {\n  return (token: any) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\n      token.index === templateIndex && token.ctx === ctx;\n}\n\nfunction serializePlaceholderValue(value: any): string {\n  const element = (data: any, closed?: boolean) => wrapTag('#', data, closed);\n  const template = (data: any, closed?: boolean) => wrapTag('*', data, closed);\n\n  switch (value.type) {\n    case TagType.ELEMENT:\n      // close element tag\n      if (value.closed) {\n        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n      }\n      // open element tag that also initiates a template\n      if (value.tmpl) {\n        return template(value.tmpl) + element(value) +\n            (value.isVoid ? template(value.tmpl, true) : '');\n      }\n      return element(value);\n\n    case TagType.TEMPLATE:\n      return template(value, value.closed);\n\n    default:\n      return value;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../../../i18n/i18n_ast';\n\nimport {formatI18nPlaceholderName} from './util';\n\nclass IcuSerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    return result;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    return ph.isVoid ?\n        this.formatPh(ph.startName) :\n        `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${\n            this.formatPh(ph.closeName)}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    return this.formatPh(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return this.formatPh(ph.name);\n  }\n\n  private formatPh(value: string): string {\n    return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\n  }\n}\n\nconst serializer = new IcuSerializerVisitor();\nexport function serializeIcuNode(icu: i18n.Icu): string {\n  return icu.visit(serializer);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST',\n};\n\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nexport class PlaceholderRegistry {\n  // Count the occurrence of the base name top generate a unique name\n  private _placeHolderNameCounts: {[k: string]: number} = {};\n  // Maps signature to placeholder names\n  private _signatureToName: {[k: string]: string} = {};\n\n  getStartTagPlaceholderName(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getCloseTagPlaceholderName(tag: string): string {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getPlaceholderName(name: string, content: string): string {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n\n    return uniqueName;\n  }\n\n  getUniquePlaceholder(name: string): string {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n\n  // Generate a hash for a tag - does not take attribute order into account\n  private _hashTag(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n\n    return start + strAttrs + end;\n  }\n\n  private _hashClosingTag(tag: string): string {\n    return this._hashTag(`/${tag}`, {}, false);\n  }\n\n  private _generateUniqueName(base: string): string {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Lexer as ExpressionLexer} from '../expression_parser/lexer';\nimport {Parser as ExpressionParser} from '../expression_parser/parser';\nimport * as html from '../ml_parser/ast';\nimport {getHtmlTagDefinition} from '../ml_parser/html_tags';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {InterpolatedAttributeToken, InterpolatedTextToken, TokenType} from '../ml_parser/tokens';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderRegistry} from './serializers/placeholder';\n\nconst _expParser = new ExpressionParser(new ExpressionLexer());\n\nexport type VisitNodeFn = (html: html.Node, i18n: i18n.Node) => i18n.Node;\n\nexport interface I18nMessageFactory {\n  (nodes: html.Node[], meaning: string|undefined, description: string|undefined,\n   customId: string|undefined, visitNodeFn?: VisitNodeFn): i18n.Message;\n}\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(interpolationConfig: InterpolationConfig):\n    I18nMessageFactory {\n  const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n  return (nodes, meaning, description, customId, visitNodeFn) =>\n             visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\n\ninterface I18nMessageVisitorContext {\n  isIcu: boolean;\n  icuDepth: number;\n  placeholderRegistry: PlaceholderRegistry;\n  placeholderToContent: {[phName: string]: i18n.MessagePlaceholder};\n  placeholderToMessage: {[phName: string]: i18n.Message};\n  visitNodeFn: VisitNodeFn;\n}\n\nfunction noopVisitNodeFn(_html: html.Node, i18n: i18n.Node): i18n.Node {\n  return i18n;\n}\n\nclass _I18nVisitor implements html.Visitor {\n  constructor(\n      private _expressionParser: ExpressionParser,\n      private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(\n      nodes: html.Node[], meaning = '', description = '', customId = '',\n      visitNodeFn: VisitNodeFn|undefined): i18n.Message {\n    const context: I18nMessageVisitorContext = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof html.Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn,\n    };\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, context);\n\n    return new i18n.Message(\n        i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description,\n        customId);\n  }\n\n  visitElement(el: html.Element, context: I18nMessageVisitorContext): i18n.Node {\n    const children = html.visitAll(this, el.children, context);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName =\n        context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    context.placeholderToContent[startPhName] = {\n      text: el.startSourceSpan.toString(),\n      sourceSpan: el.startSourceSpan,\n    };\n\n    let closePhName = '';\n\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      context.placeholderToContent[closePhName] = {\n        text: `</${el.name}>`,\n        sourceSpan: el.endSourceSpan ?? el.sourceSpan,\n      };\n    }\n\n    const node = new i18n.TagPlaceholder(\n        el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan,\n        el.startSourceSpan, el.endSourceSpan);\n    return context.visitNodeFn(el, node);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: I18nMessageVisitorContext): i18n.Node {\n    const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?\n        new i18n.Text(attribute.value, attribute.valueSpan || attribute.sourceSpan) :\n        this._visitTextWithInterpolation(\n            attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context,\n            attribute.i18n);\n    return context.visitNodeFn(attribute, node);\n  }\n\n  visitText(text: html.Text, context: I18nMessageVisitorContext): i18n.Node {\n    const node = text.tokens.length === 1 ?\n        new i18n.Text(text.value, text.sourceSpan) :\n        this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n\n  visitComment(comment: html.Comment, context: I18nMessageVisitorContext): i18n.Node|null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: I18nMessageVisitorContext): i18n.Node {\n    context.icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n          caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\n    });\n    context.icuDepth--;\n\n    if (context.isIcu || context.icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan,\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n\n  visitExpansionCase(_icuCase: html.ExpansionCase, _context: I18nMessageVisitorContext): i18n.Node {\n    throw new Error('Unreachable code');\n  }\n\n  /**\n   * Convert, text and interpolated tokens up into text and placeholder pieces.\n   *\n   * @param tokens The text and interpolated tokens.\n   * @param sourceSpan The span of the whole of the `text` string.\n   * @param context The current context of the visitor, used to compute and store placeholders.\n   * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n   */\n  private _visitTextWithInterpolation(\n      tokens: (InterpolatedTextToken|InterpolatedAttributeToken)[], sourceSpan: ParseSourceSpan,\n      context: I18nMessageVisitorContext, previousI18n: i18n.I18nMeta|undefined): i18n.Node {\n    // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n    const nodes: i18n.Node[] = [];\n    // We will only create a container if there are actually interpolations,\n    // so this flag tracks that.\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case TokenType.INTERPOLATION:\n        case TokenType.ATTR_VALUE_INTERPOLATION:\n          hasInterpolation = true;\n          const expression = token.parts[1];\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n          context.placeholderToContent[phName] = {\n            text: token.parts.join(''),\n            sourceSpan: token.sourceSpan\n          };\n          nodes.push(new i18n.Placeholder(expression, phName, token.sourceSpan));\n          break;\n        default:\n          if (token.parts[0].length > 0) {\n            // This token is text or an encoded entity.\n            // If it is following on from a previous text node then merge it into that node\n            // Otherwise, if it is following an interpolation, then add a new node.\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof i18n.Text) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(\n                  previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart,\n                  previous.sourceSpan.details);\n            } else {\n              nodes.push(new i18n.Text(token.parts[0], token.sourceSpan));\n            }\n          }\n          break;\n      }\n    }\n\n    if (hasInterpolation) {\n      // Whitespace removal may have invalidated the interpolation source-spans.\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new i18n.Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n}\n\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(nodes: i18n.Node[], previousI18n: i18n.I18nMeta|undefined): void {\n  if (previousI18n instanceof i18n.Message) {\n    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n    // metadata. The `Message` should consist only of a single `Container` that contains the\n    // parts (`Text` and `Placeholder`) to process.\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n\n  if (previousI18n instanceof i18n.Container) {\n    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n    // after whitespace has been removed from the AST nodes.\n    assertEquivalentNodes(previousI18n.children, nodes);\n\n    // Reuse the source-spans from the first pass.\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\n\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message: i18n.Message): void {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n    throw new Error(\n        'Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\n\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]): void {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error('The number of i18n message children changed between first and second pass.');\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error(\n        'The types of the i18n message children changed between first and second pass.');\n  }\n}\n\nconst _CUSTOM_PH_EXP =\n    /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\n/**\n * An i18n error.\n */\nexport class I18nError extends ParseError {\n  constructor(span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeDecimalDigest, computeDigest, decimalDigest} from '../../../i18n/digest';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {createI18nMessageFactory, I18nMessageFactory, VisitNodeFn} from '../../../i18n/i18n_parser';\nimport {I18nError} from '../../../i18n/parse_util';\nimport * as html from '../../../ml_parser/ast';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../../ml_parser/interpolation_config';\nimport {ParseTreeResult} from '../../../ml_parser/parser';\nimport * as o from '../../../output/output_ast';\nimport {isTrustedTypesSink} from '../../../schema/trusted_types_sinks';\n\nimport {hasI18nAttrs, I18N_ATTR, I18N_ATTR_PREFIX, icuFromI18nMessage} from './util';\n\nexport type I18nMeta = {\n  id?: string,\n  customId?: string,\n  legacyIds?: string[],\n  description?: string,\n  meaning?: string\n};\n\n\nconst setI18nRefs: VisitNodeFn = (htmlNode, i18nNode) => {\n  if (htmlNode instanceof html.NodeWithI18n) {\n    if (i18nNode instanceof i18n.IcuPlaceholder && htmlNode.i18n instanceof i18n.Message) {\n      // This html node represents an ICU but this is a second processing pass, and the legacy id\n      // was computed in the previous pass and stored in the `i18n` property as a message.\n      // We are about to wipe out that property so capture the previous message to be reused when\n      // generating the message for this ICU later. See `_generateI18nMessage()`.\n      i18nNode.previousMessage = htmlNode.i18n;\n    }\n    htmlNode.i18n = i18nNode;\n  }\n  return i18nNode;\n};\n\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nexport class I18nMetaVisitor implements html.Visitor {\n  // whether visited nodes contain i18n information\n  public hasI18nMeta: boolean = false;\n  private _errors: I18nError[] = [];\n\n  constructor(\n      private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n      private keepI18nAttrs = false, private enableI18nLegacyMessageIdFormat = false) {}\n\n  private _generateI18nMessage(\n      nodes: html.Node[], meta: string|i18n.I18nMeta = '',\n      visitNodeFn?: VisitNodeFn): i18n.Message {\n    const {meaning, description, customId} = this._parseMetadata(meta);\n    const createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n    const message = createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n\n  visitAllWithErrors(nodes: html.Node[]): ParseTreeResult {\n    const result = nodes.map(node => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n\n  visitElement(element: html.Element): any {\n    let message: i18n.Message|undefined = undefined;\n\n    if (hasI18nAttrs(element)) {\n      this.hasI18nMeta = true;\n      const attrs: html.Attribute[] = [];\n      const attrsMeta: {[key: string]: string} = {};\n\n      for (const attr of element.attrs) {\n        if (attr.name === I18N_ATTR) {\n          // root 'i18n' node attribute\n          const i18n = element.i18n || attr.value;\n          message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\n          if (message.nodes.length === 0) {\n            // Ignore the message if it is empty.\n            message = undefined;\n          }\n          // Store the message on the element\n          element.i18n = message;\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          // 'i18n-*' attributes\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          if (isTrustedTypesSink(element.name, name)) {\n            this._reportError(\n                attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          // non-i18n attributes\n          attrs.push(attr);\n        }\n      }\n\n      // set i18n meta for attributes\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          // do not create translation for empty attributes\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n\n      if (!this.keepI18nAttrs) {\n        // update element's attributes,\n        // keeping only non-i18n related ones\n        element.attrs = attrs;\n      }\n    }\n    html.visitAll(this, element.children, message);\n    return element;\n  }\n\n  visitExpansion(expansion: html.Expansion, currentMessage: i18n.Message|null): any {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof i18n.IcuPlaceholder) {\n      // set ICU placeholder name (e.g. \"ICU_1\"),\n      // generated while processing root element contents,\n      // so we can reference it when we output translation\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n      if (currentMessage !== null) {\n        // Also update the placeholderToMessage map with this new message\n        currentMessage.placeholderToMessage[name] = message;\n      }\n    } else {\n      // ICU is a top level message, try to use metadata from container element if provided via\n      // `context` argument. Note: context may not be available for standalone ICUs (without\n      // wrapping element), so fallback to ICU metadata in this case.\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n\n  visitText(text: html.Text): any {\n    return text;\n  }\n  visitAttribute(attribute: html.Attribute): any {\n    return attribute;\n  }\n  visitComment(comment: html.Comment): any {\n    return comment;\n  }\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return expansionCase;\n  }\n\n  /**\n   * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n   * `Message`.\n   *\n   * There are three possibilities for the `meta` variable\n   * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n   * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n   * 4) other: ignore this and just process the message metadata as normal\n   *\n   * @param meta the bucket that holds information about the message\n   * @returns the parsed metadata.\n   */\n  private _parseMetadata(meta: string|i18n.I18nMeta): I18nMeta {\n    return typeof meta === 'string'  ? parseI18nMeta(meta) :\n        meta instanceof i18n.Message ? meta :\n                                       {};\n  }\n\n  /**\n   * Generate (or restore) message id if not specified already.\n   */\n  private _setMessageId(message: i18n.Message, meta: string|i18n.I18nMeta): void {\n    if (!message.id) {\n      message.id = meta instanceof i18n.Message && meta.id || decimalDigest(message);\n    }\n  }\n\n  /**\n   * Update the `message` with a `legacyId` if necessary.\n   *\n   * @param message the message whose legacy id should be set\n   * @param meta information about the message being processed\n   */\n  private _setLegacyIds(message: i18n.Message, meta: string|i18n.I18nMeta): void {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n      // `packages/compiler/src/render3/view/template.ts`).\n      // In that case we want to reuse the legacy message generated in the 1st pass (see\n      // `setI18nRefs()`).\n      const previousMessage = meta instanceof i18n.Message ? meta :\n          meta instanceof i18n.IcuPlaceholder              ? meta.previousMessage :\n                                                             undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, msg));\n  }\n}\n\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nexport function parseI18nMeta(meta: string = ''): I18nMeta {\n  let customId: string|undefined;\n  let meaning: string|undefined;\n  let description: string|undefined;\n\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc: string;\n    [meaningAndDesc, customId] =\n        (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n  }\n\n  return {customId, meaning, description};\n}\n\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nexport function i18nMetaToJSDoc(meta: I18nMeta): o.JSDocComment {\n  const tags: o.JSDocTag[] = [];\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  } else {\n    // Suppress the JSCompiler warning that a `@desc` was not given for this message.\n    tags.push({tagName: o.JSDocTagName.Suppress, text: '{msgDescriptions}'});\n  }\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n  return o.jsDocComment(tags);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {mapLiteral} from '../../../output/map_util';\nimport * as o from '../../../output/output_ast';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {i18nMetaToJSDoc} from './meta';\nimport {formatI18nPlaceholderName, formatI18nPlaceholderNamesInMap} from './util';\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Generates a `goog.getMsg()` statement and reassignment. The template:\n *\n * ```html\n * <div i18n>Sent from {{ sender }} to <span class=\"receiver\">{{ receiver }}</span></div>\n * ```\n *\n * Generates:\n *\n * ```typescript\n * const MSG_FOO = goog.getMsg(\n *   // Message template.\n *   'Sent from {$interpolation} to {$startTagSpan}{$interpolation_1}{$closeTagSpan}.',\n *   // Placeholder values, set to magic strings which get replaced by the Angular runtime.\n *   {\n *     'interpolation': '\\uFFFD0\\uFFFD',\n *     'startTagSpan': '\\uFFFD1\\uFFFD',\n *     'interpolation_1': '\\uFFFD2\\uFFFD',\n *     'closeTagSpan': '\\uFFFD3\\uFFFD',\n *   },\n *   // Options bag.\n *   {\n *     // Maps each placeholder to the original Angular source code which generates it's value.\n *     original_code: {\n *       'interpolation': '{{ sender }}',\n *       'startTagSpan': '<span class=\"receiver\">',\n *       'interpolation_1': '{{ receiver }}',\n *       'closeTagSpan': '</span>',\n *     },\n *   },\n * );\n * const I18N_0 = MSG_FOO;\n * ```\n */\nexport function createGoogleGetMsgStatements(\n    variable: o.ReadVarExpr, message: i18n.Message, closureVar: o.ReadVarExpr,\n    placeholderValues: {[name: string]: o.Expression}): o.Statement[] {\n  const messageString = serializeI18nMessageForGetMsg(message);\n  const args = [o.literal(messageString) as o.Expression];\n  if (Object.keys(placeholderValues).length) {\n    // Message template parameters containing the magic strings replaced by the Angular runtime with\n    // real data, e.g. `{'interpolation': '\\uFFFD0\\uFFFD'}`.\n    args.push(mapLiteral(\n        formatI18nPlaceholderNamesInMap(placeholderValues, true /* useCamelCase */),\n        true /* quoted */));\n\n    // Message options object, which contains original source code for placeholders (as they are\n    // present in a template, e.g.\n    // `{original_code: {'interpolation': '{{ name }}', 'startTagSpan': '<span>'}}`.\n    args.push(mapLiteral({\n      original_code:\n          o.literalMap(Object.keys(placeholderValues)\n                           .map((param) => ({\n                                  key: formatI18nPlaceholderName(param),\n                                  quoted: true,\n                                  value: message.placeholders[param] ?\n                                      // Get source span for typical placeholder if it exists.\n                                      o.literal(message.placeholders[param].sourceSpan.toString()) :\n                                      // Otherwise must be an ICU expression, get it's source span.\n                                      o.literal(\n                                          message.placeholderToMessage[param]\n                                              .nodes.map((node) => node.sourceSpan.toString())\n                                              .join(''),\n                                          ),\n                                }))),\n    }));\n  }\n\n  // /**\n  //  * @desc description of message\n  //  * @meaning meaning of message\n  //  */\n  // const MSG_... = goog.getMsg(..);\n  // I18N_X = MSG_...;\n  const googGetMsgStmt = closureVar.set(o.variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n  const i18nAssignmentStmt = new o.ExpressionStatement(variable.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\n\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nclass GetMsgSerializerVisitor implements i18n.Visitor {\n  private formatPh(value: string): string {\n    return `{$${formatI18nPlaceholderName(value)}}`;\n  }\n\n  visitText(text: i18n.Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    return serializeIcuNode(icu);\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    return ph.isVoid ?\n        this.formatPh(ph.startName) :\n        `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${\n            this.formatPh(ph.closeName)}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    return this.formatPh(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return this.formatPh(ph.name);\n  }\n}\n\nconst serializerVisitor = new GetMsgSerializerVisitor();\n\nexport function serializeI18nMessageForGetMsg(message: i18n.Message): string {\n  return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\nimport {ParseLocation, ParseSourceSpan} from '../../../parse_util';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {formatI18nPlaceholderName} from './util';\n\nexport function createLocalizeStatements(\n    variable: o.ReadVarExpr, message: i18n.Message,\n    params: {[name: string]: o.Expression}): o.Statement[] {\n  const {messageParts, placeHolders} = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map(ph => params[ph.text]);\n  const localizedString =\n      o.localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  const variableInitialization = variable.set(localizedString);\n  return [new o.ExpressionStatement(variableInitialization)];\n}\n\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor implements i18n.Visitor {\n  constructor(\n      private placeholderToMessage: {[phName: string]: i18n.Message},\n      private pieces: o.MessagePiece[]) {}\n\n  visitText(text: i18n.Text): any {\n    if (this.pieces[this.pieces.length - 1] instanceof o.LiteralPiece) {\n      // Two literal pieces in a row means that there was some comment node in-between.\n      this.pieces[this.pieces.length - 1].text += text.value;\n    } else {\n      const sourceSpan = new ParseSourceSpan(\n          text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart,\n          text.sourceSpan.details);\n      this.pieces.push(new o.LiteralPiece(text.value, sourceSpan));\n    }\n  }\n\n  visitContainer(container: i18n.Container): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    this.pieces.push(new o.LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    this.pieces.push(\n        this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    if (!ph.isVoid) {\n      ph.children.forEach(child => child.visit(this));\n      this.pieces.push(\n          this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n    }\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder): any {\n    this.pieces.push(\n        this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n  }\n\n  private createPlaceholderPiece(\n      name: string, sourceSpan: ParseSourceSpan,\n      associatedMessage?: i18n.Message): o.PlaceholderPiece {\n    return new o.PlaceholderPiece(\n        formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan, associatedMessage);\n  }\n}\n\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nexport function serializeI18nMessageForLocalize(message: i18n.Message):\n    {messageParts: o.LiteralPiece[], placeHolders: o.PlaceholderPiece[]} {\n  const pieces: o.MessagePiece[] = [];\n  const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n  message.nodes.forEach(node => node.visit(serializerVisitor));\n  return processMessagePieces(pieces);\n}\n\nfunction getSourceSpan(message: i18n.Message): ParseSourceSpan {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(\n      startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart,\n      startNode.sourceSpan.details);\n}\n\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces: o.MessagePiece[]):\n    {messageParts: o.LiteralPiece[], placeHolders: o.PlaceholderPiece[]} {\n  const messageParts: o.LiteralPiece[] = [];\n  const placeHolders: o.PlaceholderPiece[] = [];\n\n  if (pieces[0] instanceof o.PlaceholderPiece) {\n    // The first piece was a placeholder so we need to add an initial empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof o.LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof o.PlaceholderPiece) {\n        // There were two placeholders in a row, so we need to add an empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof o.PlaceholderPiece) {\n    // The last piece was a placeholder so we need to add a final empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {messageParts, placeHolders};\n}\n\nfunction createEmptyMessagePart(location: ParseLocation): o.LiteralPiece {\n  return new o.LiteralPiece('', new ParseSourceSpan(location, location));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BuiltinFunctionCall, convertActionBinding, convertPropertyBinding, convertUpdateArguments, LocalResolver} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, Call, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, ParsedEventType, PropertyRead} from '../../expression_parser/ast';\nimport {Lexer} from '../../expression_parser/lexer';\nimport {Parser} from '../../expression_parser/parser';\nimport * as i18n from '../../i18n/i18n_ast';\nimport * as html from '../../ml_parser/ast';\nimport {HtmlParser} from '../../ml_parser/html_parser';\nimport {WhitespaceVisitor} from '../../ml_parser/html_whitespaces';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../ml_parser/interpolation_config';\nimport {LexerRange} from '../../ml_parser/lexer';\nimport {isNgContainer as checkIsNgContainer, splitNsName} from '../../ml_parser/tags';\nimport {mapLiteral} from '../../output/map_util';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\nimport {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\nimport {isIframeSecuritySensitiveAttr} from '../../schema/dom_security_schema';\nimport {isTrustedTypesSink} from '../../schema/trusted_types_sinks';\nimport {CssSelector} from '../../selector';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error, partitionArray} from '../../util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {htmlAstToRender3Ast} from '../r3_template_transform';\nimport {prepareSyntheticListenerFunctionName, prepareSyntheticListenerName, prepareSyntheticPropertyName} from '../util';\n\nimport {I18nContext} from './i18n/context';\nimport {createGoogleGetMsgStatements} from './i18n/get_msg_utils';\nimport {createLocalizeStatements} from './i18n/localize_utils';\nimport {I18nMetaVisitor} from './i18n/meta';\nimport {assembleBoundTextPlaceholders, assembleI18nBoundString, declareI18nVariable, formatI18nPlaceholderNamesInMap, getTranslationConstPrefix, hasI18nMeta, I18N_ICU_MAPPING_PREFIX, icuFromI18nMessage, isI18nRootNode, isSingleI18nIcu, placeholdersToParams, TRANSLATION_VAR_PREFIX, wrapI18nPlaceholder} from './i18n/util';\nimport {StylingBuilder, StylingInstruction} from './styling_builder';\nimport {asLiteral, CONTEXT_NAME, getInstructionStatements, getInterpolationArgsLength, IMPLICIT_REFERENCE, Instruction, InstructionParams, invalid, invokeInstruction, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, RESTORED_VIEW_CONTEXT_NAME, trimTrailingNulls} from './util';\n\n\n\n// Selector attribute name of `<ng-content>`\nconst NG_CONTENT_SELECT_ATTR = 'select';\n\n// Attribute name of `ngProjectAs`.\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n\n// Global symbols available only inside event bindings.\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set<string>(['$event']);\n\n// List of supported global targets for event listeners\nconst GLOBAL_TARGET_RESOLVERS = new Map<string, o.ExternalReference>(\n    [['window', R3.resolveWindow], ['document', R3.resolveDocument], ['body', R3.resolveBody]]);\n\nexport const LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n\n//  if (rf & flags) { .. }\nexport function renderFlagCheckIfStmt(\n    flags: core.RenderFlags, statements: o.Statement[]): o.IfStmt {\n  return o.ifStmt(o.variable(RENDER_FLAGS).bitwiseAnd(o.literal(flags), null, false), statements);\n}\n\nexport function prepareEventListenerParameters(\n    eventAst: t.BoundEvent, handlerName: string|null = null,\n    scope: BindingScope|null = null): o.Expression[] {\n  const {type, name, target, phase, handler} = eventAst;\n  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n    throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\n  }\n\n  const eventArgumentName = '$event';\n  const implicitReceiverAccesses = new Set<string>();\n  const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n      o.variable(CONTEXT_NAME) :\n      scope.getOrCreateSharedContextVar(0);\n  const bindingStatements = convertActionBinding(\n      scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses,\n      EVENT_BINDING_SCOPE_GLOBALS);\n  const statements = [];\n  const variableDeclarations = scope?.variableDeclarations();\n  const restoreViewStatement = scope?.restoreViewStatement();\n\n  if (variableDeclarations) {\n    // `variableDeclarations` needs to run first, because\n    // `restoreViewStatement` depends on the result.\n    statements.push(...variableDeclarations);\n  }\n\n  statements.push(...bindingStatements);\n\n  if (restoreViewStatement) {\n    statements.unshift(restoreViewStatement);\n\n    // If there's a `restoreView` call, we need to reset the view at the end of the listener\n    // in order to avoid a leak. If there's a `return` statement already, we wrap it in the\n    // call, e.g. `return resetView(ctx.foo())`. Otherwise we add the call as the last statement.\n    const lastStatement = statements[statements.length - 1];\n    if (lastStatement instanceof o.ReturnStatement) {\n      statements[statements.length - 1] = new o.ReturnStatement(\n          invokeInstruction(lastStatement.value.sourceSpan, R3.resetView, [lastStatement.value]));\n    } else {\n      statements.push(new o.ExpressionStatement(invokeInstruction(null, R3.resetView, [])));\n    }\n  }\n\n  const eventName: string =\n      type === ParsedEventType.Animation ? prepareSyntheticListenerName(name, phase!) : name;\n  const fnName = handlerName && sanitizeIdentifier(handlerName);\n  const fnArgs: o.FnParam[] = [];\n\n  if (implicitReceiverAccesses.has(eventArgumentName)) {\n    fnArgs.push(new o.FnParam(eventArgumentName, o.DYNAMIC_TYPE));\n  }\n\n  const handlerFn = o.fn(fnArgs, statements, o.INFERRED_TYPE, null, fnName);\n  const params: o.Expression[] = [o.literal(eventName), handlerFn];\n  if (target) {\n    params.push(\n        o.literal(false),  // `useCapture` flag, defaults to `false`\n        o.importExpr(GLOBAL_TARGET_RESOLVERS.get(target)!));\n  }\n  return params;\n}\n\n// Collects information needed to generate `consts` field of the ComponentDef.\nexport interface ComponentDefConsts {\n  /**\n   * When a constant requires some pre-processing (e.g. i18n translation block that includes\n   * goog.getMsg and $localize calls), the `prepareStatements` section contains corresponding\n   * statements.\n   */\n  prepareStatements: o.Statement[];\n\n  /**\n   * Actual expressions that represent constants.\n   */\n  constExpressions: o.Expression[];\n\n  /**\n   * Cache to avoid generating duplicated i18n translation blocks.\n   */\n  i18nVarRefsCache: Map<i18n.I18nMeta, o.ReadVarExpr>;\n}\n\nfunction createComponentDefConsts(): ComponentDefConsts {\n  return {\n    prepareStatements: [],\n    constExpressions: [],\n    i18nVarRefsCache: new Map(),\n  };\n}\n\nexport class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver {\n  private _dataIndex = 0;\n  private _bindingContext = 0;\n  private _prefixCode: o.Statement[] = [];\n  /**\n   * List of callbacks to generate creation mode instructions. We store them here as we process\n   * the template so bindings in listeners are resolved only once all nodes have been visited.\n   * This ensures all local refs and context variables are available for matching.\n   */\n  private _creationCodeFns: Instruction[] = [];\n  /**\n   * List of callbacks to generate update mode instructions. We store them here as we process\n   * the template so bindings are resolved only once all nodes have been visited. This ensures\n   * all local refs and context variables are available for matching.\n   */\n  private _updateCodeFns: Instruction[] = [];\n\n  /** Index of the currently-selected node. */\n  private _currentIndex: number = 0;\n\n  /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n  private _tempVariables: o.Statement[] = [];\n  /**\n   * List of callbacks to build nested templates. Nested templates must not be visited until\n   * after the parent template has finished visiting all of its nodes. This ensures that all\n   * local ref bindings in nested templates are able to find local ref values if the refs\n   * are defined after the template declaration.\n   */\n  private _nestedTemplateFns: (() => void)[] = [];\n  /**\n   * This scope contains local variables declared in the update mode block of the template.\n   * (e.g. refs and context vars in bindings)\n   */\n  private _bindingScope: BindingScope;\n  private _valueConverter: ValueConverter;\n\n  // i18n context local to this template\n  private i18n: I18nContext|null = null;\n\n  // Number of slots to reserve for pureFunctions\n  private _pureFunctionSlots = 0;\n\n  // Number of binding slots\n  private _bindingSlots = 0;\n\n  private fileBasedI18nSuffix: string;\n\n  // Projection slots found in the template. Projection slots can distribute projected\n  // nodes based on a selector, or can just use the wildcard selector to match\n  // all nodes which aren't matching any selector.\n  private _ngContentReservedSlots: (string|'*')[] = [];\n\n  // Number of non-default selectors found in all parent templates of this template. We need to\n  // track it to properly adjust projection slot index in the `projection` instruction.\n  private _ngContentSelectorsOffset = 0;\n\n  // Expression that should be used as implicit receiver when converting template\n  // expressions to output AST.\n  private _implicitReceiverExpr: o.ReadVarExpr|null = null;\n\n  constructor(\n      private constantPool: ConstantPool, parentBindingScope: BindingScope, private level = 0,\n      private contextName: string|null, private i18nContext: I18nContext|null,\n      private templateIndex: number|null, private templateName: string|null,\n      private _namespace: o.ExternalReference, relativeContextFilePath: string,\n      private i18nUseExternalIds: boolean,\n      private _constants: ComponentDefConsts = createComponentDefConsts()) {\n    this._bindingScope = parentBindingScope.nestedScope(level);\n\n    // Turn the relative context file path into an identifier by replacing non-alphanumeric\n    // characters with underscores.\n    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n\n    this._valueConverter = new ValueConverter(\n        constantPool, () => this.allocateDataSlot(),\n        (numSlots: number) => this.allocatePureFunctionSlots(numSlots),\n        (name, localName, slot, value: o.Expression) => {\n          this._bindingScope.set(this.level, localName, value);\n          this.creationInstruction(null, R3.pipe, [o.literal(slot), o.literal(name)]);\n        });\n  }\n\n  buildTemplateFunction(\n      nodes: t.Node[], variables: t.Variable[], ngContentSelectorsOffset: number = 0,\n      i18n?: i18n.I18nMeta): o.FunctionExpr {\n    this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n\n    if (this._namespace !== R3.namespaceHTML) {\n      this.creationInstruction(null, this._namespace);\n    }\n\n    // Create variable bindings\n    variables.forEach(v => this.registerContextVariables(v));\n\n    // Initiate i18n context in case:\n    // - this template has parent i18n context\n    // - or the template has i18n meta associated with it,\n    //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n    const initI18nContext = this.i18nContext ||\n        (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n         !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n    const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n    if (initI18nContext) {\n      this.i18nStart(null, i18n!, selfClosingI18nInstruction);\n    }\n\n    // This is the initial pass through the nodes of this template. In this pass, we\n    // queue all creation mode and update mode instructions for generation in the second\n    // pass. It's necessary to separate the passes to ensure local refs are defined before\n    // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n    t.visitAll(this, nodes);\n\n    // Add total binding count to pure function count so pure function instructions are\n    // generated with the correct slot offset when update instructions are processed.\n    this._pureFunctionSlots += this._bindingSlots;\n\n    // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n    // `pipeBind` update instructions), so we have to update the slot offsets manually\n    // to account for bindings.\n    this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n\n    // Nested templates must be processed before creation instructions so template()\n    // instructions can be generated with the correct internal const count.\n    this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n\n    // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n    // The `projectionDef` instruction is only emitted for the component template and\n    // is skipped for nested templates (<ng-template> tags).\n    if (this.level === 0 && this._ngContentReservedSlots.length) {\n      const parameters: o.Expression[] = [];\n\n      // By default the `projectionDef` instructions creates one slot for the wildcard\n      // selector if no parameters are passed. Therefore we only want to allocate a new\n      // array for the projection slots if the default projection slot is not sufficient.\n      if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n        const r3ReservedSlots = this._ngContentReservedSlots.map(\n            s => s !== '*' ? core.parseSelectorToR3Selector(s) : s);\n        parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n      }\n\n      // Since we accumulate ngContent selectors while processing template elements,\n      // we *prepend* `projectionDef` to creation instructions block, to put it before\n      // any `projection` instructions\n      this.creationInstruction(null, R3.projectionDef, parameters, /* prepend */ true);\n    }\n\n    if (initI18nContext) {\n      this.i18nEnd(null, selfClosingI18nInstruction);\n    }\n\n    // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n    const creationStatements = getInstructionStatements(this._creationCodeFns);\n\n    // Generate all the update mode instructions (e.g. resolve property or text bindings)\n    const updateStatements = getInstructionStatements(this._updateCodeFns);\n\n    //  Variable declaration must occur after binding resolution so we can generate context\n    //  instructions that build on each other.\n    // e.g. const b = nextContext().$implicit(); const b = nextContext();\n    const creationVariables = this._bindingScope.viewSnapshotStatements();\n    const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n    const creationBlock = creationStatements.length > 0 ?\n        [renderFlagCheckIfStmt(\n            core.RenderFlags.Create, creationVariables.concat(creationStatements))] :\n        [];\n\n    const updateBlock = updateStatements.length > 0 ?\n        [renderFlagCheckIfStmt(core.RenderFlags.Update, updateVariables.concat(updateStatements))] :\n        [];\n\n    return o.fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n        [\n          // Temporary variable declarations for query refresh (i.e. let _t: any;)\n          ...this._prefixCode,\n          // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n          ...creationBlock,\n          // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n          ...updateBlock,\n        ],\n        o.INFERRED_TYPE, null, this.templateName);\n  }\n\n  // LocalResolver\n  getLocal(name: string): o.Expression|null {\n    return this._bindingScope.get(name);\n  }\n\n  // LocalResolver\n  notifyImplicitReceiverUse(): void {\n    this._bindingScope.notifyImplicitReceiverUse();\n  }\n\n  // LocalResolver\n  maybeRestoreView(): void {\n    this._bindingScope.maybeRestoreView();\n  }\n\n  private i18nTranslate(\n      message: i18n.Message, params: {[name: string]: o.Expression} = {}, ref?: o.ReadVarExpr,\n      transformFn?: (raw: o.ReadVarExpr) => o.Expression): o.ReadVarExpr {\n    const _ref = ref || this.i18nGenerateMainBlockVar();\n    // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n    // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n    const closureVar = this.i18nGenerateClosureVar(message.id);\n    const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n    this._constants.prepareStatements.push(...statements);\n    return _ref;\n  }\n\n  private registerContextVariables(variable: t.Variable) {\n    const scopedName = this._bindingScope.freshReferenceName();\n    const retrievalLevel = this.level;\n    const lhs = o.variable(variable.name + scopedName);\n    this._bindingScope.set(\n        retrievalLevel, variable.name, lhs, DeclarationPriority.CONTEXT,\n        (scope: BindingScope, relativeLevel: number) => {\n          let rhs: o.Expression;\n          if (scope.bindingLevel === retrievalLevel) {\n            if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\n              // e.g. restoredCtx.\n              // We have to get the context from a view reference, if one is available, because\n              // the context that was passed in during creation may not be correct anymore.\n              // For more information see: https://github.com/angular/angular/pull/40360.\n              rhs = o.variable(RESTORED_VIEW_CONTEXT_NAME);\n              scope.notifyRestoredViewContextUse();\n            } else {\n              // e.g. ctx\n              rhs = o.variable(CONTEXT_NAME);\n            }\n          } else {\n            const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n            // e.g. ctx_r0   OR  x(2);\n            rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n          }\n          // e.g. const $item$ = x(2).$implicit;\n          return [lhs.set(rhs.prop(variable.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n  }\n\n  private i18nAppendBindings(expressions: AST[]) {\n    if (expressions.length > 0) {\n      expressions.forEach(expression => this.i18n!.appendBinding(expression));\n    }\n  }\n\n  private i18nBindProps(props: {[key: string]: t.Text|t.BoundText}): {[key: string]: o.Expression} {\n    const bound: {[key: string]: o.Expression} = {};\n    Object.keys(props).forEach(key => {\n      const prop = props[key];\n      if (prop instanceof t.Text) {\n        bound[key] = o.literal(prop.value);\n      } else {\n        const value = prop.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n          const {strings, expressions} = value;\n          const {id, bindings} = this.i18n!;\n          const label = assembleI18nBoundString(strings, bindings.size, id);\n          this.i18nAppendBindings(expressions);\n          bound[key] = o.literal(label);\n        }\n      }\n    });\n    return bound;\n  }\n\n  // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n  private i18nGenerateMainBlockVar(): o.ReadVarExpr {\n    return o.variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n  }\n\n  // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n  private i18nGenerateClosureVar(messageId: string): o.ReadVarExpr {\n    let name: string;\n    const suffix = this.fileBasedI18nSuffix.toUpperCase();\n    if (this.i18nUseExternalIds) {\n      const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n      const uniqueSuffix = this.constantPool.uniqueName(suffix);\n      name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n    } else {\n      const prefix = getTranslationConstPrefix(suffix);\n      name = this.constantPool.uniqueName(prefix);\n    }\n    return o.variable(name);\n  }\n\n  private i18nUpdateRef(context: I18nContext): void {\n    const {icus, meta, isRoot, isResolved, isEmitted} = context;\n    if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n      context.isEmitted = true;\n      const placeholders = context.getSerializedPlaceholders();\n      let icuMapping: {[name: string]: o.Expression} = {};\n      let params: {[name: string]: o.Expression} =\n          placeholders.size ? placeholdersToParams(placeholders) : {};\n      if (icus.size) {\n        icus.forEach((refs: o.Expression[], key: string) => {\n          if (refs.length === 1) {\n            // if we have one ICU defined for a given\n            // placeholder - just output its reference\n            params[key] = refs[0];\n          } else {\n            // ... otherwise we need to activate post-processing\n            // to replace ICU placeholders with proper values\n            const placeholder: string = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\n            params[key] = o.literal(placeholder);\n            icuMapping[key] = o.literalArr(refs);\n          }\n        });\n      }\n\n      // translation requires post processing in 2 cases:\n      // - if we have placeholders with multiple values (ex. `START_DIV`: [ï¿½#1ï¿½, ï¿½#2ï¿½, ...])\n      // - if we have multiple ICUs that refer to the same placeholder name\n      const needsPostprocessing =\n          Array.from(placeholders.values()).some((value: string[]) => value.length > 1) ||\n          Object.keys(icuMapping).length;\n\n      let transformFn;\n      if (needsPostprocessing) {\n        transformFn = (raw: o.ReadVarExpr) => {\n          const args: o.Expression[] = [raw];\n          if (Object.keys(icuMapping).length) {\n            args.push(mapLiteral(icuMapping, true));\n          }\n          return invokeInstruction(null, R3.i18nPostprocess, args);\n        };\n      }\n      this.i18nTranslate(meta as i18n.Message, params, context.ref, transformFn);\n    }\n  }\n\n  private i18nStart(span: ParseSourceSpan|null = null, meta: i18n.I18nMeta, selfClosing?: boolean):\n      void {\n    const index = this.allocateDataSlot();\n    this.i18n = this.i18nContext ?\n        this.i18nContext.forkChildContext(index, this.templateIndex!, meta) :\n        new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\n\n    // generate i18nStart instruction\n    const {id, ref} = this.i18n;\n    const params: o.Expression[] = [o.literal(index), this.addToConsts(ref)];\n    if (id > 0) {\n      // do not push 3rd argument (sub-block id)\n      // into i18nStart call for top level i18n context\n      params.push(o.literal(id));\n    }\n    this.creationInstruction(span, selfClosing ? R3.i18n : R3.i18nStart, params);\n  }\n\n  private i18nEnd(span: ParseSourceSpan|null = null, selfClosing?: boolean): void {\n    if (!this.i18n) {\n      throw new Error('i18nEnd is executed with no i18n context present');\n    }\n\n    if (this.i18nContext) {\n      this.i18nContext.reconcileChildContext(this.i18n);\n      this.i18nUpdateRef(this.i18nContext);\n    } else {\n      this.i18nUpdateRef(this.i18n);\n    }\n\n    // setup accumulated bindings\n    const {index, bindings} = this.i18n;\n    if (bindings.size) {\n      for (const binding of bindings) {\n        // for i18n block, advance to the most recent element index (by taking the current number of\n        // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n        // necessary lifecycle hooks of components/directives are properly flushed.\n        this.updateInstructionWithAdvance(\n            this.getConstCount() - 1, span, R3.i18nExp, () => this.convertPropertyBinding(binding));\n      }\n\n      this.updateInstruction(span, R3.i18nApply, [o.literal(index)]);\n    }\n    if (!selfClosing) {\n      this.creationInstruction(span, R3.i18nEnd);\n    }\n    this.i18n = null;  // reset local i18n context\n  }\n\n  private i18nAttributesInstruction(\n      nodeIndex: number, attrs: t.BoundAttribute[], sourceSpan: ParseSourceSpan): void {\n    let hasBindings = false;\n    const i18nAttrArgs: o.Expression[] = [];\n    attrs.forEach(attr => {\n      const message = attr.i18n! as i18n.Message;\n      const converted = attr.value.visit(this._valueConverter);\n      this.allocateBindingSlots(converted);\n      if (converted instanceof Interpolation) {\n        const placeholders = assembleBoundTextPlaceholders(message);\n        const params = placeholdersToParams(placeholders);\n        i18nAttrArgs.push(o.literal(attr.name), this.i18nTranslate(message, params));\n        converted.expressions.forEach(expression => {\n          hasBindings = true;\n          this.updateInstructionWithAdvance(\n              nodeIndex, sourceSpan, R3.i18nExp, () => this.convertPropertyBinding(expression));\n        });\n      }\n    });\n    if (i18nAttrArgs.length > 0) {\n      const index: o.Expression = o.literal(this.allocateDataSlot());\n      const constIndex = this.addToConsts(o.literalArr(i18nAttrArgs));\n      this.creationInstruction(sourceSpan, R3.i18nAttributes, [index, constIndex]);\n      if (hasBindings) {\n        this.updateInstruction(sourceSpan, R3.i18nApply, [index]);\n      }\n    }\n  }\n\n  private getNamespaceInstruction(namespaceKey: string|null) {\n    switch (namespaceKey) {\n      case 'math':\n        return R3.namespaceMathML;\n      case 'svg':\n        return R3.namespaceSVG;\n      default:\n        return R3.namespaceHTML;\n    }\n  }\n\n  private addNamespaceInstruction(nsInstruction: o.ExternalReference, element: t.Element) {\n    this._namespace = nsInstruction;\n    this.creationInstruction(element.startSourceSpan, nsInstruction);\n  }\n\n  /**\n   * Adds an update instruction for an interpolated property or attribute, such as\n   * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n   */\n  private interpolatedUpdateInstruction(\n      instruction: o.ExternalReference, elementIndex: number, attrName: string,\n      input: t.BoundAttribute, value: Interpolation, params: any[]) {\n    this.updateInstructionWithAdvance(\n        elementIndex, input.sourceSpan, instruction,\n        () => [o.literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\n  }\n\n  visitContent(ngContent: t.Content) {\n    const slot = this.allocateDataSlot();\n    const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n    const parameters: o.Expression[] = [o.literal(slot)];\n\n    this._ngContentReservedSlots.push(ngContent.selector);\n\n    const nonContentSelectAttributes =\n        ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);\n    const attributes =\n        this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n\n    if (attributes.length > 0) {\n      parameters.push(o.literal(projectionSlotIdx), o.literalArr(attributes));\n    } else if (projectionSlotIdx !== 0) {\n      parameters.push(o.literal(projectionSlotIdx));\n    }\n\n    this.creationInstruction(ngContent.sourceSpan, R3.projection, parameters);\n    if (this.i18n) {\n      this.i18n.appendProjection(ngContent.i18n!, slot);\n    }\n  }\n\n  visitElement(element: t.Element) {\n    const elementIndex = this.allocateDataSlot();\n    const stylingBuilder = new StylingBuilder(null);\n\n    let isNonBindableMode: boolean = false;\n    const isI18nRootElement: boolean =\n        isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n\n    const outputAttrs: t.TextAttribute[] = [];\n    const [namespaceKey, elementName] = splitNsName(element.name);\n    const isNgContainer = checkIsNgContainer(element.name);\n\n    // Handle styling, i18n, ngNonBindable attributes\n    for (const attr of element.attributes) {\n      const {name, value} = attr;\n      if (name === NON_BINDABLE_ATTR) {\n        isNonBindableMode = true;\n      } else if (name === 'style') {\n        stylingBuilder.registerStyleAttr(value);\n      } else if (name === 'class') {\n        stylingBuilder.registerClassAttr(value);\n      } else {\n        outputAttrs.push(attr);\n      }\n    }\n\n    // Regular element or ng-container creation mode\n    const parameters: o.Expression[] = [o.literal(elementIndex)];\n    if (!isNgContainer) {\n      parameters.push(o.literal(elementName));\n    }\n\n    // Add the attributes\n    const allOtherInputs: t.BoundAttribute[] = [];\n    const boundI18nAttrs: t.BoundAttribute[] = [];\n\n    element.inputs.forEach(input => {\n      const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n      if (!stylingInputWasSet) {\n        if (input.type === BindingType.Property && input.i18n) {\n          boundI18nAttrs.push(input);\n        } else {\n          allOtherInputs.push(input);\n        }\n      }\n    });\n\n    // add attributes for directive and projection matching purposes\n    const attributes: o.Expression[] = this.getAttributeExpressions(\n        element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [],\n        boundI18nAttrs);\n    parameters.push(this.addAttrsToConsts(attributes));\n\n    // local refs (ex.: <div #foo #bar=\"baz\">)\n    const refs = this.prepareRefsArray(element.references);\n    parameters.push(this.addToConsts(refs));\n\n    const wasInNamespace = this._namespace;\n    const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n\n    // If the namespace is changing now, include an instruction to change it\n    // during element creation.\n    if (currentNamespace !== wasInNamespace) {\n      this.addNamespaceInstruction(currentNamespace, element);\n    }\n\n    if (this.i18n) {\n      this.i18n.appendElement(element.i18n!, elementIndex);\n    }\n\n    // Note that we do not append text node instructions and ICUs inside i18n section,\n    // so we exclude them while calculating whether current element has children\n    const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n                                                            element.children.length > 0;\n\n    const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n        element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n    const createSelfClosingI18nInstruction =\n        !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n\n    if (createSelfClosingInstruction) {\n      this.creationInstruction(\n          element.sourceSpan, isNgContainer ? R3.elementContainer : R3.element,\n          trimTrailingNulls(parameters));\n    } else {\n      this.creationInstruction(\n          element.startSourceSpan, isNgContainer ? R3.elementContainerStart : R3.elementStart,\n          trimTrailingNulls(parameters));\n\n      if (isNonBindableMode) {\n        this.creationInstruction(element.startSourceSpan, R3.disableBindings);\n      }\n\n      if (boundI18nAttrs.length > 0) {\n        this.i18nAttributesInstruction(\n            elementIndex, boundI18nAttrs, element.startSourceSpan ?? element.sourceSpan);\n      }\n\n      // Generate Listeners (outputs)\n      if (element.outputs.length > 0) {\n        for (const outputAst of element.outputs) {\n          this.creationInstruction(\n              outputAst.sourceSpan, R3.listener,\n              this.prepareListenerParameter(element.name, outputAst, elementIndex));\n        }\n      }\n\n      // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n      // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n      if (isI18nRootElement) {\n        this.i18nStart(element.startSourceSpan, element.i18n!, createSelfClosingI18nInstruction);\n      }\n    }\n\n    // the code here will collect all update-level styling instructions and add them to the\n    // update block of the template function AOT code. Instructions like `styleProp`,\n    // `styleMap`, `classMap`, `classProp`\n    // are all generated and assigned in the code below.\n    const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n    const limit = stylingInstructions.length - 1;\n    for (let i = 0; i <= limit; i++) {\n      const instruction = stylingInstructions[i];\n      this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\n    }\n\n    // the reason why `undefined` is used is because the renderer understands this as a\n    // special value to symbolize that there is no RHS to this binding\n    // TODO (matsko): revisit this once FW-959 is approached\n    const emptyValueBindInstruction = o.literal(undefined);\n    const propertyBindings: Omit<Instruction, 'reference'>[] = [];\n    const attributeBindings: Omit<Instruction, 'reference'>[] = [];\n\n    // Generate element input bindings\n    allOtherInputs.forEach(input => {\n      const inputType = input.type;\n      if (inputType === BindingType.Animation) {\n        const value = input.value.visit(this._valueConverter);\n        // animation bindings can be presented in the following formats:\n        // 1. [@binding]=\"fooExp\"\n        // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n        // 3. [@binding]\n        // 4. @binding\n        // All formats will be valid for when a synthetic binding is created.\n        // The reasoning for this is because the renderer should get each\n        // synthetic binding value in the order of the array that they are\n        // defined in...\n        const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\n        this.allocateBindingSlots(value);\n\n        propertyBindings.push({\n          span: input.sourceSpan,\n          paramsOrFn: getBindingFunctionParams(\n              () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction,\n              prepareSyntheticPropertyName(input.name))\n        });\n      } else {\n        // we must skip attributes with associated i18n context, since these attributes are handled\n        // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n        if (input.i18n) return;\n\n        const value = input.value.visit(this._valueConverter);\n        if (value !== undefined) {\n          const params: any[] = [];\n          const [attrNamespace, attrName] = splitNsName(input.name);\n          const isAttributeBinding = inputType === BindingType.Attribute;\n          let sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n          if (!sanitizationRef) {\n            // If there was no sanitization function found based on the security context\n            // of an attribute/property - check whether this attribute/property is\n            // one of the security-sensitive <iframe> attributes (and that the current\n            // element is actually an <iframe>).\n            if (isIframeElement(element.name) && isIframeSecuritySensitiveAttr(input.name)) {\n              sanitizationRef = o.importExpr(R3.validateIframeAttribute);\n            }\n          }\n          if (sanitizationRef) {\n            params.push(sanitizationRef);\n          }\n          if (attrNamespace) {\n            const namespaceLiteral = o.literal(attrNamespace);\n\n            if (sanitizationRef) {\n              params.push(namespaceLiteral);\n            } else {\n              // If there wasn't a sanitization ref, we need to add\n              // an extra param so that we can pass in the namespace.\n              params.push(o.literal(null), namespaceLiteral);\n            }\n          }\n          this.allocateBindingSlots(value);\n\n          if (inputType === BindingType.Property) {\n            if (value instanceof Interpolation) {\n              // prop=\"{{value}}\" and friends\n              this.interpolatedUpdateInstruction(\n                  getPropertyInterpolationExpression(value), elementIndex, attrName, input, value,\n                  params);\n            } else {\n              // [prop]=\"value\"\n              // Collect all the properties so that we can chain into a single function at the end.\n              propertyBindings.push({\n                span: input.sourceSpan,\n                paramsOrFn: getBindingFunctionParams(\n                    () => this.convertPropertyBinding(value), attrName, params)\n              });\n            }\n          } else if (inputType === BindingType.Attribute) {\n            if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\n              // attr.name=\"text{{value}}\" and friends\n              this.interpolatedUpdateInstruction(\n                  getAttributeInterpolationExpression(value), elementIndex, attrName, input, value,\n                  params);\n            } else {\n              const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\n              // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n              // Collect the attribute bindings so that they can be chained at the end.\n              attributeBindings.push({\n                span: input.sourceSpan,\n                paramsOrFn: getBindingFunctionParams(\n                    () => this.convertPropertyBinding(boundValue), attrName, params)\n              });\n            }\n          } else {\n            // class prop\n            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, R3.classProp, () => {\n              return [\n                o.literal(elementIndex), o.literal(attrName), this.convertPropertyBinding(value),\n                ...params\n              ];\n            });\n          }\n        }\n      }\n    });\n\n    for (const propertyBinding of propertyBindings) {\n      this.updateInstructionWithAdvance(\n          elementIndex, propertyBinding.span, R3.property, propertyBinding.paramsOrFn);\n    }\n\n    for (const attributeBinding of attributeBindings) {\n      this.updateInstructionWithAdvance(\n          elementIndex, attributeBinding.span, R3.attribute, attributeBinding.paramsOrFn);\n    }\n\n    // Traverse element child nodes\n    t.visitAll(this, element.children);\n\n    if (!isI18nRootElement && this.i18n) {\n      this.i18n.appendElement(element.i18n!, elementIndex, true);\n    }\n\n    if (!createSelfClosingInstruction) {\n      // Finish element construction mode.\n      const span = element.endSourceSpan ?? element.sourceSpan;\n      if (isI18nRootElement) {\n        this.i18nEnd(span, createSelfClosingI18nInstruction);\n      }\n      if (isNonBindableMode) {\n        this.creationInstruction(span, R3.enableBindings);\n      }\n      this.creationInstruction(span, isNgContainer ? R3.elementContainerEnd : R3.elementEnd);\n    }\n  }\n\n\n  visitTemplate(template: t.Template) {\n    const NG_TEMPLATE_TAG_NAME = 'ng-template';\n    const templateIndex = this.allocateDataSlot();\n\n    if (this.i18n) {\n      this.i18n.appendTemplate(template.i18n!, templateIndex);\n    }\n\n    const tagNameWithoutNamespace =\n        template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\n    const contextName = `${this.contextName}${\n        template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;\n    const templateName = `${contextName}_Template`;\n    const parameters: o.Expression[] = [\n      o.literal(templateIndex),\n      o.variable(templateName),\n      // We don't care about the tag's namespace here, because we infer\n      // it based on the parent nodes inside the template instruction.\n      o.literal(tagNameWithoutNamespace),\n    ];\n\n    // prepare attributes parameter (including attributes used for directive matching)\n    const attrsExprs: o.Expression[] = this.getAttributeExpressions(\n        NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs,\n        undefined /* styles */, template.templateAttrs);\n    parameters.push(this.addAttrsToConsts(attrsExprs));\n\n    // local refs (ex.: <ng-template #foo>)\n    if (template.references && template.references.length) {\n      const refs = this.prepareRefsArray(template.references);\n      parameters.push(this.addToConsts(refs));\n      parameters.push(o.importExpr(R3.templateRefExtractor));\n    }\n\n    // Create the template function\n    const templateVisitor = new TemplateDefinitionBuilder(\n        this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n,\n        templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix,\n        this.i18nUseExternalIds, this._constants);\n\n    // Nested templates must not be visited until after their parent templates have completed\n    // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n    // be able to support bindings in nested templates to local refs that occur after the\n    // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n    this._nestedTemplateFns.push(() => {\n      const templateFunctionExpr = templateVisitor.buildTemplateFunction(\n          template.children, template.variables,\n          this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n      this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n      if (templateVisitor._ngContentReservedSlots.length) {\n        this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n      }\n    });\n\n    // e.g. template(1, MyComp_Template_1)\n    this.creationInstruction(template.sourceSpan, R3.templateCreate, () => {\n      parameters.splice(\n          2, 0, o.literal(templateVisitor.getConstCount()),\n          o.literal(templateVisitor.getVarCount()));\n      return trimTrailingNulls(parameters);\n    });\n\n    // handle property bindings e.g. ÉµÉµproperty('ngForOf', ctx.items), et al;\n    this.templatePropertyBindings(templateIndex, template.templateAttrs);\n\n    // Only add normal input/output binding instructions on explicit <ng-template> elements.\n    if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\n      const [i18nInputs, inputs] =\n          partitionArray<t.BoundAttribute, t.BoundAttribute>(template.inputs, hasI18nMeta);\n\n      // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n      // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n      // elements, in case of inline templates, corresponding instructions will be generated in the\n      // nested template function.\n      if (i18nInputs.length > 0) {\n        this.i18nAttributesInstruction(\n            templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);\n      }\n\n      // Add the input bindings\n      if (inputs.length > 0) {\n        this.templatePropertyBindings(templateIndex, inputs);\n      }\n\n      // Generate listeners for directive output\n      for (const outputAst of template.outputs) {\n        this.creationInstruction(\n            outputAst.sourceSpan, R3.listener,\n            this.prepareListenerParameter('ng_template', outputAst, templateIndex));\n      }\n    }\n  }\n\n  // These should be handled in the template or element directly.\n  readonly visitReference = invalid;\n  readonly visitVariable = invalid;\n  readonly visitTextAttribute = invalid;\n  readonly visitBoundAttribute = invalid;\n  readonly visitBoundEvent = invalid;\n\n  visitBoundText(text: t.BoundText) {\n    if (this.i18n) {\n      const value = text.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n      if (value instanceof Interpolation) {\n        this.i18n.appendBoundText(text.i18n!);\n        this.i18nAppendBindings(value.expressions);\n      }\n      return;\n    }\n\n    const nodeIndex = this.allocateDataSlot();\n\n    this.creationInstruction(text.sourceSpan, R3.text, [o.literal(nodeIndex)]);\n\n    const value = text.value.visit(this._valueConverter);\n    this.allocateBindingSlots(value);\n\n    if (value instanceof Interpolation) {\n      this.updateInstructionWithAdvance(\n          nodeIndex, text.sourceSpan, getTextInterpolationExpression(value),\n          () => this.getUpdateInstructionArguments(value));\n    } else {\n      error('Text nodes should be interpolated and never bound directly.');\n    }\n  }\n\n  visitText(text: t.Text) {\n    // when a text element is located within a translatable\n    // block, we exclude this text element from instructions set,\n    // since it will be captured in i18n content and processed at runtime\n    if (!this.i18n) {\n      this.creationInstruction(\n          text.sourceSpan, R3.text, [o.literal(this.allocateDataSlot()), o.literal(text.value)]);\n    }\n  }\n\n  visitIcu(icu: t.Icu) {\n    let initWasInvoked = false;\n\n    // if an ICU was created outside of i18n block, we still treat\n    // it as a translatable entity and invoke i18nStart and i18nEnd\n    // to generate i18n context and the necessary instructions\n    if (!this.i18n) {\n      initWasInvoked = true;\n      this.i18nStart(null, icu.i18n!, true);\n    }\n\n    const i18n = this.i18n!;\n    const vars = this.i18nBindProps(icu.vars);\n    const placeholders = this.i18nBindProps(icu.placeholders);\n\n    // output ICU directly and keep ICU reference in context\n    const message = icu.i18n! as i18n.Message;\n\n    // we always need post-processing function for ICUs, to make sure that:\n    // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n    // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n    // inside ICUs)\n    // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n    const transformFn = (raw: o.ReadVarExpr) => {\n      const params = {...vars, ...placeholders};\n      const formatted = formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false);\n      return invokeInstruction(null, R3.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n    };\n\n    // in case the whole i18n message is a single ICU - we do not need to\n    // create a separate top-level translation, we can use the root ref instead\n    // and make this ICU a top-level translation\n    // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n    // separately, so we do not pass placeholders into `i18nTranslate` function.\n    if (isSingleI18nIcu(i18n.meta)) {\n      this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n    } else {\n      // output ICU directly and keep ICU reference in context\n      const ref =\n          this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n      i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n    }\n\n    if (initWasInvoked) {\n      this.i18nEnd(null, true);\n    }\n    return null;\n  }\n\n  private allocateDataSlot() {\n    return this._dataIndex++;\n  }\n\n  getConstCount() {\n    return this._dataIndex;\n  }\n\n  getVarCount() {\n    return this._pureFunctionSlots;\n  }\n\n  getConsts(): ComponentDefConsts {\n    return this._constants;\n  }\n\n  getNgContentSelectors(): o.Expression|null {\n    return this._ngContentReservedSlots.length ?\n        this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n        null;\n  }\n\n  private bindingContext() {\n    return `${this._bindingContext++}`;\n  }\n\n  private templatePropertyBindings(\n      templateIndex: number, attrs: (t.BoundAttribute|t.TextAttribute)[]) {\n    const propertyBindings: Omit<Instruction, 'reference'>[] = [];\n\n    for (const input of attrs) {\n      if (!(input instanceof t.BoundAttribute)) {\n        continue;\n      }\n\n      const value = input.value.visit(this._valueConverter);\n      if (value === undefined) {\n        continue;\n      }\n\n      this.allocateBindingSlots(value);\n      if (value instanceof Interpolation) {\n        // Params typically contain attribute namespace and value sanitizer, which is applicable\n        // for regular HTML elements, but not applicable for <ng-template> (since props act as\n        // inputs to directives), so keep params array empty.\n        const params: any[] = [];\n\n        // prop=\"{{value}}\" case\n        this.interpolatedUpdateInstruction(\n            getPropertyInterpolationExpression(value), templateIndex, input.name, input, value,\n            params);\n      } else {\n        // [prop]=\"value\" case\n        propertyBindings.push({\n          span: input.sourceSpan,\n          paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), input.name)\n        });\n      }\n    }\n\n    for (const propertyBinding of propertyBindings) {\n      this.updateInstructionWithAdvance(\n          templateIndex, propertyBinding.span, R3.property, propertyBinding.paramsOrFn);\n    }\n  }\n\n  // Bindings must only be resolved after all local refs have been visited, so all\n  // instructions are queued in callbacks that execute once the initial pass has completed.\n  // Otherwise, we wouldn't be able to support local refs that are defined after their\n  // bindings. e.g. {{ foo }} <div #foo></div>\n  private instructionFn(\n      fns: Instruction[], span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn: InstructionParams, prepend: boolean = false): void {\n    fns[prepend ? 'unshift' : 'push']({span, reference, paramsOrFn});\n  }\n\n  private processStylingUpdateInstruction(\n      elementIndex: number, instruction: StylingInstruction|null) {\n    let allocateBindingSlots = 0;\n    if (instruction) {\n      for (const call of instruction.calls) {\n        allocateBindingSlots += call.allocateBindingSlots;\n        this.updateInstructionWithAdvance(\n            elementIndex, call.sourceSpan, instruction.reference,\n            () => call.params(\n                      value => (call.supportsInterpolation && value instanceof Interpolation) ?\n                          this.getUpdateInstructionArguments(value) :\n                          this.convertPropertyBinding(value)) as o.Expression[]);\n      }\n    }\n    return allocateBindingSlots;\n  }\n\n  private creationInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference, paramsOrFn?: InstructionParams,\n      prepend?: boolean) {\n    this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n  }\n\n  private updateInstructionWithAdvance(\n      nodeIndex: number, span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: InstructionParams) {\n    this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n    this.updateInstruction(span, reference, paramsOrFn);\n  }\n\n  private updateInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference, paramsOrFn?: InstructionParams) {\n    this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n  }\n\n  private addAdvanceInstructionIfNecessary(nodeIndex: number, span: ParseSourceSpan|null) {\n    if (nodeIndex !== this._currentIndex) {\n      const delta = nodeIndex - this._currentIndex;\n\n      if (delta < 1) {\n        throw new Error('advance instruction can only go forwards');\n      }\n\n      this.instructionFn(this._updateCodeFns, span, R3.advance, [o.literal(delta)]);\n      this._currentIndex = nodeIndex;\n    }\n  }\n\n  private allocatePureFunctionSlots(numSlots: number): number {\n    const originalSlots = this._pureFunctionSlots;\n    this._pureFunctionSlots += numSlots;\n    return originalSlots;\n  }\n\n  private allocateBindingSlots(value: AST|null) {\n    this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n  }\n\n  /**\n   * Gets an expression that refers to the implicit receiver. The implicit\n   * receiver is always the root level context.\n   */\n  private getImplicitReceiverExpr(): o.ReadVarExpr {\n    if (this._implicitReceiverExpr) {\n      return this._implicitReceiverExpr;\n    }\n\n    return this._implicitReceiverExpr = this.level === 0 ?\n        o.variable(CONTEXT_NAME) :\n        this._bindingScope.getOrCreateSharedContextVar(0);\n  }\n\n  private convertPropertyBinding(value: AST): o.Expression {\n    const convertedPropertyBinding =\n        convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n    const valExpr = convertedPropertyBinding.currValExpr;\n    this._tempVariables.push(...convertedPropertyBinding.stmts);\n    return valExpr;\n  }\n\n  /**\n   * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n   * the temp variables state with temp variables that were identified as needing to be created\n   * while visiting the arguments.\n   * @param value The original expression we will be resolving an arguments list from.\n   */\n  private getUpdateInstructionArguments(value: Interpolation): o.Expression[] {\n    const {args, stmts} =\n        convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n\n    this._tempVariables.push(...stmts);\n    return args;\n  }\n\n  /**\n   * Prepares all attribute expression values for the `TAttributes` array.\n   *\n   * The purpose of this function is to properly construct an attributes array that\n   * is passed into the `elementStart` (or just `element`) functions. Because there\n   * are many different types of attributes, the array needs to be constructed in a\n   * special way so that `elementStart` can properly evaluate them.\n   *\n   * The format looks like this:\n   *\n   * ```\n   * attrs = [prop, value, prop2, value2,\n   *   PROJECT_AS, selector,\n   *   CLASSES, class1, class2,\n   *   STYLES, style1, value1, style2, value2,\n   *   BINDINGS, name1, name2, name3,\n   *   TEMPLATE, name4, name5, name6,\n   *   I18N, name7, name8, ...]\n   * ```\n   *\n   * Note that this function will fully ignore all synthetic (@foo) attribute values\n   * because those values are intended to always be generated as property instructions.\n   */\n  private getAttributeExpressions(\n      elementName: string, renderAttributes: t.TextAttribute[], inputs: t.BoundAttribute[],\n      outputs: t.BoundEvent[], styles?: StylingBuilder,\n      templateAttrs: (t.BoundAttribute|t.TextAttribute)[] = [],\n      boundI18nAttrs: t.BoundAttribute[] = []): o.Expression[] {\n    const alreadySeen = new Set<string>();\n    const attrExprs: o.Expression[] = [];\n    let ngProjectAsAttr: t.TextAttribute|undefined;\n\n    for (const attr of renderAttributes) {\n      if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n        ngProjectAsAttr = attr;\n      }\n\n      // Note that static i18n attributes aren't in the i18n array,\n      // because they're treated in the same way as regular attributes.\n      if (attr.i18n) {\n        // When i18n attributes are present on elements with structural directives\n        // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n        // duplicate i18n translation blocks for `ÉµÉµtemplate` and `ÉµÉµelement` instruction\n        // attributes. So we do a cache lookup to see if suitable i18n translation block\n        // already exists.\n        const {i18nVarRefsCache} = this._constants;\n        let i18nVarRef: o.ReadVarExpr;\n        if (i18nVarRefsCache.has(attr.i18n)) {\n          i18nVarRef = i18nVarRefsCache.get(attr.i18n)!;\n        } else {\n          i18nVarRef = this.i18nTranslate(attr.i18n as i18n.Message);\n          i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n        }\n        attrExprs.push(o.literal(attr.name), i18nVarRef);\n      } else {\n        attrExprs.push(\n            ...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\n      }\n    }\n\n    // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n    // ngProjectAs marker in the attribute name slot.\n    if (ngProjectAsAttr) {\n      attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\n    }\n\n    function addAttrExpr(key: string|number, value?: o.Expression): void {\n      if (typeof key === 'string') {\n        if (!alreadySeen.has(key)) {\n          attrExprs.push(...getAttributeNameLiterals(key));\n          value !== undefined && attrExprs.push(value);\n          alreadySeen.add(key);\n        }\n      } else {\n        attrExprs.push(o.literal(key));\n      }\n    }\n\n    // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n    // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n    // as single property value cell by cell.\n    if (styles) {\n      styles.populateInitialStylingAttrs(attrExprs);\n    }\n\n    if (inputs.length || outputs.length) {\n      const attrsLengthBeforeInputs = attrExprs.length;\n\n      for (let i = 0; i < inputs.length; i++) {\n        const input = inputs[i];\n        // We don't want the animation and attribute bindings in the\n        // attributes array since they aren't used for directive matching.\n        if (input.type !== BindingType.Animation && input.type !== BindingType.Attribute) {\n          addAttrExpr(input.name);\n        }\n      }\n\n      for (let i = 0; i < outputs.length; i++) {\n        const output = outputs[i];\n        if (output.type !== ParsedEventType.Animation) {\n          addAttrExpr(output.name);\n        }\n      }\n\n      // this is a cheap way of adding the marker only after all the input/output\n      // values have been filtered (by not including the animation ones) and added\n      // to the expressions. The marker is important because it tells the runtime\n      // code that this is where attributes without values start...\n      if (attrExprs.length !== attrsLengthBeforeInputs) {\n        attrExprs.splice(attrsLengthBeforeInputs, 0, o.literal(core.AttributeMarker.Bindings));\n      }\n    }\n\n    if (templateAttrs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.Template));\n      templateAttrs.forEach(attr => addAttrExpr(attr.name));\n    }\n\n    if (boundI18nAttrs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.I18n));\n      boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\n    }\n\n    return attrExprs;\n  }\n\n  private addToConsts(expression: o.Expression): o.LiteralExpr {\n    if (o.isNull(expression)) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const consts = this._constants.constExpressions;\n\n    // Try to reuse a literal that's already in the array, if possible.\n    for (let i = 0; i < consts.length; i++) {\n      if (consts[i].isEquivalent(expression)) {\n        return o.literal(i);\n      }\n    }\n\n    return o.literal(consts.push(expression) - 1);\n  }\n\n  private addAttrsToConsts(attrs: o.Expression[]): o.LiteralExpr {\n    return attrs.length > 0 ? this.addToConsts(o.literalArr(attrs)) : o.TYPED_NULL_EXPR;\n  }\n\n  private prepareRefsArray(references: t.Reference[]): o.Expression {\n    if (!references || references.length === 0) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const refsParam = references.flatMap(reference => {\n      const slot = this.allocateDataSlot();\n      // Generate the update temporary.\n      const variableName = this._bindingScope.freshReferenceName();\n      const retrievalLevel = this.level;\n      const lhs = o.variable(variableName);\n      this._bindingScope.set(\n          retrievalLevel, reference.name, lhs,\n          DeclarationPriority.DEFAULT, (scope: BindingScope, relativeLevel: number) => {\n            // e.g. nextContext(2);\n            const nextContextStmt =\n                relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n\n            // e.g. const $foo$ = reference(1);\n            const refExpr = lhs.set(o.importExpr(R3.reference).callFn([o.literal(slot)]));\n            return nextContextStmt.concat(refExpr.toConstDecl());\n          }, true);\n\n      return [reference.name, reference.value];\n    });\n\n    return asLiteral(refsParam);\n  }\n\n  private prepareListenerParameter(tagName: string, outputAst: t.BoundEvent, index: number):\n      () => o.Expression[] {\n    return () => {\n      const eventName: string = outputAst.name;\n      const bindingFnName = outputAst.type === ParsedEventType.Animation ?\n          // synthetic @listener.foo values are treated the exact same as are standard listeners\n          prepareSyntheticListenerFunctionName(eventName, outputAst.phase!) :\n          sanitizeIdentifier(eventName);\n      const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\n      const scope = this._bindingScope.nestedScope(\n          this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n      return prepareEventListenerParameters(outputAst, handlerName, scope);\n    };\n  }\n}\n\nexport class ValueConverter extends AstMemoryEfficientTransformer {\n  private _pipeBindExprs: Call[] = [];\n\n  constructor(\n      private constantPool: ConstantPool, private allocateSlot: () => number,\n      private allocatePureFunctionSlots: (numSlots: number) => number,\n      private definePipe:\n          (name: string, localName: string, slot: number, value: o.Expression) => void) {\n    super();\n  }\n\n  // AstMemoryEfficientTransformer\n  override visitPipe(pipe: BindingPipe, context: any): AST {\n    // Allocate a slot to create the pipe\n    const slot = this.allocateSlot();\n    const slotPseudoLocal = `PIPE:${slot}`;\n    // Allocate one slot for the result plus one slot per pipe argument\n    const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n    const target = new PropertyRead(\n        pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan),\n        slotPseudoLocal);\n    const {identifier, isVarLength} = pipeBindingCallInfo(pipe.args);\n    this.definePipe(pipe.name, slotPseudoLocal, slot, o.importExpr(identifier));\n    const args: AST[] = [pipe.exp, ...pipe.args];\n    const convertedArgs: AST[] = isVarLength ?\n        this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n        this.visitAll(args);\n\n    const pipeBindExpr = new Call(\n        pipe.span, pipe.sourceSpan, target,\n        [\n          new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n          new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n          ...convertedArgs,\n        ],\n        null!);\n    this._pipeBindExprs.push(pipeBindExpr);\n    return pipeBindExpr;\n  }\n\n  updatePipeSlotOffsets(bindingSlots: number) {\n    this._pipeBindExprs.forEach((pipe: Call) => {\n      // update the slot offset arg (index 1) to account for binding slots\n      const slotOffset = pipe.args[1] as LiteralPrimitive;\n      (slotOffset.value as number) += bindingSlots;\n    });\n  }\n\n  override visitLiteralArray(array: LiteralArray, context: any): AST {\n    return new BuiltinFunctionCall(\n        array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\n          // If the literal has calculated (non-literal) elements transform it into\n          // calls to literal factories that compose the literal and will cache intermediate\n          // values.\n          const literal = o.literalArr(values);\n          return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n  }\n\n  override visitLiteralMap(map: LiteralMap, context: any): AST {\n    return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\n      // If the literal has calculated (non-literal) elements  transform it into\n      // calls to literal factories that compose the literal and will cache intermediate\n      // values.\n      const literal = o.literalMap(values.map(\n          (value, index) => ({key: map.keys[index].key, value, quoted: map.keys[index].quoted})));\n      return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n    });\n  }\n}\n\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [R3.pipeBind1, R3.pipeBind2, R3.pipeBind3, R3.pipeBind4];\n\nfunction pipeBindingCallInfo(args: o.Expression[]) {\n  const identifier = pipeBindingIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pipeBindV,\n    isVarLength: !identifier,\n  };\n}\n\nconst pureFunctionIdentifiers = [\n  R3.pureFunction0, R3.pureFunction1, R3.pureFunction2, R3.pureFunction3, R3.pureFunction4,\n  R3.pureFunction5, R3.pureFunction6, R3.pureFunction7, R3.pureFunction8\n];\n\nfunction pureFunctionCallInfo(args: o.Expression[]) {\n  const identifier = pureFunctionIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pureFunctionV,\n    isVarLength: !identifier,\n  };\n}\n\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff: number): o.Expression {\n  return o.importExpr(R3.nextContext)\n      .callFn(relativeLevelDiff > 1 ? [o.literal(relativeLevelDiff)] : []);\n}\n\nfunction getLiteralFactory(\n    constantPool: ConstantPool, literal: o.LiteralArrayExpr|o.LiteralMapExpr,\n    allocateSlots: (numSlots: number) => number): o.Expression {\n  const {literalFactory, literalFactoryArguments} = constantPool.getLiteralFactory(literal);\n  // Allocate 1 slot for the result plus 1 per argument\n  const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n  const {identifier, isVarLength} = pureFunctionCallInfo(literalFactoryArguments);\n\n  // Literal factories are pure functions that only need to be re-invoked when the parameters\n  // change.\n  const args = [o.literal(startSlot), literalFactory];\n\n  if (isVarLength) {\n    args.push(o.literalArr(literalFactoryArguments));\n  } else {\n    args.push(...literalFactoryArguments);\n  }\n\n  return o.importExpr(identifier).callFn(args);\n}\n\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name: string): o.LiteralExpr[] {\n  const [attributeNamespace, attributeName] = splitNsName(name);\n  const nameLiteral = o.literal(attributeName);\n\n  if (attributeNamespace) {\n    return [\n      o.literal(core.AttributeMarker.NamespaceURI), o.literal(attributeNamespace), nameLiteral\n    ];\n  }\n\n  return [nameLiteral];\n}\n\n/**\n * Function which is executed whenever a variable is referenced for the first time in a given\n * scope.\n *\n * It is expected that the function creates the `const localName = expression`; statement.\n */\nexport type DeclareLocalVarCallback = (scope: BindingScope, relativeLevel: number) => o.Statement[];\n\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\n/**\n * This is used when one refers to variable such as: 'let abc = nextContext(2).$implicit`.\n * - key to the map is the string literal `\"abc\"`.\n * - value `retrievalLevel` is the level from which this value can be retrieved, which is 2 levels\n * up in example.\n * - value `lhs` is the left hand side which is an AST representing `abc`.\n * - value `declareLocalCallback` is a callback that is invoked when declaring the local.\n * - value `declare` is true if this value needs to be declared.\n * - value `localRef` is true if we are storing a local reference\n * - value `priority` dictates the sorting priority of this var declaration compared\n * to other var declarations on the same retrieval level. For example, if there is a\n * context variable and a local ref accessing the same parent view, the context var\n * declaration should always come before the local ref declaration.\n */\ntype BindingData = {\n  retrievalLevel: number; lhs: o.Expression;\n  declareLocalCallback?: DeclareLocalVarCallback; declare: boolean; priority: number;\n};\n\n/**\n * The sorting priority of a local variable declaration. Higher numbers\n * mean the declaration will appear first in the generated code.\n */\nconst enum DeclarationPriority {\n  DEFAULT = 0,\n  CONTEXT = 1,\n  SHARED_CONTEXT = 2\n}\n\nexport class BindingScope implements LocalResolver {\n  /** Keeps a map from local variables to their BindingData. */\n  private map = new Map<string, BindingData>();\n  private referenceNameIndex = 0;\n  private restoreViewVariable: o.ReadVarExpr|null = null;\n  private usesRestoredViewContext = false;\n  static createRootScope(): BindingScope {\n    return new BindingScope();\n  }\n\n  private constructor(\n      public bindingLevel: number = 0, private parent: BindingScope|null = null,\n      public globals?: Set<string>) {\n    if (globals !== undefined) {\n      for (const name of globals) {\n        this.set(0, name, o.variable(name));\n      }\n    }\n  }\n\n  get(name: string): o.Expression|null {\n    let current: BindingScope|null = this;\n    while (current) {\n      let value = current.map.get(name);\n      if (value != null) {\n        if (current !== this) {\n          // make a local copy and reset the `declare` state\n          value = {\n            retrievalLevel: value.retrievalLevel,\n            lhs: value.lhs,\n            declareLocalCallback: value.declareLocalCallback,\n            declare: false,\n            priority: value.priority\n          };\n\n          // Cache the value locally.\n          this.map.set(name, value);\n          // Possibly generate a shared context var\n          this.maybeGenerateSharedContextVar(value);\n          this.maybeRestoreView();\n        }\n\n        if (value.declareLocalCallback && !value.declare) {\n          value.declare = true;\n        }\n        return value.lhs;\n      }\n      current = current.parent;\n    }\n\n    // If we get to this point, we are looking for a property on the top level component\n    // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n    // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n    // local var we used to store the component context, e.g. const $comp$ = x();\n    return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n  }\n\n  /**\n   * Create a local variable for later reference.\n   *\n   * @param retrievalLevel The level from which this value can be retrieved\n   * @param name Name of the variable.\n   * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n   * @param priority The sorting priority of this var\n   * @param declareLocalCallback The callback to invoke when declaring this local var\n   * @param localRef Whether or not this is a local ref\n   */\n  set(retrievalLevel: number, name: string, lhs: o.Expression,\n      priority: number = DeclarationPriority.DEFAULT,\n      declareLocalCallback?: DeclareLocalVarCallback, localRef?: true): BindingScope {\n    if (this.map.has(name)) {\n      if (localRef) {\n        // Do not throw an error if it's a local ref and do not update existing value,\n        // so the first defined ref is always returned.\n        return this;\n      }\n      error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n    }\n    this.map.set(name, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declare: false,\n      declareLocalCallback: declareLocalCallback,\n      priority: priority,\n    });\n    return this;\n  }\n\n  // Implemented as part of LocalResolver.\n  getLocal(name: string): (o.Expression|null) {\n    return this.get(name);\n  }\n\n  // Implemented as part of LocalResolver.\n  notifyImplicitReceiverUse(): void {\n    if (this.bindingLevel !== 0) {\n      // Since the implicit receiver is accessed in an embedded view, we need to\n      // ensure that we declare a shared context variable for the current template\n      // in the update variables.\n      this.map.get(SHARED_CONTEXT_KEY + 0)!.declare = true;\n    }\n  }\n\n  nestedScope(level: number, globals?: Set<string>): BindingScope {\n    const newScope = new BindingScope(level, this, globals);\n    if (level > 0) newScope.generateSharedContextVar(0);\n    return newScope;\n  }\n\n  /**\n   * Gets or creates a shared context variable and returns its expression. Note that\n   * this does not mean that the shared variable will be declared. Variables in the\n   * binding scope will be only declared if they are used.\n   */\n  getOrCreateSharedContextVar(retrievalLevel: number): o.ReadVarExpr {\n    const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n    if (!this.map.has(bindingKey)) {\n      this.generateSharedContextVar(retrievalLevel);\n    }\n    // Shared context variables are always generated as \"ReadVarExpr\".\n    return this.map.get(bindingKey)!.lhs as o.ReadVarExpr;\n  }\n\n  getSharedContextName(retrievalLevel: number): o.ReadVarExpr|null {\n    const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n    // Shared context variables are always generated as \"ReadVarExpr\".\n    return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs as o.ReadVarExpr : null;\n  }\n\n  maybeGenerateSharedContextVar(value: BindingData) {\n    if (value.priority === DeclarationPriority.CONTEXT &&\n        value.retrievalLevel < this.bindingLevel) {\n      const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n      if (sharedCtxObj) {\n        sharedCtxObj.declare = true;\n      } else {\n        this.generateSharedContextVar(value.retrievalLevel);\n      }\n    }\n  }\n\n  generateSharedContextVar(retrievalLevel: number) {\n    const lhs = o.variable(CONTEXT_NAME + this.freshReferenceName());\n    this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declareLocalCallback: (scope: BindingScope, relativeLevel: number) => {\n        // const ctx_r0 = nextContext(2);\n        return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n      },\n      declare: false,\n      priority: DeclarationPriority.SHARED_CONTEXT,\n    });\n  }\n\n  getComponentProperty(name: string): o.Expression {\n    const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0)!;\n    componentValue.declare = true;\n    this.maybeRestoreView();\n    return componentValue.lhs.prop(name);\n  }\n\n  maybeRestoreView() {\n    // View restoration is required for listener instructions inside embedded views, because\n    // they only run in creation mode and they can have references to the context object.\n    // If the context object changes in update mode, the reference will be incorrect, because\n    // it was established during creation.\n    if (this.isListenerScope()) {\n      if (!this.parent!.restoreViewVariable) {\n        // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n        this.parent!.restoreViewVariable = o.variable(this.parent!.freshReferenceName());\n      }\n      this.restoreViewVariable = this.parent!.restoreViewVariable;\n    }\n  }\n\n  restoreViewStatement(): o.Statement|null {\n    if (this.restoreViewVariable) {\n      const restoreCall = invokeInstruction(null, R3.restoreView, [this.restoreViewVariable]);\n      // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\n      // depending on whether it is being used.\n      return this.usesRestoredViewContext ?\n          o.variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :\n          restoreCall.toStmt();\n    }\n    return null;\n  }\n\n  viewSnapshotStatements(): o.Statement[] {\n    // const $state$ = getCurrentView();\n    return this.restoreViewVariable ?\n        [\n          this.restoreViewVariable.set(invokeInstruction(null, R3.getCurrentView, [])).toConstDecl()\n        ] :\n        [];\n  }\n\n  isListenerScope() {\n    return this.parent && this.parent.bindingLevel === this.bindingLevel;\n  }\n\n  variableDeclarations(): o.Statement[] {\n    let currentContextLevel = 0;\n    return Array.from(this.map.values())\n               .filter(value => value.declare)\n               .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n               .reduce((stmts: o.Statement[], value: BindingData) => {\n                 const levelDiff = this.bindingLevel - value.retrievalLevel;\n                 const currStmts =\n                     value.declareLocalCallback!(this, levelDiff - currentContextLevel);\n                 currentContextLevel = levelDiff;\n                 return stmts.concat(currStmts);\n               }, []) as o.Statement[];\n  }\n\n\n  freshReferenceName(): string {\n    let current: BindingScope = this;\n    // Find the top scope as it maintains the global reference count\n    while (current.parent) current = current.parent;\n    const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n    return ref;\n  }\n\n  hasRestoreViewVariable(): boolean {\n    return !!this.restoreViewVariable;\n  }\n\n  notifyRestoredViewContextUse(): void {\n    this.usesRestoredViewContext = true;\n  }\n}\n\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nexport function createCssSelector(\n    elementName: string, attributes: {[name: string]: string}): CssSelector {\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elementNameNoNs);\n\n  Object.getOwnPropertyNames(attributes).forEach((name) => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n\n  return cssSelector;\n}\n\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute: t.TextAttribute): o.Expression[] {\n  // Parse the attribute value into a CssSelectorList. Note that we only take the\n  // first selector, because we don't support multiple selectors in ngProjectAs.\n  const parsedR3Selector = core.parseSelectorToR3Selector(attribute.value)[0];\n  return [o.literal(core.AttributeMarker.ProjectAs), asLiteral(parsedR3Selector)];\n}\n\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.propertyInterpolate;\n    case 3:\n      return R3.propertyInterpolate1;\n    case 5:\n      return R3.propertyInterpolate2;\n    case 7:\n      return R3.propertyInterpolate3;\n    case 9:\n      return R3.propertyInterpolate4;\n    case 11:\n      return R3.propertyInterpolate5;\n    case 13:\n      return R3.propertyInterpolate6;\n    case 15:\n      return R3.propertyInterpolate7;\n    case 17:\n      return R3.propertyInterpolate8;\n    default:\n      return R3.propertyInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 3:\n      return R3.attributeInterpolate1;\n    case 5:\n      return R3.attributeInterpolate2;\n    case 7:\n      return R3.attributeInterpolate3;\n    case 9:\n      return R3.attributeInterpolate4;\n    case 11:\n      return R3.attributeInterpolate5;\n    case 13:\n      return R3.attributeInterpolate6;\n    case 15:\n      return R3.attributeInterpolate7;\n    case 17:\n      return R3.attributeInterpolate8;\n    default:\n      return R3.attributeInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.textInterpolate;\n    case 3:\n      return R3.textInterpolate1;\n    case 5:\n      return R3.textInterpolate2;\n    case 7:\n      return R3.textInterpolate3;\n    case 9:\n      return R3.textInterpolate4;\n    case 11:\n      return R3.textInterpolate5;\n    case 13:\n      return R3.textInterpolate6;\n    case 15:\n      return R3.textInterpolate7;\n    case 17:\n      return R3.textInterpolate8;\n    default:\n      return R3.textInterpolateV;\n  }\n}\n\n/**\n * Options that can be used to modify how a template is parsed by `parseTemplate()`.\n */\nexport interface ParseTemplateOptions {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n  /**\n   * Preserve original line endings instead of normalizing '\\r\\n' endings to '\\n'.\n   */\n  preserveLineEndings?: boolean;\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n\n  /**\n   * Render `$localize` message ids with additional legacy message ids.\n   *\n   * This option defaults to `true` but in the future the default will be flipped.\n   *\n   * For now set this option to false if you have migrated the translation files to use the new\n   * `$localize` message id format and you are not using compile time translation merging.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n\n  /**\n   * Whether to always attempt to convert the parsed HTML AST to an R3 AST, despite HTML or i18n\n   * Meta parse errors.\n   *\n   *\n   * This option is useful in the context of the language service, where we want to get as much\n   * information as possible, despite any errors in the HTML. As an example, a user may be adding\n   * a new tag and expecting autocomplete on that tag. In this scenario, the HTML is in an errored\n   * state, as there is an incomplete open tag. However, we're still able to convert the HTML AST\n   * nodes to R3 AST nodes in order to provide information for the language service.\n   *\n   * Note that even when `true` the HTML parse and i18n errors are still appended to the errors\n   * output, but this is done after converting the HTML AST to R3 AST.\n   */\n  alwaysAttemptHtmlToR3AstConversion?: boolean;\n\n  /**\n   * Include HTML Comment nodes in a top-level comments array on the returned R3 AST.\n   *\n   * This option is required by tooling that needs to know the location of comment nodes within the\n   * AST. A concrete example is @angular-eslint which requires this in order to enable\n   * \"eslint-disable\" comments within HTML templates, which then allows users to turn off specific\n   * rules on a case by case basis, instead of for their whole project within a configuration file.\n   */\n  collectCommentNodes?: boolean;\n}\n\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nexport function parseTemplate(\n    template: string, templateUrl: string, options: ParseTemplateOptions = {}): ParsedTemplate {\n  const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n  const bindingParser = makeBindingParser(interpolationConfig);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(\n      template, templateUrl,\n      {leadingTriviaChars: LEADING_TRIVIA_CHARS, ...options, tokenizeExpansionForms: true});\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\n      parseResult.errors.length > 0) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  let rootNodes: html.Node[] = parseResult.rootNodes;\n\n  // process i18n meta information (scan attributes, generate ids)\n  // before we run whitespace removal process, because existing i18n\n  // extraction process (ng extract-i18n) relies on a raw content to generate\n  // message ids\n  const i18nMetaVisitor = new I18nMetaVisitor(\n      interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces,\n      enableI18nLegacyMessageIdFormat);\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\n      i18nMetaResult.errors.length > 0) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  rootNodes = i18nMetaResult.rootNodes;\n\n  if (!preserveWhitespaces) {\n    rootNodes = html.visitAll(new WhitespaceVisitor(), rootNodes);\n\n    // run i18n meta visitor again in case whitespaces are removed (because that might affect\n    // generated i18n message content) and first pass indicated that i18n content is present in a\n    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n    // mimic existing extraction process (ng extract-i18n)\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = html.visitAll(\n          new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n    }\n  }\n\n  const {nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes} = htmlAstToRender3Ast(\n      rootNodes, bindingParser, {collectCommentNodes: !!options.collectCommentNodes});\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n\n  const parsedTemplate: ParsedTemplate = {\n    interpolationConfig,\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors\n  };\n\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\n\nconst elementRegistry = new DomElementSchemaRegistry();\n\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nexport function makeBindingParser(\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): BindingParser {\n  return new BindingParser(new Parser(new Lexer()), interpolationConfig, elementRegistry, []);\n}\n\nexport function resolveSanitizationFn(context: core.SecurityContext, isAttribute?: boolean) {\n  switch (context) {\n    case core.SecurityContext.HTML:\n      return o.importExpr(R3.sanitizeHtml);\n    case core.SecurityContext.SCRIPT:\n      return o.importExpr(R3.sanitizeScript);\n    case core.SecurityContext.STYLE:\n      // the compiler does not fill in an instruction for [style.prop?] binding\n      // values because the style algorithm knows internally what props are subject\n      // to sanitization (only [attr.style] values are explicitly sanitized)\n      return isAttribute ? o.importExpr(R3.sanitizeStyle) : null;\n    case core.SecurityContext.URL:\n      return o.importExpr(R3.sanitizeUrl);\n    case core.SecurityContext.RESOURCE_URL:\n      return o.importExpr(R3.sanitizeResourceUrl);\n    default:\n      return null;\n  }\n}\n\nfunction trustedConstAttribute(tagName: string, attr: t.TextAttribute): o.Expression {\n  const value = asLiteral(attr.value);\n  if (isTrustedTypesSink(tagName, attr.name)) {\n    switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\n      case core.SecurityContext.HTML:\n        return o.taggedTemplate(\n            o.importExpr(R3.trustConstantHtml),\n            new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined,\n            attr.valueSpan);\n      // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n      case core.SecurityContext.RESOURCE_URL:\n        return o.taggedTemplate(\n            o.importExpr(R3.trustConstantResourceUrl),\n            new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined,\n            attr.valueSpan);\n      default:\n        return value;\n    }\n  } else {\n    return value;\n  }\n}\n\nfunction isSingleElementTemplate(children: t.Node[]): children is[t.Element] {\n  return children.length === 1 && children[0] instanceof t.Element;\n}\n\nfunction isTextNode(node: t.Node): boolean {\n  return node instanceof t.Text || node instanceof t.BoundText || node instanceof t.Icu;\n}\n\nfunction isIframeElement(tagName: string): boolean {\n  return tagName.toLowerCase() === 'iframe';\n}\n\nfunction hasTextChildrenOnly(children: t.Node[]): boolean {\n  return children.every(isTextNode);\n}\n\nfunction getBindingFunctionParams(\n    deferredParams: () => (o.Expression | o.Expression[]), name?: string,\n    eagerParams?: o.Expression[]) {\n  return () => {\n    const value = deferredParams();\n    const fnParams = Array.isArray(value) ? value : [value];\n    if (eagerParams) {\n      fnParams.push(...eagerParams);\n    }\n    if (name) {\n      // We want the property name to always be the first function parameter.\n      fnParams.unshift(o.literal(name));\n    }\n    return fnParams;\n  };\n}\n\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nexport function getTranslationDeclStmts(\n    message: i18n.Message, variable: o.ReadVarExpr, closureVar: o.ReadVarExpr,\n    params: {[name: string]: o.Expression} = {},\n    transformFn?: (raw: o.ReadVarExpr) => o.Expression): o.Statement[] {\n  const statements: o.Statement[] = [\n    declareI18nVariable(variable),\n    o.ifStmt(\n        createClosureModeGuard(),\n        createGoogleGetMsgStatements(variable, message, closureVar, params),\n        createLocalizeStatements(\n            variable, message, formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false))),\n  ];\n\n  if (transformFn) {\n    statements.push(new o.ExpressionStatement(variable.set(transformFn(variable))));\n  }\n\n  return statements;\n}\n\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard(): o.BinaryOperatorExpr {\n  return o.typeofExpr(o.variable(NG_I18N_CLOSURE_MODE))\n      .notIdentical(o.literal('undefined', o.STRING_TYPE))\n      .and(o.variable(NG_I18N_CLOSURE_MODE));\n}\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedTemplate {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * Any errors from parsing the template the first time.\n   *\n   * `null` if there are no errors. Otherwise, the array of errors is guaranteed to be non-empty.\n   */\n  errors: ParseError[]|null;\n\n  /**\n   * The template AST, parsed from the template.\n   */\n  nodes: t.Node[];\n\n  /**\n   * Any styleUrls extracted from the metadata.\n   */\n  styleUrls: string[];\n\n  /**\n   * Any inline styles extracted from the metadata.\n   */\n  styles: string[];\n\n  /**\n   * Any ng-content selectors extracted from the template.\n   */\n  ngContentSelectors: string[];\n\n  /**\n   * Any R3 Comment Nodes extracted from the template when the `collectCommentNodes` parse template\n   * option is enabled.\n   */\n  commentNodes?: t.Comment[];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {convertPropertyBinding} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, ParsedEvent, ParsedEventType, ParsedProperty} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\nimport {isIframeSecuritySensitiveAttr} from '../../schema/dom_security_schema';\nimport {CssSelector} from '../../selector';\nimport {ShadowCss} from '../../shadow_css';\nimport {emitTemplateFn, transformTemplate} from '../../template/pipeline/src/emit';\nimport {ingest} from '../../template/pipeline/src/ingest';\nimport {USE_TEMPLATE_PIPELINE} from '../../template/pipeline/switch';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error} from '../../util';\nimport {BoundEvent} from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {prepareSyntheticListenerFunctionName, prepareSyntheticPropertyName, R3CompiledExpression, typeWithParameters} from '../util';\n\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata, R3TemplateDependency} from './api';\nimport {MIN_STYLING_BINDING_SLOTS_REQUIRED, StylingBuilder, StylingInstructionCall} from './styling_builder';\nimport {BindingScope, makeBindingParser, prepareEventListenerParameters, renderFlagCheckIfStmt, resolveSanitizationFn, TemplateDefinitionBuilder, ValueConverter} from './template';\nimport {asLiteral, conditionallyCreateDirectiveBindingLiteral, CONTEXT_NAME, DefinitionMap, getInstructionStatements, getQueryPredicate, Instruction, RENDER_FLAGS, TEMPORARY_NAME, temporaryAllocator} from './util';\n\n\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\n\n\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\nfunction baseDirectiveFields(\n    meta: R3DirectiveMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): DefinitionMap {\n  const definitionMap = new DefinitionMap();\n  const selectors = core.parseSelectorToR3Selector(meta.selector);\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.type.value);\n\n  // e.g. `selectors: [['', 'someDir', '']]`\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n\n  if (meta.queries.length > 0) {\n    // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n    definitionMap.set(\n        'contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n\n  if (meta.viewQueries.length) {\n    definitionMap.set(\n        'viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  }\n\n  // e.g. `hostBindings: (rf, ctx) => { ... }\n  definitionMap.set(\n      'hostBindings',\n      createHostBindingsFunction(\n          meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '',\n          meta.name, definitionMap));\n\n  // e.g 'inputs: {a: 'a'}`\n  definitionMap.set('inputs', conditionallyCreateDirectiveBindingLiteral(meta.inputs, true));\n\n  // e.g 'outputs: {a: 'a'}`\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', o.literalArr(meta.exportAs.map(e => o.literal(e))));\n  }\n\n  if (meta.isStandalone) {\n    definitionMap.set('standalone', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(\n    definitionMap: DefinitionMap,\n    meta: R3DirectiveMetadata|R3ComponentMetadata<R3TemplateDependency>) {\n  // e.g. `features: [NgOnChangesFeature]`\n  const features: o.Expression[] = [];\n\n  const providers = meta.providers;\n  const viewProviders = (meta as R3ComponentMetadata<R3TemplateDependency>).viewProviders;\n  if (providers || viewProviders) {\n    const args = [providers || new o.LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(o.importExpr(R3.ProvidersFeature).callFn(args));\n  }\n\n  if (meta.usesInheritance) {\n    features.push(o.importExpr(R3.InheritDefinitionFeature));\n  }\n  if (meta.fullInheritance) {\n    features.push(o.importExpr(R3.CopyDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(o.importExpr(R3.NgOnChangesFeature));\n  }\n  // TODO: better way of differentiating component vs directive metadata.\n  if (meta.hasOwnProperty('template') && meta.isStandalone) {\n    features.push(o.importExpr(R3.StandaloneFeature));\n  }\n  if (meta.hostDirectives?.length) {\n    features.push(o.importExpr(R3.HostDirectivesFeature).callFn([createHostDirectivesFeatureArg(\n        meta.hostDirectives)]));\n  }\n  if (features.length) {\n    definitionMap.set('features', o.literalArr(features));\n  }\n}\n\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nexport function compileDirectiveFromMetadata(\n    meta: R3DirectiveMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): R3CompiledExpression {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression =\n      o.importExpr(R3.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nexport function compileComponentFromMetadata(\n    meta: R3ComponentMetadata<R3TemplateDependency>, constantPool: ConstantPool,\n    bindingParser: BindingParser): R3CompiledExpression {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n\n  // e.g. `attr: [\"class\", \".my.app\"]`\n  // This is optional an only included if the first selector of a component specifies attributes.\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set(\n          'attrs',\n          constantPool.getConstLiteral(\n              o.literalArr(selectorAttributes.map(\n                  value => value != null ? o.literal(value) : o.literal(undefined))),\n              /* forceShared */ true));\n    }\n  }\n\n  // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n  const templateTypeName = meta.name;\n  const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n\n  const changeDetection = meta.changeDetection;\n\n  // Template compilation is currently conditional as we're in the process of rewriting it.\n  if (!USE_TEMPLATE_PIPELINE) {\n    // This is the main path currently used in compilation, which compiles the template with the\n    // legacy `TemplateDefinitionBuilder`.\n\n    const template = meta.template;\n    const templateBuilder = new TemplateDefinitionBuilder(\n        constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName,\n        R3.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n\n    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n\n    // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is\n    //     instantiated.\n    const ngContentSelectors = templateBuilder.getNgContentSelectors();\n    if (ngContentSelectors) {\n      definitionMap.set('ngContentSelectors', ngContentSelectors);\n    }\n\n    // e.g. `decls: 2`\n    // definitionMap.set('decls', o.literal(tpl.root.decls!));\n    definitionMap.set('decls', o.literal(templateBuilder.getConstCount()));\n\n    // e.g. `vars: 2`\n    // definitionMap.set('vars', o.literal(tpl.root.vars!));\n    definitionMap.set('vars', o.literal(templateBuilder.getVarCount()));\n\n    // Generate `consts` section of ComponentDef:\n    // - either as an array:\n    //   `consts: [['one', 'two'], ['three', 'four']]`\n    // - or as a factory function in case additional statements are present (to support i18n):\n    //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0];\n    //   }`\n    const {constExpressions, prepareStatements} = templateBuilder.getConsts();\n    if (constExpressions.length > 0) {\n      let constsExpr: o.LiteralArrayExpr|o.FunctionExpr = o.literalArr(constExpressions);\n      // Prepare statements are present - turn `consts` into a function.\n      if (prepareStatements.length > 0) {\n        constsExpr = o.fn([], [...prepareStatements, new o.ReturnStatement(constsExpr)]);\n      }\n      definitionMap.set('consts', constsExpr);\n    }\n\n    definitionMap.set('template', templateFunctionExpression);\n  } else {\n    // This path compiles the template using the prototype template pipeline. First the template is\n    // ingested into IR:\n    const tpl = ingest(meta.name, meta.template.nodes);\n\n    // Then the IR is transformed to prepare it for cod egeneration.\n    transformTemplate(tpl);\n\n    // Finally we emit the template function:\n    const templateFn = emitTemplateFn(tpl, constantPool);\n    definitionMap.set('decls', o.literal(tpl.root.decls as number));\n    definitionMap.set('vars', o.literal(tpl.root.vars as number));\n    if (tpl.consts.length > 0) {\n      definitionMap.set('consts', o.literalArr(tpl.consts));\n    }\n    definitionMap.set('template', templateFn);\n  }\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set(\n        'dependencies',\n        compileDeclarationList(\n            o.literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n  }\n\n  if (meta.encapsulation === null) {\n    meta.encapsulation = core.ViewEncapsulation.Emulated;\n  }\n\n  // e.g. `styles: [str1, str2]`\n  if (meta.styles && meta.styles.length) {\n    const styleValues = meta.encapsulation == core.ViewEncapsulation.Emulated ?\n        compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n        meta.styles;\n    const styleNodes = styleValues.reduce((result, style) => {\n      if (style.trim().length > 0) {\n        result.push(constantPool.getConstLiteral(o.literal(style)));\n      }\n      return result;\n    }, [] as o.Expression[]);\n\n    if (styleNodes.length > 0) {\n      definitionMap.set('styles', o.literalArr(styleNodes));\n    }\n  } else if (meta.encapsulation === core.ViewEncapsulation.Emulated) {\n    // If there is no style, don't generate css selectors on elements\n    meta.encapsulation = core.ViewEncapsulation.None;\n  }\n\n  // Only set view encapsulation if it's not the default value\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set('encapsulation', o.literal(meta.encapsulation));\n  }\n\n  // e.g. `animation: [trigger('123', [])]`\n  if (meta.animations !== null) {\n    definitionMap.set(\n        'data', o.literalMap([{key: 'animation', value: meta.animations, quoted: false}]));\n  }\n\n  // Only set the change detection flag if it's defined and it's not the default.\n  if (changeDetection != null && changeDetection !== core.ChangeDetectionStrategy.Default) {\n    definitionMap.set('changeDetection', o.literal(changeDetection));\n  }\n\n  const expression =\n      o.importExpr(R3.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createComponentType(meta: R3ComponentMetadata<R3TemplateDependency>): o.Type {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  typeParams.push(o.expressionType(o.literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  return o.expressionType(o.importExpr(R3.ComponentDeclaration, typeParams));\n}\n\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(\n    list: o.LiteralArrayExpr, mode: DeclarationListEmitMode): o.Expression {\n  switch (mode) {\n    case DeclarationListEmitMode.Direct:\n      // directives: [MyDir],\n      return list;\n    case DeclarationListEmitMode.Closure:\n      // directives: function () { return [MyDir]; }\n      return o.fn([], [new o.ReturnStatement(list)]);\n    case DeclarationListEmitMode.ClosureResolved:\n      // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n      const resolvedList = list.prop('map').callFn([o.importExpr(R3.resolveForwardRef)]);\n      return o.fn([], [new o.ReturnStatement(resolvedList)]);\n  }\n}\n\nfunction prepareQueryParams(query: R3QueryMetadata, constantPool: ConstantPool): o.Expression[] {\n  const parameters = [getQueryPredicate(query, constantPool), o.literal(toQueryFlags(query))];\n  if (query.read) {\n    parameters.push(query.read);\n  }\n  return parameters;\n}\n\n/**\n * A set of flags to be used with Queries.\n *\n * NOTE: Ensure changes here are in sync with `packages/core/src/render3/interfaces/query.ts`\n */\nexport const enum QueryFlags {\n  /**\n   * No flags\n   */\n  none = 0b0000,\n\n  /**\n   * Whether or not the query should descend into children.\n   */\n  descendants = 0b0001,\n\n  /**\n   * The query can be computed statically and hence can be assigned eagerly.\n   *\n   * NOTE: Backwards compatibility with ViewEngine.\n   */\n  isStatic = 0b0010,\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly = 0b0100,\n}\n\n/**\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query: R3QueryMetadata): number {\n  return (query.descendants ? QueryFlags.descendants : QueryFlags.none) |\n      (query.static ? QueryFlags.isStatic : QueryFlags.none) |\n      (query.emitDistinctChangesOnly ? QueryFlags.emitDistinctChangesOnly : QueryFlags.none);\n}\n\nfunction convertAttributesToExpressions(attributes: {[name: string]: o.Expression}):\n    o.Expression[] {\n  const values: o.Expression[] = [];\n  for (let key of Object.getOwnPropertyNames(attributes)) {\n    const value = attributes[key];\n    values.push(o.literal(key), value);\n  }\n  return values;\n}\n\n// Define and update any content queries\nfunction createContentQueriesFunction(\n    queries: R3QueryMetadata[], constantPool: ConstantPool, name?: string): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  for (const query of queries) {\n    // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n    createStatements.push(\n        o.importExpr(R3.contentQuery)\n            .callFn([o.variable('dirIndex'), ...prepareQueryParams(query, constantPool) as any])\n            .toStmt());\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o.variable(CONTEXT_NAME)\n                                .prop(query.propertyName)\n                                .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return o.fn(\n      [\n        new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null),\n        new o.FnParam('dirIndex', null)\n      ],\n      [\n        renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n        renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements)\n      ],\n      o.INFERRED_TYPE, null, contentQueriesFnName);\n}\n\nfunction stringAsType(str: string): o.Type {\n  return o.expressionType(o.literal(str));\n}\n\nfunction stringMapAsLiteralExpression(map: {[key: string]: string|string[]}): o.LiteralMapExpr {\n  const mapValues = Object.keys(map).map(key => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: o.literal(value),\n      quoted: true,\n    };\n  });\n\n  return o.literalMap(mapValues);\n}\n\nfunction stringArrayAsType(arr: ReadonlyArray<string|null>): o.Type {\n  return arr.length > 0 ? o.expressionType(o.literalArr(arr.map(value => o.literal(value)))) :\n                          o.NONE_TYPE;\n}\n\nfunction createBaseDirectiveTypeParams(meta: R3DirectiveMetadata): o.Type[] {\n  // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n  // string literal, which must be on one line.\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n\n  return [\n    typeWithParameters(meta.type.type, meta.typeArgumentCount),\n    selectorForType !== null ? stringAsType(selectorForType) : o.NONE_TYPE,\n    meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : o.NONE_TYPE,\n    o.expressionType(getInputsTypeExpression(meta)),\n    o.expressionType(stringMapAsLiteralExpression(meta.outputs)),\n    stringArrayAsType(meta.queries.map(q => q.propertyName)),\n  ];\n}\n\nfunction getInputsTypeExpression(meta: R3DirectiveMetadata): o.Expression {\n  return o.literalMap(Object.keys(meta.inputs).map(key => {\n    const value = meta.inputs[key];\n    return {\n      key,\n      value: o.literalMap([\n        {key: 'alias', value: o.literal(value.bindingPropertyName), quoted: true},\n        {key: 'required', value: o.literal(value.required), quoted: true}\n      ]),\n      quoted: true\n    };\n  }));\n}\n\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createDirectiveType(meta: R3DirectiveMetadata): o.Type {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  // Directives have no NgContentSelectors slot, but instead express a `never` type\n  // so that future fields align.\n  typeParams.push(o.NONE_TYPE);\n  typeParams.push(o.expressionType(o.literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  return o.expressionType(o.importExpr(R3.DirectiveDeclaration, typeParams));\n}\n\n// Define and update any view queries\nfunction createViewQueriesFunction(\n    viewQueries: R3QueryMetadata[], constantPool: ConstantPool, name?: string): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  viewQueries.forEach((query: R3QueryMetadata) => {\n    // creation, e.g. r3.viewQuery(somePredicate, true);\n    const queryDefinition =\n        o.importExpr(R3.viewQuery).callFn(prepareQueryParams(query, constantPool));\n    createStatements.push(queryDefinition.toStmt());\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o.variable(CONTEXT_NAME)\n                                .prop(query.propertyName)\n                                .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return o.fn(\n      [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n      [\n        renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n        renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements)\n      ],\n      o.INFERRED_TYPE, null, viewQueryFnName);\n}\n\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(\n    hostBindingsMetadata: R3HostMetadata, typeSourceSpan: ParseSourceSpan,\n    bindingParser: BindingParser, constantPool: ConstantPool, selector: string, name: string,\n    definitionMap: DefinitionMap): o.Expression|null {\n  const bindingContext = o.variable(CONTEXT_NAME);\n  const styleBuilder = new StylingBuilder(bindingContext);\n\n  const {styleAttr, classAttr} = hostBindingsMetadata.specialAttributes;\n  if (styleAttr !== undefined) {\n    styleBuilder.registerStyleAttr(styleAttr);\n  }\n  if (classAttr !== undefined) {\n    styleBuilder.registerClassAttr(classAttr);\n  }\n\n  const createInstructions: Instruction[] = [];\n  const updateInstructions: Instruction[] = [];\n  const updateVariables: o.Statement[] = [];\n\n  const hostBindingSourceSpan = typeSourceSpan;\n\n  // Calculate host event bindings\n  const eventBindings = bindingParser.createDirectiveHostEventAsts(\n      hostBindingsMetadata.listeners, hostBindingSourceSpan);\n  if (eventBindings && eventBindings.length) {\n    createInstructions.push(...createHostListeners(eventBindings, name));\n  }\n\n  // Calculate the host property bindings\n  const bindings = bindingParser.createBoundHostProperties(\n      hostBindingsMetadata.properties, hostBindingSourceSpan);\n  const allOtherBindings: ParsedProperty[] = [];\n\n  // We need to calculate the total amount of binding slots required by\n  // all the instructions together before any value conversions happen.\n  // Value conversions may require additional slots for interpolation and\n  // bindings with pipes. These calculates happen after this block.\n  let totalHostVarsCount = 0;\n  bindings && bindings.forEach((binding: ParsedProperty) => {\n    const stylingInputWasSet = styleBuilder.registerInputBasedOnName(\n        binding.name, binding.expression, hostBindingSourceSpan);\n    if (stylingInputWasSet) {\n      totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n    } else {\n      allOtherBindings.push(binding);\n      totalHostVarsCount++;\n    }\n  });\n\n  let valueConverter: ValueConverter;\n  const getValueConverter = () => {\n    if (!valueConverter) {\n      const hostVarsCountFn = (numSlots: number): number => {\n        const originalVarsCount = totalHostVarsCount;\n        totalHostVarsCount += numSlots;\n        return originalVarsCount;\n      };\n      valueConverter = new ValueConverter(\n          constantPool,\n          () => error('Unexpected node'),  // new nodes are illegal here\n          hostVarsCountFn,\n          () => error('Unexpected pipe'));  // pipes are illegal here\n    }\n    return valueConverter;\n  };\n\n  const propertyBindings: o.Expression[][] = [];\n  const attributeBindings: o.Expression[][] = [];\n  const syntheticHostBindings: o.Expression[][] = [];\n\n  for (const binding of allOtherBindings) {\n    // resolve literal arrays and literal objects\n    const value = binding.expression.visit(getValueConverter());\n    const bindingExpr = bindingFn(bindingContext, value);\n\n    const {bindingName, instruction, isAttribute} = getBindingNameAndInstruction(binding);\n\n    const securityContexts =\n        bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(context => context !== core.SecurityContext.NONE);\n\n    let sanitizerFn: o.ExternalExpr|null = null;\n    if (securityContexts.length) {\n      if (securityContexts.length === 2 &&\n          securityContexts.indexOf(core.SecurityContext.URL) > -1 &&\n          securityContexts.indexOf(core.SecurityContext.RESOURCE_URL) > -1) {\n        // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n        // of different security contexts. In this case we use special sanitization function and\n        // select the actual sanitizer at runtime based on a tag name that is provided while\n        // invoking sanitization function.\n        sanitizerFn = o.importExpr(R3.sanitizeUrlOrResourceUrl);\n      } else {\n        sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n      }\n    }\n    const instructionParams = [o.literal(bindingName), bindingExpr.currValExpr];\n    if (sanitizerFn) {\n      instructionParams.push(sanitizerFn);\n    } else {\n      // If there was no sanitization function found based on the security context\n      // of an attribute/property binding - check whether this attribute/property is\n      // one of the security-sensitive <iframe> attributes.\n      // Note: for host bindings defined on a directive, we do not try to find all\n      // possible places where it can be matched, so we can not determine whether\n      // the host element is an <iframe>. In this case, if an attribute/binding\n      // name is in the `IFRAME_SECURITY_SENSITIVE_ATTRS` set - append a validation\n      // function, which would be invoked at runtime and would have access to the\n      // underlying DOM element, check if it's an <iframe> and if so - runs extra checks.\n      if (isIframeSecuritySensitiveAttr(bindingName)) {\n        instructionParams.push(o.importExpr(R3.validateIframeAttribute));\n      }\n    }\n\n    updateVariables.push(...bindingExpr.stmts);\n\n    if (instruction === R3.hostProperty) {\n      propertyBindings.push(instructionParams);\n    } else if (instruction === R3.attribute) {\n      attributeBindings.push(instructionParams);\n    } else if (instruction === R3.syntheticHostProperty) {\n      syntheticHostBindings.push(instructionParams);\n    } else {\n      updateInstructions.push({reference: instruction, paramsOrFn: instructionParams, span: null});\n    }\n  }\n\n  for (const bindingParams of propertyBindings) {\n    updateInstructions.push({reference: R3.hostProperty, paramsOrFn: bindingParams, span: null});\n  }\n\n  for (const bindingParams of attributeBindings) {\n    updateInstructions.push({reference: R3.attribute, paramsOrFn: bindingParams, span: null});\n  }\n\n  for (const bindingParams of syntheticHostBindings) {\n    updateInstructions.push(\n        {reference: R3.syntheticHostProperty, paramsOrFn: bindingParams, span: null});\n  }\n\n  // since we're dealing with directives/components and both have hostBinding\n  // functions, we need to generate a special hostAttrs instruction that deals\n  // with both the assignment of styling as well as static attributes to the host\n  // element. The instruction below will instruct all initial styling (styling\n  // that is inside of a host binding within a directive/component) to be attached\n  // to the host element alongside any of the provided host attributes that were\n  // collected earlier.\n  const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n  styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n\n  if (styleBuilder.hasBindings) {\n    // finally each binding that was registered in the statement above will need to be added to\n    // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n    // are evaluated and updated for the element.\n    styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\n      for (const call of instruction.calls) {\n        // we subtract a value of `1` here because the binding slot was already allocated\n        // at the top of this method when all the input bindings were counted.\n        totalHostVarsCount +=\n            Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n\n        updateInstructions.push({\n          reference: instruction.reference,\n          paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),\n          span: null\n        });\n      }\n    });\n  }\n\n  if (totalHostVarsCount) {\n    definitionMap.set('hostVars', o.literal(totalHostVarsCount));\n  }\n\n  if (createInstructions.length > 0 || updateInstructions.length > 0) {\n    const hostBindingsFnName = name ? `${name}_HostBindings` : null;\n    const statements: o.Statement[] = [];\n    if (createInstructions.length > 0) {\n      statements.push(renderFlagCheckIfStmt(\n          core.RenderFlags.Create, getInstructionStatements(createInstructions)));\n    }\n    if (updateInstructions.length > 0) {\n      statements.push(renderFlagCheckIfStmt(\n          core.RenderFlags.Update,\n          updateVariables.concat(getInstructionStatements(updateInstructions))));\n    }\n    return o.fn(\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)], statements,\n        o.INFERRED_TYPE, null, hostBindingsFnName);\n  }\n\n  return null;\n}\n\nfunction bindingFn(implicit: any, value: AST) {\n  return convertPropertyBinding(null, implicit, value, 'b');\n}\n\nfunction convertStylingCall(\n    call: StylingInstructionCall, bindingContext: any, bindingFn: Function) {\n  return call.params(value => bindingFn(bindingContext, value).currValExpr);\n}\n\nfunction getBindingNameAndInstruction(binding: ParsedProperty):\n    {bindingName: string, instruction: o.ExternalReference, isAttribute: boolean} {\n  let bindingName = binding.name;\n  let instruction!: o.ExternalReference;\n\n  // Check to see if this is an attr binding or a property binding\n  const attrMatches = bindingName.match(ATTR_REGEX);\n  if (attrMatches) {\n    bindingName = attrMatches[1];\n    instruction = R3.attribute;\n  } else {\n    if (binding.isAnimation) {\n      bindingName = prepareSyntheticPropertyName(bindingName);\n      // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n      // in the context of the component and not the parent. Therefore there is a special\n      // compatibility instruction available for this purpose.\n      instruction = R3.syntheticHostProperty;\n    } else {\n      instruction = R3.hostProperty;\n    }\n  }\n\n  return {bindingName, instruction, isAttribute: !!attrMatches};\n}\n\nfunction createHostListeners(eventBindings: ParsedEvent[], name?: string): Instruction[] {\n  const listenerParams: o.Expression[][] = [];\n  const syntheticListenerParams: o.Expression[][] = [];\n  const instructions: Instruction[] = [];\n\n  for (const binding of eventBindings) {\n    let bindingName = binding.name && sanitizeIdentifier(binding.name);\n    const bindingFnName = binding.type === ParsedEventType.Animation ?\n        prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n        bindingName;\n    const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\n    const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n\n    if (binding.type == ParsedEventType.Animation) {\n      syntheticListenerParams.push(params);\n    } else {\n      listenerParams.push(params);\n    }\n  }\n\n  for (const params of syntheticListenerParams) {\n    instructions.push({reference: R3.syntheticHostListener, paramsOrFn: params, span: null});\n  }\n\n  for (const params of listenerParams) {\n    instructions.push({reference: R3.listener, paramsOrFn: params, span: null});\n  }\n\n  return instructions;\n}\n\n\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n// Represents the groups in the above regex.\nconst enum HostBindingGroup {\n  // group 1: \"prop\" from \"[prop]\", or \"attr.role\" from \"[attr.role]\", or @anim from [@anim]\n  Binding = 1,\n\n  // group 2: \"event\" from \"(event)\"\n  Event = 2,\n}\n\n// Defines Host Bindings structure that contains attributes, listeners, and properties,\n// parsed from the `host` object defined for a Type.\nexport interface ParsedHostBindings {\n  attributes: {[key: string]: o.Expression};\n  listeners: {[key: string]: string};\n  properties: {[key: string]: string};\n  specialAttributes: {styleAttr?: string; classAttr?: string;};\n}\n\nexport function parseHostBindings(host: {[key: string]: string|o.Expression}): ParsedHostBindings {\n  const attributes: {[key: string]: o.Expression} = {};\n  const listeners: {[key: string]: string} = {};\n  const properties: {[key: string]: string} = {};\n  const specialAttributes: {styleAttr?: string; classAttr?: string;} = {};\n\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = o.literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[HostBindingGroup.Binding] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Property binding must be string`);\n      }\n      // synthetic properties (the ones that have a `@` as a prefix)\n      // are still treated the same as regular properties. Therefore\n      // there is no point in storing them in a separate map.\n      properties[matches[HostBindingGroup.Binding]] = value;\n    } else if (matches[HostBindingGroup.Event] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[HostBindingGroup.Event]] = value;\n    }\n  }\n\n  return {attributes, listeners, properties, specialAttributes};\n}\n\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nexport function verifyHostBindings(\n    bindings: ParsedHostBindings, sourceSpan: ParseSourceSpan): ParseError[] {\n  // TODO: abstract out host bindings verification logic and use it instead of\n  // creating events and properties ASTs to detect errors (FW-996)\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n  return bindingParser.errors;\n}\n\nfunction compileStyles(styles: string[], selector: string, hostSelector: string): string[] {\n  const shadowCss = new ShadowCss();\n  return styles.map(style => {\n    return shadowCss!.shimCssText(style, selector, hostSelector);\n  });\n}\n\nfunction createHostDirectivesType(meta: R3DirectiveMetadata): o.Type {\n  if (!meta.hostDirectives?.length) {\n    return o.NONE_TYPE;\n  }\n\n  return o.expressionType(o.literalArr(meta.hostDirectives.map(hostMeta => o.literalMap([\n    {key: 'directive', value: o.typeofExpr(hostMeta.directive.type), quoted: false},\n    {key: 'inputs', value: stringMapAsLiteralExpression(hostMeta.inputs || {}), quoted: false},\n    {key: 'outputs', value: stringMapAsLiteralExpression(hostMeta.outputs || {}), quoted: false},\n  ]))));\n}\n\nfunction createHostDirectivesFeatureArg(\n    hostDirectives: NonNullable<R3DirectiveMetadata['hostDirectives']>): o.Expression {\n  const expressions: o.Expression[] = [];\n  let hasForwardRef = false;\n\n  for (const current of hostDirectives) {\n    // Use a shorthand if there are no inputs or outputs.\n    if (!current.inputs && !current.outputs) {\n      expressions.push(current.directive.type);\n    } else {\n      const keys = [{key: 'directive', value: current.directive.type, quoted: false}];\n\n      if (current.inputs) {\n        const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n        if (inputsLiteral) {\n          keys.push({key: 'inputs', value: inputsLiteral, quoted: false});\n        }\n      }\n\n      if (current.outputs) {\n        const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n        if (outputsLiteral) {\n          keys.push({key: 'outputs', value: outputsLiteral, quoted: false});\n        }\n      }\n\n      expressions.push(o.literalMap(keys));\n    }\n\n    if (current.isForwardReference) {\n      hasForwardRef = true;\n    }\n  }\n\n  // If there's a forward reference, we generate a `function() { return [HostDir] }`,\n  // otherwise we can save some bytes by using a plain array, e.g. `[HostDir]`.\n  return hasForwardRef ?\n      new o.FunctionExpr([], [new o.ReturnStatement(o.literalArr(expressions))]) :\n      o.literalArr(expressions);\n}\n\n/**\n * Converts an input/output mapping object literal into an array where the even keys are the\n * public name of the binding and the odd ones are the name it was aliased to. E.g.\n * `{inputOne: 'aliasOne', inputTwo: 'aliasTwo'}` will become\n * `['inputOne', 'aliasOne', 'inputTwo', 'aliasTwo']`.\n *\n * This conversion is necessary, because hosts bind to the public name of the host directive and\n * keeping the mapping in an object literal will break for apps using property renaming.\n */\nexport function createHostDirectivesMappingArray(mapping: Record<string, string>):\n    o.LiteralArrayExpr|null {\n  const elements: o.LiteralExpr[] = [];\n\n  for (const publicName in mapping) {\n    if (mapping.hasOwnProperty(publicName)) {\n      elements.push(o.literal(publicName), o.literal(mapping[publicName]));\n    }\n  }\n\n  return elements.length > 0 ? o.literalArr(elements) : null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An interface for retrieving documents by URL that the compiler uses to\n * load templates.\n *\n * This is an abstract class, rather than an interface, so that it can be used\n * as injection token.\n */\nexport abstract class ResourceLoader {\n  abstract get(url: string): Promise<string>|string;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {CompilerFacade, CoreEnvironment, ExportedCompilerFacade, InputMap, OpaqueValue, R3ComponentMetadataFacade, R3DeclareComponentFacade, R3DeclareDependencyMetadataFacade, R3DeclareDirectiveDependencyFacade, R3DeclareDirectiveFacade, R3DeclareFactoryFacade, R3DeclareInjectableFacade, R3DeclareInjectorFacade, R3DeclareNgModuleFacade, R3DeclarePipeDependencyFacade, R3DeclarePipeFacade, R3DeclareQueryMetadataFacade, R3DependencyMetadataFacade, R3DirectiveMetadataFacade, R3FactoryDefMetadataFacade, R3InjectableMetadataFacade, R3InjectorMetadataFacade, R3NgModuleMetadataFacade, R3PipeMetadataFacade, R3QueryMetadataFacade, R3TemplateDependencyFacade} from './compiler_facade_interface';\nimport {ConstantPool} from './constant_pool';\nimport {ChangeDetectionStrategy, HostBinding, HostListener, Input, Output, ViewEncapsulation} from './core';\nimport {compileInjectable} from './injectable_compiler_2';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\nimport {DeclareVarStmt, Expression, literal, LiteralExpr, Statement, StmtModifier, WrappedNodeExpr} from './output/output_ast';\nimport {JitEvaluator} from './output/output_jit';\nimport {ParseError, ParseSourceSpan, r3JitTypeSourceSpan} from './parse_util';\nimport {compileFactoryFunction, FactoryTarget, R3DependencyMetadata} from './render3/r3_factory';\nimport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nimport {R3JitReflector} from './render3/r3_jit';\nimport {compileNgModule, compileNgModuleDeclarationExpression, R3NgModuleMetadata, R3SelectorScopeMode} from './render3/r3_module_compiler';\nimport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nimport {createMayBeForwardRefExpression, ForwardRefHandling, getSafePropertyAccessString, MaybeForwardRefExpression, wrapReference} from './render3/util';\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3DirectiveDependencyMetadata, R3DirectiveMetadata, R3HostDirectiveMetadata, R3HostMetadata, R3PipeDependencyMetadata, R3QueryMetadata, R3TemplateDependency, R3TemplateDependencyKind, R3TemplateDependencyMetadata} from './render3/view/api';\nimport {compileComponentFromMetadata, compileDirectiveFromMetadata, ParsedHostBindings, parseHostBindings, verifyHostBindings} from './render3/view/compiler';\nimport {makeBindingParser, parseTemplate} from './render3/view/template';\nimport {ResourceLoader} from './resource_loader';\nimport {DomElementSchemaRegistry} from './schema/dom_element_schema_registry';\n\nexport class CompilerFacadeImpl implements CompilerFacade {\n  FactoryTarget = FactoryTarget;\n  ResourceLoader = ResourceLoader;\n  private elementSchemaRegistry = new DomElementSchemaRegistry();\n\n  constructor(private jitEvaluator = new JitEvaluator()) {}\n\n  compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, facade: R3PipeMetadataFacade):\n      any {\n    const metadata: R3PipeMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      deps: null,\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n      isStandalone: facade.isStandalone,\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compilePipeDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclarePipeFacade): any {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectable(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3InjectableMetadataFacade): any {\n    const {expression, statements} = compileInjectable(\n        {\n          name: facade.name,\n          type: wrapReference(facade.type),\n          typeArgumentCount: facade.typeArgumentCount,\n          providedIn: computeProvidedIn(facade.providedIn),\n          useClass: convertToProviderExpression(facade, 'useClass'),\n          useFactory: wrapExpression(facade, 'useFactory'),\n          useValue: convertToProviderExpression(facade, 'useValue'),\n          useExisting: convertToProviderExpression(facade, 'useExisting'),\n          deps: facade.deps?.map(convertR3DependencyMetadata),\n        },\n        /* resolveForwardRefs */ true);\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjectableDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3DeclareInjectableFacade): any {\n    const {expression, statements} = compileInjectable(\n        {\n          name: facade.type.name,\n          type: wrapReference(facade.type),\n          typeArgumentCount: 0,\n          providedIn: computeProvidedIn(facade.providedIn),\n          useClass: convertToProviderExpression(facade, 'useClass'),\n          useFactory: wrapExpression(facade, 'useFactory'),\n          useValue: convertToProviderExpression(facade, 'useValue'),\n          useExisting: convertToProviderExpression(facade, 'useExisting'),\n          deps: facade.deps?.map(convertR3DeclareDependencyMetadata),\n        },\n        /* resolveForwardRefs */ true);\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjector(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3InjectorMetadataFacade): any {\n    const meta: R3InjectorMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      providers: facade.providers && facade.providers.length > 0 ?\n          new WrappedNodeExpr(facade.providers) :\n          null,\n      imports: facade.imports.map(i => new WrappedNodeExpr(i)),\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectorDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareInjectorFacade): any {\n    const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModule(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3NgModuleMetadataFacade): any {\n    const meta: R3NgModuleMetadata = {\n      type: wrapReference(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      publicDeclarationTypes: null,  // only needed for types in AOT\n      imports: facade.imports.map(wrapReference),\n      includeImportTypes: true,\n      exports: facade.exports.map(wrapReference),\n      selectorScopeMode: R3SelectorScopeMode.Inline,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModuleDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareNgModuleFacade): any {\n    const expression = compileNgModuleDeclarationExpression(declaration);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileDirective(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3DirectiveMetadataFacade): any {\n    const meta: R3DirectiveMetadata = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  compileDirectiveDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareDirectiveFacade): any {\n    const typeSourceSpan =\n        this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileDirectiveFromMeta(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadata): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n        res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n\n  compileComponent(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3ComponentMetadataFacade): any {\n    // Parse the template and check for errors.\n    const {template, interpolation} = parseJitTemplate(\n        facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces,\n        facade.interpolation);\n\n    // Compile the component metadata, including template, into an expression.\n    const meta: R3ComponentMetadata<R3TemplateDependency> = {\n      ...facade,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n      declarationListEmitMode: DeclarationListEmitMode.Direct,\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation,\n      interpolation,\n      changeDetection: facade.changeDetection,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                                                    null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n\n  compileComponentDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareComponentFacade): any {\n    const typeSourceSpan =\n        this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileComponentFromMeta(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      meta: R3ComponentMetadata<R3TemplateDependency>): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser(meta.interpolation);\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n        res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n\n  compileFactory(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3FactoryDefMetadataFacade) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      target: meta.target,\n    });\n    return this.jitExpression(\n        factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n\n  compileFactoryDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DeclareFactoryFacade) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.type.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: 0,\n      deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :\n                                       meta.deps,\n      target: meta.target,\n    });\n    return this.jitExpression(\n        factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n\n  /**\n   * JIT compiles an expression and returns the result of executing that expression.\n   *\n   * @param def the definition which will be compiled and executed to get the value to patch\n   * @param context an object map of @angular/core symbol names to symbols which will be available\n   * in the context of the compiled expression\n   * @param sourceUrl a URL to use for the source map of the compiled expression\n   * @param preStatements a collection of statements that should be evaluated before the expression.\n   */\n  private jitExpression(\n      def: Expression, context: {[key: string]: any}, sourceUrl: string,\n      preStatements: Statement[]): any {\n    // The ConstantPool may contain Statements which declare variables used in the final expression.\n    // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n    // declaration of $def which is set to the expression being compiled.\n    const statements: Statement[] = [\n      ...preStatements,\n      new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported),\n    ];\n\n    const res = this.jitEvaluator.evaluateStatements(\n        sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n    return res['$def'];\n  }\n}\n\nfunction convertToR3QueryMetadata(facade: R3QueryMetadataFacade): R3QueryMetadata {\n  return {\n    ...facade,\n    predicate: convertQueryPredicate(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly,\n  };\n}\n\nfunction convertQueryDeclarationToMetadata(declaration: R3DeclareQueryMetadataFacade):\n    R3QueryMetadata {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: convertQueryPredicate(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n  };\n}\n\nfunction convertQueryPredicate(predicate: OpaqueValue|string[]): MaybeForwardRefExpression|\n    string[] {\n  return Array.isArray(predicate) ?\n      // The predicate is an array of strings so pass it through.\n      predicate :\n      // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.\n      createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), ForwardRefHandling.Wrapped);\n}\n\nfunction convertDirectiveFacadeToMetadata(facade: R3DirectiveMetadataFacade): R3DirectiveMetadata {\n  const inputsFromMetadata = parseInputsArray(facade.inputs || []);\n  const outputsFromMetadata = parseMappingStringArray(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType: InputMap = {};\n  const outputsFromType: Record<string, string> = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] = {\n            bindingPropertyName: ann.alias || field,\n            classPropertyName: field,\n            required: ann.required || false\n          };\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.alias || field;\n        }\n      });\n    }\n  }\n\n  return {\n    ...facade,\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    deps: null,\n    host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n    inputs: {...inputsFromMetadata, ...inputsFromType},\n    outputs: {...outputsFromMetadata, ...outputsFromType},\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    fullInheritance: false,\n    hostDirectives: convertHostDirectivesToMetadata(facade),\n  };\n}\n\nfunction convertDeclareDirectiveFacadeToMetadata(\n    declaration: R3DeclareDirectiveFacade, typeSourceSpan: ParseSourceSpan): R3DirectiveMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ? inputsMappingToInputMetadata(declaration.inputs) : {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n                                                     null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {usesOnChanges: declaration.usesOnChanges ?? false},\n    deps: null,\n    typeArgumentCount: 0,\n    fullInheritance: false,\n    isStandalone: declaration.isStandalone ?? false,\n    hostDirectives: convertHostDirectivesToMetadata(declaration),\n  };\n}\n\nfunction convertHostDeclarationToMetadata(host: R3DeclareDirectiveFacade['host'] = {}):\n    R3HostMetadata {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute,\n    },\n  };\n}\n\nfunction convertHostDirectivesToMetadata(\n    metadata: R3DeclareDirectiveFacade|R3DirectiveMetadataFacade): R3HostDirectiveMetadata[]|null {\n  if (metadata.hostDirectives?.length) {\n    return metadata.hostDirectives.map(hostDirective => {\n      return typeof hostDirective === 'function' ?\n          {\n            directive: wrapReference(hostDirective),\n            inputs: null,\n            outputs: null,\n            isForwardReference: false\n          } :\n          {\n            directive: wrapReference(hostDirective.directive),\n            isForwardReference: false,\n            inputs: hostDirective.inputs ? parseMappingStringArray(hostDirective.inputs) : null,\n            outputs: hostDirective.outputs ? parseMappingStringArray(hostDirective.outputs) : null,\n          };\n    });\n  }\n\n  return null;\n}\n\nfunction convertOpaqueValuesToExpressions(obj: {[key: string]: OpaqueValue}):\n    {[key: string]: WrappedNodeExpr<unknown>} {\n  const result: {[key: string]: WrappedNodeExpr<unknown>} = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\n\nfunction convertDeclareComponentFacadeToMetadata(\n    decl: R3DeclareComponentFacade, typeSourceSpan: ParseSourceSpan,\n    sourceMapUrl: string): R3ComponentMetadata<R3TemplateDependencyMetadata> {\n  const {template, interpolation} = parseJitTemplate(\n      decl.template, decl.type.name, sourceMapUrl, decl.preserveWhitespaces ?? false,\n      decl.interpolation);\n\n  const declarations: R3TemplateDependencyMetadata[] = [];\n  if (decl.dependencies) {\n    for (const innerDep of decl.dependencies) {\n      switch (innerDep.kind) {\n        case 'directive':\n        case 'component':\n          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n          break;\n        case 'pipe':\n          declarations.push(convertPipeDeclarationToMetadata(innerDep));\n          break;\n      }\n    }\n  } else if (decl.components || decl.directives || decl.pipes) {\n    // Existing declarations on NPM may not be using the new `dependencies` merged field, and may\n    // have separate fields for dependencies instead. Unify them for JIT compilation.\n    decl.components &&\n        declarations.push(...decl.components.map(\n            dir => convertDirectiveDeclarationToMetadata(dir, /* isComponent */ true)));\n    decl.directives &&\n        declarations.push(\n            ...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n  }\n\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n    template,\n    styles: decl.styles ?? [],\n    declarations,\n    viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) :\n                                                      null,\n    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n    changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: decl.encapsulation ?? ViewEncapsulation.Emulated,\n    interpolation,\n    declarationListEmitMode: DeclarationListEmitMode.ClosureResolved,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n  };\n}\n\nfunction convertDeclarationFacadeToMetadata(declaration: R3TemplateDependencyFacade):\n    R3TemplateDependency {\n  return {\n    ...declaration,\n    type: new WrappedNodeExpr(declaration.type),\n  };\n}\n\nfunction convertDirectiveDeclarationToMetadata(\n    declaration: R3DeclareDirectiveDependencyFacade,\n    isComponent: true|null = null): R3DirectiveDependencyMetadata {\n  return {\n    kind: R3TemplateDependencyKind.Directive,\n    isComponent: isComponent || declaration.kind === 'component',\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null,\n  };\n}\n\nfunction convertPipeMapToMetadata(pipes: R3DeclareComponentFacade['pipes']):\n    R3PipeDependencyMetadata[] {\n  if (!pipes) {\n    return [];\n  }\n\n  return Object.keys(pipes).map(name => {\n    return {\n      kind: R3TemplateDependencyKind.Pipe,\n      name,\n      type: new WrappedNodeExpr(pipes[name]),\n    };\n  });\n}\n\nfunction convertPipeDeclarationToMetadata(pipe: R3DeclarePipeDependencyFacade):\n    R3PipeDependencyMetadata {\n  return {\n    kind: R3TemplateDependencyKind.Pipe,\n    name: pipe.name,\n    type: new WrappedNodeExpr(pipe.type),\n  };\n}\n\nfunction parseJitTemplate(\n    template: string, typeName: string, sourceMapUrl: string, preserveWhitespaces: boolean,\n    interpolation: [string, string]|undefined) {\n  const interpolationConfig =\n      interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\n  // Parse the template and check for errors.\n  const parsed = parseTemplate(template, sourceMapUrl, {preserveWhitespaces, interpolationConfig});\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map(err => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  return {template: parsed, interpolation: interpolationConfig};\n}\n\n/**\n * Convert the expression, if present to an `R3ProviderExpression`.\n *\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n * use `ForwardRefHandling.None`.\n */\nfunction convertToProviderExpression(obj: any, property: string): MaybeForwardRefExpression|\n    undefined {\n  if (obj.hasOwnProperty(property)) {\n    return createMayBeForwardRefExpression(\n        new WrappedNodeExpr(obj[property]), ForwardRefHandling.None);\n  } else {\n    return undefined;\n  }\n}\n\nfunction wrapExpression(obj: any, property: string): WrappedNodeExpr<any>|undefined {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\n\nfunction computeProvidedIn(providedIn: Function|string|null|undefined): MaybeForwardRefExpression {\n  const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) :\n                                                        new LiteralExpr(providedIn ?? null);\n  // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.\n  return createMayBeForwardRefExpression(expression, ForwardRefHandling.None);\n}\n\nfunction convertR3DependencyMetadataArray(facades: R3DependencyMetadataFacade[]|null|\n                                          undefined): R3DependencyMetadata[]|null {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\n\nfunction convertR3DependencyMetadata(facade: R3DependencyMetadataFacade): R3DependencyMetadata {\n  const isAttributeDep = facade.attribute != null;  // both `null` and `undefined`\n  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n  // `attribute` rather than the `token`.\n  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(\n      token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\n\nfunction convertR3DeclareDependencyMetadata(facade: R3DeclareDependencyMetadataFacade):\n    R3DependencyMetadata {\n  const isAttributeDep = facade.attribute ?? false;\n  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(\n      token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false,\n      facade.skipSelf ?? false);\n}\n\nfunction createR3DependencyMetadata(\n    token: WrappedNodeExpr<unknown>|null, isAttributeDep: boolean, host: boolean, optional: boolean,\n    self: boolean, skipSelf: boolean): R3DependencyMetadata {\n  // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n  // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n  // marker.\n  const attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {token, attributeNameType, host, optional, self, skipSelf};\n}\n\nfunction extractHostBindings(\n    propMetadata: {[key: string]: any[]}, sourceSpan: ParseSourceSpan,\n    host?: {[key: string]: string}): ParsedHostBindings {\n  // First parse the declarations from the metadata.\n  const bindings = parseHostBindings(host || {});\n\n  // After that check host bindings for errors\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map((error: ParseError) => error.msg).join('\\n'));\n  }\n\n  // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`).\n          bindings.properties[ann.hostPropertyName || field] =\n              getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n\n  return bindings;\n}\n\nfunction isHostBinding(value: any): value is HostBinding {\n  return value.ngMetadataName === 'HostBinding';\n}\n\nfunction isHostListener(value: any): value is HostListener {\n  return value.ngMetadataName === 'HostListener';\n}\n\n\nfunction isInput(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction isOutput(value: any): value is Output {\n  return value.ngMetadataName === 'Output';\n}\n\nfunction inputsMappingToInputMetadata(inputs: Record<string, string|[string, string]>) {\n  return Object.keys(inputs).reduce<InputMap>((result, key) => {\n    const value = inputs[key];\n    result[key] = typeof value === 'string' ?\n        {bindingPropertyName: value, classPropertyName: value, required: false} :\n        {bindingPropertyName: value[0], classPropertyName: value[1], required: false};\n    return result;\n  }, {});\n}\n\nfunction parseInputsArray(values: (string|{name: string, alias?: string, required?: boolean})[]) {\n  return values.reduce<InputMap>((results, value) => {\n    if (typeof value === 'string') {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      results[classPropertyName] = {bindingPropertyName, classPropertyName, required: false};\n    } else {\n      results[value.name] = {\n        bindingPropertyName: value.alias || value.name,\n        classPropertyName: value.name,\n        required: value.required || false\n      };\n    }\n    return results;\n  }, {});\n}\n\nfunction parseMappingStringArray(values: string[]): Record<string, string> {\n  return values.reduce<Record<string, string>>((results, value) => {\n    const [alias, fieldName] = parseMappingString(value);\n    results[fieldName] = alias;\n    return results;\n  }, {});\n}\n\nfunction parseMappingString(value: string): [alias: string, fieldName: string] {\n  // Either the value is 'field' or 'field: property'. In the first case, `property` will\n  // be undefined, in which case the field name should also be used as the property name.\n  const [fieldName, bindingPropertyName] = value.split(':', 2).map(str => str.trim());\n  return [bindingPropertyName ?? fieldName, fieldName];\n}\n\nfunction convertDeclarePipeFacadeToMetadata(declaration: R3DeclarePipeFacade): R3PipeMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n    isStandalone: declaration.isStandalone ?? false,\n  };\n}\n\nfunction convertDeclareInjectorFacadeToMetadata(declaration: R3DeclareInjectorFacade):\n    R3InjectorMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    providers: declaration.providers !== undefined && declaration.providers.length > 0 ?\n        new WrappedNodeExpr(declaration.providers) :\n        null,\n    imports: declaration.imports !== undefined ?\n        declaration.imports.map(i => new WrappedNodeExpr(i)) :\n        [],\n  };\n}\n\nexport function publishFacade(global: any) {\n  const ng: ExportedCompilerFacade = global.ng || (global.ng = {});\n  ng.ÉµcompilerFacade = new CompilerFacadeImpl();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n\nimport {Version} from './util';\n\nexport const VERSION = new Version('16.0.0');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseTreeResult} from '../ml_parser/parser';\n\nimport * as i18n from './i18n_ast';\nimport {createI18nMessageFactory, I18nMessageFactory} from './i18n_parser';\nimport {I18nError} from './parse_util';\nimport {TranslationBundle} from './translation_bundle';\n\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n\n/**\n * Extract translatable messages from an html AST\n */\nexport function extractMessages(\n    nodes: html.Node[], interpolationConfig: InterpolationConfig, implicitTags: string[],\n    implicitAttrs: {[k: string]: string[]}): ExtractionResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.extract(nodes, interpolationConfig);\n}\n\nexport function mergeTranslations(\n    nodes: html.Node[], translations: TranslationBundle, interpolationConfig: InterpolationConfig,\n    implicitTags: string[], implicitAttrs: {[k: string]: string[]}): ParseTreeResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations, interpolationConfig);\n}\n\nexport class ExtractionResult {\n  constructor(public messages: i18n.Message[], public errors: I18nError[]) {}\n}\n\nenum _VisitorMode {\n  Extract,\n  Merge\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor implements html.Visitor {\n  // Using non-null assertions because all variables are (re)set in init()\n\n  private _depth!: number;\n\n  // <el i18n>...</el>\n  private _inI18nNode!: boolean;\n  private _inImplicitNode!: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  private _inI18nBlock!: boolean;\n  private _blockMeaningAndDesc!: string;\n  private _blockChildren!: html.Node[];\n  private _blockStartDepth!: number;\n\n  // {<icu message>}\n  private _inIcu!: boolean;\n\n  // set to void 0 when not in a section\n  private _msgCountAtSectionStart: number|undefined;\n  private _errors!: I18nError[];\n  private _mode!: _VisitorMode;\n\n  // _VisitorMode.Extract only\n  private _messages!: i18n.Message[];\n\n  // _VisitorMode.Merge only\n  private _translations!: TranslationBundle;\n  private _createI18nMessage!: I18nMessageFactory;\n\n\n  constructor(private _implicitTags: string[], private _implicitAttrs: {[k: string]: string[]}) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(nodes: html.Node[], interpolationConfig: InterpolationConfig): ExtractionResult {\n    this._init(_VisitorMode.Extract, interpolationConfig);\n\n    nodes.forEach(node => node.visit(this, null));\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ExtractionResult(this._messages, this._errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n      nodes: html.Node[], translations: TranslationBundle,\n      interpolationConfig: InterpolationConfig): ParseTreeResult {\n    this._init(_VisitorMode.Merge, interpolationConfig);\n    this._translations = translations;\n\n    // Construct a single fake root element\n    const wrapper = new html.Element('wrapper', [], nodes, undefined!, undefined!, undefined);\n\n    const translatedNode = wrapper.visit(this, null);\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      return new html.ExpansionCase(\n          icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan,\n          icuCase.expSourceSpan);\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this._mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this._inIcu;\n\n    if (!this._inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new html.Expansion(\n          icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n\n    this._inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    const isOpening = _isOpeningComment(comment);\n\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n\n    const isClosing = _isClosingComment(comment);\n\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n          if (!i18nCommentsWarned && <any>console && <any>console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            // TODO(ocombe): use a log service once there is a public one available\n            console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${\n                comment.sourceSpan.start}${details})`);\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc =\n              comment.value!.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc)!;\n            // merge attributes in sections\n            const nodes = this._translateMessage(comment, message);\n            return html.visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element|null {\n    this._mayBeAddBlockChildren(el);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const i18nAttr = _getI18nAttr(el);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n        !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(el.children, i18nMeta)!;\n        translatedChildNodes = this._translateMessage(el, message);\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(el);\n        html.visitAll(this, el.children);\n        if (isTranslatable) this._closeTranslatableSection(el, el.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(\n            el, 'Could not mark an element as translatable inside a translatable section');\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, el.children);\n      }\n    }\n\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || el.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this._visitAttributesOf(el);\n\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n\n    if (this._mode === _VisitorMode.Merge) {\n      const translatedAttrs = this._translateAttributes(el);\n      return new html.Element(\n          el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan,\n          el.endSourceSpan);\n    }\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error('unreachable code');\n  }\n\n  private _init(mode: _VisitorMode, interpolationConfig: InterpolationConfig): void {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n  }\n\n  // looks for translatable attributes\n  private _visitAttributesOf(el: html.Element): void {\n    const explicitAttrNameToValue: {[k: string]: string} = {};\n    const implicitAttrNames: string[] = this._implicitAttrs[el.name] || [];\n\n    el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n        .forEach(\n            attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                attr.value);\n\n    el.attrs.forEach(attr => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some(name => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n\n  // add a translatable message\n  private _addMessage(ast: html.Node[], msgMeta?: string): i18n.Message|null {\n    if (ast.length == 0 ||\n        ast.length == 1 && ast[0] instanceof html.Attribute && !(<html.Attribute>ast[0]).value) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const {meaning, description, id} = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private _translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(\n          el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n    }\n\n    return [];\n  }\n\n  // translate the attributes of an element and remove i18n specific attributes\n  private _translateAttributes(el: html.Element): html.Attribute[] {\n    const attributes = el.attrs;\n    const i18nParsedMessageMeta:\n        {[name: string]: {meaning: string, description: string, id: string}} = {};\n\n    attributes.forEach(attr => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            _parseMessageMeta(attr.value);\n      }\n    });\n\n    const translatedAttributes: html.Attribute[] = [];\n\n    attributes.forEach((attr) => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        // strip i18n specific attributes\n        return;\n      }\n\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {meaning, description, id} = i18nParsedMessageMeta[attr.name];\n        const message: i18n.Message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(new html.Attribute(\n                attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */,\n                undefined /* valueTokens */, undefined /* i18n */));\n          } else if (nodes[0] instanceof html.Text) {\n            const value = (nodes[0] as html.Text).value;\n            translatedAttributes.push(new html.Attribute(\n                attr.name, value, attr.sourceSpan, undefined /* keySpan */,\n                undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n          } else {\n            this._reportError(\n                el,\n                `Unexpected translation for attribute \"${attr.name}\" (id=\"${\n                    id || this._translations.digest(message)}\")`);\n          }\n        } else {\n          this._reportError(\n              el,\n              `Translation unavailable for attribute \"${attr.name}\" (id=\"${\n                  id || this._translations.digest(message)}\")`);\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n\n    return translatedAttributes;\n  }\n\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private _mayBeAddBlockChildren(node: html.Node): void {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private _openTranslatableSection(node: html.Node): void {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get _isInTranslatableSection(): boolean {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n        (count: number, node: html.Node): number => count + (node instanceof html.Comment ? 0 : 1),\n        0);\n\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex!; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this._msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, msg));\n  }\n}\n\nfunction _isOpeningComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value.startsWith('i18n'));\n}\n\nfunction _isClosingComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value === '/i18n');\n}\n\nfunction _getI18nAttr(p: html.Element): html.Attribute|null {\n  return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n\nfunction _parseMessageMeta(i18n?: string): {meaning: string, description: string, id: string} {\n  if (!i18n) return {meaning: '', description: '', id: ''};\n\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] =\n      (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] = (descIndex > -1) ?\n      [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n      ['', meaningAndDesc];\n\n  return {meaning, description, id: id.trim()};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class XmlTagDefinition implements TagDefinition {\n  closedByParent: boolean = false;\n  implicitNamespacePrefix: string|null = null;\n  isVoid: boolean = false;\n  ignoreFirstLf: boolean = false;\n  canSelfClose: boolean = true;\n  preventNamespaceInheritance: boolean = false;\n\n  requireExtraParent(currentParent: string): boolean {\n    return false;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return false;\n  }\n\n  getContentType(): TagContentType {\n    return TagContentType.PARSABLE_DATA;\n  }\n}\n\nconst _TAG_DEFINITION = new XmlTagDefinition();\n\nexport function getXmlTagDefinition(tagName: string): XmlTagDefinition {\n  return _TAG_DEFINITION;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TokenizeOptions} from './lexer';\nimport {Parser, ParseTreeResult} from './parser';\nimport {getXmlTagDefinition} from './xml_tags';\n\nexport class XmlParser extends Parser {\n  constructor() {\n    super(getXmlTagDefinition);\n  }\n\n  override parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    return super.parse(source, url, options);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {digest} from '../digest';\nimport * as i18n from '../i18n_ast';\nimport {I18nError} from '../parse_util';\n\nimport {Serializer} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _VERSION = '1.2';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG = 'x';\nconst _MARKER_TAG = 'mrk';\n\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\n\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nexport class Xliff extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const visitor = new _WriteVisitor();\n    const transUnits: xml.Node[] = [];\n\n    messages.forEach(message => {\n      let contextTags: xml.Node[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        let contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, {purpose: 'location'});\n        contextGroupTag.children.push(\n            new xml.CR(10),\n            new xml.Tag(\n                _CONTEXT_TAG, {'context-type': 'sourcefile'}, [new xml.Text(source.filePath)]),\n            new xml.CR(10),\n            new xml.Tag(_CONTEXT_TAG, {'context-type': 'linenumber'}, [new xml.Text(\n                                                                          `${source.startLine}`)]),\n            new xml.CR(8));\n        contextTags.push(new xml.CR(8), contextGroupTag);\n      });\n\n      const transUnit = new xml.Tag(_UNIT_TAG, {id: message.id, datatype: 'html'});\n      transUnit.children.push(\n          new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n          ...contextTags);\n\n      if (message.description) {\n        transUnit.children.push(\n            new xml.CR(8),\n            new xml.Tag(\n                'note', {priority: '1', from: 'description'}, [new xml.Text(message.description)]));\n      }\n\n      if (message.meaning) {\n        transUnit.children.push(\n            new xml.CR(8),\n            new xml.Tag('note', {priority: '1', from: 'meaning'}, [new xml.Text(message.meaning)]));\n      }\n\n      transUnit.children.push(new xml.CR(6));\n\n      transUnits.push(new xml.CR(6), transUnit);\n    });\n\n    const body = new xml.Tag('body', {}, [...transUnits, new xml.CR(4)]);\n    const file = new xml.Tag(\n        'file', {\n          'source-language': locale || _DEFAULT_SOURCE_LANG,\n          datatype: 'plaintext',\n          original: 'ng2.template',\n        },\n        [new xml.CR(4), body, new xml.CR(2)]);\n    const xliff = new xml.Tag(\n        'xliff', {version: _VERSION, xmlns: _XMLNS}, [new xml.CR(2), file, new xml.CR()]);\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}), new xml.CR(), xliff, new xml.CR()\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xliff to xml nodes\n    const xliffParser = new XliffParser();\n    const {locale, msgIdToHtml, errors} = xliffParser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n\n    if (errors.length) {\n      throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n}\n\nclass _WriteVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const ctype = getCtypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [new xml.Tag(\n          _PLACEHOLDER_TAG, {id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>`})];\n    }\n\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>`});\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>`});\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, 'equiv-text': `{{${ph.value}}}`})];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${\n        Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ')}}`;\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, 'equiv-text': equivText})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nclass XliffParser implements ml.Visitor {\n  // using non-null assertions because they're re(set) by parse()\n  private _unitMlString!: string|null;\n  private _errors!: I18nError[];\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string|null = null;\n\n  parse(xliff: string, url: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const xml = new XmlParser().parse(xliff, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null!;\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      // ignore those tags\n      case _SOURCE_TAG:\n      case _SEGMENT_SOURCE_TAG:\n      case _ALT_TRANS_TAG:\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _FILE_TAG:\n        const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        ml.visitAll(this, element.children, null);\n        break;\n\n      default:\n        // TODO(vicb): assert file structure, xliff version\n        // For now only recurse on unhandled nodes\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // using non-null assertion because it's re(set) by convert()\n  private _errors!: I18nError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n        [] :\n        [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes: i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder|ml.Node[]|null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find((attr) => attr.name === 'id');\n      if (nameAttr) {\n        return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n      return null;\n    }\n\n    if (el.name === _MARKER_TAG) {\n      return [].concat(...ml.visitAll(this, el.children));\n    }\n\n    this._addError(el, `Unexpected tag`);\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression),\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nfunction getCtypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n    case 'img':\n      return 'image';\n    default:\n      return `x-${tag}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\nimport {I18nError} from '../parse_util';\n\nimport {Serializer} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\n\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\n\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nexport class Xliff2 extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const visitor = new _WriteVisitor();\n    const units: xml.Node[] = [];\n\n    messages.forEach(message => {\n      const unit = new xml.Tag(_UNIT_TAG, {id: message.id});\n      const notes = new xml.Tag('notes');\n\n      if (message.description || message.meaning) {\n        if (message.description) {\n          notes.children.push(\n              new xml.CR(8),\n              new xml.Tag('note', {category: 'description'}, [new xml.Text(message.description)]));\n        }\n\n        if (message.meaning) {\n          notes.children.push(\n              new xml.CR(8),\n              new xml.Tag('note', {category: 'meaning'}, [new xml.Text(message.meaning)]));\n        }\n      }\n\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        notes.children.push(new xml.CR(8), new xml.Tag('note', {category: 'location'}, [\n          new xml.Text(`${source.filePath}:${source.startLine}${\n              source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n        ]));\n      });\n\n      notes.children.push(new xml.CR(6));\n      unit.children.push(new xml.CR(6), notes);\n\n      const segment = new xml.Tag('segment');\n\n      segment.children.push(\n          new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n          new xml.CR(6));\n\n      unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n\n      units.push(new xml.CR(4), unit);\n    });\n\n    const file =\n        new xml.Tag('file', {'original': 'ng.template', id: 'ngi18n'}, [...units, new xml.CR(2)]);\n\n    const xliff = new xml.Tag(\n        _XLIFF_TAG, {version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG},\n        [new xml.CR(2), file, new xml.CR()]);\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}), new xml.CR(), xliff, new xml.CR()\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xliff to xml nodes\n    const xliff2Parser = new Xliff2Parser();\n    const {locale, msgIdToHtml, errors} = xliff2Parser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n\n    if (errors.length) {\n      throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return decimalDigest(message);\n  }\n}\n\nclass _WriteVisitor implements i18n.Visitor {\n  private _nextPlaceholderId = 0;\n\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const type = getTypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      const tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type: type,\n        disp: `<${ph.tag}/>`,\n      });\n      return [tagPh];\n    }\n\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`,\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(''));\n    }\n\n    return [tagPc];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new xml.Tag(_PLACEHOLDER_TAG, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{{${ph.value}}}`,\n    })];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const cases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new xml.Tag(\n        _PLACEHOLDER_TAG,\n        {id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser implements ml.Visitor {\n  // using non-null assertions because they're all (re)set by parse()\n  private _unitMlString!: string|null;\n  private _errors!: I18nError[];\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string|null = null;\n\n  parse(xliff: string, url: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const xml = new XmlParser().parse(xliff, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _XLIFF_TAG:\n        const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n\n        const versionAttr = element.attrs.find((attr) => attr.name === 'version');\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== '2.0') {\n            this._addError(\n                element,\n                `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            ml.visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // using non-null assertion because re(set) by convert()\n  private _errors!: I18nError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n        [] :\n        [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Node[]|null {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG:\n        const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n        if (nameAttr) {\n          return [new i18n.Placeholder('', nameAttr.value, el.sourceSpan)];\n        }\n\n        this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n        const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n\n          const nodes: i18n.Node[] = [];\n\n          return nodes.concat(\n              new i18n.Placeholder('', startId, el.sourceSpan),\n              ...el.children.map(node => node.visit(this, null)),\n              new i18n.Placeholder('', endId, el.sourceSpan));\n        }\n        break;\n      case _MARKER_TAG:\n        return [].concat(...ml.visitAll(this, el.children));\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...ml.visitAll(this, icuCase.expression)),\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nfunction getTypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n    case 'img':\n      return 'image';\n    case 'a':\n      return 'link';\n    default:\n      return 'other';\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseError} from '../parse_util';\n\nimport {extractMessages} from './extractor_merger';\nimport * as i18n from './i18n_ast';\nimport {PlaceholderMapper, Serializer} from './serializers/serializer';\n\n\n/**\n * A container for message extracted from the templates.\n */\nexport class MessageBundle {\n  private _messages: i18n.Message[] = [];\n\n  constructor(\n      private _htmlParser: HtmlParser, private _implicitTags: string[],\n      private _implicitAttrs: {[k: string]: string[]}, private _locale: string|null = null) {}\n\n  updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig):\n      ParseError[] {\n    const htmlParserResult =\n        this._htmlParser.parse(html, url, {tokenizeExpansionForms: true, interpolationConfig});\n\n    if (htmlParserResult.errors.length) {\n      return htmlParserResult.errors;\n    }\n\n    const i18nParserResult = extractMessages(\n        htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n\n    if (i18nParserResult.errors.length) {\n      return i18nParserResult.errors;\n    }\n\n    this._messages.push(...i18nParserResult.messages);\n    return [];\n  }\n\n  // Return the message in the internal format\n  // The public (serialized) format might be different, see the `write` method.\n  getMessages(): i18n.Message[] {\n    return this._messages;\n  }\n\n  write(serializer: Serializer, filterSources?: (path: string) => string): string {\n    const messages: {[id: string]: i18n.Message} = {};\n    const mapperVisitor = new MapPlaceholderNames();\n\n    // Deduplicate messages based on their ID\n    this._messages.forEach(message => {\n      const id = serializer.digest(message);\n      if (!messages.hasOwnProperty(id)) {\n        messages[id] = message;\n      } else {\n        messages[id].sources.push(...message.sources);\n      }\n    });\n\n    // Transform placeholder names using the serializer mapping\n    const msgList = Object.keys(messages).map(id => {\n      const mapper = serializer.createNameMapper(messages[id]);\n      const src = messages[id];\n      const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n      let transformedMessage = new i18n.Message(nodes, {}, {}, src.meaning, src.description, id);\n      transformedMessage.sources = src.sources;\n      if (filterSources) {\n        transformedMessage.sources.forEach(\n            (source: i18n.MessageSpan) => source.filePath = filterSources(source.filePath));\n      }\n      return transformedMessage;\n    });\n\n    return serializer.write(msgList, this._locale);\n  }\n}\n\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nclass MapPlaceholderNames extends i18n.CloneVisitor {\n  convert(nodes: i18n.Node[], mapper: PlaceholderMapper): i18n.Node[] {\n    return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, mapper: PlaceholderMapper):\n      i18n.TagPlaceholder {\n    const startName = mapper.toPublicName(ph.startName)!;\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName)! : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new i18n.TagPlaceholder(\n        ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, mapper: PlaceholderMapper): i18n.Placeholder {\n    return new i18n.Placeholder(ph.value, mapper.toPublicName(ph.name)!, ph.sourceSpan);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, mapper: PlaceholderMapper):\n      i18n.IcuPlaceholder {\n    return new i18n.IcuPlaceholder(ph.value, mapper.toPublicName(ph.name)!, ph.sourceSpan);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport * as o from '../../output/output_ast';\n\nexport interface R3PartialDeclaration {\n  /**\n   * The minimum version of the compiler that can process this partial declaration.\n   */\n  minVersion: string;\n\n  /**\n   * Version number of the Angular compiler that was used to compile this declaration. The linker\n   * will be able to detect which version a library is using and interpret its metadata accordingly.\n   */\n  version: string;\n\n  /**\n   * A reference to the `@angular/core` ES module, which allows access\n   * to all Angular exports, including Ivy instructions.\n   */\n  ngImport: o.Expression;\n\n  /**\n   * Reference to the decorated class, which is subject to this partial declaration.\n   */\n  type: o.Expression;\n}\n\n/**\n * Describes the shape of the object that the `ÉµÉµngDeclareDirective()` function accepts.\n */\nexport interface R3DeclareDirectiveMetadata extends R3PartialDeclaration {\n  /**\n   * Unparsed selector of the directive.\n   */\n  selector?: string;\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs?: {[classPropertyName: string]: string|[string, string]};\n\n  /**\n   * A mapping of outputs from class property names to binding property names.\n   */\n  outputs?: {[classPropertyName: string]: string};\n\n  /**\n   * Information about host bindings present on the component.\n   */\n  host?: {\n    /**\n     * A mapping of attribute names to their value expression.\n     */\n    attributes?: {[key: string]: o.Expression};\n\n    /**\n     * A mapping of event names to their unparsed event handler expression.\n     */\n    listeners: {[key: string]: string};\n\n    /**\n     * A mapping of bound properties to their unparsed binding expression.\n     */\n    properties?: {[key: string]: string};\n\n    /**\n     * The value of the class attribute, if present. This is stored outside of `attributes` as its\n     * string value must be known statically.\n     */\n    classAttribute?: string;\n\n    /**\n     * The value of the style attribute, if present. This is stored outside of `attributes` as its\n     * string value must be known statically.\n     */\n    styleAttribute?: string;\n  };\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries?: R3DeclareQueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries?: R3DeclareQueryMetadata[];\n\n  /**\n   * The list of providers provided by the directive.\n   */\n  providers?: o.Expression;\n\n  /**\n   * The names by which the directive is exported.\n   */\n  exportAs?: string[];\n\n  /**\n   * Whether the directive has an inheritance clause. Defaults to false.\n   */\n  usesInheritance?: boolean;\n\n  /**\n   * Whether the directive implements the `ngOnChanges` hook. Defaults to false.\n   */\n  usesOnChanges?: boolean;\n\n  /**\n   * Whether the directive is standalone. Defaults to false.\n   */\n  isStandalone?: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives?: R3DeclareHostDirectiveMetadata[];\n}\n\n/**\n * Describes the shape of the object that the `ÉµÉµngDeclareComponent()` function accepts.\n */\nexport interface R3DeclareComponentMetadata extends R3DeclareDirectiveMetadata {\n  /**\n   * The component's unparsed template string as opaque expression. The template is represented\n   * using either a string literal or template literal without substitutions, but its value is\n   * not read directly. Instead, the template parser is given the full source file's text and\n   * the range of this expression to parse directly from source.\n   */\n  template: o.Expression;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   * Defaults to false.\n   */\n  isInline?: boolean;\n\n  /**\n   * CSS from inline styles and included styleUrls.\n   */\n  styles?: string[];\n\n  /**\n   * List of components which matched in the template, including sufficient\n   * metadata for each directive to attribute bindings and references within\n   * the template to each directive specifically, if the runtime instructions\n   * support this.\n   */\n  components?: R3DeclareDirectiveDependencyMetadata[];\n\n  /**\n   * List of directives which matched in the template, including sufficient\n   * metadata for each directive to attribute bindings and references within\n   * the template to each directive specifically, if the runtime instructions\n   * support this.\n   */\n  directives?: R3DeclareDirectiveDependencyMetadata[];\n\n  /**\n   * List of dependencies which matched in the template, including sufficient\n   * metadata for each directive/pipe to attribute bindings and references within\n   * the template to each directive specifically, if the runtime instructions\n   * support this.\n   */\n  dependencies?: R3DeclareTemplateDependencyMetadata[];\n\n  /**\n   * A map of pipe names to an expression referencing the pipe type (possibly a forward reference\n   * wrapped in a `forwardRef` invocation) which are used in the template.\n   */\n  pipes?: {[pipeName: string]: o.Expression|(() => o.Expression)};\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders?: o.Expression;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations?: o.Expression;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   * Defaults to `ChangeDetectionStrategy.Default`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Defaults to `ViewEncapsulation.Emulated`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default interpolation start and end delimiters. Defaults to {{ and }}.\n   */\n  interpolation?: [string, string];\n\n  /**\n   * Whether whitespace in the template should be preserved. Defaults to false.\n   */\n  preserveWhitespaces?: boolean;\n}\n\nexport type R3DeclareTemplateDependencyMetadata = R3DeclareDirectiveDependencyMetadata|\n    R3DeclarePipeDependencyMetadata|R3DeclareNgModuleDependencyMetadata;\n\nexport interface R3DeclareDirectiveDependencyMetadata {\n  kind: 'directive'|'component';\n\n  /**\n   * Selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * Reference to the directive class (possibly a forward reference wrapped in a `forwardRef`\n   * invocation).\n   */\n  type: o.Expression|(() => o.Expression);\n\n  /**\n   * Property names of the directive's inputs.\n   */\n  inputs?: string[];\n\n  /**\n   * Event names of the directive's outputs.\n   */\n  outputs?: string[];\n\n  /**\n   * Names by which this directive exports itself for references.\n   */\n  exportAs?: string[];\n}\n\nexport interface R3DeclarePipeDependencyMetadata {\n  kind: 'pipe';\n\n  name: string;\n\n  /**\n   * Reference to the pipe class (possibly a forward reference wrapped in a `forwardRef`\n   * invocation).\n   */\n  type: o.Expression|(() => o.Expression);\n}\n\nexport interface R3DeclareNgModuleDependencyMetadata {\n  kind: 'ngmodule';\n\n  type: o.Expression|(() => o.Expression);\n}\n\nexport interface R3DeclareQueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results. Defaults to false.\n   */\n  first?: boolean;\n\n  /**\n   * Either an expression representing a type (possibly wrapped in a `forwardRef()`) or\n   * `InjectionToken` for the query predicate, or a set of string selectors.\n   */\n  predicate: o.Expression|string[];\n\n  /**\n   * Whether to include only direct children or all descendants. Defaults to false.\n   */\n  descendants?: boolean;\n\n  /**\n   * True to only fire changes if there are underlying changes to the query.\n   */\n  emitDistinctChangesOnly?: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read?: o.Expression;\n\n  /**\n   * Whether or not this query should collect only static results. Defaults to false.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   */\n  static?: boolean;\n}\n\n/**\n * Describes the shape of the objects that the `ÉµÉµngDeclareNgModule()` accepts.\n */\nexport interface R3DeclareNgModuleMetadata extends R3PartialDeclaration {\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap?: o.Expression[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations?: o.Expression[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression[];\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas?: o.Expression[];\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id?: o.Expression;\n}\n\n/**\n * Describes the shape of the objects that the `ÉµÉµngDeclareInjector()` accepts.\n */\nexport interface R3DeclareInjectorMetadata extends R3PartialDeclaration {\n  /**\n   * The list of providers provided by the injector.\n   */\n  providers?: o.Expression;\n  /**\n   * The list of imports into the injector.\n   */\n  imports?: o.Expression[];\n}\n\n/**\n * Describes the shape of the object that the `ÉµÉµngDeclarePipe()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclarePipeMetadata extends R3PartialDeclaration {\n  /**\n   * The name to use in templates to refer to this pipe.\n   */\n  name: string;\n\n  /**\n   * Whether this pipe is \"pure\".\n   *\n   * A pure pipe's `transform()` method is only invoked when its input arguments change.\n   *\n   * Default: true.\n   */\n  pure?: boolean;\n\n  /**\n   * Whether the pipe is standalone.\n   *\n   * Default: false.\n   */\n  isStandalone?: boolean;\n}\n\n\n/**\n * Describes the shape of the object that the `ÉµÉµngDeclareFactory()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclareFactoryMetadata extends R3PartialDeclaration {\n  /**\n   * A collection of dependencies that this factory relies upon.\n   *\n   * If this is `null`, then the type's constructor is nonexistent and will be inherited from an\n   * ancestor of the type.\n   *\n   * If this is `'invalid'`, then one or more of the parameters wasn't resolvable and any attempt to\n   * use these deps will result in a runtime error.\n   */\n  deps: R3DeclareDependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\n/**\n * Describes the shape of the object that the `ÉµÉµngDeclareInjectable()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclareInjectableMetadata extends R3PartialDeclaration {\n  /**\n   * If provided, specifies that the declared injectable belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * If not provided, then it does not belong to any injector. Must be explicitly listed in the\n   * providers of an injector.\n   */\n  providedIn?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to a class to use when creating an instance of this\n   * injectable.\n   */\n  useClass?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to a function to use when creating an instance of\n   * this injectable.\n   */\n  useFactory?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to a token of another injectable that this injectable\n   * aliases.\n   */\n  useExisting?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to the value of the instance of this injectable.\n   */\n  useValue?: o.Expression;\n\n  /**\n   * An array of dependencies to support instantiating this injectable via `useClass` or\n   * `useFactory`.\n   */\n  deps?: R3DeclareDependencyMetadata[];\n}\n\n/**\n * Metadata indicating how a dependency should be injected into a factory.\n */\nexport interface R3DeclareDependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected, or `null` if the dependency is\n   * not valid.\n   *\n   * If this dependency is due to the `@Attribute()` decorator, then this is an expression\n   * evaluating to the name of the attribute.\n   */\n  token: o.Expression|null;\n\n  /**\n   * Whether the dependency is injecting an attribute value.\n   * Default: false.\n   */\n  attribute?: boolean;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   * Default: false,\n   */\n  host?: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   * Default: false,\n   */\n  optional?: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   * Default: false,\n   */\n  self?: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   * Default: false,\n   */\n  skipSelf?: boolean;\n}\n\n/**\n * Describes the shape of the object that the `ÉµÉµngDeclareClassMetadata()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclareClassMetadata extends R3PartialDeclaration {\n  /**\n   * The Angular decorators of the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * Optionally specifies the constructor parameters, their types and the Angular decorators of each\n   * parameter. This property is omitted if the class does not have a constructor.\n   */\n  ctorParameters?: o.Expression;\n\n  /**\n   * Optionally specifies the Angular decorators applied to the class properties. This property is\n   * omitted if no properties have any decorators.\n   */\n  propDecorators?: o.Expression;\n}\n\n/**\n * Describes the shape of the object literal that can be\n * passed in as a part of the `hostDirectives` array.\n */\nexport interface R3DeclareHostDirectiveMetadata {\n  directive: o.Expression;\n  inputs?: string[];\n  outputs?: string[];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BindingPipe, ImplicitReceiver, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafePropertyRead} from '../../expression_parser/ast';\nimport {SelectorMatcher} from '../../selector';\nimport {BoundAttribute, BoundEvent, BoundText, Content, Element, Icu, Node, Reference, Template, Text, TextAttribute, Variable, Visitor} from '../r3_ast';\n\nimport {BoundTarget, DirectiveMeta, Target, TargetBinder} from './t2_api';\nimport {createCssSelector} from './template';\nimport {getAttrsForDirectiveMatching} from './util';\n\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nexport class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetBinder<DirectiveT> {\n  constructor(private directiveMatcher: SelectorMatcher<DirectiveT[]>) {}\n\n  /**\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n   * metadata about the types referenced in the template.\n   */\n  bind(target: Target): BoundTarget<DirectiveT> {\n    if (!target.template) {\n      // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n      throw new Error('Binding without a template not yet supported');\n    }\n\n    // First, parse the template into a `Scope` structure. This operation captures the syntactic\n    // scopes in the template and makes them available for later use.\n    const scope = Scope.apply(target.template);\n\n\n    // Use the `Scope` to extract the entities present at every level of the template.\n    const templateEntities = extractTemplateEntities(scope);\n\n    // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n    //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n    //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n    //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n    //   - references: Map of #references to their targets.\n    const {directives, bindings, references} =\n        DirectiveBinder.apply(target.template, this.directiveMatcher);\n    // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n    // template. This extracts all the metadata that doesn't depend on directive matching.\n    const {expressions, symbols, nestingLevel, usedPipes} =\n        TemplateBinder.applyWithScope(target.template, scope);\n    return new R3BoundTarget(\n        target, directives, bindings, references, expressions, symbols, nestingLevel,\n        templateEntities, usedPipes);\n  }\n}\n\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope implements Visitor {\n  /**\n   * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n   */\n  readonly namedEntities = new Map<string, Reference|Variable>();\n\n  /**\n   * Child `Scope`s for immediately nested `Template`s.\n   */\n  readonly childScopes = new Map<Template, Scope>();\n\n  private constructor(readonly parentScope: Scope|null, readonly template: Template|null) {}\n\n  static newRootScope(): Scope {\n    return new Scope(null, null);\n  }\n\n  /**\n   * Process a template (either as a `Template` sub-template with variables, or a plain array of\n   * template `Node`s) and construct its `Scope`.\n   */\n  static apply(template: Node[]): Scope {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n\n  /**\n   * Internal method to process the template and populate the `Scope`.\n   */\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // Variables on an <ng-template> are defined in the inner scope.\n      template.variables.forEach(node => this.visitVariable(node));\n\n      // Process the nodes of the template.\n      template.children.forEach(node => node.visit(this));\n    } else {\n      // No overarching `Template` instance, so process the nodes directly.\n      template.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: Element) {\n    // `Element`s in the template may have `Reference`s which are captured in the scope.\n    element.references.forEach(node => this.visitReference(node));\n\n    // Recurse into the `Element`'s children.\n    element.children.forEach(node => node.visit(this));\n  }\n\n  visitTemplate(template: Template) {\n    // References on a <ng-template> are defined in the outer scope, so capture them before\n    // processing the template's child scope.\n    template.references.forEach(node => this.visitReference(node));\n\n    // Next, create an inner scope and process the template within it.\n    const scope = new Scope(this, template);\n    scope.ingest(template);\n    this.childScopes.set(template, scope);\n  }\n\n  visitVariable(variable: Variable) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(variable);\n  }\n\n  visitReference(reference: Reference) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(reference);\n  }\n\n  // Unused visitors.\n  visitContent(content: Content) {}\n  visitBoundAttribute(attr: BoundAttribute) {}\n  visitBoundEvent(event: BoundEvent) {}\n  visitBoundText(text: BoundText) {}\n  visitText(text: Text) {}\n  visitTextAttribute(attr: TextAttribute) {}\n  visitIcu(icu: Icu) {}\n\n  private maybeDeclare(thing: Reference|Variable) {\n    // Declare something with a name, as long as that name isn't taken.\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n\n  /**\n   * Look up a variable within this `Scope`.\n   *\n   * This can recurse into a parent `Scope` if it's available.\n   */\n  lookup(name: string): Reference|Variable|null {\n    if (this.namedEntities.has(name)) {\n      // Found in the local scope.\n      return this.namedEntities.get(name)!;\n    } else if (this.parentScope !== null) {\n      // Not in the local scope, but there's a parent scope so check there.\n      return this.parentScope.lookup(name);\n    } else {\n      // At the top level and it wasn't found.\n      return null;\n    }\n  }\n\n  /**\n   * Get the child scope for a `Template`.\n   *\n   * This should always be defined.\n   */\n  getChildScope(template: Template): Scope {\n    const res = this.childScopes.get(template);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${template} not found`);\n    }\n    return res;\n  }\n}\n\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n  constructor(\n      private matcher: SelectorMatcher<DirectiveT[]>,\n      private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>) {}\n\n  /**\n   * Process a template (list of `Node`s) and perform directive matching against each node.\n   *\n   * @param template the list of template `Node`s to match (recursively).\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n   * this template.\n   * @returns three maps which contain information about directives in the template: the\n   * `directives` map which lists directives matched on each node, the `bindings` map which\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n   * map which resolves #references (`Reference`s) within the template to the named directive or\n   * template node.\n   */\n  static apply<DirectiveT extends DirectiveMeta>(\n      template: Node[], selectorMatcher: SelectorMatcher<DirectiveT[]>): {\n    directives: Map<Element|Template, DirectiveT[]>,\n    bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n    references: Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>,\n  } {\n    const directives = new Map<Element|Template, DirectiveT[]>();\n    const bindings =\n        new Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>();\n    const references =\n        new Map<Reference, {directive: DirectiveT, node: Element | Template}|Element|Template>();\n    const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n    matcher.ingest(template);\n    return {directives, bindings, references};\n  }\n\n  private ingest(template: Node[]): void {\n    template.forEach(node => node.visit(this));\n  }\n\n  visitElement(element: Element): void {\n    this.visitElementOrTemplate(element.name, element);\n  }\n\n  visitTemplate(template: Template): void {\n    this.visitElementOrTemplate('ng-template', template);\n  }\n\n  visitElementOrTemplate(elementName: string, node: Element|Template): void {\n    // First, determine the HTML shape of the node for the purpose of directive matching.\n    // Do this by building up a `CssSelector` for the node.\n    const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n\n    // Next, use the `SelectorMatcher` to get the list of directives on the node.\n    const directives: DirectiveT[] = [];\n    this.matcher.match(cssSelector, (_selector, results) => directives.push(...results));\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n    }\n\n    // Resolve any references that are created on this node.\n    node.references.forEach(ref => {\n      let dirTarget: DirectiveT|null = null;\n\n      // If the reference expression is empty, then it matches the \"primary\" directive on the node\n      // (if there is one). Otherwise it matches the host node itself (either an element or\n      // <ng-template> node).\n      if (ref.value.trim() === '') {\n        // This could be a reference to a component if there is one.\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        // This should be a reference to a directive exported via exportAs.\n        dirTarget =\n            directives.find(\n                dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\n            null;\n        // Check if a matching directive was found.\n        if (dirTarget === null) {\n          // No matching directive was found - this reference points to an unknown target. Leave it\n          // unmapped.\n          return;\n        }\n      }\n\n      if (dirTarget !== null) {\n        // This reference points to a directive.\n        this.references.set(ref, {directive: dirTarget, node});\n      } else {\n        // This reference points to the node itself.\n        this.references.set(ref, node);\n      }\n    });\n\n    // Associate attributes/bindings on the node with directives or with the node itself.\n    type BoundNode = BoundAttribute|BoundEvent|TextAttribute;\n    const setAttributeBinding =\n        (attribute: BoundNode, ioType: keyof Pick<DirectiveMeta, 'inputs'|'outputs'>) => {\n          const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n          const binding = dir !== undefined ? dir : node;\n          this.bindings.set(attribute, binding);\n        };\n\n    // Node inputs (bound attributes) and text attributes can be bound to an\n    // input on a directive.\n    node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    }\n    // Node outputs (bound events) can be bound to an output on a directive.\n    node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n\n    // Recurse into the node's children.\n    node.children.forEach(child => child.visit(this));\n  }\n\n  // Unused visitors.\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitBoundAttributeOrEvent(node: BoundAttribute|BoundEvent) {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor implements Visitor {\n  private visitNode: (node: Node) => void;\n\n  private constructor(\n      private bindings: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>, private usedPipes: Set<string>,\n      private nestingLevel: Map<Template, number>, private scope: Scope,\n      private template: Template|null, private level: number) {\n    super();\n\n    // Save a bit of processing time by constructing this closure in advance.\n    this.visitNode = (node: Node) => node.visit(this);\n  }\n\n  // This method is defined to reconcile the type of TemplateBinder since both\n  // RecursiveAstVisitor and Visitor define the visit() method in their\n  // interfaces.\n  override visit(node: AST|Node, context?: any) {\n    if (node instanceof AST) {\n      node.visit(this, context);\n    } else {\n      node.visit(this);\n    }\n  }\n\n  /**\n   * Process a template and extract metadata about expressions and symbols within.\n   *\n   * @param template the nodes of the template to process\n   * @param scope the `Scope` of the template being processed.\n   * @returns three maps which contain metadata about the template: `expressions` which interprets\n   * special `AST` nodes in expressions as pointing to references or variables declared within the\n   * template, `symbols` which maps those variables and references to the nested `Template` which\n   * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n   * nesting level (how many levels deep within the template structure the `Template` is), starting\n   * at 1.\n   */\n  static applyWithScope(template: Node[], scope: Scope): {\n    expressions: Map<AST, Reference|Variable>,\n    symbols: Map<Variable|Reference, Template>,\n    nestingLevel: Map<Template, number>,\n    usedPipes: Set<string>,\n  } {\n    const expressions = new Map<AST, Reference|Variable>();\n    const symbols = new Map<Variable|Reference, Template>();\n    const nestingLevel = new Map<Template, number>();\n    const usedPipes = new Set<string>();\n    // The top-level template has nesting level 0.\n    const binder = new TemplateBinder(\n        expressions, symbols, usedPipes, nestingLevel, scope,\n        template instanceof Template ? template : null, 0);\n    binder.ingest(template);\n    return {expressions, symbols, nestingLevel, usedPipes};\n  }\n\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n      // and references were all processed in the scope of the containing template.\n      template.variables.forEach(this.visitNode);\n      template.children.forEach(this.visitNode);\n\n      // Set the nesting level.\n      this.nestingLevel.set(template, this.level);\n    } else {\n      // Visit each node from the top-level template.\n      template.forEach(this.visitNode);\n    }\n  }\n\n  visitElement(element: Element) {\n    // Visit the inputs, outputs, and children of the element.\n    element.inputs.forEach(this.visitNode);\n    element.outputs.forEach(this.visitNode);\n    element.children.forEach(this.visitNode);\n  }\n\n  visitTemplate(template: Template) {\n    // First, visit inputs, outputs and template attributes of the template node.\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n\n    // References are also evaluated in the outer context.\n    template.references.forEach(this.visitNode);\n\n    // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n    const childScope = this.scope.getChildScope(template);\n    const binder = new TemplateBinder(\n        this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template,\n        this.level + 1);\n    binder.ingest(template);\n  }\n\n  visitVariable(variable: Variable) {\n    // Register the `Variable` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(variable, this.template);\n    }\n  }\n\n  visitReference(reference: Reference) {\n    // Register the `Reference` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(reference, this.template);\n    }\n  }\n\n  // Unused template visitors\n\n  visitText(text: Text) {}\n  visitContent(content: Content) {}\n  visitTextAttribute(attribute: TextAttribute) {}\n  visitIcu(icu: Icu): void {\n    Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\n    Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\n  }\n\n  // The remaining visitors are concerned with processing AST expressions within template bindings\n\n  visitBoundAttribute(attribute: BoundAttribute) {\n    attribute.value.visit(this);\n  }\n\n  visitBoundEvent(event: BoundEvent) {\n    event.handler.visit(this);\n  }\n\n  visitBoundText(text: BoundText) {\n    text.value.visit(this);\n  }\n  override visitPipe(ast: BindingPipe, context: any): any {\n    this.usedPipes.add(ast.name);\n    return super.visitPipe(ast, context);\n  }\n\n  // These five types of AST expressions can refer to expression roots, which could be variables\n  // or references in the current scope.\n\n  override visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n\n  override visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n\n  override visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyWrite(ast, context);\n  }\n\n  private maybeMap(scope: Scope, ast: PropertyRead|SafePropertyRead|PropertyWrite, name: string):\n      void {\n    // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n    // `AST` expression that maps to a `Variable` or `Reference`.\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n    // probably a property on the top-level component context.\n    let target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\n\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nexport class R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTarget<DirectiveT> {\n  constructor(\n      readonly target: Target, private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<BoundAttribute|BoundEvent|Reference|TextAttribute,\n              {directive: DirectiveT, node: Element|Template}|Element|Template>,\n      private exprTargets: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>,\n      private nestingLevel: Map<Template, number>,\n      private templateEntities: Map<Template|null, ReadonlySet<Reference|Variable>>,\n      private usedPipes: Set<string>) {}\n\n  getEntitiesInTemplateScope(template: Template|null): ReadonlySet<Reference|Variable> {\n    return this.templateEntities.get(template) ?? new Set();\n  }\n\n  getDirectivesOfNode(node: Element|Template): DirectiveT[]|null {\n    return this.directives.get(node) || null;\n  }\n\n  getReferenceTarget(ref: Reference): {directive: DirectiveT, node: Element|Template}|Element\n      |Template|null {\n    return this.references.get(ref) || null;\n  }\n\n  getConsumerOfBinding(binding: BoundAttribute|BoundEvent|TextAttribute): DirectiveT|Element\n      |Template|null {\n    return this.bindings.get(binding) || null;\n  }\n\n  getExpressionTarget(expr: AST): Reference|Variable|null {\n    return this.exprTargets.get(expr) || null;\n  }\n\n  getTemplateOfSymbol(symbol: Reference|Variable): Template|null {\n    return this.symbols.get(symbol) || null;\n  }\n\n  getNestingLevel(template: Template): number {\n    return this.nestingLevel.get(template) || 0;\n  }\n\n  getUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n\n  getUsedPipes(): string[] {\n    return Array.from(this.usedPipes);\n  }\n}\n\nfunction extractTemplateEntities(rootScope: Scope): Map<Template|null, Set<Reference|Variable>> {\n  const entityMap = new Map<Template|null, Map<string, Reference|Variable>>();\n\n  function extractScopeEntities(scope: Scope): Map<string, Reference|Variable> {\n    if (entityMap.has(scope.template)) {\n      return entityMap.get(scope.template)!;\n    }\n\n    const currentEntities = scope.namedEntities;\n\n    let templateEntities: Map<string, Reference|Variable>;\n    if (scope.parentScope !== null) {\n      templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      templateEntities = new Map(currentEntities);\n    }\n\n    entityMap.set(scope.template, templateEntities);\n    return templateEntities;\n  }\n\n  const scopesToProcess: Scope[] = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop()!;\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n\n  const templateEntities = new Map<Template|null, Set<Reference|Variable>>();\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n  return templateEntities;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {devOnlyGuardedExpression} from './util';\n\nexport type CompileClassMetadataFn = (metadata: R3ClassMetadata) => o.Expression;\n\n/**\n * Metadata of a class which captures the original Angular decorators of a class. The original\n * decorators are preserved in the generated code to allow TestBed APIs to recompile the class\n * using the original decorator with a set of overrides applied.\n */\nexport interface R3ClassMetadata {\n  /**\n   * The class type for which the metadata is captured.\n   */\n  type: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators applied to constructor parameters, or `null`\n   * if there is no constructor.\n   */\n  ctorParameters: o.Expression|null;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the properties of the\n   * class, or `null` if no properties have decorators.\n   */\n  propDecorators: o.Expression|null;\n}\n\nexport function compileClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n  // metadata.\n  const fnCall = o.importExpr(R3.setClassMetadata).callFn([\n    metadata.type,\n    metadata.decorators,\n    metadata.ctorParameters ?? o.literal(null),\n    metadata.propDecorators ?? o.literal(null),\n  ]);\n  const iife = o.fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3ClassMetadata} from '../r3_class_metadata_compiler';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareClassMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  const definitionMap = new DefinitionMap<R3DeclareClassMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n\n  return o.importExpr(R3.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareDependencyMetadata} from './api';\n\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nexport function toOptionalLiteralArray<T>(\n    values: T[]|null, mapper: (value: T) => o.Expression): o.LiteralArrayExpr|null {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return o.literalArr(values.map(value => mapper(value)));\n}\n\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nexport function toOptionalLiteralMap<T>(\n    object: {[key: string]: T}, mapper: (value: T) => o.Expression): o.LiteralMapExpr|null {\n  const entries = Object.keys(object).map(key => {\n    const value = object[key];\n    return {key, value: mapper(value), quoted: true};\n  });\n\n  if (entries.length > 0) {\n    return o.literalMap(entries);\n  } else {\n    return null;\n  }\n}\n\nexport function compileDependencies(deps: R3DependencyMetadata[]|'invalid'|null): o.LiteralExpr|\n    o.LiteralArrayExpr {\n  if (deps === 'invalid') {\n    // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n    // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n    return o.literal('invalid');\n  } else if (deps === null) {\n    return o.literal(null);\n  } else {\n    return o.literalArr(deps.map(compileDependency));\n  }\n}\n\nexport function compileDependency(dep: R3DependencyMetadata): o.LiteralMapExpr {\n  const depMeta = new DefinitionMap<R3DeclareDependencyMetadata>();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', o.literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', o.literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', o.literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', o.literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', o.literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, generateForwardRef, R3CompiledExpression} from '../util';\nimport {R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata} from '../view/api';\nimport {createDirectiveType, createHostDirectivesMappingArray} from '../view/compiler';\nimport {asLiteral, conditionallyCreateDirectiveBindingLiteral, DefinitionMap} from '../view/util';\n\nimport {R3DeclareDirectiveMetadata, R3DeclareQueryMetadata} from './api';\nimport {toOptionalLiteralMap} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nexport function compileDeclareDirectiveFromMetadata(meta: R3DirectiveMetadata):\n    R3CompiledExpression {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nexport function createDirectiveDefinitionMap(meta: R3DirectiveMetadata):\n    DefinitionMap<R3DeclareDirectiveMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareDirectiveMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.type.value);\n\n  if (meta.isStandalone) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `selector: 'some-dir'`\n  if (meta.selector !== null) {\n    definitionMap.set('selector', o.literal(meta.selector));\n  }\n\n  definitionMap.set('inputs', conditionallyCreateDirectiveBindingLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n\n  definitionMap.set('host', compileHostMetadata(meta.host));\n\n  definitionMap.set('providers', meta.providers);\n\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', o.literalArr(meta.queries.map(compileQuery)));\n  }\n\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', o.literalArr(meta.viewQueries.map(compileQuery)));\n  }\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', o.literal(true));\n  }\n\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', o.literal(true));\n  }\n\n  if (meta.hostDirectives?.length) {\n    definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n  }\n\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  return definitionMap;\n}\n\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query: R3QueryMetadata): o.LiteralMapExpr {\n  const meta = new DefinitionMap<R3DeclareQueryMetadata>();\n  meta.set('propertyName', o.literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', o.literal(true));\n  }\n  meta.set(\n      'predicate',\n      Array.isArray(query.predicate) ? asLiteral(query.predicate) :\n                                       convertFromMaybeForwardRefExpression(query.predicate));\n  if (!query.emitDistinctChangesOnly) {\n    // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n    // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n    meta.set('emitDistinctChangesOnly', o.literal(false));\n  } else {\n    // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n  }\n  if (query.descendants) {\n    meta.set('descendants', o.literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', o.literal(true));\n  }\n  return meta.toLiteralMap();\n}\n\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta: R3HostMetadata): o.LiteralMapExpr|null {\n  const hostMetadata = new DefinitionMap<NonNullable<R3DeclareDirectiveMetadata['host']>>();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, o.literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, o.literal));\n\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', o.literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', o.literal(meta.specialAttributes.classAttr));\n  }\n\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\n\nfunction createHostDirectives(hostDirectives: NonNullable<R3DirectiveMetadata['hostDirectives']>):\n    o.LiteralArrayExpr {\n  const expressions = hostDirectives.map(current => {\n    const keys = [{\n      key: 'directive',\n      value: current.isForwardReference ? generateForwardRef(current.directive.type) :\n                                          current.directive.type,\n      quoted: false\n    }];\n    const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n    const outputsLiteral =\n        current.outputs ? createHostDirectivesMappingArray(current.outputs) : null;\n\n    if (inputsLiteral) {\n      keys.push({key: 'inputs', value: inputsLiteral, quoted: false});\n    }\n\n    if (outputsLiteral) {\n      keys.push({key: 'outputs', value: outputsLiteral, quoted: false});\n    }\n\n    return o.literalMap(keys);\n  });\n\n  // If there's a forward reference, we generate a `function() { return [{directive: HostDir}] }`,\n  // otherwise we can save some bytes by using a plain array, e.g. `[{directive: HostDir}]`.\n  return o.literalArr(expressions);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as core from '../../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {generateForwardRef, R3CompiledExpression} from '../util';\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3TemplateDependencyKind, R3TemplateDependencyMetadata} from '../view/api';\nimport {createComponentType} from '../view/compiler';\nimport {ParsedTemplate} from '../view/template';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareComponentMetadata, R3DeclareDirectiveDependencyMetadata, R3DeclareNgModuleDependencyMetadata, R3DeclarePipeDependencyMetadata} from './api';\nimport {createDirectiveDefinitionMap} from './directive';\nimport {toOptionalLiteralArray} from './util';\n\nexport interface DeclareComponentTemplateInfo {\n  /**\n   * The string contents of the template.\n   *\n   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n   */\n  content: string;\n\n  /**\n   * A full path to the file which contains the template.\n   *\n   * This can be either the original .ts file if the template is inline, or the .html file if an\n   * external file was used.\n   */\n  sourceUrl: string;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   */\n  isInline: boolean;\n\n  /**\n   * If the template was defined inline by a direct string literal, then this is that literal\n   * expression. Otherwise `null`, if the template was not defined inline or was not a literal.\n   */\n  inlineTemplateLiteralExpression: o.Expression|null;\n}\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nexport function compileDeclareComponentFromMetadata(\n    meta: R3ComponentMetadata<R3TemplateDependencyMetadata>, template: ParsedTemplate,\n    additionalTemplateInfo: DeclareComponentTemplateInfo): R3CompiledExpression {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n\n  const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nexport function createComponentDefinitionMap(\n    meta: R3ComponentMetadata<R3TemplateDependencyMetadata>, template: ParsedTemplate,\n    templateInfo: DeclareComponentTemplateInfo): DefinitionMap<R3DeclareComponentMetadata> {\n  const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n      createDirectiveDefinitionMap(meta);\n\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', o.literal(true));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, o.literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== undefined) {\n    definitionMap.set(\n        'changeDetection',\n        o.importExpr(R3.ChangeDetectionStrategy)\n            .prop(core.ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set(\n        'encapsulation',\n        o.importExpr(R3.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]));\n  }\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set(\n        'interpolation',\n        o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]));\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(\n    template: ParsedTemplate, templateInfo: DeclareComponentTemplateInfo): o.Expression {\n  // If the template has been defined using a direct literal, we use that expression directly\n  // without any modifications. This is ensures proper source mapping from the partially\n  // compiled code to the source file declaring the template. Note that this does not capture\n  // template literals referenced indirectly through an identifier.\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n\n  // If the template is defined inline but not through a literal, the template has been resolved\n  // through static interpretation. We create a literal but cannot provide any source span. Note\n  // that we cannot use the expression defining the template because the linker expects the template\n  // to be defined as a literal in the declaration.\n  if (templateInfo.isInline) {\n    return o.literal(templateInfo.content, null, null);\n  }\n\n  // The template is external so we must synthesize an expression node with\n  // the appropriate source-span.\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return o.literal(contents, null, span);\n}\n\nfunction computeEndLocation(file: ParseSourceFile, contents: string): ParseLocation {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n\nfunction compileUsedDependenciesMetadata(meta: R3ComponentMetadata<R3TemplateDependencyMetadata>):\n    o.LiteralArrayExpr|null {\n  const wrapType = meta.declarationListEmitMode !== DeclarationListEmitMode.Direct ?\n      generateForwardRef :\n      (expr: o.Expression) => expr;\n\n  return toOptionalLiteralArray(meta.declarations, decl => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap<R3DeclareDirectiveDependencyMetadata>();\n        dirMeta.set('kind', o.literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', o.literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, o.literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, o.literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, o.literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap<R3DeclarePipeDependencyMetadata>();\n        pipeMeta.set('kind', o.literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', o.literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap<R3DeclareNgModuleDependencyMetadata>();\n        ngModuleMeta.set('kind', o.literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {createFactoryType, FactoryTarget, R3FactoryMetadata} from '../r3_factory';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareFactoryMetadata} from './api';\nimport {compileDependencies} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<R3DeclareFactoryMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', o.importExpr(R3.FactoryTarget).prop(FactoryTarget[meta.target]));\n\n  return {\n    expression: o.importExpr(R3.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {createInjectableType, R3InjectableMetadata} from '../../injectable_compiler_2';\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectableMetadata} from './api';\nimport {compileDependency} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nexport function compileDeclareInjectableFromMetadata(meta: R3InjectableMetadata):\n    R3CompiledExpression {\n  const definitionMap = createInjectableDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nexport function createInjectableDefinitionMap(meta: R3InjectableMetadata):\n    DefinitionMap<R3DeclareInjectableMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectableMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n\n  // Only generate providedIn property if it has a non-null value\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if ((providedIn as o.LiteralExpr).value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n  // with `convertFromProviderExpression()`.\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', o.literalArr(meta.deps.map(compileDependency)));\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createInjectorType, R3InjectorMetadata} from '../r3_injector_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectorMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareInjectorFromMetadata(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = createInjectorDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(meta: R3InjectorMetadata):\n    DefinitionMap<R3DeclareInjectorMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectorMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createNgModuleType, R3NgModuleMetadata} from '../r3_module_compiler';\nimport {R3CompiledExpression, refsToArray} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareNgModuleMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\nexport function compileDeclareNgModuleFromMetadata(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(meta: R3NgModuleMetadata):\n    DefinitionMap<R3DeclareNgModuleMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareNgModuleMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n\n  // We only generate the keys in the metadata if the arrays contain values.\n\n  // We must wrap the arrays inside a function if any of the values are a forward reference to a\n  // not-yet-declared class. This is to support JIT execution of the `ÉµÉµngDeclareNgModule()` call.\n  // In the linker these wrappers are stripped and then reapplied for the `ÉµÉµdefineNgModule()` call.\n\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map(ref => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createPipeType, R3PipeMetadata} from '../r3_pipe_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclarePipeMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nexport function compileDeclarePipeFromMetadata(meta: R3PipeMetadata): R3CompiledExpression {\n  const definitionMap = createPipeDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nexport function createPipeDefinitionMap(meta: R3PipeMetadata):\n    DefinitionMap<R3DeclarePipeMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclarePipeMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('16.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  // e.g. `type: MyPipe`\n  definitionMap.set('type', meta.type.value);\n\n  if (meta.isStandalone) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `name: \"myPipe\"`\n  definitionMap.set('name', o.literal(meta.pipeName));\n\n  if (meta.pure === false) {\n    // e.g. `pure: false`\n    definitionMap.set('pure', o.literal(meta.pure));\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//////////////////////////////////////\n// THIS FILE HAS GLOBAL SIDE EFFECT //\n//       (see bottom of file)       //\n//////////////////////////////////////\n\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n\nimport * as core from './core';\nimport {publishFacade} from './jit_compiler_facade';\nimport {global} from './util';\n\nexport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from './core';\nexport {core};\n\nexport * from './version';\nexport {CompilerConfig, preserveWhitespacesDefault} from './config';\nexport * from './resource_loader';\nexport {ConstantPool} from './constant_pool';\nexport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\nexport * from './schema/element_schema_registry';\nexport * from './i18n/index';\nexport * from './expression_parser/ast';\nexport * from './expression_parser/lexer';\nexport * from './expression_parser/parser';\nexport * from './ml_parser/ast';\nexport * from './ml_parser/html_parser';\nexport * from './ml_parser/html_tags';\nexport * from './ml_parser/interpolation_config';\nexport * from './ml_parser/tags';\nexport {ParseTreeResult, TreeError} from './ml_parser/parser';\nexport {LexerRange} from './ml_parser/lexer';\nexport * from './ml_parser/xml_parser';\nexport {ArrayType, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, Type, TypeModifier, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\nexport {EmitterVisitorContext} from './output/abstract_emitter';\nexport {JitEvaluator} from './output/output_jit';\nexport * from './parse_util';\nexport * from './schema/dom_element_schema_registry';\nexport * from './selector';\nexport {Version} from './util';\nexport {SourceMap} from './output/source_map';\nexport * from './injectable_compiler_2';\nexport * from './render3/partial/api';\nexport * from './render3/view/api';\nexport {BoundAttribute as TmplAstBoundAttribute, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Content as TmplAstContent, Element as TmplAstElement, Icu as TmplAstIcu, Node as TmplAstNode, RecursiveVisitor as TmplAstRecursiveVisitor, Reference as TmplAstReference, Template as TmplAstTemplate, Text as TmplAstText, TextAttribute as TmplAstTextAttribute, Variable as TmplAstVariable} from './render3/r3_ast';\nexport * from './render3/view/t2_api';\nexport * from './render3/view/t2_binder';\nexport {Identifiers as R3Identifiers} from './render3/r3_identifiers';\nexport {R3ClassMetadata, CompileClassMetadataFn, compileClassMetadata} from './render3/r3_class_metadata_compiler';\nexport {compileFactoryFunction, R3DependencyMetadata, R3FactoryMetadata, FactoryTarget} from './render3/r3_factory';\nexport {compileNgModule, R3NgModuleMetadata, R3SelectorScopeMode} from './render3/r3_module_compiler';\nexport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nexport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nexport {makeBindingParser, ParsedTemplate, parseTemplate, ParseTemplateOptions} from './render3/view/template';\nexport {ForwardRefHandling, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, createMayBeForwardRefExpression, devOnlyGuardedExpression, getSafePropertyAccessString} from './render3/util';\nexport {compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, ParsedHostBindings, verifyHostBindings} from './render3/view/compiler';\nexport {compileDeclareClassMetadata} from './render3/partial/class_metadata';\nexport {compileDeclareComponentFromMetadata, DeclareComponentTemplateInfo} from './render3/partial/component';\nexport {compileDeclareDirectiveFromMetadata} from './render3/partial/directive';\nexport {compileDeclareFactoryFunction} from './render3/partial/factory';\nexport {compileDeclareInjectableFromMetadata} from './render3/partial/injectable';\nexport {compileDeclareInjectorFromMetadata} from './render3/partial/injector';\nexport {compileDeclareNgModuleFromMetadata} from './render3/partial/ng_module';\nexport {compileDeclarePipeFromMetadata} from './render3/partial/pipe';\nexport {publishFacade} from './jit_compiler_facade';\nexport {emitDistinctChangesOnlyDefaultValue, ChangeDetectionStrategy, ViewEncapsulation} from './core';\nimport * as outputAst from './output/output_ast';\nexport {outputAst};\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(global);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler-cli package.\n */\n\nimport {Version} from '@angular/compiler';\n\nexport const VERSION = new Version('16.0.0');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ExtendedTsCompilerHost, NgCompilerOptions} from '../ngtsc/core/api';\n\nexport const DEFAULT_ERROR_CODE = 100;\nexport const UNKNOWN_ERROR_CODE = 500;\nexport const SOURCE = 'angular' as 'angular';\n\nexport function isTsDiagnostic(diagnostic: any): diagnostic is ts.Diagnostic {\n  return diagnostic != null && diagnostic.source !== 'angular';\n}\n\nexport interface CompilerOptions extends NgCompilerOptions, ts.CompilerOptions {\n  // NOTE: These comments and aio/content/guides/aot-compiler.md should be kept in sync.\n\n  // Write statistics about compilation (e.g. total time, ...)\n  // Note: this is the --diagnostics command line option from TS (which is @internal\n  // on ts.CompilerOptions interface).\n  diagnostics?: boolean;\n\n  // Absolute path to a directory where generated file structure is written.\n  // If unspecified, generated files will be written alongside sources.\n  // @deprecated - no effect\n  genDir?: string;\n\n  // Path to the directory containing the tsconfig.json file.\n  basePath?: string;\n\n  // Don't produce .metadata.json files (they don't work for bundled emit with --out)\n  skipMetadataEmit?: boolean;\n\n  // Produce an error if the metadata written for a class would produce an error if used.\n  strictMetadataEmit?: boolean;\n\n  // Don't produce .ngfactory.js or .ngstyle.js files\n  skipTemplateCodegen?: boolean;\n\n  // A prefix to insert in generated private symbols, e.g. for \"my_prefix_\" we\n  // would generate private symbols named like `Éµmy_prefix_a`.\n  flatModulePrivateSymbolPrefix?: string;\n\n  // Whether to generate code for library code.\n  // Default is true.\n  generateCodeForLibraries?: boolean;\n\n  // Modify how angular annotations are emitted to improve tree-shaking.\n  // Default is static fields.\n  // decorators: Leave the Decorators in-place. This makes compilation faster.\n  //             TypeScript will emit calls to the __decorate helper.\n  //             `--emitDecoratorMetadata` can be used for runtime reflection.\n  //             However, the resulting code will not properly tree-shake.\n  // static fields: Replace decorators with a static field in the class.\n  //                Allows advanced tree-shakers like Closure Compiler to remove\n  //                unused classes.\n  annotationsAs?: 'decorators'|'static fields';\n\n  // Print extra information while running the compiler\n  trace?: boolean;\n\n  // Whether to enable lowering expressions lambdas and expressions in a reference value\n  // position.\n  disableExpressionLowering?: boolean;\n\n  // Import format if different from `i18nFormat`\n  i18nInFormat?: string;\n  // Path to the translation file\n  i18nInFile?: string;\n  // How to handle missing messages\n  i18nInMissingTranslations?: 'error'|'warning'|'ignore';\n\n  /**\n   * Whether to replace the `templateUrl` and `styleUrls` property in all\n   * @Component decorators with inlined contents in `template` and `styles`\n   * properties.\n   * When enabled, the .js output of ngc will have no lazy-loaded `templateUrl`\n   * or `styleUrl`s. Note that this requires that resources be available to\n   * load statically at compile-time.\n   */\n  enableResourceInlining?: boolean;\n\n  /** @internal */\n  collectAllErrors?: boolean;\n\n  /**\n   * Whether NGC should generate re-exports for external symbols which are referenced\n   * in Angular metadata (e.g. @Component, @Inject, @ViewChild). This can be enabled in\n   * order to avoid dynamically generated module dependencies which can break strict\n   * dependency enforcements. This is not enabled by default.\n   * Read more about this here: https://github.com/angular/angular/issues/25644.\n   */\n  createExternalSymbolFactoryReexports?: boolean;\n}\n\nexport interface CompilerHost extends ts.CompilerHost, ExtendedTsCompilerHost {\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e. `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName?(moduleName: string, containingFile: string): string|null;\n  /**\n   * Converts a file name into a representation that should be stored in a summary file.\n   * This has to include changing the suffix as well.\n   * E.g.\n   * `some_file.ts` -> `some_file.d.ts`\n   *\n   * @param referringSrcFileName the source file that refers to fileName\n   */\n  toSummaryFileName?(fileName: string, referringSrcFileName: string): string;\n  /**\n   * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\n   * given the fileName of the library that is referring to it.\n   */\n  fromSummaryFileName?(fileName: string, referringLibFileName: string): string;\n  /**\n   * Produce an AMD module name for the source file. Used in Bazel.\n   *\n   * An AMD module can have an arbitrary name, so that it is require'd by name\n   * rather than by path. See https://requirejs.org/docs/whyamd.html#namedmodules\n   */\n  amdModuleName?(sf: ts.SourceFile): string|undefined;\n}\n\nexport enum EmitFlags {\n  DTS = 1 << 0,\n  JS = 1 << 1,\n  Metadata = 1 << 2,\n  I18nBundle = 1 << 3,\n  Codegen = 1 << 4,\n\n  Default = DTS | JS | Codegen,\n  All = DTS | JS | Metadata | I18nBundle | Codegen,\n}\n\nexport interface CustomTransformers {\n  beforeTs?: ts.TransformerFactory<ts.SourceFile>[];\n  afterTs?: ts.TransformerFactory<ts.SourceFile>[];\n}\n\nexport interface TsEmitArguments {\n  program: ts.Program;\n  host: CompilerHost;\n  options: CompilerOptions;\n  targetSourceFile?: ts.SourceFile;\n  writeFile?: ts.WriteFileCallback;\n  cancellationToken?: ts.CancellationToken;\n  emitOnlyDtsFiles?: boolean;\n  customTransformers?: ts.CustomTransformers;\n}\n\nexport interface TsEmitCallback<T extends ts.EmitResult> {\n  (args: TsEmitArguments): T;\n}\nexport interface TsMergeEmitResultsCallback<T extends ts.EmitResult> {\n  (results: T[]): T;\n}\n\nexport interface LazyRoute {\n  route: string;\n  module: {name: string, filePath: string};\n  referencedModule: {name: string, filePath: string};\n}\n\nexport interface EmitOptions<CbEmitRes extends ts.EmitResult> {\n  emitFlags?: EmitFlags;\n  forceEmit?: boolean;\n  cancellationToken?: ts.CancellationToken;\n  customTransformers?: CustomTransformers;\n  emitCallback?: TsEmitCallback<CbEmitRes>;\n  mergeEmitResultsCallback?: TsMergeEmitResultsCallback<CbEmitRes>;\n}\n\nexport interface Program {\n  /**\n   * Retrieve the TypeScript program used to produce semantic diagnostics and emit the sources.\n   *\n   * Angular structural information is required to produce the program.\n   */\n  getTsProgram(): ts.Program;\n\n  /**\n   * Retrieve options diagnostics for the TypeScript options used to create the program. This is\n   * faster than calling `getTsProgram().getOptionsDiagnostics()` since it does not need to\n   * collect Angular structural information to produce the errors.\n   */\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve options diagnostics for the Angular options used to create the program.\n   */\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve the syntax diagnostics from TypeScript. This is faster than calling\n   * `getTsProgram().getSyntacticDiagnostics()` since it does not need to collect Angular structural\n   * information to produce the errors.\n   */\n  getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve the diagnostics for the structure of an Angular application is correctly formed.\n   * This includes validating Angular annotations and the syntax of referenced and imbedded HTML\n   * and CSS.\n   *\n   * Note it is important to displaying TypeScript semantic diagnostics along with Angular\n   * structural diagnostics as an error in the program structure might cause errors detected in\n   * semantic analysis and a semantic error might cause errors in specifying the program structure.\n   *\n   * Angular structural information is required to produce these diagnostics.\n   */\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve the semantic diagnostics from TypeScript. This is equivalent to calling\n   * `getTsProgram().getSemanticDiagnostics()` directly and is included for completeness.\n   */\n  getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve the Angular semantic diagnostics.\n   *\n   * Angular structural information is required to produce these diagnostics.\n   */\n  getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Load Angular structural information asynchronously. If this method is not called then the\n   * Angular structural information, including referenced HTML and CSS files, are loaded\n   * synchronously. If the supplied Angular compiler host returns a promise from `loadResource()`\n   * will produce a diagnostic error message or, `getTsProgram()` or `emit` to throw.\n   */\n  loadNgStructureAsync(): Promise<void>;\n\n  /**\n   * This method is obsolete and always returns an empty array.\n   */\n  listLazyRoutes(entryRoute?: string): LazyRoute[];\n\n  /**\n   * Emit the files requested by emitFlags implied by the program.\n   *\n   * Angular structural information is required to emit files.\n   */\n  emit<CbEmitRes extends ts.EmitResult>(opts?: EmitOptions<CbEmitRes>|undefined): ts.EmitResult;\n\n  /**\n   * @internal\n   */\n  getEmittedSourceFiles(): Map<string, ts.SourceFile>;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {CompilerHost, CompilerOptions} from './api';\n\nlet wrapHostForTest: ((host: ts.CompilerHost) => ts.CompilerHost)|null = null;\n\nexport function setWrapHostForTest(wrapFn: ((host: ts.CompilerHost) => ts.CompilerHost)|\n                                   null): void {\n  wrapHostForTest = wrapFn;\n}\n\nexport function createCompilerHost(\n    {options, tsHost = ts.createCompilerHost(options, true)}:\n        {options: CompilerOptions, tsHost?: ts.CompilerHost}): CompilerHost {\n  if (wrapHostForTest !== null) {\n    tsHost = wrapHostForTest(tsHost);\n  }\n  return tsHost;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HtmlParser, MessageBundle} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport * as api from '../transformers/api';\nimport {i18nExtract} from '../transformers/i18n';\nimport {verifySupportedTypeScriptVersion} from '../typescript_support';\n\nimport {CompilationTicket, freshCompilationTicket, incrementalFromCompilerTicket, NgCompiler, NgCompilerHost} from './core';\nimport {NgCompilerOptions} from './core/api';\nimport {absoluteFrom, AbsoluteFsPath, getFileSystem, resolve} from './file_system';\nimport {TrackedIncrementalBuildStrategy} from './incremental';\nimport {IndexedComponent} from './indexer';\nimport {ActivePerfRecorder, PerfCheckpoint as PerfCheckpoint, PerfEvent, PerfPhase} from './perf';\nimport {TsCreateProgramDriver} from './program_driver';\nimport {DeclarationNode} from './reflection';\nimport {retagAllTsFiles, untagAllTsFiles} from './shims';\nimport {OptimizeFor} from './typecheck/api';\n\n/**\n * Entrypoint to the Angular Compiler (Ivy+) which sits behind the `api.Program` interface, allowing\n * it to be a drop-in replacement for the legacy View Engine compiler to tooling such as the\n * command-line main() function or the Angular CLI.\n */\nexport class NgtscProgram implements api.Program {\n  readonly compiler: NgCompiler;\n\n  /**\n   * The primary TypeScript program, which is used for analysis and emit.\n   */\n  private tsProgram: ts.Program;\n\n  private host: NgCompilerHost;\n  private incrementalStrategy: TrackedIncrementalBuildStrategy;\n\n  constructor(\n      rootNames: ReadonlyArray<string>, private options: NgCompilerOptions,\n      delegateHost: api.CompilerHost, oldProgram?: NgtscProgram) {\n    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n\n    perfRecorder.phase(PerfPhase.Setup);\n\n    // First, check whether the current TS version is supported.\n    if (!options.disableTypeScriptVersionCheck) {\n      verifySupportedTypeScriptVersion();\n    }\n\n    const reuseProgram = oldProgram?.compiler.getCurrentProgram();\n    this.host = NgCompilerHost.wrap(delegateHost, rootNames, options, reuseProgram ?? null);\n\n    if (reuseProgram !== undefined) {\n      // Prior to reusing the old program, restore shim tagging for all its `ts.SourceFile`s.\n      // TypeScript checks the `referencedFiles` of `ts.SourceFile`s for changes when evaluating\n      // incremental reuse of data from the old program, so it's important that these match in order\n      // to get the most benefit out of reuse.\n      retagAllTsFiles(reuseProgram);\n    }\n\n    this.tsProgram = perfRecorder.inPhase(\n        PerfPhase.TypeScriptProgramCreate,\n        () => ts.createProgram(this.host.inputFiles, options, this.host, reuseProgram));\n\n    perfRecorder.phase(PerfPhase.Unaccounted);\n    perfRecorder.memory(PerfCheckpoint.TypeScriptProgramCreate);\n\n    this.host.postProgramCreationCleanup();\n\n    // Shim tagging has served its purpose, and tags can now be removed from all `ts.SourceFile`s in\n    // the program.\n    untagAllTsFiles(this.tsProgram);\n\n    const programDriver = new TsCreateProgramDriver(\n        this.tsProgram, this.host, this.options, this.host.shimExtensionPrefixes);\n\n    this.incrementalStrategy = oldProgram !== undefined ?\n        oldProgram.incrementalStrategy.toNextBuildStrategy() :\n        new TrackedIncrementalBuildStrategy();\n    const modifiedResourceFiles = new Set<AbsoluteFsPath>();\n    if (this.host.getModifiedResourceFiles !== undefined) {\n      const strings = this.host.getModifiedResourceFiles();\n      if (strings !== undefined) {\n        for (const fileString of strings) {\n          modifiedResourceFiles.add(absoluteFrom(fileString));\n        }\n      }\n    }\n\n    let ticket: CompilationTicket;\n    if (oldProgram === undefined) {\n      ticket = freshCompilationTicket(\n          this.tsProgram, options, this.incrementalStrategy, programDriver, perfRecorder,\n          /* enableTemplateTypeChecker */ false, /* usePoisonedData */ false);\n    } else {\n      ticket = incrementalFromCompilerTicket(\n          oldProgram.compiler,\n          this.tsProgram,\n          this.incrementalStrategy,\n          programDriver,\n          modifiedResourceFiles,\n          perfRecorder,\n      );\n    }\n\n\n    // Create the NgCompiler which will drive the rest of the compilation.\n    this.compiler = NgCompiler.fromTicket(ticket, this.host);\n  }\n\n  getTsProgram(): ts.Program {\n    return this.tsProgram;\n  }\n\n  getReuseTsProgram(): ts.Program {\n    return this.compiler.getCurrentProgram();\n  }\n\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                         undefined): readonly ts.Diagnostic[] {\n    return this.compiler.perfRecorder.inPhase(\n        PerfPhase.TypeScriptDiagnostics,\n        () => this.tsProgram.getOptionsDiagnostics(cancellationToken));\n  }\n\n  getTsSyntacticDiagnostics(\n      sourceFile?: ts.SourceFile|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res: readonly ts.Diagnostic[];\n      if (sourceFile !== undefined) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n\n        res = this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics: ts.Diagnostic[] = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n\n  getTsSemanticDiagnostics(\n      sourceFile?: ts.SourceFile|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res: readonly ts.Diagnostic[];\n      if (sourceFile !== undefined) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n\n        res = this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics: ts.Diagnostic[] = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                         undefined): readonly ts.Diagnostic[] {\n    return this.compiler.getOptionDiagnostics();\n  }\n\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken|\n                             undefined): readonly ts.Diagnostic[] {\n    return [];\n  }\n\n  getNgSemanticDiagnostics(\n      fileName?: string|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n    let sf: ts.SourceFile|undefined = undefined;\n    if (fileName !== undefined) {\n      sf = this.tsProgram.getSourceFile(fileName);\n      if (sf === undefined) {\n        // There are no diagnostics for files which don't exist in the program - maybe the caller\n        // has stale data?\n        return [];\n      }\n    }\n\n    if (sf === undefined) {\n      return this.compiler.getDiagnostics();\n    } else {\n      return this.compiler.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n    }\n  }\n\n  /**\n   * Ensure that the `NgCompiler` has properly analyzed the program, and allow for the asynchronous\n   * loading of any resources during the process.\n   *\n   * This is used by the Angular CLI to allow for spawning (async) child compilations for things\n   * like SASS files used in `styleUrls`.\n   */\n  loadNgStructureAsync(): Promise<void> {\n    return this.compiler.analyzeAsync();\n  }\n\n  listLazyRoutes(entryRoute?: string|undefined): api.LazyRoute[] {\n    return [];\n  }\n\n  private emitXi18n(): void {\n    const ctx = new MessageBundle(new HtmlParser(), [], {}, this.options.i18nOutLocale ?? null);\n    this.compiler.xi18n(ctx);\n    i18nExtract(\n        this.options.i18nOutFormat ?? null, this.options.i18nOutFile ?? null, this.host,\n        this.options, ctx, resolve);\n  }\n\n  emit<CbEmitRes extends ts.EmitResult>(opts?: api.EmitOptions<CbEmitRes>|\n                                        undefined): ts.EmitResult {\n    // Check if emission of the i18n messages bundle was requested.\n    if (opts !== undefined && opts.emitFlags !== undefined &&\n        opts.emitFlags & api.EmitFlags.I18nBundle) {\n      this.emitXi18n();\n\n      // `api.EmitFlags` is a View Engine compiler concept. We only pay attention to the absence of\n      // the other flags here if i18n emit was requested (since this is usually done in the xi18n\n      // flow, where we don't want to emit JS at all).\n      if (!(opts.emitFlags & api.EmitFlags.JS)) {\n        return {\n          diagnostics: [],\n          emitSkipped: true,\n          emittedFiles: [],\n        };\n      }\n    }\n\n    const forceEmit = opts?.forceEmit ?? false;\n\n    this.compiler.perfRecorder.memory(PerfCheckpoint.PreEmit);\n\n    const res = this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptEmit, () => {\n      const {transformers} = this.compiler.prepareEmit();\n      const ignoreFiles = this.compiler.ignoreForEmit;\n      const emitCallback =\n          (opts?.emitCallback ?? defaultEmitCallback) as api.TsEmitCallback<CbEmitRes>;\n\n      const writeFile: ts.WriteFileCallback =\n          (fileName: string, data: string, writeByteOrderMark: boolean,\n           onError: ((message: string) => void)|undefined,\n           sourceFiles: ReadonlyArray<ts.SourceFile>|undefined) => {\n            if (sourceFiles !== undefined) {\n              // Record successful writes for any `ts.SourceFile` (that's not a declaration file)\n              // that's an input to this write.\n              for (const writtenSf of sourceFiles) {\n                if (writtenSf.isDeclarationFile) {\n                  continue;\n                }\n\n                this.compiler.incrementalCompilation.recordSuccessfulEmit(writtenSf);\n              }\n            }\n            this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n          };\n\n      const customTransforms = opts && opts.customTransformers;\n      const beforeTransforms = transformers.before || [];\n      const afterDeclarationsTransforms = transformers.afterDeclarations;\n\n      if (customTransforms !== undefined && customTransforms.beforeTs !== undefined) {\n        beforeTransforms.push(...customTransforms.beforeTs);\n      }\n\n      const emitResults: CbEmitRes[] = [];\n\n      for (const targetSourceFile of this.tsProgram.getSourceFiles()) {\n        if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n          continue;\n        }\n\n        if (!forceEmit && this.compiler.incrementalCompilation.safeToSkipEmit(targetSourceFile)) {\n          this.compiler.perfRecorder.eventCount(PerfEvent.EmitSkipSourceFile);\n          continue;\n        }\n\n        this.compiler.perfRecorder.eventCount(PerfEvent.EmitSourceFile);\n\n        emitResults.push(emitCallback({\n          targetSourceFile,\n          program: this.tsProgram,\n          host: this.host,\n          options: this.options,\n          emitOnlyDtsFiles: false,\n          writeFile,\n          customTransformers: {\n            before: beforeTransforms,\n            after: customTransforms && customTransforms.afterTs,\n            afterDeclarations: afterDeclarationsTransforms,\n          } as any,\n        }));\n      }\n\n      this.compiler.perfRecorder.memory(PerfCheckpoint.Emit);\n\n      // Run the emit, including a custom transformer that will downlevel the Ivy decorators in\n      // code.\n      return ((opts && opts.mergeEmitResultsCallback) || mergeEmitResults)(emitResults);\n    });\n\n    // Record performance analysis information to disk if we've been asked to do so.\n    if (this.options.tracePerformance !== undefined) {\n      const perf = this.compiler.perfRecorder.finalize();\n      getFileSystem().writeFile(\n          getFileSystem().resolve(this.options.tracePerformance), JSON.stringify(perf, null, 2));\n    }\n    return res;\n  }\n\n  getIndexedComponents(): Map<DeclarationNode, IndexedComponent> {\n    return this.compiler.getIndexedComponents();\n  }\n\n  getEmittedSourceFiles(): Map<string, ts.SourceFile> {\n    throw new Error('Method not implemented.');\n  }\n}\n\nconst defaultEmitCallback: api.TsEmitCallback<ts.EmitResult> = ({\n  program,\n  targetSourceFile,\n  writeFile,\n  cancellationToken,\n  emitOnlyDtsFiles,\n  customTransformers\n}) =>\n    program.emit(\n        targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n\nfunction mergeEmitResults(emitResults: ts.EmitResult[]): ts.EmitResult {\n  const diagnostics: ts.Diagnostic[] = [];\n  let emitSkipped = false;\n  const emittedFiles: string[] = [];\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...(er.emittedFiles || []));\n  }\n\n  return {diagnostics, emitSkipped, emittedFiles};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MessageBundle, Serializer, Xliff, Xliff2, Xmb} from '@angular/compiler';\nimport * as path from 'path';\nimport ts from 'typescript';\n\nimport {CompilerOptions} from './api';\n\nexport function i18nGetExtension(formatName: string): string {\n  const format = formatName.toLowerCase();\n\n  switch (format) {\n    case 'xmb':\n      return 'xmb';\n    case 'xlf':\n    case 'xlif':\n    case 'xliff':\n    case 'xlf2':\n    case 'xliff2':\n      return 'xlf';\n  }\n\n  throw new Error(`Unsupported format \"${formatName}\"`);\n}\n\nexport function i18nExtract(\n    formatName: string|null, outFile: string|null, host: ts.CompilerHost, options: CompilerOptions,\n    bundle: MessageBundle,\n    pathResolve: (...segments: string[]) => string = path.resolve): string[] {\n  formatName = formatName || 'xlf';\n  // Checks the format and returns the extension\n  const ext = i18nGetExtension(formatName);\n  const content = i18nSerialize(bundle, formatName, options);\n  const dstFile = outFile || `messages.${ext}`;\n  const dstPath = pathResolve(options.outDir || options.basePath!, dstFile);\n  host.writeFile(dstPath, content, false, undefined, []);\n  return [dstPath];\n}\n\nexport function i18nSerialize(\n    bundle: MessageBundle, formatName: string, options: CompilerOptions): string {\n  const format = formatName.toLowerCase();\n  let serializer: Serializer;\n\n  switch (format) {\n    case 'xmb':\n      serializer = new Xmb();\n      break;\n    case 'xliff2':\n    case 'xlf2':\n      serializer = new Xliff2();\n      break;\n    case 'xlf':\n    case 'xliff':\n    default:\n      serializer = new Xliff();\n  }\n\n  return bundle.write(serializer, getPathNormalizer(options.basePath));\n}\n\nfunction getPathNormalizer(basePath?: string) {\n  // normalize source paths by removing the base path and always using \"/\" as a separator\n  return (sourcePath: string) => {\n    sourcePath = basePath ? path.relative(basePath, sourcePath) : sourcePath;\n    return sourcePath.split(path.sep).join('/');\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {compareVersions} from './version_helpers';\n\n/**\n * Minimum supported TypeScript version\n * âˆ€ supported typescript version v, v >= MIN_TS_VERSION\n *\n * Note: this check is disabled in g3, search for\n * `angularCompilerOptions.disableTypeScriptVersionCheck` config param value in g3.\n */\nconst MIN_TS_VERSION = '4.9.3';\n\n/**\n * Supremum of supported TypeScript versions\n * âˆ€ supported typescript version v, v < MAX_TS_VERSION\n * MAX_TS_VERSION is not considered as a supported TypeScript version\n *\n * Note: this check is disabled in g3, search for\n * `angularCompilerOptions.disableTypeScriptVersionCheck` config param value in g3.\n */\nconst MAX_TS_VERSION = '5.1.0';\n\n/**\n * The currently used version of TypeScript, which can be adjusted for testing purposes using\n * `setTypeScriptVersionForTesting` and `restoreTypeScriptVersionForTesting` below.\n */\nlet tsVersion = ts.version;\n\nexport function setTypeScriptVersionForTesting(version: string): void {\n  tsVersion = version;\n}\n\nexport function restoreTypeScriptVersionForTesting(): void {\n  tsVersion = ts.version;\n}\n\n/**\n * Checks whether a given version âˆˆ [minVersion, maxVersion[.\n * An error will be thrown when the given version âˆ‰ [minVersion, maxVersion[.\n *\n * @param version The version on which the check will be performed\n * @param minVersion The lower bound version. A valid version needs to be greater than minVersion\n * @param maxVersion The upper bound version. A valid version needs to be strictly less than\n * maxVersion\n *\n * @throws Will throw an error if the given version âˆ‰ [minVersion, maxVersion[\n */\nexport function checkVersion(version: string, minVersion: string, maxVersion: string) {\n  if ((compareVersions(version, minVersion) < 0 || compareVersions(version, maxVersion) >= 0)) {\n    throw new Error(`The Angular Compiler requires TypeScript >=${minVersion} and <${\n        maxVersion} but ${version} was found instead.`);\n  }\n}\n\nexport function verifySupportedTypeScriptVersion(): void {\n  checkVersion(tsVersion, MIN_TS_VERSION, MAX_TS_VERSION);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Converts a `string` version into an array of numbers\n * @example\n * toNumbers('2.0.1'); // returns [2, 0, 1]\n */\nexport function toNumbers(value: string): number[] {\n  // Drop any suffixes starting with `-` so that versions like `1.2.3-rc.5` are treated as `1.2.3`.\n  const suffixIndex = value.lastIndexOf('-');\n  return value.slice(0, suffixIndex === -1 ? value.length : suffixIndex).split('.').map(segment => {\n    const parsed = parseInt(segment, 10);\n\n    if (isNaN(parsed)) {\n      throw Error(`Unable to parse version string ${value}.`);\n    }\n\n    return parsed;\n  });\n}\n\n/**\n * Compares two arrays of positive numbers with lexicographical order in mind.\n *\n * However - unlike lexicographical order - for arrays of different length we consider:\n * [1, 2, 3] = [1, 2, 3, 0] instead of [1, 2, 3] < [1, 2, 3, 0]\n *\n * @param a The 'left hand' array in the comparison test\n * @param b The 'right hand' in the comparison test\n * @returns {-1|0|1} The comparison result: 1 if a is greater, -1 if b is greater, 0 is the two\n * arrays are equals\n */\nexport function compareNumbers(a: number[], b: number[]): -1|0|1 {\n  const max = Math.max(a.length, b.length);\n  const min = Math.min(a.length, b.length);\n\n  for (let i = 0; i < min; i++) {\n    if (a[i] > b[i]) return 1;\n    if (a[i] < b[i]) return -1;\n  }\n\n  if (min !== max) {\n    const longestArray = a.length === max ? a : b;\n\n    // The result to return in case the to arrays are considered different (1 if a is greater,\n    // -1 if b is greater)\n    const comparisonResult = a.length === max ? 1 : -1;\n\n    // Check that at least one of the remaining elements is greater than 0 to consider that the two\n    // arrays are different (e.g. [1, 0] and [1] are considered the same but not [1, 0, 1] and [1])\n    for (let i = min; i < max; i++) {\n      if (longestArray[i] > 0) {\n        return comparisonResult;\n      }\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Checks if a TypeScript version is:\n * - greater or equal than the provided `low` version,\n * - lower or equal than an optional `high` version.\n *\n * @param version The TypeScript version\n * @param low The minimum version\n * @param high The maximum version\n */\nexport function isVersionBetween(version: string, low: string, high?: string): boolean {\n  const tsNumbers = toNumbers(version);\n  if (high !== undefined) {\n    return compareNumbers(toNumbers(low), tsNumbers) <= 0 &&\n        compareNumbers(toNumbers(high), tsNumbers) >= 0;\n  }\n  return compareNumbers(toNumbers(low), tsNumbers) <= 0;\n}\n\n/**\n * Compares two versions\n *\n * @param v1 The 'left hand' version in the comparison test\n * @param v2 The 'right hand' version in the comparison test\n * @returns {-1|0|1} The comparison result: 1 if v1 is greater, -1 if v2 is greater, 0 is the two\n * versions are equals\n */\nexport function compareVersions(v1: string, v2: string): -1|0|1 {\n  return compareNumbers(toNumbers(v1), toNumbers(v2));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ComponentDecoratorHandler, DirectiveDecoratorHandler, InjectableDecoratorHandler, NgModuleDecoratorHandler, NoopReferencesRegistry, PipeDecoratorHandler, ReferencesRegistry} from '../../annotations';\nimport {InjectableClassRegistry} from '../../annotations/common';\nimport {CycleAnalyzer, CycleHandlingStrategy, ImportGraph} from '../../cycles';\nimport {COMPILER_ERRORS_WITH_GUIDES, ERROR_DETAILS_PAGE_BASE_URL, ErrorCode, FatalDiagnosticError, ngErrorCode} from '../../diagnostics';\nimport {checkForPrivateExports, ReferenceGraph} from '../../entry_point';\nimport {absoluteFromSourceFile, AbsoluteFsPath, LogicalFileSystem, resolve} from '../../file_system';\nimport {AbsoluteModuleStrategy, AliasingHost, AliasStrategy, DefaultImportTracker, ImportRewriter, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, NoopImportRewriter, PrivateExportAliasingHost, R3SymbolsImportRewriter, Reference, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesAliasingHost, UnifiedModulesStrategy} from '../../imports';\nimport {IncrementalBuildStrategy, IncrementalCompilation, IncrementalState} from '../../incremental';\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\nimport {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer';\nimport {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DirectiveMeta, DtsMetadataReader, ExportedProviderStatusResolver, HostDirectivesResolver, LocalMetadataRegistry, MetadataReader, MetadataReaderWithIndex, PipeMeta, ResourceRegistry} from '../../metadata';\nimport {NgModuleIndexImpl} from '../../metadata/src/ng_module_index';\nimport {PartialEvaluator} from '../../partial_evaluator';\nimport {ActivePerfRecorder, DelegatingPerfRecorder, PerfCheckpoint, PerfEvent, PerfPhase} from '../../perf';\nimport {FileUpdate, ProgramDriver, UpdateMode} from '../../program_driver';\nimport {DeclarationNode, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\nimport {AdapterResourceLoader} from '../../resource';\nimport {ComponentScopeReader, CompoundComponentScopeReader, LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver, TypeCheckScopeRegistry} from '../../scope';\nimport {StandaloneComponentScopeReader} from '../../scope/src/standalone';\nimport {aliasTransformFactory, CompilationMode, declarationTransformFactory, DecoratorHandler, DtsTransformRegistry, ivyTransformFactory, TraitCompiler} from '../../transform';\nimport {TemplateTypeCheckerImpl} from '../../typecheck';\nimport {OptimizeFor, TemplateTypeChecker, TypeCheckingConfig} from '../../typecheck/api';\nimport {ALL_DIAGNOSTIC_FACTORIES, ExtendedTemplateCheckerImpl} from '../../typecheck/extended';\nimport {ExtendedTemplateChecker} from '../../typecheck/extended/api';\nimport {getSourceFileOrNull, isDtsPath, toUnredirectedSourceFile} from '../../util/src/typescript';\nimport {Xi18nContext} from '../../xi18n';\nimport {DiagnosticCategoryLabel, NgCompilerAdapter, NgCompilerOptions} from '../api';\n\n/**\n * State information about a compilation which is only generated once some data is requested from\n * the `NgCompiler` (for example, by calling `getDiagnostics`).\n */\ninterface LazyCompilationState {\n  isCore: boolean;\n  traitCompiler: TraitCompiler;\n  reflector: TypeScriptReflectionHost;\n  metaReader: MetadataReader;\n  scopeRegistry: LocalModuleScopeRegistry;\n  typeCheckScopeRegistry: TypeCheckScopeRegistry;\n  exportReferenceGraph: ReferenceGraph|null;\n  dtsTransforms: DtsTransformRegistry;\n  aliasingHost: AliasingHost|null;\n  refEmitter: ReferenceEmitter;\n  templateTypeChecker: TemplateTypeChecker;\n  resourceRegistry: ResourceRegistry;\n  extendedTemplateChecker: ExtendedTemplateChecker|null;\n}\n\n\n\n/**\n * Discriminant type for a `CompilationTicket`.\n */\nexport enum CompilationTicketKind {\n  Fresh,\n  IncrementalTypeScript,\n  IncrementalResource,\n}\n\n/**\n * Begin an Angular compilation operation from scratch.\n */\nexport interface FreshCompilationTicket {\n  kind: CompilationTicketKind.Fresh;\n  options: NgCompilerOptions;\n  incrementalBuildStrategy: IncrementalBuildStrategy;\n  programDriver: ProgramDriver;\n  enableTemplateTypeChecker: boolean;\n  usePoisonedData: boolean;\n  tsProgram: ts.Program;\n  perfRecorder: ActivePerfRecorder;\n}\n\n/**\n * Begin an Angular compilation operation that incorporates changes to TypeScript code.\n */\nexport interface IncrementalTypeScriptCompilationTicket {\n  kind: CompilationTicketKind.IncrementalTypeScript;\n  options: NgCompilerOptions;\n  newProgram: ts.Program;\n  incrementalBuildStrategy: IncrementalBuildStrategy;\n  incrementalCompilation: IncrementalCompilation;\n  programDriver: ProgramDriver;\n  enableTemplateTypeChecker: boolean;\n  usePoisonedData: boolean;\n  perfRecorder: ActivePerfRecorder;\n}\n\nexport interface IncrementalResourceCompilationTicket {\n  kind: CompilationTicketKind.IncrementalResource;\n  compiler: NgCompiler;\n  modifiedResourceFiles: Set<string>;\n  perfRecorder: ActivePerfRecorder;\n}\n\n/**\n * A request to begin Angular compilation, either starting from scratch or from a known prior state.\n *\n * `CompilationTicket`s are used to initialize (or update) an `NgCompiler` instance, the core of the\n * Angular compiler. They abstract the starting state of compilation and allow `NgCompiler` to be\n * managed independently of any incremental compilation lifecycle.\n */\nexport type CompilationTicket = FreshCompilationTicket|IncrementalTypeScriptCompilationTicket|\n    IncrementalResourceCompilationTicket;\n\n/**\n * Create a `CompilationTicket` for a brand new compilation, using no prior state.\n */\nexport function freshCompilationTicket(\n    tsProgram: ts.Program, options: NgCompilerOptions,\n    incrementalBuildStrategy: IncrementalBuildStrategy, programDriver: ProgramDriver,\n    perfRecorder: ActivePerfRecorder|null, enableTemplateTypeChecker: boolean,\n    usePoisonedData: boolean): CompilationTicket {\n  return {\n    kind: CompilationTicketKind.Fresh,\n    tsProgram,\n    options,\n    incrementalBuildStrategy,\n    programDriver,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder: perfRecorder ?? ActivePerfRecorder.zeroedToNow(),\n  };\n}\n\n/**\n * Create a `CompilationTicket` as efficiently as possible, based on a previous `NgCompiler`\n * instance and a new `ts.Program`.\n */\nexport function incrementalFromCompilerTicket(\n    oldCompiler: NgCompiler, newProgram: ts.Program,\n    incrementalBuildStrategy: IncrementalBuildStrategy, programDriver: ProgramDriver,\n    modifiedResourceFiles: Set<AbsoluteFsPath>,\n    perfRecorder: ActivePerfRecorder|null): CompilationTicket {\n  const oldProgram = oldCompiler.getCurrentProgram();\n  const oldState = oldCompiler.incrementalStrategy.getIncrementalState(oldProgram);\n  if (oldState === null) {\n    // No incremental step is possible here, since no IncrementalState was found for the old\n    // program.\n    return freshCompilationTicket(\n        newProgram, oldCompiler.options, incrementalBuildStrategy, programDriver, perfRecorder,\n        oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n  }\n\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n\n  const incrementalCompilation = IncrementalCompilation.incremental(\n      newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState,\n      modifiedResourceFiles, perfRecorder);\n\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,\n    usePoisonedData: oldCompiler.usePoisonedData,\n    options: oldCompiler.options,\n    incrementalBuildStrategy,\n    incrementalCompilation,\n    programDriver,\n    newProgram,\n    perfRecorder,\n  };\n}\n\n/**\n * Create a `CompilationTicket` directly from an old `ts.Program` and associated Angular compilation\n * state, along with a new `ts.Program`.\n */\nexport function incrementalFromStateTicket(\n    oldProgram: ts.Program, oldState: IncrementalState, newProgram: ts.Program,\n    options: NgCompilerOptions, incrementalBuildStrategy: IncrementalBuildStrategy,\n    programDriver: ProgramDriver, modifiedResourceFiles: Set<AbsoluteFsPath>,\n    perfRecorder: ActivePerfRecorder|null, enableTemplateTypeChecker: boolean,\n    usePoisonedData: boolean): CompilationTicket {\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n  const incrementalCompilation = IncrementalCompilation.incremental(\n      newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState,\n      modifiedResourceFiles, perfRecorder);\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    newProgram,\n    options,\n    incrementalBuildStrategy,\n    incrementalCompilation,\n    programDriver,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder,\n  };\n}\n\nexport function resourceChangeTicket(compiler: NgCompiler, modifiedResourceFiles: Set<string>):\n    IncrementalResourceCompilationTicket {\n  return {\n    kind: CompilationTicketKind.IncrementalResource,\n    compiler,\n    modifiedResourceFiles,\n    perfRecorder: ActivePerfRecorder.zeroedToNow(),\n  };\n}\n\n\n/**\n * The heart of the Angular Ivy compiler.\n *\n * The `NgCompiler` provides an API for performing Angular compilation within a custom TypeScript\n * compiler. Each instance of `NgCompiler` supports a single compilation, which might be\n * incremental.\n *\n * `NgCompiler` is lazy, and does not perform any of the work of the compilation until one of its\n * output methods (e.g. `getDiagnostics`) is called.\n *\n * See the README.md for more information.\n */\nexport class NgCompiler {\n  /**\n   * Lazily evaluated state of the compilation.\n   *\n   * This is created on demand by calling `ensureAnalyzed`.\n   */\n  private compilation: LazyCompilationState|null = null;\n\n  /**\n   * Any diagnostics related to the construction of the compilation.\n   *\n   * These are diagnostics which arose during setup of the host and/or program.\n   */\n  private constructionDiagnostics: ts.Diagnostic[] = [];\n\n  /**\n   * Non-template diagnostics related to the program itself. Does not include template\n   * diagnostics because the template type checker memoizes them itself.\n   *\n   * This is set by (and memoizes) `getNonTemplateDiagnostics`.\n   */\n  private nonTemplateDiagnostics: ts.Diagnostic[]|null = null;\n\n  private closureCompilerEnabled: boolean;\n  private currentProgram: ts.Program;\n  private entryPoint: ts.SourceFile|null;\n  private moduleResolver: ModuleResolver;\n  private resourceManager: AdapterResourceLoader;\n  private cycleAnalyzer: CycleAnalyzer;\n  readonly ignoreForDiagnostics: Set<ts.SourceFile>;\n  readonly ignoreForEmit: Set<ts.SourceFile>;\n  readonly enableTemplateTypeChecker: boolean;\n\n  /**\n   * `NgCompiler` can be reused for multiple compilations (for resource-only changes), and each\n   * new compilation uses a fresh `PerfRecorder`. Thus, classes created with a lifespan of the\n   * `NgCompiler` use a `DelegatingPerfRecorder` so the `PerfRecorder` they write to can be updated\n   * with each fresh compilation.\n   */\n  private delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);\n\n  /**\n   * Convert a `CompilationTicket` into an `NgCompiler` instance for the requested compilation.\n   *\n   * Depending on the nature of the compilation request, the `NgCompiler` instance may be reused\n   * from a previous compilation and updated with any changes, it may be a new instance which\n   * incrementally reuses state from a previous compilation, or it may represent a fresh\n   * compilation entirely.\n   */\n  static fromTicket(ticket: CompilationTicket, adapter: NgCompilerAdapter) {\n    switch (ticket.kind) {\n      case CompilationTicketKind.Fresh:\n        return new NgCompiler(\n            adapter,\n            ticket.options,\n            ticket.tsProgram,\n            ticket.programDriver,\n            ticket.incrementalBuildStrategy,\n            IncrementalCompilation.fresh(\n                ticket.tsProgram, versionMapFromProgram(ticket.tsProgram, ticket.programDriver)),\n            ticket.enableTemplateTypeChecker,\n            ticket.usePoisonedData,\n            ticket.perfRecorder,\n        );\n      case CompilationTicketKind.IncrementalTypeScript:\n        return new NgCompiler(\n            adapter,\n            ticket.options,\n            ticket.newProgram,\n            ticket.programDriver,\n            ticket.incrementalBuildStrategy,\n            ticket.incrementalCompilation,\n            ticket.enableTemplateTypeChecker,\n            ticket.usePoisonedData,\n            ticket.perfRecorder,\n        );\n      case CompilationTicketKind.IncrementalResource:\n        const compiler = ticket.compiler;\n        compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);\n        return compiler;\n    }\n  }\n\n  private constructor(\n      private adapter: NgCompilerAdapter,\n      readonly options: NgCompilerOptions,\n      private inputProgram: ts.Program,\n      readonly programDriver: ProgramDriver,\n      readonly incrementalStrategy: IncrementalBuildStrategy,\n      readonly incrementalCompilation: IncrementalCompilation,\n      enableTemplateTypeChecker: boolean,\n      readonly usePoisonedData: boolean,\n      private livePerfRecorder: ActivePerfRecorder,\n  ) {\n    this.enableTemplateTypeChecker =\n        enableTemplateTypeChecker || (options._enableTemplateTypeChecker ?? false);\n    this.constructionDiagnostics.push(\n        ...this.adapter.constructionDiagnostics, ...verifyCompatibleTypeCheckOptions(this.options));\n\n    this.currentProgram = inputProgram;\n    this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;\n\n    this.entryPoint =\n        adapter.entryPoint !== null ? getSourceFileOrNull(inputProgram, adapter.entryPoint) : null;\n\n    const moduleResolutionCache = ts.createModuleResolutionCache(\n        this.adapter.getCurrentDirectory(),\n        // doen't retain a reference to `this`, if other closures in the constructor here reference\n        // `this` internally then a closure created here would retain them. This can cause major\n        // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its\n        // way into all kinds of places inside TS internal objects.\n        this.adapter.getCanonicalFileName.bind(this.adapter));\n    this.moduleResolver =\n        new ModuleResolver(inputProgram, this.options, this.adapter, moduleResolutionCache);\n    this.resourceManager = new AdapterResourceLoader(adapter, this.options);\n    this.cycleAnalyzer = new CycleAnalyzer(\n        new ImportGraph(inputProgram.getTypeChecker(), this.delegatingPerfRecorder));\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, inputProgram);\n\n    this.ignoreForDiagnostics =\n        new Set(inputProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));\n    this.ignoreForEmit = this.adapter.ignoreForEmit;\n\n    let dtsFileCount = 0;\n    let nonDtsFileCount = 0;\n    for (const sf of inputProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile) {\n        dtsFileCount++;\n      } else {\n        nonDtsFileCount++;\n      }\n    }\n\n    livePerfRecorder.eventCount(PerfEvent.InputDtsFile, dtsFileCount);\n    livePerfRecorder.eventCount(PerfEvent.InputTsFile, nonDtsFileCount);\n  }\n\n  get perfRecorder(): ActivePerfRecorder {\n    return this.livePerfRecorder;\n  }\n\n  private updateWithChangedResources(\n      changedResources: Set<string>, perfRecorder: ActivePerfRecorder): void {\n    this.livePerfRecorder = perfRecorder;\n    this.delegatingPerfRecorder.target = perfRecorder;\n\n    perfRecorder.inPhase(PerfPhase.ResourceUpdate, () => {\n      if (this.compilation === null) {\n        // Analysis hasn't happened yet, so no update is necessary - any changes to resources will\n        // be captured by the initial analysis pass itself.\n        return;\n      }\n\n      this.resourceManager.invalidate();\n\n      const classesToUpdate = new Set<DeclarationNode>();\n      for (const resourceFile of changedResources) {\n        for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {\n          classesToUpdate.add(templateClass);\n        }\n\n        for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {\n          classesToUpdate.add(styleClass);\n        }\n      }\n\n      for (const clazz of classesToUpdate) {\n        this.compilation.traitCompiler.updateResources(clazz);\n        if (!ts.isClassDeclaration(clazz)) {\n          continue;\n        }\n\n        this.compilation.templateTypeChecker.invalidateClass(clazz);\n      }\n    });\n  }\n\n  /**\n   * Get the resource dependencies of a file.\n   *\n   * If the file is not part of the compilation, an empty array will be returned.\n   */\n  getResourceDependencies(file: ts.SourceFile): string[] {\n    this.ensureAnalyzed();\n\n    return this.incrementalCompilation.depGraph.getResourceDependencies(file);\n  }\n\n  /**\n   * Get all Angular-related diagnostics for this compilation.\n   */\n  getDiagnostics(): ts.Diagnostic[] {\n    const diagnostics: ts.Diagnostic[] = [];\n    diagnostics.push(...this.getNonTemplateDiagnostics(), ...this.getTemplateDiagnostics());\n    if (this.options.strictTemplates) {\n      diagnostics.push(...this.getExtendedTemplateDiagnostics());\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n\n  /**\n   * Get all Angular-related diagnostics for this compilation.\n   *\n   * If a `ts.SourceFile` is passed, only diagnostics related to that file are returned.\n   */\n  getDiagnosticsForFile(file: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[] {\n    const diagnostics: ts.Diagnostic[] = [];\n    diagnostics.push(\n        ...this.getNonTemplateDiagnostics().filter(diag => diag.file === file),\n        ...this.getTemplateDiagnosticsForFile(file, optimizeFor));\n    if (this.options.strictTemplates) {\n      diagnostics.push(...this.getExtendedTemplateDiagnostics(file));\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n\n  /**\n   * Get all `ts.Diagnostic`s currently available that pertain to the given component.\n   */\n  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[] {\n    const compilation = this.ensureAnalyzed();\n    const ttc = compilation.templateTypeChecker;\n    const diagnostics: ts.Diagnostic[] = [];\n    try {\n      diagnostics.push(...ttc.getDiagnosticsForComponent(component));\n\n      const extendedTemplateChecker = compilation.extendedTemplateChecker;\n      if (this.options.strictTemplates && extendedTemplateChecker) {\n        diagnostics.push(...extendedTemplateChecker.getDiagnosticsForComponent(component));\n      }\n    } catch (err: unknown) {\n      if (!(err instanceof FatalDiagnosticError)) {\n        throw err;\n      }\n      diagnostics.push(err.toDiagnostic());\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n\n  /**\n   * Add Angular.io error guide links to diagnostics for this compilation.\n   */\n  private addMessageTextDetails(diagnostics: ts.Diagnostic[]): ts.Diagnostic[] {\n    return diagnostics.map(diag => {\n      if (diag.code && COMPILER_ERRORS_WITH_GUIDES.has(ngErrorCode(diag.code))) {\n        return {\n          ...diag,\n          messageText: diag.messageText +\n              `. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG${ngErrorCode(diag.code)}`\n        };\n      }\n      return diag;\n    });\n  }\n\n  /**\n   * Get all setup-related diagnostics for this compilation.\n   */\n  getOptionDiagnostics(): ts.Diagnostic[] {\n    return this.constructionDiagnostics;\n  }\n\n  /**\n   * Get the current `ts.Program` known to this `NgCompiler`.\n   *\n   * Compilation begins with an input `ts.Program`, and during template type-checking operations new\n   * `ts.Program`s may be produced using the `ProgramDriver`. The most recent such `ts.Program` to\n   * be produced is available here.\n   *\n   * This `ts.Program` serves two key purposes:\n   *\n   * * As an incremental starting point for creating the next `ts.Program` based on files that the\n   *   user has changed (for clients using the TS compiler program APIs).\n   *\n   * * As the \"before\" point for an incremental compilation invocation, to determine what's changed\n   *   between the old and new programs (for all compilations).\n   */\n  getCurrentProgram(): ts.Program {\n    return this.currentProgram;\n  }\n\n  getTemplateTypeChecker(): TemplateTypeChecker {\n    if (!this.enableTemplateTypeChecker) {\n      throw new Error(\n          'The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.');\n    }\n    return this.ensureAnalyzed().templateTypeChecker;\n  }\n\n  /**\n   * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.\n   */\n  getComponentsWithTemplateFile(templateFilePath: string): ReadonlySet<DeclarationNode> {\n    const {resourceRegistry} = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithTemplate(resolve(templateFilePath));\n  }\n\n  /**\n   * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.\n   */\n  getComponentsWithStyleFile(styleFilePath: string): ReadonlySet<DeclarationNode> {\n    const {resourceRegistry} = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithStyle(resolve(styleFilePath));\n  }\n\n  /**\n   * Retrieves external resources for the given component.\n   */\n  getComponentResources(classDecl: DeclarationNode): ComponentResources|null {\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const {resourceRegistry} = this.ensureAnalyzed();\n    const styles = resourceRegistry.getStyles(classDecl);\n    const template = resourceRegistry.getTemplate(classDecl);\n    if (template === null) {\n      return null;\n    }\n\n    return {styles, template};\n  }\n\n  getMeta(classDecl: DeclarationNode): PipeMeta|DirectiveMeta|null {\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const ref = new Reference(classDecl);\n    const {metaReader} = this.ensureAnalyzed();\n    const meta = metaReader.getPipeMetadata(ref) ?? metaReader.getDirectiveMetadata(ref);\n    if (meta === null) {\n      return null;\n    }\n    return meta;\n  }\n\n  /**\n   * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)\n   * asynchronously.\n   *\n   * Normally, this operation happens lazily whenever `getDiagnostics` or `prepareEmit` are called.\n   * However, certain consumers may wish to allow for an asynchronous phase of analysis, where\n   * resources such as `styleUrls` are resolved asynchronously. In these cases `analyzeAsync` must\n   * be called first, and its `Promise` awaited prior to calling any other APIs of `NgCompiler`.\n   */\n  async analyzeAsync(): Promise<void> {\n    if (this.compilation !== null) {\n      return;\n    }\n\n    await this.perfRecorder.inPhase(PerfPhase.Analysis, async () => {\n      this.compilation = this.makeCompilation();\n\n      const promises: Promise<void>[] = [];\n      for (const sf of this.inputProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n\n        let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n        if (analysisPromise !== undefined) {\n          promises.push(analysisPromise);\n        }\n      }\n\n      await Promise.all(promises);\n\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n\n  /**\n   * Fetch transformers and other information which is necessary for a consumer to `emit` the\n   * program with Angular-added definitions.\n   */\n  prepareEmit(): {\n    transformers: ts.CustomTransformers,\n  } {\n    const compilation = this.ensureAnalyzed();\n\n    const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.inputProgram) : null;\n    let importRewriter: ImportRewriter;\n    if (coreImportsFrom !== null) {\n      importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);\n    } else {\n      importRewriter = new NoopImportRewriter();\n    }\n\n    const defaultImportTracker = new DefaultImportTracker();\n\n    const before = [\n      ivyTransformFactory(\n          compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker,\n          this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled),\n      aliasTransformFactory(compilation.traitCompiler.exportStatements),\n      defaultImportTracker.importPreservingTransformer(),\n    ];\n\n    const afterDeclarations: ts.TransformerFactory<ts.SourceFile>[] = [];\n    if (compilation.dtsTransforms !== null) {\n      afterDeclarations.push(\n          declarationTransformFactory(compilation.dtsTransforms, importRewriter));\n    }\n\n    // Only add aliasing re-exports to the .d.ts output if the `AliasingHost` requests it.\n    if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {\n      afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));\n    }\n\n    return {transformers: {before, afterDeclarations} as ts.CustomTransformers};\n  }\n\n  /**\n   * Run the indexing process and return a `Map` of all indexed components.\n   *\n   * See the `indexing` package for more details.\n   */\n  getIndexedComponents(): Map<DeclarationNode, IndexedComponent> {\n    const compilation = this.ensureAnalyzed();\n    const context = new IndexingContext();\n    compilation.traitCompiler.index(context);\n    return generateAnalysis(context);\n  }\n\n  /**\n   * Collect i18n messages into the `Xi18nContext`.\n   */\n  xi18n(ctx: Xi18nContext): void {\n    // Note that the 'resolve' phase is not strictly necessary for xi18n, but this is not currently\n    // optimized.\n    const compilation = this.ensureAnalyzed();\n    compilation.traitCompiler.xi18n(ctx);\n  }\n\n  private ensureAnalyzed(this: NgCompiler): LazyCompilationState {\n    if (this.compilation === null) {\n      this.analyzeSync();\n    }\n    return this.compilation!;\n  }\n\n  private analyzeSync(): void {\n    this.perfRecorder.inPhase(PerfPhase.Analysis, () => {\n      this.compilation = this.makeCompilation();\n      for (const sf of this.inputProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n        this.compilation.traitCompiler.analyzeSync(sf);\n      }\n\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n\n  private resolveCompilation(traitCompiler: TraitCompiler): void {\n    this.perfRecorder.inPhase(PerfPhase.Resolve, () => {\n      traitCompiler.resolve();\n\n      // At this point, analysis is complete and the compiler can now calculate which files need to\n      // be emitted, so do that.\n      this.incrementalCompilation.recordSuccessfulAnalysis(traitCompiler);\n\n      this.perfRecorder.memory(PerfCheckpoint.Resolve);\n    });\n  }\n\n  private get fullTemplateTypeCheck(): boolean {\n    // Determine the strictness level of type checking based on compiler options. As\n    // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.\n    // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`\n    // is not disabled when `strictTemplates` is enabled.\n    const strictTemplates = !!this.options.strictTemplates;\n    return strictTemplates || !!this.options.fullTemplateTypeCheck;\n  }\n\n  private getTypeCheckingConfig(): TypeCheckingConfig {\n    // Determine the strictness level of type checking based on compiler options. As\n    // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.\n    // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`\n    // is not disabled when `strictTemplates` is enabled.\n    const strictTemplates = !!this.options.strictTemplates;\n\n    const useInlineTypeConstructors = this.programDriver.supportsInlineOperations;\n\n    // First select a type-checking configuration, based on whether full template type-checking is\n    // requested.\n    let typeCheckingConfig: TypeCheckingConfig;\n    if (this.fullTemplateTypeCheck) {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: strictTemplates,\n        checkQueries: false,\n        checkTemplateBodies: true,\n        alwaysCheckSchemaInTemplateBodies: true,\n        checkTypeOfInputBindings: strictTemplates,\n        honorAccessModifiersForInputBindings: false,\n        strictNullInputBindings: strictTemplates,\n        checkTypeOfAttributes: strictTemplates,\n        // Even in full template type-checking mode, DOM binding checks are not quite ready yet.\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: strictTemplates,\n        checkTypeOfAnimationEvents: strictTemplates,\n        // Checking of DOM events currently has an adverse effect on developer experience,\n        // e.g. for `<input (blur)=\"update($event.target.value)\">` enabling this check results in:\n        // - error TS2531: Object is possibly 'null'.\n        // - error TS2339: Property 'value' does not exist on type 'EventTarget'.\n        checkTypeOfDomEvents: strictTemplates,\n        checkTypeOfDomReferences: strictTemplates,\n        // Non-DOM references have the correct type in View Engine so there is no strictness flag.\n        checkTypeOfNonDomReferences: true,\n        // Pipes are checked in View Engine so there is no strictness flag.\n        checkTypeOfPipes: true,\n        strictSafeNavigationTypes: strictTemplates,\n        useContextGenericType: strictTemplates,\n        strictLiteralTypes: true,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        // Warnings for suboptimal type inference are only enabled if in Language Service mode\n        // (providing the full TemplateTypeChecker API) and if strict mode is not enabled. In strict\n        // mode, the user is in full control of type inference.\n        suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates,\n      };\n    } else {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: false,\n        checkQueries: false,\n        checkTemplateBodies: false,\n        // Enable deep schema checking in \"basic\" template type-checking mode only if Closure\n        // compilation is requested, which is a good proxy for \"only in google3\".\n        alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,\n        checkTypeOfInputBindings: false,\n        strictNullInputBindings: false,\n        honorAccessModifiersForInputBindings: false,\n        checkTypeOfAttributes: false,\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: false,\n        checkTypeOfAnimationEvents: false,\n        checkTypeOfDomEvents: false,\n        checkTypeOfDomReferences: false,\n        checkTypeOfNonDomReferences: false,\n        checkTypeOfPipes: false,\n        strictSafeNavigationTypes: false,\n        useContextGenericType: false,\n        strictLiteralTypes: false,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        // In \"basic\" template type-checking mode, no warnings are produced since most things are\n        // not checked anyways.\n        suggestionsForSuboptimalTypeInference: false,\n      };\n    }\n\n    // Apply explicitly configured strictness flags on top of the default configuration\n    // based on \"fullTemplateTypeCheck\".\n    if (this.options.strictInputTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;\n      typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;\n    }\n    if (this.options.strictInputAccessModifiers !== undefined) {\n      typeCheckingConfig.honorAccessModifiersForInputBindings =\n          this.options.strictInputAccessModifiers;\n    }\n    if (this.options.strictNullInputTypes !== undefined) {\n      typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;\n    }\n    if (this.options.strictOutputEventTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;\n      typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;\n    }\n    if (this.options.strictDomEventTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;\n    }\n    if (this.options.strictSafeNavigationTypes !== undefined) {\n      typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;\n    }\n    if (this.options.strictDomLocalRefTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;\n    }\n    if (this.options.strictAttributeTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;\n    }\n    if (this.options.strictContextGenerics !== undefined) {\n      typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;\n    }\n    if (this.options.strictLiteralTypes !== undefined) {\n      typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;\n    }\n\n    return typeCheckingConfig;\n  }\n\n  private getTemplateDiagnostics(): ReadonlyArray<ts.Diagnostic> {\n    const compilation = this.ensureAnalyzed();\n\n    // Get the diagnostics.\n    const diagnostics: ts.Diagnostic[] = [];\n    for (const sf of this.inputProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile || this.adapter.isShim(sf)) {\n        continue;\n      }\n\n      try {\n        diagnostics.push(\n            ...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));\n      } catch (err) {\n        if (!(err instanceof FatalDiagnosticError)) {\n          throw err;\n        }\n        diagnostics.push(err.toDiagnostic());\n      }\n    }\n\n    const program = this.programDriver.getProgram();\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n    this.currentProgram = program;\n\n    return diagnostics;\n  }\n\n  private getTemplateDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor):\n      ReadonlyArray<ts.Diagnostic> {\n    const compilation = this.ensureAnalyzed();\n\n    // Get the diagnostics.\n    const diagnostics: ts.Diagnostic[] = [];\n    if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {\n      try {\n        diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));\n      } catch (err) {\n        if (!(err instanceof FatalDiagnosticError)) {\n          throw err;\n        }\n        diagnostics.push(err.toDiagnostic());\n      }\n    }\n\n    const program = this.programDriver.getProgram();\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n    this.currentProgram = program;\n\n    return diagnostics;\n  }\n\n  private getNonTemplateDiagnostics(): ts.Diagnostic[] {\n    if (this.nonTemplateDiagnostics === null) {\n      const compilation = this.ensureAnalyzed();\n      this.nonTemplateDiagnostics = [...compilation.traitCompiler.diagnostics];\n      if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {\n        this.nonTemplateDiagnostics.push(...checkForPrivateExports(\n            this.entryPoint, this.inputProgram.getTypeChecker(), compilation.exportReferenceGraph));\n      }\n    }\n    return this.nonTemplateDiagnostics;\n  }\n\n  /**\n   * Calls the `extendedTemplateCheck` phase of the trait compiler\n   * @param sf optional parameter to get diagnostics for a certain file\n   *     or all files in the program if `sf` is undefined\n   * @returns generated extended template diagnostics\n   */\n  private getExtendedTemplateDiagnostics(sf?: ts.SourceFile): ts.Diagnostic[] {\n    const diagnostics: ts.Diagnostic[] = [];\n    const compilation = this.ensureAnalyzed();\n    const extendedTemplateChecker = compilation.extendedTemplateChecker;\n    if (!extendedTemplateChecker) {\n      return [];\n    }\n\n    if (sf !== undefined) {\n      return compilation.traitCompiler.extendedTemplateCheck(sf, extendedTemplateChecker);\n    }\n    for (const sf of this.inputProgram.getSourceFiles()) {\n      diagnostics.push(\n          ...compilation.traitCompiler.extendedTemplateCheck(sf, extendedTemplateChecker));\n    }\n\n    return diagnostics;\n  }\n\n  private makeCompilation(): LazyCompilationState {\n    const checker = this.inputProgram.getTypeChecker();\n\n    const reflector = new TypeScriptReflectionHost(checker);\n\n    // Construct the ReferenceEmitter.\n    let refEmitter: ReferenceEmitter;\n    let aliasingHost: AliasingHost|null = null;\n    if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {\n      let localImportStrategy: ReferenceEmitStrategy;\n\n      // The strategy used for local, in-project imports depends on whether TS has been configured\n      // with rootDirs. If so, then multiple directories may be mapped in the same \"module\n      // namespace\" and the logic of `LogicalProjectStrategy` is required to generate correct\n      // imports which may cross these multiple directories. Otherwise, plain relative imports are\n      // sufficient.\n      if (this.options.rootDir !== undefined ||\n          (this.options.rootDirs !== undefined && this.options.rootDirs.length > 0)) {\n        // rootDirs logic is in effect - use the `LogicalProjectStrategy` for in-project relative\n        // imports.\n        localImportStrategy = new LogicalProjectStrategy(\n            reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));\n      } else {\n        // Plain relative imports are all that's needed.\n        localImportStrategy = new RelativePathStrategy(reflector);\n      }\n\n      // The CompilerHost doesn't have fileNameToModuleName, so build an NPM-centric reference\n      // resolution strategy.\n      refEmitter = new ReferenceEmitter([\n        // First, try to use local identifiers if available.\n        new LocalIdentifierStrategy(),\n        // Next, attempt to use an absolute import.\n        new AbsoluteModuleStrategy(this.inputProgram, checker, this.moduleResolver, reflector),\n        // Finally, check if the reference is being written into a file within the project's .ts\n        // sources, and use a relative import if so. If this fails, ReferenceEmitter will throw\n        // an error.\n        localImportStrategy,\n      ]);\n\n      // If an entrypoint is present, then all user imports should be directed through the\n      // entrypoint and private exports are not needed. The compiler will validate that all publicly\n      // visible directives/pipes are importable via this entrypoint.\n      if (this.entryPoint === null && this.options.generateDeepReexports === true) {\n        // No entrypoint is present and deep re-exports were requested, so configure the aliasing\n        // system to generate them.\n        aliasingHost = new PrivateExportAliasingHost(reflector);\n      }\n    } else {\n      // The CompilerHost supports fileNameToModuleName, so use that to emit imports.\n      refEmitter = new ReferenceEmitter([\n        // First, try to use local identifiers if available.\n        new LocalIdentifierStrategy(),\n        // Then use aliased references (this is a workaround to StrictDeps checks).\n        new AliasStrategy(),\n        // Then use fileNameToModuleName to emit imports.\n        new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost),\n      ]);\n      aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);\n    }\n\n    const isCore = isAngularCorePackage(this.inputProgram);\n\n    const evaluator =\n        new PartialEvaluator(reflector, checker, this.incrementalCompilation.depGraph);\n    const dtsReader = new DtsMetadataReader(checker, reflector);\n    const localMetaRegistry = new LocalMetadataRegistry();\n    const localMetaReader: MetadataReaderWithIndex = localMetaRegistry;\n    const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);\n    const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);\n    const ngModuleIndex = new NgModuleIndexImpl(metaReader, localMetaReader);\n    const ngModuleScopeRegistry = new LocalModuleScopeRegistry(\n        localMetaReader, metaReader, depScopeReader, refEmitter, aliasingHost);\n    const standaloneScopeReader =\n        new StandaloneComponentScopeReader(metaReader, ngModuleScopeRegistry, depScopeReader);\n    const scopeReader: ComponentScopeReader =\n        new CompoundComponentScopeReader([ngModuleScopeRegistry, standaloneScopeReader]);\n    const semanticDepGraphUpdater = this.incrementalCompilation.semanticDepGraphUpdater;\n    const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, ngModuleScopeRegistry]);\n    const injectableRegistry = new InjectableClassRegistry(reflector, isCore);\n    const hostDirectivesResolver = new HostDirectivesResolver(metaReader);\n    const exportedProviderStatusResolver = new ExportedProviderStatusResolver(metaReader);\n\n    const typeCheckScopeRegistry =\n        new TypeCheckScopeRegistry(scopeReader, metaReader, hostDirectivesResolver);\n\n\n    // If a flat module entrypoint was specified, then track references via a `ReferenceGraph` in\n    // order to produce proper diagnostics for incorrectly exported directives/pipes/etc. If there\n    // is no flat module entrypoint then don't pay the cost of tracking references.\n    let referencesRegistry: ReferencesRegistry;\n    let exportReferenceGraph: ReferenceGraph|null = null;\n    if (this.entryPoint !== null) {\n      exportReferenceGraph = new ReferenceGraph();\n      referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);\n    } else {\n      referencesRegistry = new NoopReferencesRegistry();\n    }\n\n    const dtsTransforms = new DtsTransformRegistry();\n\n    const resourceRegistry = new ResourceRegistry();\n\n    // Note: If this compilation builds `@angular/core`, we always build in full compilation\n    // mode. Code inside the core package is always compatible with itself, so it does not\n    // make sense to go through the indirection of partial compilation\n    let compilationMode: CompilationMode = CompilationMode.FULL;\n    if (!isCore) {\n      switch (this.options.compilationMode) {\n        case 'full':\n          compilationMode = CompilationMode.FULL;\n          break;\n        case 'partial':\n          compilationMode = CompilationMode.PARTIAL;\n          break;\n        case 'experimental-local':\n          compilationMode = CompilationMode.LOCAL;\n          break;\n      }\n    }\n\n    // Cycles are handled in full compilation mode by \"remote scoping\".\n    // \"Remote scoping\" does not work well with tree shaking for libraries.\n    // So in partial compilation mode, when building a library, a cycle will cause an error.\n    const cycleHandlingStrategy = compilationMode === CompilationMode.FULL ?\n        CycleHandlingStrategy.UseRemoteScoping :\n        CycleHandlingStrategy.Error;\n\n    const strictCtorDeps = this.options.strictInjectionParameters || false;\n\n    // Set up the IvyCompilation, which manages state for the Ivy transformer.\n    const handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[] = [\n      new ComponentDecoratorHandler(\n          reflector, evaluator, metaRegistry, metaReader, scopeReader, depScopeReader,\n          ngModuleScopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps,\n          this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false,\n          this.options.i18nUseExternalIds !== false,\n          this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData,\n          this.options.i18nNormalizeLineEndingsInICUs === true, this.moduleResolver,\n          this.cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry,\n          this.incrementalCompilation.depGraph, injectableRegistry, semanticDepGraphUpdater,\n          this.closureCompilerEnabled, this.delegatingPerfRecorder, hostDirectivesResolver),\n\n      // TODO(alxhub): understand why the cast here is necessary (something to do with `null`\n      // not being assignable to `unknown` when wrapped in `Readonly`).\n      // clang-format off\n        new DirectiveDecoratorHandler(\n            reflector, evaluator, metaRegistry, ngModuleScopeRegistry, metaReader,\n            injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater,\n          this.closureCompilerEnabled,\n          this.delegatingPerfRecorder,\n        ) as Readonly<DecoratorHandler<unknown, unknown, SemanticSymbol | null,unknown>>,\n      // clang-format on\n      // Pipe handler must be before injectable handler in list so pipe factories are printed\n      // before injectable factories (so injectable factories can delegate to them)\n      new PipeDecoratorHandler(\n          reflector, evaluator, metaRegistry, ngModuleScopeRegistry, injectableRegistry, isCore,\n          this.delegatingPerfRecorder),\n      new InjectableDecoratorHandler(\n          reflector, evaluator, isCore, strictCtorDeps, injectableRegistry,\n          this.delegatingPerfRecorder),\n      new NgModuleDecoratorHandler(\n          reflector, evaluator, metaReader, metaRegistry, ngModuleScopeRegistry, referencesRegistry,\n          exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter,\n          this.closureCompilerEnabled, this.options.onlyPublishPublicTypingsForNgModules ?? false,\n          injectableRegistry, this.delegatingPerfRecorder),\n    ];\n\n    const traitCompiler = new TraitCompiler(\n        handlers, reflector, this.delegatingPerfRecorder, this.incrementalCompilation,\n        this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms,\n        semanticDepGraphUpdater, this.adapter);\n\n    // Template type-checking may use the `ProgramDriver` to produce new `ts.Program`(s). If this\n    // happens, they need to be tracked by the `NgCompiler`.\n    const notifyingDriver =\n        new NotifyingProgramDriverWrapper(this.programDriver, (program: ts.Program) => {\n          this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n          this.currentProgram = program;\n        });\n\n    const templateTypeChecker = new TemplateTypeCheckerImpl(\n        this.inputProgram, notifyingDriver, traitCompiler, this.getTypeCheckingConfig(), refEmitter,\n        reflector, this.adapter, this.incrementalCompilation, metaReader, localMetaReader,\n        ngModuleIndex, scopeReader, typeCheckScopeRegistry, this.delegatingPerfRecorder);\n\n    // Only construct the extended template checker if the configuration is valid and usable.\n    const extendedTemplateChecker = this.constructionDiagnostics.length === 0 ?\n        new ExtendedTemplateCheckerImpl(\n            templateTypeChecker, checker, ALL_DIAGNOSTIC_FACTORIES, this.options) :\n        null;\n\n    return {\n      isCore,\n      traitCompiler,\n      reflector,\n      scopeRegistry: ngModuleScopeRegistry,\n      dtsTransforms,\n      exportReferenceGraph,\n      metaReader,\n      typeCheckScopeRegistry,\n      aliasingHost,\n      refEmitter,\n      templateTypeChecker,\n      resourceRegistry,\n      extendedTemplateChecker\n    };\n  }\n}\n\n/**\n * Determine if the given `Program` is @angular/core.\n */\nexport function isAngularCorePackage(program: ts.Program): boolean {\n  // Look for its_just_angular.ts somewhere in the program.\n  const r3Symbols = getR3SymbolsFile(program);\n  if (r3Symbols === null) {\n    return false;\n  }\n\n  // Look for the constant ITS_JUST_ANGULAR in that file.\n  return r3Symbols.statements.some(stmt => {\n    // The statement must be a variable declaration statement.\n    if (!ts.isVariableStatement(stmt)) {\n      return false;\n    }\n    // It must be exported.\n    const modifiers = ts.getModifiers(stmt);\n    if (modifiers === undefined ||\n        !modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword)) {\n      return false;\n    }\n    // It must declare ITS_JUST_ANGULAR.\n    return stmt.declarationList.declarations.some(decl => {\n      // The declaration must match the name.\n      if (!ts.isIdentifier(decl.name) || decl.name.text !== 'ITS_JUST_ANGULAR') {\n        return false;\n      }\n      // It must initialize the variable to true.\n      if (decl.initializer === undefined || decl.initializer.kind !== ts.SyntaxKind.TrueKeyword) {\n        return false;\n      }\n      // This definition matches.\n      return true;\n    });\n  });\n}\n\n/**\n * Find the 'r3_symbols.ts' file in the given `Program`, or return `null` if it wasn't there.\n */\nfunction getR3SymbolsFile(program: ts.Program): ts.SourceFile|null {\n  return program.getSourceFiles().find(file => file.fileName.indexOf('r3_symbols.ts') >= 0) || null;\n}\n\n/**\n * Since \"strictTemplates\" is a true superset of type checking capabilities compared to\n * \"fullTemplateTypeCheck\", it is required that the latter is not explicitly disabled if the\n * former is enabled.\n */\nfunction*\n    verifyCompatibleTypeCheckOptions(options: NgCompilerOptions):\n        Generator<ts.Diagnostic, void, void> {\n  if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {\n    yield makeConfigDiagnostic({\n      category: ts.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK,\n      messageText: `\nAngular compiler option \"strictTemplates\" is enabled, however \"fullTemplateTypeCheck\" is disabled.\n\nHaving the \"strictTemplates\" flag enabled implies that \"fullTemplateTypeCheck\" is also enabled, so\nthe latter can not be explicitly disabled.\n\nOne of the following actions is required:\n1. Remove the \"fullTemplateTypeCheck\" option.\n2. Remove \"strictTemplates\" or set it to 'false'.\n\nMore information about the template type checking compiler options can be found in the documentation:\nhttps://angular.io/guide/template-typecheck\n      `.trim(),\n    });\n  }\n\n  if (options.extendedDiagnostics && options.strictTemplates === false) {\n    yield makeConfigDiagnostic({\n      category: ts.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES,\n      messageText: `\nAngular compiler option \"extendedDiagnostics\" is configured, however \"strictTemplates\" is disabled.\n\nUsing \"extendedDiagnostics\" requires that \"strictTemplates\" is also enabled.\n\nOne of the following actions is required:\n1. Remove \"strictTemplates: false\" to enable it.\n2. Remove \"extendedDiagnostics\" configuration to disable them.\n      `.trim(),\n    });\n  }\n\n  const allowedCategoryLabels = Array.from(Object.values(DiagnosticCategoryLabel)) as string[];\n  const defaultCategory = options.extendedDiagnostics?.defaultCategory;\n  if (defaultCategory && !allowedCategoryLabels.includes(defaultCategory)) {\n    yield makeConfigDiagnostic({\n      category: ts.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,\n      messageText: `\nAngular compiler option \"extendedDiagnostics.defaultCategory\" has an unknown diagnostic category: \"${\n                       defaultCategory}\".\n\nAllowed diagnostic categories are:\n${allowedCategoryLabels.join('\\n')}\n      `.trim(),\n    });\n  }\n\n  const allExtendedDiagnosticNames =\n      ALL_DIAGNOSTIC_FACTORIES.map((factory) => factory.name) as string[];\n  for (const [checkName, category] of Object.entries(options.extendedDiagnostics?.checks ?? {})) {\n    if (!allExtendedDiagnosticNames.includes(checkName)) {\n      yield makeConfigDiagnostic({\n        category: ts.DiagnosticCategory.Error,\n        code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK,\n        messageText: `\nAngular compiler option \"extendedDiagnostics.checks\" has an unknown check: \"${checkName}\".\n\nAllowed check names are:\n${allExtendedDiagnosticNames.join('\\n')}\n        `.trim(),\n      });\n    }\n\n    if (!allowedCategoryLabels.includes(category)) {\n      yield makeConfigDiagnostic({\n        category: ts.DiagnosticCategory.Error,\n        code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,\n        messageText: `\nAngular compiler option \"extendedDiagnostics.checks['${\n                         checkName}']\" has an unknown diagnostic category: \"${category}\".\n\nAllowed diagnostic categories are:\n${allowedCategoryLabels.join('\\n')}\n        `.trim(),\n      });\n    }\n  }\n}\n\nfunction makeConfigDiagnostic({category, code, messageText}: {\n  category: ts.DiagnosticCategory,\n  code: ErrorCode,\n  messageText: string,\n}): ts.Diagnostic {\n  return {\n    category,\n    code: ngErrorCode(code),\n    file: undefined,\n    start: undefined,\n    length: undefined,\n    messageText,\n  };\n}\n\nclass ReferenceGraphAdapter implements ReferencesRegistry {\n  constructor(private graph: ReferenceGraph) {}\n\n  add(source: DeclarationNode, ...references: Reference<DeclarationNode>[]): void {\n    for (const {node} of references) {\n      let sourceFile = node.getSourceFile();\n      if (sourceFile === undefined) {\n        sourceFile = ts.getOriginalNode(node).getSourceFile();\n      }\n\n      // Only record local references (not references into .d.ts files).\n      if (sourceFile === undefined || !isDtsPath(sourceFile.fileName)) {\n        this.graph.add(source, node);\n      }\n    }\n  }\n}\n\nclass NotifyingProgramDriverWrapper implements ProgramDriver {\n  getSourceFileVersion: ProgramDriver['getSourceFileVersion'];\n\n  constructor(\n      private delegate: ProgramDriver, private notifyNewProgram: (program: ts.Program) => void) {\n    this.getSourceFileVersion = this.delegate.getSourceFileVersion?.bind(this);\n  }\n\n  get supportsInlineOperations() {\n    return this.delegate.supportsInlineOperations;\n  }\n\n  getProgram(): ts.Program {\n    return this.delegate.getProgram();\n  }\n\n  updateFiles(contents: Map<AbsoluteFsPath, FileUpdate>, updateMode: UpdateMode): void {\n    this.delegate.updateFiles(contents, updateMode);\n    this.notifyNewProgram(this.delegate.getProgram());\n  }\n}\n\nfunction versionMapFromProgram(\n    program: ts.Program, driver: ProgramDriver): Map<AbsoluteFsPath, string>|null {\n  if (driver.getSourceFileVersion === undefined) {\n    return null;\n  }\n\n  const versions = new Map<AbsoluteFsPath, string>();\n  for (const possiblyRedirectedSourceFile of program.getSourceFiles()) {\n    const sf = toUnredirectedSourceFile(possiblyRedirectedSourceFile);\n    versions.set(absoluteFromSourceFile(sf), driver.getSourceFileVersion(sf));\n  }\n  return versions;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, LiteralExpr, R3DependencyMetadata, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError, makeRelatedInformation} from '../../../diagnostics';\nimport {ClassDeclaration, CtorParameter, ReflectionHost, TypeValueReferenceKind, UnavailableValue, ValueUnavailableKind,} from '../../../reflection';\n\nimport {isAngularCore, valueReferenceToExpression} from './util';\n\nexport type ConstructorDeps = {\n  deps: R3DependencyMetadata[];\n}|{\n  deps: null;\n  errors: ConstructorDepError[];\n};\n\nexport interface ConstructorDepError {\n  index: number;\n  param: CtorParameter;\n  reason: UnavailableValue;\n}\n\nexport function getConstructorDependencies(\n    clazz: ClassDeclaration, reflector: ReflectionHost, isCore: boolean): ConstructorDeps|null {\n  const deps: R3DependencyMetadata[] = [];\n  const errors: ConstructorDepError[] = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n  ctorParams.forEach((param, idx) => {\n    let token = valueReferenceToExpression(param.typeValueReference);\n    let attributeNameType: Expression|null = null;\n    let optional = false, self = false, skipSelf = false, host = false;\n\n    (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {\n      const name = isCore || dec.import === null ? dec.name : dec.import!.name;\n      if (name === 'Inject') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DECORATOR_ARITY_WRONG, dec.node,\n              `Unexpected number of arguments to @Inject().`);\n        }\n        token = new WrappedNodeExpr(dec.args[0]);\n      } else if (name === 'Optional') {\n        optional = true;\n      } else if (name === 'SkipSelf') {\n        skipSelf = true;\n      } else if (name === 'Self') {\n        self = true;\n      } else if (name === 'Host') {\n        host = true;\n      } else if (name === 'Attribute') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DECORATOR_ARITY_WRONG, dec.node,\n              `Unexpected number of arguments to @Attribute().`);\n        }\n        const attributeName = dec.args[0];\n        token = new WrappedNodeExpr(attributeName);\n        if (ts.isStringLiteralLike(attributeName)) {\n          attributeNameType = new LiteralExpr(attributeName.text);\n        } else {\n          attributeNameType =\n              new WrappedNodeExpr(ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword));\n        }\n      } else {\n        throw new FatalDiagnosticError(\n            ErrorCode.DECORATOR_UNEXPECTED, dec.node, `Unexpected decorator ${name} on parameter.`);\n      }\n    });\n\n    if (token === null) {\n      if (param.typeValueReference.kind !== TypeValueReferenceKind.UNAVAILABLE) {\n        throw new Error(\n            'Illegal state: expected value reference to be unavailable if no token is present');\n      }\n      errors.push({\n        index: idx,\n        param,\n        reason: param.typeValueReference.reason,\n      });\n    } else {\n      deps.push({token, attributeNameType, optional, self, skipSelf, host});\n    }\n  });\n  if (errors.length === 0) {\n    return {deps};\n  } else {\n    return {deps: null, errors};\n  }\n}\n\n\n/**\n * Convert `ConstructorDeps` into the `R3DependencyMetadata` array for those deps if they're valid,\n * or into an `'invalid'` signal if they're not.\n *\n * This is a companion function to `validateConstructorDependencies` which accepts invalid deps.\n */\nexport function unwrapConstructorDependencies(deps: ConstructorDeps|null): R3DependencyMetadata[]|\n    'invalid'|null {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    // These constructor dependencies are valid.\n    return deps.deps;\n  } else {\n    // These deps are invalid.\n    return 'invalid';\n  }\n}\n\nexport function getValidConstructorDependencies(\n    clazz: ClassDeclaration, reflector: ReflectionHost, isCore: boolean): R3DependencyMetadata[]|\n    null {\n  return validateConstructorDependencies(\n      clazz, getConstructorDependencies(clazz, reflector, isCore));\n}\n\n/**\n * Validate that `ConstructorDeps` does not have any invalid dependencies and convert them into the\n * `R3DependencyMetadata` array if so, or raise a diagnostic if some deps are invalid.\n *\n * This is a companion function to `unwrapConstructorDependencies` which does not accept invalid\n * deps.\n */\nexport function validateConstructorDependencies(\n    clazz: ClassDeclaration, deps: ConstructorDeps|null): R3DependencyMetadata[]|null {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    // There is at least one error.\n    const error = deps.errors[0];\n    throw createUnsuitableInjectionTokenError(clazz, error);\n  }\n}\n\n/**\n * Creates a fatal error with diagnostic for an invalid injection token.\n * @param clazz The class for which the injection token was unavailable.\n * @param error The reason why no valid injection token is available.\n */\nfunction createUnsuitableInjectionTokenError(\n    clazz: ClassDeclaration, error: ConstructorDepError): FatalDiagnosticError {\n  const {param, index, reason} = error;\n  let chainMessage: string|undefined = undefined;\n  let hints: ts.DiagnosticRelatedInformation[]|undefined = undefined;\n  switch (reason.kind) {\n    case ValueUnavailableKind.UNSUPPORTED:\n      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.'),\n      ];\n      break;\n    case ValueUnavailableKind.NO_VALUE_DECLARATION:\n      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(\n            reason.typeNode,\n            'This type does not have a value, so it cannot be used as injection token.'),\n      ];\n      if (reason.decl !== null) {\n        hints.push(makeRelatedInformation(reason.decl, 'The type is declared here.'));\n      }\n      break;\n    case ValueUnavailableKind.TYPE_ONLY_IMPORT:\n      chainMessage =\n          'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(\n            reason.typeNode,\n            'This type is imported using a type-only import, which prevents it from being usable as an injection token.'),\n        makeRelatedInformation(reason.node, 'The type-only import occurs here.'),\n      ];\n      break;\n    case ValueUnavailableKind.NAMESPACE:\n      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(\n            reason.typeNode,\n            'This type corresponds with a namespace, which cannot be used as injection token.'),\n        makeRelatedInformation(reason.importClause, 'The namespace import occurs here.'),\n      ];\n      break;\n    case ValueUnavailableKind.UNKNOWN_REFERENCE:\n      chainMessage = 'The type should reference a known declaration.';\n      hints = [makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];\n      break;\n    case ValueUnavailableKind.MISSING_TYPE:\n      chainMessage =\n          'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';\n      break;\n  }\n\n  const chain: ts.DiagnosticMessageChain = {\n    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${\n        clazz.name.text}'.`,\n    category: ts.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainMessage,\n      category: ts.DiagnosticCategory.Message,\n      code: 0,\n    }],\n  };\n\n  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @publicApi\n */\nexport enum ErrorCode {\n  DECORATOR_ARG_NOT_LITERAL = 1001,\n  DECORATOR_ARITY_WRONG = 1002,\n  DECORATOR_NOT_CALLED = 1003,\n  DECORATOR_UNEXPECTED = 1005,\n\n  /**\n   * This error code indicates that there are incompatible decorators on a type or a class field.\n   */\n  DECORATOR_COLLISION = 1006,\n\n  VALUE_HAS_WRONG_TYPE = 1010,\n  VALUE_NOT_LITERAL = 1011,\n\n  COMPONENT_MISSING_TEMPLATE = 2001,\n  PIPE_MISSING_NAME = 2002,\n  PARAM_MISSING_TOKEN = 2003,\n  DIRECTIVE_MISSING_SELECTOR = 2004,\n\n  /** Raised when an undecorated class is passed in as a provider to a module or a directive. */\n  UNDECORATED_PROVIDER = 2005,\n\n  /**\n   * Raised when a Directive inherits its constructor from a base class without an Angular\n   * decorator.\n   */\n  DIRECTIVE_INHERITS_UNDECORATED_CTOR = 2006,\n\n  /**\n   * Raised when an undecorated class that is using Angular features\n   * has been discovered.\n   */\n  UNDECORATED_CLASS_USING_ANGULAR_FEATURES = 2007,\n\n  /**\n   * Raised when an component cannot resolve an external resource, such as a template or a style\n   * sheet.\n   */\n  COMPONENT_RESOURCE_NOT_FOUND = 2008,\n\n  /**\n   * Raised when a component uses `ShadowDom` view encapsulation, but its selector\n   * does not match the shadow DOM tag name requirements.\n   */\n  COMPONENT_INVALID_SHADOW_DOM_SELECTOR = 2009,\n\n  /**\n   * Raised when a component has `imports` but is not marked as `standalone: true`.\n   */\n  COMPONENT_NOT_STANDALONE = 2010,\n\n  /**\n   * Raised when a type in the `imports` of a component is a directive or pipe, but is not\n   * standalone.\n   */\n  COMPONENT_IMPORT_NOT_STANDALONE = 2011,\n\n  /**\n   * Raised when a type in the `imports` of a component is not a directive, pipe, or NgModule.\n   */\n  COMPONENT_UNKNOWN_IMPORT = 2012,\n\n  /**\n   * Raised when the compiler wasn't able to resolve the metadata of a host directive.\n   */\n  HOST_DIRECTIVE_INVALID = 2013,\n\n  /**\n   * Raised when a host directive isn't standalone.\n   */\n  HOST_DIRECTIVE_NOT_STANDALONE = 2014,\n\n  /**\n   * Raised when a host directive is a component.\n   */\n  HOST_DIRECTIVE_COMPONENT = 2015,\n\n  /**\n   * Raised when a type with Angular decorator inherits its constructor from a base class\n   * which has a constructor that is incompatible with Angular DI.\n   */\n  INJECTABLE_INHERITS_INVALID_CONSTRUCTOR = 2016,\n\n  /** Raised when a host tries to alias a host directive binding that does not exist. */\n  HOST_DIRECTIVE_UNDEFINED_BINDING = 2017,\n\n  /**\n   * Raised when a host tries to alias a host directive\n   * binding to a pre-existing binding's public name.\n   */\n  HOST_DIRECTIVE_CONFLICTING_ALIAS = 2018,\n\n  /**\n   * Raised when a host directive definition doesn't expose a\n   * required binding from the host directive.\n   */\n  HOST_DIRECTIVE_MISSING_REQUIRED_BINDING = 2019,\n\n  SYMBOL_NOT_EXPORTED = 3001,\n  /**\n   * Raised when a relationship between directives and/or pipes would cause a cyclic import to be\n   * created that cannot be handled, such as in partial compilation mode.\n   */\n  IMPORT_CYCLE_DETECTED = 3003,\n\n  /**\n   * Raised when the compiler is unable to generate an import statement for a reference.\n   */\n  IMPORT_GENERATION_FAILURE = 3004,\n\n  CONFIG_FLAT_MODULE_NO_INDEX = 4001,\n  CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK = 4002,\n  CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES = 4003,\n  CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL = 4004,\n  CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK = 4005,\n\n  /**\n   * Raised when a host expression has a parse error, such as a host listener or host binding\n   * expression containing a pipe.\n   */\n  HOST_BINDING_PARSE_ERROR = 5001,\n\n  /**\n   * Raised when the compiler cannot parse a component's template.\n   */\n  TEMPLATE_PARSE_ERROR = 5002,\n\n  /**\n   * Raised when an NgModule contains an invalid reference in `declarations`.\n   */\n  NGMODULE_INVALID_DECLARATION = 6001,\n\n  /**\n   * Raised when an NgModule contains an invalid type in `imports`.\n   */\n  NGMODULE_INVALID_IMPORT = 6002,\n\n  /**\n   * Raised when an NgModule contains an invalid type in `exports`.\n   */\n  NGMODULE_INVALID_EXPORT = 6003,\n\n  /**\n   * Raised when an NgModule contains a type in `exports` which is neither in `declarations` nor\n   * otherwise imported.\n   */\n  NGMODULE_INVALID_REEXPORT = 6004,\n\n  /**\n   * Raised when a `ModuleWithProviders` with a missing\n   * generic type argument is passed into an `NgModule`.\n   */\n  NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC = 6005,\n\n  /**\n   * Raised when an NgModule exports multiple directives/pipes of the same name and the compiler\n   * attempts to generate private re-exports within the NgModule file.\n   */\n  NGMODULE_REEXPORT_NAME_COLLISION = 6006,\n\n  /**\n   * Raised when a directive/pipe is part of the declarations of two or more NgModules.\n   */\n  NGMODULE_DECLARATION_NOT_UNIQUE = 6007,\n\n  /**\n   * Raised when a standalone directive/pipe is part of the declarations of an NgModule.\n   */\n  NGMODULE_DECLARATION_IS_STANDALONE = 6008,\n\n  /**\n   * Raised when a standalone component is part of the bootstrap list of an NgModule.\n   */\n  NGMODULE_BOOTSTRAP_IS_STANDALONE = 6009,\n\n  /**\n   * Indicates that an NgModule is declared with `id: module.id`. This is an anti-pattern that is\n   * disabled explicitly in the compiler, that was originally based on a misunderstanding of\n   * `NgModule.id`.\n   */\n  WARN_NGMODULE_ID_UNNECESSARY = 6100,\n\n  /**\n   * Not actually raised by the compiler, but reserved for documentation of a View Engine error when\n   * a View Engine build depends on an Ivy-compiled NgModule.\n   */\n  NGMODULE_VE_DEPENDENCY_ON_IVY_LIB = 6999,\n\n  /**\n   * An element name failed validation against the DOM schema.\n   */\n  SCHEMA_INVALID_ELEMENT = 8001,\n\n  /**\n   * An element's attribute name failed validation against the DOM schema.\n   */\n  SCHEMA_INVALID_ATTRIBUTE = 8002,\n\n  /**\n   * No matching directive was found for a `#ref=\"target\"` expression.\n   */\n  MISSING_REFERENCE_TARGET = 8003,\n\n  /**\n   * No matching pipe was found for a\n   */\n  MISSING_PIPE = 8004,\n\n  /**\n   * The left-hand side of an assignment expression was a template variable. Effectively, the\n   * template looked like:\n   *\n   * ```\n   * <ng-template let-something>\n   *   <button (click)=\"something = ...\">...</button>\n   * </ng-template>\n   * ```\n   *\n   * Template variables are read-only.\n   */\n  WRITE_TO_READ_ONLY_VARIABLE = 8005,\n\n  /**\n   * A template variable was declared twice. For example:\n   *\n   * ```html\n   * <div *ngFor=\"let i of items; let i = index\">\n   * </div>\n   * ```\n   */\n  DUPLICATE_VARIABLE_DECLARATION = 8006,\n\n  /**\n   * A template has a two way binding (two bindings created by a single syntactical element)\n   * in which the input and output are going to different places.\n   */\n  SPLIT_TWO_WAY_BINDING = 8007,\n\n  /**\n   * A directive usage isn't binding to one or more required inputs.\n   */\n  MISSING_REQUIRED_INPUTS = 8008,\n\n  /**\n   * A two way binding in a template has an incorrect syntax,\n   * parentheses outside brackets. For example:\n   *\n   * ```\n   * <div ([foo])=\"bar\" />\n   * ```\n   */\n  INVALID_BANANA_IN_BOX = 8101,\n\n  /**\n   * The left side of a nullish coalescing operation is not nullable.\n   *\n   * ```\n   * {{ foo ?? bar }}\n   * ```\n   * When the type of foo doesn't include `null` or `undefined`.\n   */\n  NULLISH_COALESCING_NOT_NULLABLE = 8102,\n\n  /**\n   * A known control flow directive (e.g. `*ngIf`) is used in a template,\n   * but the `CommonModule` is not imported.\n   */\n  MISSING_CONTROL_FLOW_DIRECTIVE = 8103,\n\n  /**\n   * A text attribute is not interpreted as a binding but likely intended to be.\n   *\n   * For example:\n   * ```\n   * <div\n   *   attr.x=\"value\"\n   *   class.blue=\"true\"\n   *   style.margin-right.px=\"5\">\n   * </div>\n   * ```\n   *\n   * All of the above attributes will just be static text attributes and will not be interpreted as\n   * bindings by the compiler.\n   */\n  TEXT_ATTRIBUTE_NOT_BINDING = 8104,\n\n  /**\n   * NgForOf is used in a template, but the user forgot to include let\n   * in their statement.\n   *\n   * For example:\n   * ```\n   * <ul><li *ngFor=\"item of items\">{{item[\"name\"]}};</li></ul>\n   * ```\n   */\n  MISSING_NGFOROF_LET = 8105,\n  /**\n   * Indicates that the binding suffix is not supported\n   *\n   * Style bindings support suffixes like `style.width.px`, `.em`, and `.%`.\n   * These suffixes are _not_ supported for attribute bindings.\n   *\n   * For example `[attr.width.px]=\"5\"` becomes `width.px=\"5\"` when bound.\n   * This is almost certainly unintentional and this error is meant to\n   * surface this mistake to the developer.\n   */\n  SUFFIX_NOT_SUPPORTED = 8106,\n\n  /**\n   * The left side of an optional chain operation is not nullable.\n   *\n   * ```\n   * {{ foo?.bar }}\n   * {{ foo?.['bar'] }}\n   * {{ foo?.() }}\n   * ```\n   * When the type of foo doesn't include `null` or `undefined`.\n   */\n  OPTIONAL_CHAIN_NOT_NULLABLE = 8107,\n\n\n  /**\n   * `ngSkipHydration` should not be a binding (it should be a static attribute).\n   *\n   * For example:\n   * ```\n   * <my-cmp [ngSkipHydration]=\"someTruthyVar\" />\n   * ```\n   *\n   * `ngSkipHydration` cannot be a binding and can not have values other than \"true\" or an empty\n   * value\n   */\n  SKIP_HYDRATION_NOT_STATIC = 8108,\n\n  /**\n   * The template type-checking engine would need to generate an inline type check block for a\n   * component, but the current type-checking environment doesn't support it.\n   */\n  INLINE_TCB_REQUIRED = 8900,\n\n  /**\n   * The template type-checking engine would need to generate an inline type constructor for a\n   * directive or component, but the current type-checking environment doesn't support it.\n   */\n  INLINE_TYPE_CTOR_REQUIRED = 8901,\n\n  /**\n   * An injectable already has a `Éµprov` property.\n   */\n  INJECTABLE_DUPLICATE_PROV = 9001,\n\n  // 10XXX error codes are reserved for diagnostics with categories other than\n  // `ts.DiagnosticCategory.Error`. These diagnostics are generated by the compiler when configured\n  // to do so by a tool such as the Language Service, or by the Language Service itself.\n\n  /**\n   * Suggest users to enable `strictTemplates` to make use of full capabilities\n   * provided by Angular language service.\n   */\n  SUGGEST_STRICT_TEMPLATES = 10001,\n\n  /**\n   * Indicates that a particular structural directive provides advanced type narrowing\n   * functionality, but the current template type-checking configuration does not allow its usage in\n   * type inference.\n   */\n  SUGGEST_SUBOPTIMAL_TYPE_INFERENCE = 10002,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ErrorCode} from './error_code';\n\n/**\n * Contains a set of error messages that have detailed guides at angular.io.\n * Full list of available error guides can be found at https://angular.io/errors\n */\nexport const COMPILER_ERRORS_WITH_GUIDES = new Set([\n  ErrorCode.DECORATOR_ARG_NOT_LITERAL,\n  ErrorCode.IMPORT_CYCLE_DETECTED,\n  ErrorCode.PARAM_MISSING_TOKEN,\n  ErrorCode.SCHEMA_INVALID_ELEMENT,\n  ErrorCode.SCHEMA_INVALID_ATTRIBUTE,\n  ErrorCode.MISSING_REFERENCE_TARGET,\n  ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR,\n  ErrorCode.WARN_NGMODULE_ID_UNNECESSARY,\n]);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode} from './error_code';\nimport {ngErrorCode} from './util';\n\nexport class FatalDiagnosticError {\n  constructor(\n      readonly code: ErrorCode, readonly node: ts.Node,\n      readonly message: string|ts.DiagnosticMessageChain,\n      readonly relatedInformation?: ts.DiagnosticRelatedInformation[]) {}\n\n  /**\n   * @internal\n   */\n  _isFatalDiagnosticError = true;\n\n  toDiagnostic(): ts.DiagnosticWithLocation {\n    return makeDiagnostic(this.code, this.node, this.message, this.relatedInformation);\n  }\n}\n\nexport function makeDiagnostic(\n    code: ErrorCode, node: ts.Node, messageText: string|ts.DiagnosticMessageChain,\n    relatedInformation?: ts.DiagnosticRelatedInformation[]): ts.DiagnosticWithLocation {\n  node = ts.getOriginalNode(node);\n  return {\n    category: ts.DiagnosticCategory.Error,\n    code: ngErrorCode(code),\n    file: ts.getOriginalNode(node).getSourceFile(),\n    start: node.getStart(undefined, false),\n    length: node.getWidth(),\n    messageText,\n    relatedInformation,\n  };\n}\n\nexport function makeDiagnosticChain(\n    messageText: string, next?: ts.DiagnosticMessageChain[]): ts.DiagnosticMessageChain {\n  return {\n    category: ts.DiagnosticCategory.Message,\n    code: 0,\n    messageText,\n    next,\n  };\n}\n\nexport function makeRelatedInformation(\n    node: ts.Node, messageText: string): ts.DiagnosticRelatedInformation {\n  node = ts.getOriginalNode(node);\n  return {\n    category: ts.DiagnosticCategory.Message,\n    code: 0,\n    file: node.getSourceFile(),\n    start: node.getStart(),\n    length: node.getWidth(),\n    messageText,\n  };\n}\n\nexport function addDiagnosticChain(\n    messageText: string|ts.DiagnosticMessageChain,\n    add: ts.DiagnosticMessageChain[]): ts.DiagnosticMessageChain {\n  if (typeof messageText === 'string') {\n    return makeDiagnosticChain(messageText, add);\n  }\n\n  if (messageText.next === undefined) {\n    messageText.next = add;\n  } else {\n    messageText.next.push(...add);\n  }\n\n  return messageText;\n}\n\nexport function isFatalDiagnosticError(err: any): err is FatalDiagnosticError {\n  return err._isFatalDiagnosticError === true;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ErrorCode} from './error_code';\n\nconst ERROR_CODE_MATCHER = /(\\u001b\\[\\d+m ?)TS-99(\\d+: ?\\u001b\\[\\d+m)/g;\n\n/**\n * During formatting of `ts.Diagnostic`s, the numeric code of each diagnostic is prefixed with the\n * hard-coded \"TS\" prefix. For Angular's own error codes, a prefix of \"NG\" is desirable. To achieve\n * this, all Angular error codes start with \"-99\" so that the sequence \"TS-99\" can be assumed to\n * correspond with an Angular specific error code. This function replaces those occurrences with\n * just \"NG\".\n *\n * @param errors The formatted diagnostics\n */\nexport function replaceTsWithNgInErrors(errors: string): string {\n  return errors.replace(ERROR_CODE_MATCHER, '$1NG$2');\n}\n\nexport function ngErrorCode(code: ErrorCode): number {\n  return parseInt('-99' + code);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base URL for the error details page.\n *\n * Keep the files below in full sync:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nexport const ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Enum holding the name of each extended template diagnostic. The name is used as a user-meaningful\n * value for configuring the diagnostic in the project's options.\n *\n * See the corresponding `ErrorCode` for documentation about each specific error.\n * packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.ts\n *\n * @publicApi\n */\nexport enum ExtendedTemplateDiagnosticName {\n  INVALID_BANANA_IN_BOX = 'invalidBananaInBox',\n  NULLISH_COALESCING_NOT_NULLABLE = 'nullishCoalescingNotNullable',\n  OPTIONAL_CHAIN_NOT_NULLABLE = 'optionalChainNotNullable',\n  MISSING_CONTROL_FLOW_DIRECTIVE = 'missingControlFlowDirective',\n  TEXT_ATTRIBUTE_NOT_BINDING = 'textAttributeNotBinding',\n  MISSING_NGFOROF_LET = 'missingNgForOfLet',\n  SUFFIX_NOT_SUPPORTED = 'suffixNotSupported',\n  SKIP_HYDRATION_NOT_STATIC = 'skipHydrationNotStatic',\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr, FactoryTarget, ParseLocation, ParseSourceFile, ParseSourceSpan, R3CompiledExpression, R3FactoryMetadata, R3Reference, ReadPropExpr, Statement, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {assertSuccessfulReferenceEmit, ImportedFile, ImportFlags, ModuleResolver, Reference, ReferenceEmitter} from '../../../imports';\nimport {attachDefaultImportDeclaration} from '../../../imports/src/default';\nimport {DynamicValue, ForeignFunctionResolver, PartialEvaluator} from '../../../partial_evaluator';\nimport {ClassDeclaration, Decorator, Import, ImportedTypeValueReference, LocalTypeValueReference, ReflectionHost, TypeValueReference, TypeValueReferenceKind} from '../../../reflection';\nimport {CompileResult} from '../../../transform';\n\n/**\n * Convert a `TypeValueReference` to an `Expression` which refers to the type as a value.\n *\n * Local references are converted to a `WrappedNodeExpr` of the TypeScript expression, and non-local\n * references are converted to an `ExternalExpr`. Note that this is only valid in the context of the\n * file in which the `TypeValueReference` originated.\n */\nexport function valueReferenceToExpression(valueRef: LocalTypeValueReference|\n                                           ImportedTypeValueReference): Expression;\nexport function valueReferenceToExpression(valueRef: TypeValueReference): Expression|null;\nexport function valueReferenceToExpression(valueRef: TypeValueReference): Expression|null {\n  if (valueRef.kind === TypeValueReferenceKind.UNAVAILABLE) {\n    return null;\n  } else if (valueRef.kind === TypeValueReferenceKind.LOCAL) {\n    const expr = new WrappedNodeExpr(valueRef.expression);\n    if (valueRef.defaultImportStatement !== null) {\n      attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n    }\n    return expr;\n  } else {\n    let importExpr: Expression =\n        new ExternalExpr({moduleName: valueRef.moduleName, name: valueRef.importedName});\n    if (valueRef.nestedPath !== null) {\n      for (const property of valueRef.nestedPath) {\n        importExpr = new ReadPropExpr(importExpr, property);\n      }\n    }\n    return importExpr;\n  }\n}\n\nexport function toR3Reference(\n    origin: ts.Node, ref: Reference, context: ts.SourceFile,\n    refEmitter: ReferenceEmitter): R3Reference {\n  const emittedValueRef = refEmitter.emit(ref, context);\n  assertSuccessfulReferenceEmit(emittedValueRef, origin, 'class');\n\n  const emittedTypeRef =\n      refEmitter.emit(ref, context, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);\n  assertSuccessfulReferenceEmit(emittedTypeRef, origin, 'class');\n\n  return {\n    value: emittedValueRef.expression,\n    type: emittedTypeRef.expression,\n  };\n}\n\nexport function isAngularCore(decorator: Decorator): decorator is Decorator&{import: Import} {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\nexport function isAngularCoreReference(reference: Reference, symbolName: string): boolean {\n  return reference.ownedByModuleGuess === '@angular/core' && reference.debugName === symbolName;\n}\n\nexport function findAngularDecorator(\n    decorators: Decorator[], name: string, isCore: boolean): Decorator|undefined {\n  return decorators.find(decorator => isAngularDecorator(decorator, name, isCore));\n}\n\nexport function isAngularDecorator(decorator: Decorator, name: string, isCore: boolean): boolean {\n  if (isCore) {\n    return decorator.name === name;\n  } else if (isAngularCore(decorator)) {\n    return decorator.import.name === name;\n  }\n  return false;\n}\n\n/**\n * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its\n * lowest level form.\n *\n * For example, the expression \"(foo as Type)\" unwraps to \"foo\".\n */\nexport function unwrapExpression(node: ts.Expression): ts.Expression {\n  while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\n\nfunction expandForwardRef(arg: ts.Expression): ts.Expression|null {\n  arg = unwrapExpression(arg);\n  if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {\n    return null;\n  }\n\n  const body = arg.body;\n  // Either the body is a ts.Expression directly, or a block with a single return statement.\n  if (ts.isBlock(body)) {\n    // Block body - look for a single return statement.\n    if (body.statements.length !== 1) {\n      return null;\n    }\n    const stmt = body.statements[0];\n    if (!ts.isReturnStatement(stmt) || stmt.expression === undefined) {\n      return null;\n    }\n    return stmt.expression;\n  } else {\n    // Shorthand body - return as an expression.\n    return body;\n  }\n}\n\n\n/**\n * If the given `node` is a forwardRef() expression then resolve its inner value, otherwise return\n * `null`.\n *\n * @param node the forwardRef() expression to resolve\n * @param reflector a ReflectionHost\n * @returns the resolved expression, if the original expression was a forwardRef(), or `null`\n *     otherwise.\n */\nexport function tryUnwrapForwardRef(node: ts.Expression, reflector: ReflectionHost): ts.Expression|\n    null {\n  node = unwrapExpression(node);\n  if (!ts.isCallExpression(node) || node.arguments.length !== 1) {\n    return null;\n  }\n\n  const fn =\n      ts.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n  if (!ts.isIdentifier(fn)) {\n    return null;\n  }\n\n  const expr = expandForwardRef(node.arguments[0]);\n  if (expr === null) {\n    return null;\n  }\n\n  const imp = reflector.getImportOfIdentifier(fn);\n  if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {\n    return null;\n  }\n\n  return expr;\n}\n\n/**\n * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.\n *\n * @param ref a Reference to the declaration of the function being called (which might be\n * forwardRef)\n * @param args the arguments to the invocation of the forwardRef expression\n * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise\n */\nexport const forwardRefResolver: ForeignFunctionResolver =\n    (fn, callExpr, resolve, unresolvable) => {\n      if (!isAngularCoreReference(fn, 'forwardRef') || callExpr.arguments.length !== 1) {\n        return unresolvable;\n      }\n      const expanded = expandForwardRef(callExpr.arguments[0]);\n      if (expanded !== null) {\n        return resolve(expanded);\n      } else {\n        return unresolvable;\n      }\n    };\n\n/**\n * Combines an array of resolver functions into a one.\n * @param resolvers Resolvers to be combined.\n */\nexport function combineResolvers(resolvers: ForeignFunctionResolver[]): ForeignFunctionResolver {\n  return (fn, callExpr, resolve, unresolvable) => {\n    for (const resolver of resolvers) {\n      const resolved = resolver(fn, callExpr, resolve, unresolvable);\n      if (resolved !== unresolvable) {\n        return resolved;\n      }\n    }\n    return unresolvable;\n  };\n}\n\nexport function isExpressionForwardReference(\n    expr: Expression, context: ts.Node, contextSource: ts.SourceFile): boolean {\n  if (isWrappedTsNodeExpr(expr)) {\n    const node = ts.getOriginalNode(expr.node);\n    return node.getSourceFile() === contextSource && context.pos < node.pos;\n  } else {\n    return false;\n  }\n}\n\nexport function isWrappedTsNodeExpr(expr: Expression): expr is WrappedNodeExpr<ts.Node> {\n  return expr instanceof WrappedNodeExpr;\n}\n\nexport function readBaseClass(\n    node: ClassDeclaration, reflector: ReflectionHost,\n    evaluator: PartialEvaluator): Reference<ClassDeclaration>|'dynamic'|null {\n  const baseExpression = reflector.getBaseClassExpression(node);\n  if (baseExpression !== null) {\n    const baseClass = evaluator.evaluate(baseExpression);\n    if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {\n      return baseClass as Reference<ClassDeclaration>;\n    } else {\n      return 'dynamic';\n    }\n  }\n\n  return null;\n}\n\nconst parensWrapperTransformerFactory: ts.TransformerFactory<ts.Expression> =\n    (context: ts.TransformationContext) => {\n      const visitor: ts.Visitor = (node: ts.Node): ts.Node => {\n        const visited = ts.visitEachChild(node, visitor, context);\n        if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {\n          return ts.factory.createParenthesizedExpression(visited);\n        }\n        return visited;\n      };\n      return (node: ts.Expression) => ts.visitEachChild(node, visitor, context);\n    };\n\n/**\n * Wraps all functions in a given expression in parentheses. This is needed to avoid problems\n * where Tsickle annotations added between analyse and transform phases in Angular may trigger\n * automatic semicolon insertion, e.g. if a function is the expression in a `return` statement.\n * More\n * info can be found in Tsickle source code here:\n * https://github.com/angular/tsickle/blob/d7974262571c8a17d684e5ba07680e1b1993afdd/src/jsdoc_transformer.ts#L1021\n *\n * @param expression Expression where functions should be wrapped in parentheses\n */\nexport function wrapFunctionExpressionsInParens(expression: ts.Expression): ts.Expression {\n  return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n}\n\n/**\n * Resolves the given `rawProviders` into `ClassDeclarations` and returns\n * a set containing those that are known to require a factory definition.\n * @param rawProviders Expression that declared the providers array in the source.\n */\nexport function resolveProvidersRequiringFactory(\n    rawProviders: ts.Expression, reflector: ReflectionHost,\n    evaluator: PartialEvaluator): Set<Reference<ClassDeclaration>> {\n  const providers = new Set<Reference<ClassDeclaration>>();\n  const resolvedProviders = evaluator.evaluate(rawProviders);\n\n  if (!Array.isArray(resolvedProviders)) {\n    return providers;\n  }\n\n  resolvedProviders.forEach(function processProviders(provider) {\n    let tokenClass: Reference|null = null;\n\n    if (Array.isArray(provider)) {\n      // If we ran into an array, recurse into it until we've resolve all the classes.\n      provider.forEach(processProviders);\n    } else if (provider instanceof Reference) {\n      tokenClass = provider;\n    } else if (provider instanceof Map && provider.has('useClass') && !provider.has('deps')) {\n      const useExisting = provider.get('useClass')!;\n      if (useExisting instanceof Reference) {\n        tokenClass = useExisting;\n      }\n    }\n\n    // TODO(alxhub): there was a bug where `getConstructorParameters` would return `null` for a\n    // class in a .d.ts file, always, even if the class had a constructor. This was fixed for\n    // `getConstructorParameters`, but that fix causes more classes to be recognized here as needing\n    // provider checks, which is a breaking change in g3. Avoid this breakage for now by skipping\n    // classes from .d.ts files here directly, until g3 can be cleaned up.\n    if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile &&\n        reflector.isClass(tokenClass.node)) {\n      const constructorParameters = reflector.getConstructorParameters(tokenClass.node);\n\n      // Note that we only want to capture providers with a non-trivial constructor,\n      // because they're the ones that might be using DI and need to be decorated.\n      if (constructorParameters !== null && constructorParameters.length > 0) {\n        providers.add(tokenClass as Reference<ClassDeclaration>);\n      }\n    }\n  });\n\n  return providers;\n}\n\n/**\n * Create an R3Reference for a class.\n *\n * The `value` is the exported declaration of the class from its source file.\n * The `type` is an expression that would be used in the typings (.d.ts) files.\n */\nexport function wrapTypeReference(reflector: ReflectionHost, clazz: ClassDeclaration): R3Reference {\n  const value = new WrappedNodeExpr(clazz.name);\n  const type = value;\n  return {value, type};\n}\n\n/** Creates a ParseSourceSpan for a TypeScript node. */\nexport function createSourceSpan(node: ts.Node): ParseSourceSpan {\n  const sf = node.getSourceFile();\n  const [startOffset, endOffset] = [node.getStart(), node.getEnd()];\n  const {line: startLine, character: startCol} = sf.getLineAndCharacterOfPosition(startOffset);\n  const {line: endLine, character: endCol} = sf.getLineAndCharacterOfPosition(endOffset);\n  const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);\n\n  // +1 because values are zero-indexed.\n  return new ParseSourceSpan(\n      new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1),\n      new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n}\n\n/**\n * Collate the factory and definition compiled results into an array of CompileResult objects.\n */\nexport function compileResults(\n    fac: CompileResult, def: R3CompiledExpression, metadataStmt: Statement|null,\n    propName: string): CompileResult[] {\n  const statements = def.statements;\n  if (metadataStmt !== null) {\n    statements.push(metadataStmt);\n  }\n  return [\n    fac, {\n      name: propName,\n      initializer: def.expression,\n      statements: def.statements,\n      type: def.type,\n    }\n  ];\n}\n\nexport function toFactoryMetadata(\n    meta: Omit<R3FactoryMetadata, 'target'>, target: FactoryTarget): R3FactoryMetadata {\n  return {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: meta.deps,\n    target\n  };\n}\n\nexport function resolveImportedFile(\n    moduleResolver: ModuleResolver, importedFile: ImportedFile, expr: Expression,\n    origin: ts.SourceFile): ts.SourceFile|null {\n  // If `importedFile` is not 'unknown' then it accurately reflects the source file that is\n  // being imported.\n  if (importedFile !== 'unknown') {\n    return importedFile;\n  }\n\n  // Otherwise `expr` has to be inspected to determine the file that is being imported. If `expr`\n  // is not an `ExternalExpr` then it does not correspond with an import, so return null in that\n  // case.\n  if (!(expr instanceof ExternalExpr)) {\n    return null;\n  }\n\n  // Figure out what file is being imported.\n  return moduleResolver.resolveModule(expr.value.moduleName!, origin.fileName);\n}\n\n\n/**\n * Determines the most appropriate expression for diagnostic reporting purposes. If `expr` is\n * contained within `container` then `expr` is used as origin node, otherwise `container` itself is\n * used.\n */\nexport function getOriginNodeForDiagnostics(\n    expr: ts.Expression, container: ts.Expression): ts.Expression {\n  const nodeSf = expr.getSourceFile();\n  const exprSf = container.getSourceFile();\n\n  if (nodeSf === exprSf && expr.pos >= container.pos && expr.end <= container.end) {\n    // `expr` occurs within the same source file as `container` and is contained within it, so\n    // `expr` is appropriate to use as origin node for diagnostics.\n    return expr;\n  } else {\n    return container;\n  }\n}\n\nexport function isAbstractClassDeclaration(clazz: ClassDeclaration): boolean {\n  return ts.canHaveModifiers(clazz) && clazz.modifiers !== undefined ?\n      clazz.modifiers.some(mod => mod.kind === ts.SyntaxKind.AbstractKeyword) :\n      false;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Expression, ExternalExpr, ExternalReference, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {UnifiedModulesHost} from '../../core/api';\nimport {ErrorCode, FatalDiagnosticError, makeDiagnosticChain, makeRelatedInformation} from '../../diagnostics';\nimport {absoluteFromSourceFile, dirname, LogicalFileSystem, LogicalProjectPath, relative, toRelativeImport} from '../../file_system';\nimport {stripExtension} from '../../file_system/src/util';\nimport {DeclarationNode, ReflectionHost} from '../../reflection';\nimport {getSourceFile, isDeclaration, isNamedDeclaration, isTypeDeclaration, nodeNameForError} from '../../util/src/typescript';\n\nimport {findExportedNameOfNode} from './find_export';\nimport {Reference} from './references';\nimport {ModuleResolver} from './resolver';\n\n\n/**\n * Flags which alter the imports generated by the `ReferenceEmitter`.\n */\nexport enum ImportFlags {\n  None = 0x00,\n\n  /**\n   * Force the generation of a new import when generating a reference, even if an identifier already\n   * exists in the target file which could be used instead.\n   *\n   * This is sometimes required if there's a risk TypeScript might remove imports during emit.\n   */\n  ForceNewImport = 0x01,\n\n  /**\n   * Don't make use of any aliasing information when emitting a reference.\n   *\n   * This is sometimes required if emitting into a context where generated references will be fed\n   * into TypeScript and type-checked (such as in template type-checking).\n   */\n  NoAliasing = 0x02,\n\n  /**\n   * Indicates that an import to a type-only declaration is allowed.\n   *\n   * For references that occur in type-positions, the referred declaration may be a type-only\n   * declaration that is not retained during emit. Including this flag allows to emit references to\n   * type-only declarations as used in e.g. template type-checking.\n   */\n  AllowTypeImports = 0x04,\n\n  /**\n   * Indicates that importing from a declaration file using a relative import path is allowed.\n   *\n   * The generated imports should normally use module specifiers that are valid for use in\n   * production code, where arbitrary relative imports into e.g. node_modules are not allowed. For\n   * template type-checking code it is however acceptable to use relative imports, as such files are\n   * never emitted to JS code.\n   *\n   * Non-declaration files have to be contained within a configured `rootDir` so using relative\n   * paths may not be possible for those, hence this flag only applies when importing from a\n   * declaration file.\n   */\n  AllowRelativeDtsImports = 0x08,\n}\n\n/**\n * An emitter strategy has the ability to indicate which `ts.SourceFile` is being imported by the\n * expression that it has generated. This information is useful for consumers of the emitted\n * reference that would otherwise have to perform a relatively expensive module resolution step,\n * e.g. for cyclic import analysis. In cases the emitter is unable to definitively determine the\n * imported source file or a computation would be required to actually determine the imported\n * source file, then `'unknown'` should be returned. If the generated expression does not represent\n * an import then `null` should be used.\n */\nexport type ImportedFile = ts.SourceFile|'unknown'|null;\n\nexport const enum ReferenceEmitKind {\n  Success,\n  Failed,\n}\n\n/**\n * Represents the emitted expression of a `Reference` that is valid in the source file it was\n * emitted from.\n */\nexport interface EmittedReference {\n  kind: ReferenceEmitKind.Success;\n\n  /**\n   * The expression that refers to `Reference`.\n   */\n  expression: Expression;\n\n  /**\n   * The `ts.SourceFile` that is imported by `expression`. This is not necessarily the source file\n   * of the `Reference`'s declaration node, as the reference may have been rewritten through an\n   * alias export. It could also be `null` if `expression` is a local identifier, or `'unknown'` if\n   * the exact source file that is being imported is not known to the emitter.\n   */\n  importedFile: ImportedFile;\n}\n\n/**\n * Represents a failure to emit a `Reference` into a different source file.\n */\nexport interface FailedEmitResult {\n  kind: ReferenceEmitKind.Failed;\n\n  /**\n   * The reference that could not be emitted.\n   */\n  ref: Reference;\n\n  /**\n   * The source file into which the reference was requested to be emitted.\n   */\n  context: ts.SourceFile;\n\n  /**\n   * Describes why the reference could not be emitted. This may be shown in a diagnostic.\n   */\n  reason: string;\n}\n\nexport type ReferenceEmitResult = EmittedReference|FailedEmitResult;\n\n/**\n * Verifies that a reference was emitted successfully, or raises a `FatalDiagnosticError` otherwise.\n * @param result The emit result that should have been successful.\n * @param origin The node that is used to report the failure diagnostic.\n * @param typeKind The kind of the symbol that the reference represents, e.g. 'component' or\n *     'class'.\n */\nexport function assertSuccessfulReferenceEmit(\n    result: ReferenceEmitResult, origin: ts.Node,\n    typeKind: string): asserts result is EmittedReference {\n  if (result.kind === ReferenceEmitKind.Success) {\n    return;\n  }\n\n  const message = makeDiagnosticChain(\n      `Unable to import ${typeKind} ${nodeNameForError(result.ref.node)}.`,\n      [makeDiagnosticChain(result.reason)]);\n  throw new FatalDiagnosticError(\n      ErrorCode.IMPORT_GENERATION_FAILURE, origin, message,\n      [makeRelatedInformation(result.ref.node, `The ${typeKind} is declared here.`)]);\n}\n\n/**\n * A particular strategy for generating an expression which refers to a `Reference`.\n *\n * There are many potential ways a given `Reference` could be referred to in the context of a given\n * file. A local declaration could be available, the `Reference` could be importable via a relative\n * import within the project, or an absolute import into `node_modules` might be necessary.\n *\n * Different `ReferenceEmitStrategy` implementations implement specific logic for generating such\n * references. A single strategy (such as using a local declaration) may not always be able to\n * generate an expression for every `Reference` (for example, if no local identifier is available),\n * and may return `null` in such a case.\n */\nexport interface ReferenceEmitStrategy {\n  /**\n   * Emit an `Expression` which refers to the given `Reference` in the context of a particular\n   * source file, if possible.\n   *\n   * @param ref the `Reference` for which to generate an expression\n   * @param context the source file in which the `Expression` must be valid\n   * @param importFlags a flag which controls whether imports should be generated or not\n   * @returns an `EmittedReference` which refers to the `Reference`, or `null` if none can be\n   *   generated\n   */\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): ReferenceEmitResult|null;\n}\n\n/**\n * Generates `Expression`s which refer to `Reference`s in a given context.\n *\n * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an\n * `Expression` which refers to a `Reference` in the context of a particular file.\n */\nexport class ReferenceEmitter {\n  constructor(private strategies: ReferenceEmitStrategy[]) {}\n\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags = ImportFlags.None):\n      ReferenceEmitResult {\n    for (const strategy of this.strategies) {\n      const emitted = strategy.emit(ref, context, importFlags);\n      if (emitted !== null) {\n        return emitted;\n      }\n    }\n\n    return {\n      kind: ReferenceEmitKind.Failed,\n      ref,\n      context,\n      reason: `Unable to write a reference to ${nodeNameForError(ref.node)}.`,\n    };\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if\n * such identifiers are available.\n */\nexport class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null {\n    const refSf = getSourceFile(ref.node);\n\n    // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a\n    // local identifier at all, *except* in the source file where the node is actually declared.\n    if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {\n      return null;\n    }\n\n    // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,\n    // etc) and it is in the current file then just use it directly.\n    // This is important because the reference could be a property access (e.g. `exports.foo`). In\n    // such a case, the reference's `identities` property would be `[foo]`, which would result in an\n    // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.\n    if (!isDeclaration(ref.node) && refSf === context) {\n      return {\n        kind: ReferenceEmitKind.Success,\n        expression: new WrappedNodeExpr(ref.node),\n        importedFile: null,\n      };\n    }\n\n    // A Reference can have multiple identities in different files, so it may already have an\n    // Identifier in the requested context file.\n    const identifier = ref.getIdentityIn(context);\n    if (identifier !== null) {\n      return {\n        kind: ReferenceEmitKind.Success,\n        expression: new WrappedNodeExpr(identifier),\n        importedFile: null,\n      };\n    } else {\n      return null;\n    }\n  }\n}\n\n/**\n * Represents the exported declarations from a module source file.\n */\ninterface ModuleExports {\n  /**\n   * The source file of the module.\n   */\n  module: ts.SourceFile|null;\n\n  /**\n   * The map of declarations to their exported name.\n   */\n  exportMap: Map<DeclarationNode, string>|null;\n}\n\n/**\n * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using\n * an absolute import.\n *\n * Part of this strategy involves looking at the target entry point and identifying the exported\n * name of the targeted declaration, as it might be different from the declared name (e.g. a\n * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found\n * which maps back to the original directive, an error is thrown.\n */\nexport class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n  /**\n   * A cache of the exports of specific modules, because resolving a module to its exports is a\n   * costly operation.\n   */\n  private moduleExportsCache = new Map<string, ModuleExports>();\n\n  constructor(\n      protected program: ts.Program, protected checker: ts.TypeChecker,\n      protected moduleResolver: ModuleResolver, private reflectionHost: ReflectionHost) {}\n\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): ReferenceEmitResult|null {\n    if (ref.bestGuessOwningModule === null) {\n      // There is no module name available for this Reference, meaning it was arrived at via a\n      // relative path.\n      return null;\n    } else if (!isDeclaration(ref.node)) {\n      // It's not possible to import something which isn't a declaration.\n      throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${\n          ts.SyntaxKind[ref.node.kind]}.`);\n    } else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {\n      throw new Error(`Importing a type-only declaration of type ${\n          ts.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);\n    }\n\n    // Try to find the exported name of the declaration, if one is available.\n    const {specifier, resolutionContext} = ref.bestGuessOwningModule;\n    const exports = this.getExportsOfModule(specifier, resolutionContext);\n    if (exports.module === null) {\n      return {\n        kind: ReferenceEmitKind.Failed,\n        ref,\n        context,\n        reason: `The module '${specifier}' could not be found.`,\n      };\n    } else if (exports.exportMap === null || !exports.exportMap.has(ref.node)) {\n      return {\n        kind: ReferenceEmitKind.Failed,\n        ref,\n        context,\n        reason:\n            `The symbol is not exported from ${exports.module.fileName} (module '${specifier}').`,\n      };\n    }\n    const symbolName = exports.exportMap.get(ref.node)!;\n\n    return {\n      kind: ReferenceEmitKind.Success,\n      expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),\n      importedFile: exports.module,\n    };\n  }\n\n  private getExportsOfModule(moduleName: string, fromFile: string): ModuleExports {\n    if (!this.moduleExportsCache.has(moduleName)) {\n      this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));\n    }\n    return this.moduleExportsCache.get(moduleName)!;\n  }\n\n  protected enumerateExportsOfModule(specifier: string, fromFile: string): ModuleExports {\n    // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.\n    const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);\n    if (entryPointFile === null) {\n      return {module: null, exportMap: null};\n    }\n\n    const exports = this.reflectionHost.getExportsOfModule(entryPointFile);\n    if (exports === null) {\n      return {module: entryPointFile, exportMap: null};\n    }\n    const exportMap = new Map<DeclarationNode, string>();\n    for (const [name, declaration] of exports) {\n      if (exportMap.has(declaration.node)) {\n        // An export for this declaration has already been registered. We prefer an export that\n        // has the same name as the declared name, i.e. is not an aliased export. This is relevant\n        // for partial compilations where emitted references should import symbols using a stable\n        // name. This is particularly relevant for declarations inside VE-generated libraries, as\n        // such libraries contain private, unstable reexports of symbols.\n        const existingExport = exportMap.get(declaration.node)!;\n        if (isNamedDeclaration(declaration.node) && declaration.node.name.text === existingExport) {\n          continue;\n        }\n      }\n      exportMap.set(declaration.node, name);\n    }\n    return {module: entryPointFile, exportMap};\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're\n * both in the logical project \"space\" of paths.\n *\n * This is trickier than it sounds, as the two files may be in different root directories in the\n * project. Simply calculating a file system relative path between the two is not sufficient.\n * Instead, `LogicalProjectPath`s are used.\n */\nexport class LogicalProjectStrategy implements ReferenceEmitStrategy {\n  private relativePathStrategy: RelativePathStrategy;\n\n  constructor(private reflector: ReflectionHost, private logicalFs: LogicalFileSystem) {\n    this.relativePathStrategy = new RelativePathStrategy(this.reflector);\n  }\n\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): ReferenceEmitResult|null {\n    const destSf = getSourceFile(ref.node);\n\n    // Compute the relative path from the importing file to the file being imported. This is done\n    // as a logical path computation, because the two files might be in different rootDirs.\n    const destPath = this.logicalFs.logicalPathOfSf(destSf);\n    if (destPath === null) {\n      // The imported file is not within the logical project filesystem. An import into a\n      // declaration file is exempt from `TS6059: File is not under 'rootDir'` so we choose to allow\n      // using a filesystem relative path as fallback, if allowed per the provided import flags.\n      if (destSf.isDeclarationFile && importFlags & ImportFlags.AllowRelativeDtsImports) {\n        return this.relativePathStrategy.emit(ref, context);\n      }\n\n      // Note: this error is analogous to `TS6059: File is not under 'rootDir'` that TypeScript\n      // reports.\n      return {\n        kind: ReferenceEmitKind.Failed,\n        ref,\n        context,\n        reason: `The file ${destSf.fileName} is outside of the configured 'rootDir'.`,\n      };\n    }\n\n    const originPath = this.logicalFs.logicalPathOfSf(context);\n    if (originPath === null) {\n      throw new Error(\n          `Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);\n    }\n\n    // There's no way to emit a relative reference from a file to itself.\n    if (destPath === originPath) {\n      return null;\n    }\n\n    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n    if (name === null) {\n      // The target declaration isn't exported from the file it's declared in. This is an issue!\n      return {\n        kind: ReferenceEmitKind.Failed,\n        ref,\n        context,\n        reason: `The symbol is not exported from ${destSf.fileName}.`,\n      };\n    }\n\n    // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative\n    // path is now straightforward.\n    const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);\n    return {\n      kind: ReferenceEmitKind.Success,\n      expression: new ExternalExpr({moduleName, name}),\n      importedFile: destSf,\n    };\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.\n *\n * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which\n * necessitates the stronger logic of `LogicalProjectStrategy`.\n */\nexport class RelativePathStrategy implements ReferenceEmitStrategy {\n  constructor(private reflector: ReflectionHost) {}\n\n  emit(ref: Reference, context: ts.SourceFile): ReferenceEmitResult|null {\n    const destSf = getSourceFile(ref.node);\n    const relativePath =\n        relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));\n    const moduleName = toRelativeImport(stripExtension(relativePath));\n\n    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n    if (name === null) {\n      return {\n        kind: ReferenceEmitKind.Failed,\n        ref,\n        context,\n        reason: `The symbol is not exported from ${destSf.fileName}.`,\n      };\n    }\n    return {\n      kind: ReferenceEmitKind.Success,\n      expression: new ExternalExpr({moduleName, name}),\n      importedFile: destSf,\n    };\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import\n * references.\n */\nexport class UnifiedModulesStrategy implements ReferenceEmitStrategy {\n  constructor(private reflector: ReflectionHost, private unifiedModulesHost: UnifiedModulesHost) {}\n\n  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n    const destSf = getSourceFile(ref.node);\n    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n    if (name === null) {\n      return null;\n    }\n\n    const moduleName =\n        this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);\n\n    return {\n      kind: ReferenceEmitKind.Success,\n      expression: new ExternalExpr({moduleName, name}),\n      importedFile: destSf,\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TS = /\\.tsx?$/i;\nconst D_TS = /\\.d\\.ts$/i;\n\nimport ts from 'typescript';\nimport {AbsoluteFsPath, getFileSystem} from '../../file_system';\nimport {DeclarationNode} from '../../reflection';\n\n/**\n * Type describing a symbol that is guaranteed to have a value declaration.\n */\nexport type SymbolWithValueDeclaration = ts.Symbol&{\n  valueDeclaration: ts.Declaration;\n  declarations: ts.Declaration[];\n};\n\nexport function isSymbolWithValueDeclaration(symbol: ts.Symbol|null|\n                                             undefined): symbol is SymbolWithValueDeclaration {\n  // If there is a value declaration set, then the `declarations` property is never undefined. We\n  // still check for the property to exist as this matches with the type that `symbol` is narrowed\n  // to.\n  return symbol != null && symbol.valueDeclaration !== undefined &&\n      symbol.declarations !== undefined;\n}\n\nexport function isDtsPath(filePath: string): boolean {\n  return D_TS.test(filePath);\n}\n\nexport function isNonDeclarationTsPath(filePath: string): boolean {\n  return TS.test(filePath) && !D_TS.test(filePath);\n}\n\nexport function isFromDtsFile(node: ts.Node): boolean {\n  let sf: ts.SourceFile|undefined = node.getSourceFile();\n  if (sf === undefined) {\n    sf = ts.getOriginalNode(node).getSourceFile();\n  }\n  return sf !== undefined && sf.isDeclarationFile;\n}\n\nexport function nodeNameForError(node: ts.Node&{name?: ts.Node}): string {\n  if (node.name !== undefined && ts.isIdentifier(node.name)) {\n    return node.name.text;\n  } else {\n    const kind = ts.SyntaxKind[node.kind];\n    const {line, character} =\n        ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());\n    return `${kind}@${line}:${character}`;\n  }\n}\n\nexport function getSourceFile(node: ts.Node): ts.SourceFile {\n  // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,\n  // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the\n  // original node instead (which works).\n  const directSf = node.getSourceFile() as ts.SourceFile | undefined;\n  return directSf !== undefined ? directSf : ts.getOriginalNode(node).getSourceFile();\n}\n\nexport function getSourceFileOrNull(program: ts.Program, fileName: AbsoluteFsPath): ts.SourceFile|\n    null {\n  return program.getSourceFile(fileName) || null;\n}\n\n\nexport function getTokenAtPosition(sf: ts.SourceFile, pos: number): ts.Node {\n  // getTokenAtPosition is part of TypeScript's private API.\n  return (ts as any).getTokenAtPosition(sf, pos);\n}\n\nexport function identifierOfNode(decl: ts.Node&{name?: ts.Node}): ts.Identifier|null {\n  if (decl.name !== undefined && ts.isIdentifier(decl.name)) {\n    return decl.name;\n  } else {\n    return null;\n  }\n}\n\nexport function isDeclaration(node: ts.Node): node is ts.Declaration {\n  return isValueDeclaration(node) || isTypeDeclaration(node);\n}\n\nexport function isValueDeclaration(node: ts.Node): node is ts.ClassDeclaration|\n    ts.FunctionDeclaration|ts.VariableDeclaration {\n  return ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) ||\n      ts.isVariableDeclaration(node);\n}\n\nexport function isTypeDeclaration(node: ts.Node): node is ts.EnumDeclaration|\n    ts.TypeAliasDeclaration|ts.InterfaceDeclaration {\n  return ts.isEnumDeclaration(node) || ts.isTypeAliasDeclaration(node) ||\n      ts.isInterfaceDeclaration(node);\n}\n\nexport function isNamedDeclaration(node: ts.Node): node is ts.Declaration&{name: ts.Identifier} {\n  const namedNode = node as {name?: ts.Identifier};\n  return namedNode.name !== undefined && ts.isIdentifier(namedNode.name);\n}\n\nexport function isExported(node: DeclarationNode): boolean {\n  let topLevel: ts.Node = node;\n  if (ts.isVariableDeclaration(node) && ts.isVariableDeclarationList(node.parent)) {\n    topLevel = node.parent.parent;\n  }\n  const modifiers = ts.canHaveModifiers(topLevel) ? ts.getModifiers(topLevel) : undefined;\n  return modifiers !== undefined &&\n      modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword);\n}\n\nexport function getRootDirs(\n    host: Pick<ts.CompilerHost, 'getCurrentDirectory'|'getCanonicalFileName'>,\n    options: ts.CompilerOptions): AbsoluteFsPath[] {\n  const rootDirs: string[] = [];\n  const cwd = host.getCurrentDirectory();\n  const fs = getFileSystem();\n  if (options.rootDirs !== undefined) {\n    rootDirs.push(...options.rootDirs);\n  } else if (options.rootDir !== undefined) {\n    rootDirs.push(options.rootDir);\n  } else {\n    rootDirs.push(cwd);\n  }\n\n  // In Windows the above might not always return posix separated paths\n  // See:\n  // https://github.com/Microsoft/TypeScript/blob/3f7357d37f66c842d70d835bc925ec2a873ecfec/src/compiler/sys.ts#L650\n  // Also compiler options might be set via an API which doesn't normalize paths\n  return rootDirs.map(rootDir => fs.resolve(cwd, host.getCanonicalFileName(rootDir)));\n}\n\nexport function nodeDebugInfo(node: ts.Node): string {\n  const sf = getSourceFile(node);\n  const {line, character} = ts.getLineAndCharacterOfPosition(sf, node.pos);\n  return `[${sf.fileName}: ${ts.SyntaxKind[node.kind]} @ ${line}:${character}]`;\n}\n\n/**\n * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.\n *\n * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.\n * Otherwise it will fallback on the `ts.ResolveModuleName()` function.\n */\nexport function resolveModuleName(\n    moduleName: string, containingFile: string, compilerOptions: ts.CompilerOptions,\n    compilerHost: ts.ModuleResolutionHost&Pick<ts.CompilerHost, 'resolveModuleNames'>,\n    moduleResolutionCache: ts.ModuleResolutionCache|null): ts.ResolvedModule|undefined {\n  if (compilerHost.resolveModuleNames) {\n    return compilerHost.resolveModuleNames(\n        [moduleName], containingFile,\n        undefined,  // reusedNames\n        undefined,  // redirectedReference\n        compilerOptions)[0];\n  } else {\n    return ts\n        .resolveModuleName(\n            moduleName, containingFile, compilerOptions, compilerHost,\n            moduleResolutionCache !== null ? moduleResolutionCache : undefined)\n        .resolvedModule;\n  }\n}\n\n/** Returns true if the node is an assignment expression. */\nexport function isAssignment(node: ts.Node): node is ts.BinaryExpression {\n  return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n}\n\n/**\n * Asserts that the keys `K` form a subset of the keys of `T`.\n */\nexport type SubsetOfKeys<T, K extends keyof T> = K;\n\n/**\n * Represents the type `T`, with a transformation applied that turns all methods (even optional\n * ones) into required fields (which may be `undefined`, if the method was optional).\n */\nexport type RequiredDelegations<T> = {\n  [M in keyof Required<T>]: T[M];\n};\n\n/**\n * Source files may become redirects to other source files when their package name and version are\n * identical. TypeScript creates a proxy source file for such source files which has an internal\n * `redirectInfo` property that refers to the original source file.\n */\ninterface RedirectedSourceFile extends ts.SourceFile {\n  redirectInfo?: {unredirected: ts.SourceFile;};\n}\n\n/**\n * Obtains the non-redirected source file for `sf`.\n */\nexport function toUnredirectedSourceFile(sf: ts.SourceFile): ts.SourceFile {\n  const redirectInfo = (sf as RedirectedSourceFile).redirectInfo;\n  if (redirectInfo === undefined) {\n    return sf;\n  }\n  return redirectInfo.unredirected;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ReflectionHost} from '../../reflection';\nimport {isNamedDeclaration} from '../../util/src/typescript';\n\n/**\n * Find the name, if any, by which a node is exported from a given file.\n */\nexport function findExportedNameOfNode(\n    target: ts.Node, file: ts.SourceFile, reflector: ReflectionHost): string|null {\n  const exports = reflector.getExportsOfModule(file);\n  if (exports === null) {\n    return null;\n  }\n\n  const declaredName = isNamedDeclaration(target) ? target.name.text : null;\n\n  // Look for the export which declares the node.\n  let foundExportName: string|null = null;\n  for (const [exportName, declaration] of exports) {\n    if (declaration.node !== target) {\n      continue;\n    }\n\n    if (exportName === declaredName) {\n      // A non-alias export exists which is always preferred, so use that one.\n      return exportName;\n    }\n\n    foundExportName = exportName;\n  }\n  return foundExportName;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {UnifiedModulesHost} from '../../core/api';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\n\nimport {EmittedReference, ImportFlags, ReferenceEmitKind, ReferenceEmitStrategy} from './emitter';\nimport {Reference} from './references';\n\n\n// Escape anything that isn't alphanumeric, '/' or '_'.\nconst CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;\n\n/**\n * A host for the aliasing system, which allows for alternative exports/imports of directives/pipes.\n *\n * Given an import of an NgModule (e.g. `CommonModule`), the compiler must generate imports to the\n * directives and pipes exported by this module (e.g. `NgIf`) when they're used in a particular\n * template. In its default configuration, if the compiler is not directly able to import the\n * component from another file within the same project, it will attempt to import the component\n * from the same (absolute) path by which the module was imported. So in the above example if\n * `CommonModule` was imported from '@angular/common', the compiler will attempt to import `NgIf`\n * from '@angular/common' as well.\n *\n * The aliasing system interacts with the above logic in two distinct ways.\n *\n * 1) It can be used to create \"alias\" re-exports from different files, which can be used when the\n *    user hasn't exported the directive(s) from the ES module containing the NgModule. These re-\n *    exports can also be helpful when using a `UnifiedModulesHost`, which overrides the import\n *    logic described above.\n *\n * 2) It can be used to get an alternative import expression for a directive or pipe, instead of\n *    the import that the normal logic would apply. The alias used depends on the provenance of the\n *    `Reference` which was obtained for the directive/pipe, which is usually a property of how it\n *    came to be in a template's scope (e.g. by which NgModule).\n *\n * See the README.md for more information on how aliasing works within the compiler.\n */\nexport interface AliasingHost {\n  /**\n   * Controls whether any alias re-exports are rendered into .d.ts files.\n   *\n   * This is not always necessary for aliasing to function correctly, so this flag allows an\n   * `AliasingHost` to avoid cluttering the .d.ts files if exports are not strictly needed.\n   */\n  readonly aliasExportsInDts: boolean;\n\n  /**\n   * Determine a name by which `decl` should be re-exported from `context`, depending on the\n   * particular set of aliasing rules in place.\n   *\n   * `maybeAliasSymbolAs` can return `null`, in which case no alias export should be generated.\n   *\n   * @param ref a `Reference` to the directive/pipe to consider for aliasing.\n   * @param context the `ts.SourceFile` in which the alias re-export might need to be generated.\n   * @param ngModuleName the declared name of the `NgModule` within `context` for which the alias\n   * would be generated.\n   * @param isReExport whether the directive/pipe under consideration is re-exported from another\n   * NgModule (as opposed to being declared by it directly).\n   */\n  maybeAliasSymbolAs(\n      ref: Reference<ClassDeclaration>, context: ts.SourceFile, ngModuleName: string,\n      isReExport: boolean): string|null;\n\n  /**\n   * Determine an `Expression` by which `decl` should be imported from `via` using an alias export\n   * (which should have been previously created when compiling `via`).\n   *\n   * `getAliasIn` can return `null`, in which case no alias is needed to import `decl` from `via`\n   * (and the normal import rules should be used).\n   *\n   * @param decl the declaration of the directive/pipe which is being imported, and which might be\n   * aliased.\n   * @param via the `ts.SourceFile` which might contain an alias to the\n   */\n  getAliasIn(decl: ClassDeclaration, via: ts.SourceFile, isReExport: boolean): Expression|null;\n}\n\n/**\n * An `AliasingHost` which generates and consumes alias re-exports when module names for each file\n * are determined by a `UnifiedModulesHost`.\n *\n * When using a `UnifiedModulesHost`, aliasing prevents issues with transitive dependencies. See the\n * README.md for more details.\n */\nexport class UnifiedModulesAliasingHost implements AliasingHost {\n  constructor(private unifiedModulesHost: UnifiedModulesHost) {}\n\n  /**\n   * With a `UnifiedModulesHost`, aliases are chosen automatically without the need to look through\n   * the exports present in a .d.ts file, so we can avoid cluttering the .d.ts files.\n   */\n  readonly aliasExportsInDts = false;\n\n  maybeAliasSymbolAs(\n      ref: Reference<ClassDeclaration>, context: ts.SourceFile, ngModuleName: string,\n      isReExport: boolean): string|null {\n    if (!isReExport) {\n      // Aliasing is used with a UnifiedModulesHost to prevent transitive dependencies. Thus,\n      // aliases\n      // only need to be created for directives/pipes which are not direct declarations of an\n      // NgModule which exports them.\n      return null;\n    }\n    return this.aliasName(ref.node, context);\n  }\n\n  /**\n   * Generates an `Expression` to import `decl` from `via`, assuming an export was added when `via`\n   * was compiled per `maybeAliasSymbolAs` above.\n   */\n  getAliasIn(decl: ClassDeclaration, via: ts.SourceFile, isReExport: boolean): Expression|null {\n    if (!isReExport) {\n      // Directly exported directives/pipes don't require an alias, per the logic in\n      // `maybeAliasSymbolAs`.\n      return null;\n    }\n    // viaModule is the module it'll actually be imported from.\n    const moduleName = this.unifiedModulesHost.fileNameToModuleName(via.fileName, via.fileName);\n    return new ExternalExpr({moduleName, name: this.aliasName(decl, via)});\n  }\n\n  /**\n   * Generates an alias name based on the full module name of the file which declares the aliased\n   * directive/pipe.\n   */\n  private aliasName(decl: ClassDeclaration, context: ts.SourceFile): string {\n    // The declared module is used to get the name of the alias.\n    const declModule = this.unifiedModulesHost.fileNameToModuleName(\n        decl.getSourceFile().fileName, context.fileName);\n\n    const replaced = declModule.replace(CHARS_TO_ESCAPE, '_').replace(/\\//g, '$');\n    return 'Éµng$' + replaced + '$$' + decl.name.text;\n  }\n}\n\n/**\n * An `AliasingHost` which exports directives from any file containing an NgModule in which they're\n * declared/exported, under a private symbol name.\n *\n * These exports support cases where an NgModule is imported deeply from an absolute module path\n * (that is, it's not part of an Angular Package Format entrypoint), and the compiler needs to\n * import any matched directives/pipes from the same path (to the NgModule file). See README.md for\n * more details.\n */\nexport class PrivateExportAliasingHost implements AliasingHost {\n  constructor(private host: ReflectionHost) {}\n\n  /**\n   * Under private export aliasing, the `AbsoluteModuleStrategy` used for emitting references will\n   * will select aliased exports that it finds in the .d.ts file for an NgModule's file. Thus,\n   * emitting these exports in .d.ts is a requirement for the `PrivateExportAliasingHost` to\n   * function correctly.\n   */\n  readonly aliasExportsInDts = true;\n\n  maybeAliasSymbolAs(\n      ref: Reference<ClassDeclaration>, context: ts.SourceFile, ngModuleName: string): string|null {\n    if (ref.hasOwningModuleGuess) {\n      // Skip nodes that already have an associated absolute module specifier, since they can be\n      // safely imported from that specifier.\n      return null;\n    }\n    // Look for a user-provided export of `decl` in `context`. If one exists, then an alias export\n    // is not needed.\n    // TODO(alxhub): maybe add a host method to check for the existence of an export without going\n    // through the entire list of exports.\n    const exports = this.host.getExportsOfModule(context);\n    if (exports === null) {\n      // Something went wrong, and no exports were available at all. Bail rather than risk creating\n      // re-exports when they're not needed.\n      throw new Error(`Could not determine the exports of: ${context.fileName}`);\n    }\n    let found: boolean = false;\n    exports.forEach(value => {\n      if (value.node === ref.node) {\n        found = true;\n      }\n    });\n    if (found) {\n      // The module exports the declared class directly, no alias is necessary.\n      return null;\n    }\n    return `ÉµngExportÉµ${ngModuleName}Éµ${ref.node.name.text}`;\n  }\n\n  /**\n   * A `PrivateExportAliasingHost` only generates re-exports and does not direct the compiler to\n   * directly consume the aliases it creates.\n   *\n   * Instead, they're consumed indirectly: `AbsoluteModuleStrategy` `ReferenceEmitterStrategy` will\n   * select these alias exports automatically when looking for an export of the directive/pipe from\n   * the same path as the NgModule was imported.\n   *\n   * Thus, `getAliasIn` always returns `null`.\n   */\n  getAliasIn(): null {\n    return null;\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which will consume the alias attached to a particular `Reference` to a\n * directive or pipe, if it exists.\n */\nexport class AliasStrategy implements ReferenceEmitStrategy {\n  emit(ref: Reference, context: ts.SourceFile, importMode: ImportFlags): EmittedReference|null {\n    if (importMode & ImportFlags.NoAliasing || ref.alias === null) {\n      return null;\n    }\n\n    return {\n      kind: ReferenceEmitKind.Success,\n      expression: ref.alias,\n      importedFile: 'unknown',\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {dirname, relative, resolve, toRelativeImport} from '../../file_system';\nimport {stripExtension} from '../../file_system/src/util';\n\nexport function relativePathBetween(from: string, to: string): string|null {\n  const relativePath = stripExtension(relative(dirname(resolve(from)), resolve(to)));\n  return relativePath !== '' ? toRelativeImport(relativePath) : null;\n}\n\nexport function normalizeSeparators(path: string): string {\n  // TODO: normalize path only for OS that need it.\n  return path.replace(/\\\\/g, '/');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {relativePathBetween} from '../../util/src/path';\n\n/**\n * Rewrites imports of symbols being written into generated code.\n */\nexport interface ImportRewriter {\n  /**\n   * Should the given symbol be imported at all?\n   *\n   * If `true`, the symbol should be imported from the given specifier. If `false`, the symbol\n   * should be referenced directly, without an import.\n   */\n  shouldImportSymbol(symbol: string, specifier: string): boolean;\n\n  /**\n   * Optionally rewrite a reference to an imported symbol, changing either the binding prefix or the\n   * symbol name itself.\n   */\n  rewriteSymbol(symbol: string, specifier: string): string;\n\n  /**\n   * Optionally rewrite the given module specifier in the context of a given file.\n   */\n  rewriteSpecifier(specifier: string, inContextOfFile: string): string;\n}\n\n/**\n * `ImportRewriter` that does no rewriting.\n */\nexport class NoopImportRewriter implements ImportRewriter {\n  shouldImportSymbol(symbol: string, specifier: string): boolean {\n    return true;\n  }\n\n  rewriteSymbol(symbol: string, specifier: string): string {\n    return symbol;\n  }\n\n  rewriteSpecifier(specifier: string, inContextOfFile: string): string {\n    return specifier;\n  }\n}\n\n/**\n * A mapping of supported symbols that can be imported from within @angular/core, and the names by\n * which they're exported from r3_symbols.\n */\nconst CORE_SUPPORTED_SYMBOLS = new Map<string, string>([\n  ['ÉµÉµdefineInjectable', 'ÉµÉµdefineInjectable'],\n  ['ÉµÉµdefineInjector', 'ÉµÉµdefineInjector'],\n  ['ÉµÉµdefineNgModule', 'ÉµÉµdefineNgModule'],\n  ['ÉµÉµsetNgModuleScope', 'ÉµÉµsetNgModuleScope'],\n  ['ÉµÉµinject', 'ÉµÉµinject'],\n  ['ÉµÉµFactoryDeclaration', 'ÉµÉµFactoryDeclaration'],\n  ['ÉµsetClassMetadata', 'setClassMetadata'],\n  ['ÉµÉµInjectableDeclaration', 'ÉµÉµInjectableDeclaration'],\n  ['ÉµÉµInjectorDeclaration', 'ÉµÉµInjectorDeclaration'],\n  ['ÉµÉµNgModuleDeclaration', 'ÉµÉµNgModuleDeclaration'],\n  ['ÉµNgModuleFactory', 'NgModuleFactory'],\n  ['ÉµnoSideEffects', 'ÉµnoSideEffects'],\n]);\n\nconst CORE_MODULE = '@angular/core';\n\n/**\n * `ImportRewriter` that rewrites imports from '@angular/core' to be imported from the r3_symbols.ts\n * file instead.\n */\nexport class R3SymbolsImportRewriter implements ImportRewriter {\n  constructor(private r3SymbolsPath: string) {}\n\n  shouldImportSymbol(symbol: string, specifier: string): boolean {\n    return true;\n  }\n\n  rewriteSymbol(symbol: string, specifier: string): string {\n    if (specifier !== CORE_MODULE) {\n      // This import isn't from core, so ignore it.\n      return symbol;\n    }\n\n    return validateAndRewriteCoreSymbol(symbol);\n  }\n\n  rewriteSpecifier(specifier: string, inContextOfFile: string): string {\n    if (specifier !== CORE_MODULE) {\n      // This module isn't core, so ignore it.\n      return specifier;\n    }\n\n    const relativePathToR3Symbols = relativePathBetween(inContextOfFile, this.r3SymbolsPath);\n    if (relativePathToR3Symbols === null) {\n      throw new Error(`Failed to rewrite import inside ${CORE_MODULE}: ${inContextOfFile} -> ${\n          this.r3SymbolsPath}`);\n    }\n\n    return relativePathToR3Symbols;\n  }\n}\n\nexport function validateAndRewriteCoreSymbol(name: string): string {\n  if (!CORE_SUPPORTED_SYMBOLS.has(name)) {\n    throw new Error(`Importing unexpected symbol ${name} while compiling ${CORE_MODULE}`);\n  }\n  return CORE_SUPPORTED_SYMBOLS.get(name)!;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n/**\n * Describes a TypeScript transformation context with the internal emit\n * resolver exposed. There are requests upstream in TypeScript to expose\n * that as public API: https://github.com/microsoft/TypeScript/issues/17516.\n */\ninterface TransformationContextWithResolver extends ts.TransformationContext {\n  getEmitResolver: () => EmitResolver;\n}\n\nconst patchedReferencedAliasesSymbol = Symbol('patchedReferencedAliases');\n\n/** Describes a subset of the TypeScript internal emit resolver. */\ninterface EmitResolver {\n  isReferencedAliasDeclaration?(node: ts.Node, ...args: unknown[]): void;\n  [patchedReferencedAliasesSymbol]?: Set<ts.Declaration>;\n}\n\n/**\n * Patches the alias declaration reference resolution for a given transformation context\n * so that TypeScript knows about the specified alias declarations being referenced.\n *\n * This exists because TypeScript performs analysis of import usage before transformers\n * run and doesn't refresh its state after transformations. This means that imports\n * for symbols used as constructor types are elided due to their original type-only usage.\n *\n * In reality though, since we downlevel decorators and constructor parameters, we want\n * these symbols to be retained in the JavaScript output as they will be used as values\n * at runtime. We can instruct TypeScript to preserve imports for such identifiers by\n * creating a mutable clone of a given import specifier/clause or namespace, but that\n * has the downside of preserving the full import in the JS output. See:\n * https://github.com/microsoft/TypeScript/blob/3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/src/compiler/transformers/ts.ts#L242-L250.\n *\n * This is a trick the CLI used in the past  for constructor parameter downleveling in JIT:\n * https://github.com/angular/angular-cli/blob/b3f84cc5184337666ce61c07b7b9df418030106f/packages/ngtools/webpack/src/transformers/ctor-parameters.ts#L323-L325\n * The trick is not ideal though as it preserves the full import (as outlined before), and it\n * results in a slow-down due to the type checker being involved multiple times. The CLI worked\n * around this import preserving issue by having another complex post-process step that detects and\n * elides unused imports. Note that these unused imports could cause unused chunks being generated\n * by Webpack if the application or library is not marked as side-effect free.\n *\n * This is not ideal though, as we basically re-implement the complex import usage resolution\n * from TypeScript. We can do better by letting TypeScript do the import eliding, but providing\n * information about the alias declarations (e.g. import specifiers) that should not be elided\n * because they are actually referenced (as they will now appear in static properties).\n *\n * More information about these limitations with transformers can be found in:\n *   1. https://github.com/Microsoft/TypeScript/issues/17552.\n *   2. https://github.com/microsoft/TypeScript/issues/17516.\n *   3. https://github.com/angular/tsickle/issues/635.\n *\n * The patch we apply to tell TypeScript about actual referenced aliases (i.e. imported symbols),\n * matches conceptually with the logic that runs internally in TypeScript when the\n * `emitDecoratorMetadata` flag is enabled. TypeScript basically surfaces the same problem and\n * solves it conceptually the same way, but obviously doesn't need to access an internal API.\n *\n * The set that is returned by this function is meant to be filled with import declaration nodes\n * that have been referenced in a value-position by the transform, such the installed patch can\n * ensure that those import declarations are not elided.\n *\n * See below. Note that this uses sourcegraph as the TypeScript checker file doesn't display on\n * Github.\n * https://sourcegraph.com/github.com/microsoft/TypeScript@3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/-/blob/src/compiler/checker.ts#L31219-31257\n */\nexport function loadIsReferencedAliasDeclarationPatch(context: ts.TransformationContext):\n    Set<ts.Declaration> {\n  // If the `getEmitResolver` method is not available, TS most likely changed the\n  // internal structure of the transformation context. We will abort gracefully.\n  if (!isTransformationContextWithEmitResolver(context)) {\n    throwIncompatibleTransformationContextError();\n  }\n  const emitResolver = context.getEmitResolver();\n\n  // The emit resolver may have been patched already, in which case we return the set of referenced\n  // aliases that was created when the patch was first applied.\n  // See https://github.com/angular/angular/issues/40276.\n  const existingReferencedAliases = emitResolver[patchedReferencedAliasesSymbol];\n  if (existingReferencedAliases !== undefined) {\n    return existingReferencedAliases;\n  }\n\n  const originalIsReferencedAliasDeclaration = emitResolver.isReferencedAliasDeclaration;\n  // If the emit resolver does not have a function called `isReferencedAliasDeclaration`, then\n  // we abort gracefully as most likely TS changed the internal structure of the emit resolver.\n  if (originalIsReferencedAliasDeclaration === undefined) {\n    throwIncompatibleTransformationContextError();\n  }\n\n  const referencedAliases = new Set<ts.Declaration>();\n  emitResolver.isReferencedAliasDeclaration = function(node, ...args) {\n    if (isAliasImportDeclaration(node) && referencedAliases.has(node)) {\n      return true;\n    }\n    return originalIsReferencedAliasDeclaration.call(emitResolver, node, ...args);\n  };\n  return emitResolver[patchedReferencedAliasesSymbol] = referencedAliases;\n}\n\n/**\n * Gets whether a given node corresponds to an import alias declaration. Alias\n * declarations can be import specifiers, namespace imports or import clauses\n * as these do not declare an actual symbol but just point to a target declaration.\n */\nexport function isAliasImportDeclaration(node: ts.Node): node is ts.ImportSpecifier|\n    ts.NamespaceImport|ts.ImportClause {\n  return ts.isImportSpecifier(node) || ts.isNamespaceImport(node) || ts.isImportClause(node);\n}\n\n/** Whether the transformation context exposes its emit resolver. */\nfunction isTransformationContextWithEmitResolver(context: ts.TransformationContext):\n    context is TransformationContextWithResolver {\n  return (context as Partial<TransformationContextWithResolver>).getEmitResolver !== undefined;\n}\n\n\n/**\n * Throws an error about an incompatible TypeScript version for which the alias\n * declaration reference resolution could not be monkey-patched. The error will\n * also propose potential solutions that can be applied by developers.\n */\nfunction throwIncompatibleTransformationContextError(): never {\n  throw Error(\n      'Angular compiler is incompatible with this version of the TypeScript compiler.\\n\\n' +\n      'If you recently updated TypeScript and this issue surfaces now, consider downgrading.\\n\\n' +\n      'Please report an issue on the Angular repositories when this issue ' +\n      'surfaces and you are using a supposedly compatible TypeScript version.');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {getSourceFile} from '../../util/src/typescript';\n\nimport {loadIsReferencedAliasDeclarationPatch} from './patch_alias_reference_resolution';\n\nconst DefaultImportDeclaration = Symbol('DefaultImportDeclaration');\n\ninterface WithDefaultImportDeclaration {\n  [DefaultImportDeclaration]?: ts.ImportDeclaration;\n}\n\n/**\n * Attaches a default import declaration to `expr` to indicate the dependency of `expr` on the\n * default import.\n */\nexport function attachDefaultImportDeclaration(\n    expr: WrappedNodeExpr<unknown>, importDecl: ts.ImportDeclaration): void {\n  (expr as WithDefaultImportDeclaration)[DefaultImportDeclaration] = importDecl;\n}\n\n/**\n * Obtains the default import declaration that `expr` depends on, or `null` if there is no such\n * dependency.\n */\nexport function getDefaultImportDeclaration(expr: WrappedNodeExpr<unknown>): ts.ImportDeclaration|\n    null {\n  return (expr as WithDefaultImportDeclaration)[DefaultImportDeclaration] ?? null;\n}\n\n/**\n * TypeScript has trouble with generating default imports inside of transformers for some module\n * formats. The issue is that for the statement:\n *\n * import X from 'some/module';\n * console.log(X);\n *\n * TypeScript will not use the \"X\" name in generated code. For normal user code, this is fine\n * because references to X will also be renamed. However, if both the import and any references are\n * added in a transformer, TypeScript does not associate the two, and will leave the \"X\" references\n * dangling while renaming the import variable. The generated code looks something like:\n *\n * const module_1 = require('some/module');\n * console.log(X); // now X is a dangling reference.\n *\n * Therefore, we cannot synthetically add default imports, and must reuse the imports that users\n * include. Doing this poses a challenge for imports that are only consumed in the type position in\n * the user's code. If Angular reuses the imported symbol in a value position (for example, we\n * see a constructor parameter of type Foo and try to write \"inject(Foo)\") we will also end up with\n * a dangling reference, as TS will elide the import because it was only used in the type position\n * originally.\n *\n * To avoid this, the compiler must patch the emit resolver, and should only do this for imports\n * which are actually consumed. The `DefaultImportTracker` keeps track of these imports as they're\n * encountered and emitted, and implements a transform which can correctly flag the imports as\n * required.\n *\n * This problem does not exist for non-default imports as the compiler can easily insert\n * \"import * as X\" style imports for those, and the \"X\" identifier survives transformation.\n */\nexport class DefaultImportTracker {\n  /**\n   * A `Map` which tracks the `Set` of `ts.ImportClause`s for default imports that were used in\n   * a given file name.\n   */\n  private sourceFileToUsedImports = new Map<string, Set<ts.ImportClause>>();\n\n  recordUsedImport(importDecl: ts.ImportDeclaration): void {\n    if (importDecl.importClause) {\n      const sf = getSourceFile(importDecl);\n\n      // Add the default import declaration to the set of used import declarations for the file.\n      if (!this.sourceFileToUsedImports.has(sf.fileName)) {\n        this.sourceFileToUsedImports.set(sf.fileName, new Set<ts.ImportClause>());\n      }\n      this.sourceFileToUsedImports.get(sf.fileName)!.add(importDecl.importClause);\n    }\n  }\n\n  /**\n   * Get a `ts.TransformerFactory` which will preserve default imports that were previously marked\n   * as used.\n   *\n   * This transformer must run after any other transformers which call `recordUsedImport`.\n   */\n  importPreservingTransformer(): ts.TransformerFactory<ts.SourceFile> {\n    return context => {\n      let clausesToPreserve: Set<ts.Declaration>|null = null;\n\n      return sourceFile => {\n        const clausesForFile = this.sourceFileToUsedImports.get(sourceFile.fileName);\n\n        if (clausesForFile !== undefined) {\n          for (const clause of clausesForFile) {\n            // Initialize the patch lazily so that apps that\n            // don't use default imports aren't patched.\n            if (clausesToPreserve === null) {\n              clausesToPreserve = loadIsReferencedAliasDeclarationPatch(context);\n            }\n            clausesToPreserve.add(clause);\n          }\n        }\n\n        return sourceFile;\n      };\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {identifierOfNode} from '../../util/src/typescript';\n\nexport interface OwningModule {\n  specifier: string;\n  resolutionContext: string;\n}\n\n/**\n * A `ts.Node` plus the context in which it was discovered.\n *\n * A `Reference` is a pointer to a `ts.Node` that was extracted from the program somehow. It\n * contains not only the node itself, but the information regarding how the node was located. In\n * particular, it might track different identifiers by which the node is exposed, as well as\n * potentially a module specifier which might expose the node.\n *\n * The Angular compiler uses `Reference`s instead of `ts.Node`s when tracking classes or generating\n * imports.\n */\nexport class Reference<T extends ts.Node = ts.Node> {\n  /**\n   * The compiler's best guess at an absolute module specifier which owns this `Reference`.\n   *\n   * This is usually determined by tracking the import statements which led the compiler to a given\n   * node. If any of these imports are absolute, it's an indication that the node being imported\n   * might come from that module.\n   *\n   * It is not _guaranteed_ that the node in question is exported from its `bestGuessOwningModule` -\n   * that is mostly a convention that applies in certain package formats.\n   *\n   * If `bestGuessOwningModule` is `null`, then it's likely the node came from the current program.\n   */\n  readonly bestGuessOwningModule: OwningModule|null;\n\n  private identifiers: ts.Identifier[] = [];\n\n  /**\n   * Indicates that the Reference was created synthetically, not as a result of natural value\n   * resolution.\n   *\n   * This is used to avoid misinterpreting the Reference in certain contexts.\n   */\n  synthetic = false;\n\n  private _alias: Expression|null = null;\n\n  constructor(readonly node: T, bestGuessOwningModule: OwningModule|null = null) {\n    this.bestGuessOwningModule = bestGuessOwningModule;\n\n    const id = identifierOfNode(node);\n    if (id !== null) {\n      this.identifiers.push(id);\n    }\n  }\n\n  /**\n   * The best guess at which module specifier owns this particular reference, or `null` if there\n   * isn't one.\n   */\n  get ownedByModuleGuess(): string|null {\n    if (this.bestGuessOwningModule !== null) {\n      return this.bestGuessOwningModule.specifier;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Whether this reference has a potential owning module or not.\n   *\n   * See `bestGuessOwningModule`.\n   */\n  get hasOwningModuleGuess(): boolean {\n    return this.bestGuessOwningModule !== null;\n  }\n\n  /**\n   * A name for the node, if one is available.\n   *\n   * This is only suited for debugging. Any actual references to this node should be made with\n   * `ts.Identifier`s (see `getIdentityIn`).\n   */\n  get debugName(): string|null {\n    const id = identifierOfNode(this.node);\n    return id !== null ? id.text : null;\n  }\n\n  get alias(): Expression|null {\n    return this._alias;\n  }\n\n\n  /**\n   * Record a `ts.Identifier` by which it's valid to refer to this node, within the context of this\n   * `Reference`.\n   */\n  addIdentifier(identifier: ts.Identifier): void {\n    this.identifiers.push(identifier);\n  }\n\n  /**\n   * Get a `ts.Identifier` within this `Reference` that can be used to refer within the context of a\n   * given `ts.SourceFile`, if any.\n   */\n  getIdentityIn(context: ts.SourceFile): ts.Identifier|null {\n    return this.identifiers.find(id => id.getSourceFile() === context) || null;\n  }\n\n  /**\n   * Get a `ts.Identifier` for this `Reference` that exists within the given expression.\n   *\n   * This is very useful for producing `ts.Diagnostic`s that reference `Reference`s that were\n   * extracted from some larger expression, as it can be used to pinpoint the `ts.Identifier` within\n   * the expression from which the `Reference` originated.\n   */\n  getIdentityInExpression(expr: ts.Expression): ts.Identifier|null {\n    const sf = expr.getSourceFile();\n    return this.identifiers.find(id => {\n      if (id.getSourceFile() !== sf) {\n        return false;\n      }\n\n      // This identifier is a match if its position lies within the given expression.\n      return id.pos >= expr.pos && id.end <= expr.end;\n    }) ||\n        null;\n  }\n\n  /**\n   * Given the 'container' expression from which this `Reference` was extracted, produce a\n   * `ts.Expression` to use in a diagnostic which best indicates the position within the container\n   * expression that generated the `Reference`.\n   *\n   * For example, given a `Reference` to the class 'Bar' and the containing expression:\n   * `[Foo, Bar, Baz]`, this function would attempt to return the `ts.Identifier` for `Bar` within\n   * the array. This could be used to produce a nice diagnostic context:\n   *\n   * ```text\n   * [Foo, Bar, Baz]\n   *       ~~~\n   * ```\n   *\n   * If no specific node can be found, then the `fallback` expression is used, which defaults to the\n   * entire containing expression.\n   */\n  getOriginForDiagnostics(container: ts.Expression, fallback: ts.Expression = container):\n      ts.Expression {\n    const id = this.getIdentityInExpression(container);\n    return id !== null ? id : fallback;\n  }\n\n  cloneWithAlias(alias: Expression): Reference<T> {\n    const ref = new Reference(this.node, this.bestGuessOwningModule);\n    ref.identifiers = [...this.identifiers];\n    ref._alias = alias;\n    return ref;\n  }\n\n  cloneWithNoIdentifiers(): Reference<T> {\n    const ref = new Reference(this.node, this.bestGuessOwningModule);\n    ref._alias = this._alias;\n    ref.identifiers = [];\n    return ref;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {absoluteFrom} from '../../file_system';\nimport {getSourceFileOrNull, resolveModuleName} from '../../util/src/typescript';\n\n/**\n * Used by `RouterEntryPointManager` and `NgModuleRouteAnalyzer` (which is in turn is used by\n * `NgModuleDecoratorHandler`) for resolving the module source-files references in lazy-loaded\n * routes (relative to the source-file containing the `NgModule` that provides the route\n * definitions).\n */\nexport class ModuleResolver {\n  constructor(\n      private program: ts.Program, private compilerOptions: ts.CompilerOptions,\n      private host: ts.ModuleResolutionHost&Pick<ts.CompilerHost, 'resolveModuleNames'>,\n      private moduleResolutionCache: ts.ModuleResolutionCache|null) {}\n\n  resolveModule(moduleName: string, containingFile: string): ts.SourceFile|null {\n    const resolved = resolveModuleName(\n        moduleName, containingFile, this.compilerOptions, this.host, this.moduleResolutionCache);\n    if (resolved === undefined) {\n      return null;\n    }\n    return getSourceFileOrNull(this.program, absoluteFrom(resolved.resolvedFileName));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../../diagnostics';\nimport {Reference} from '../../../imports';\nimport {ClassPropertyName, DirectiveMeta, flattenInheritedDirectiveMetadata, HostDirectiveMeta, MetadataReader} from '../../../metadata';\nimport {describeResolvedType, DynamicValue, PartialEvaluator, ResolvedValue, traceDynamicValue} from '../../../partial_evaluator';\nimport {ClassDeclaration, ReflectionHost} from '../../../reflection';\nimport {DeclarationData, LocalModuleScopeRegistry} from '../../../scope';\nimport {identifierOfNode, isFromDtsFile} from '../../../util/src/typescript';\n\nimport {InjectableClassRegistry} from './injectable_registry';\nimport {isAbstractClassDeclaration, readBaseClass} from './util';\n\n\n/**\n * Create a `ts.Diagnostic` which indicates the given class is part of the declarations of two or\n * more NgModules.\n *\n * The resulting `ts.Diagnostic` will have a context entry for each NgModule showing the point where\n * the directive/pipe exists in its `declarations` (if possible).\n */\nexport function makeDuplicateDeclarationError(\n    node: ClassDeclaration, data: DeclarationData[], kind: string): ts.Diagnostic {\n  const context: ts.DiagnosticRelatedInformation[] = [];\n  for (const decl of data) {\n    if (decl.rawDeclarations === null) {\n      continue;\n    }\n    // Try to find the reference to the declaration within the declarations array, to hang the\n    // error there. If it can't be found, fall back on using the NgModule's name.\n    const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n    context.push(makeRelatedInformation(\n        contextNode,\n        `'${node.name.text}' is listed in the declarations of the NgModule '${\n            decl.ngModule.name.text}'.`));\n  }\n\n  // Finally, produce the diagnostic.\n  return makeDiagnostic(\n      ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name,\n      `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);\n}\n\n\n/**\n * Creates a `FatalDiagnosticError` for a node that did not evaluate to the expected type. The\n * diagnostic that is created will include details on why the value is incorrect, i.e. it includes\n * a representation of the actual type that was unsupported, or in the case of a dynamic value the\n * trace to the node where the dynamic value originated.\n *\n * @param node The node for which the diagnostic should be produced.\n * @param value The evaluated value that has the wrong type.\n * @param messageText The message text of the error.\n */\nexport function createValueHasWrongTypeError(\n    node: ts.Node, value: ResolvedValue, messageText: string): FatalDiagnosticError {\n  let chainedMessage: string;\n  let relatedInformation: ts.DiagnosticRelatedInformation[]|undefined;\n  if (value instanceof DynamicValue) {\n    chainedMessage = 'Value could not be determined statically.';\n    relatedInformation = traceDynamicValue(node, value);\n  } else if (value instanceof Reference) {\n    const target = value.debugName !== null ? `'${value.debugName}'` : 'an anonymous declaration';\n    chainedMessage = `Value is a reference to ${target}.`;\n\n    const referenceNode = identifierOfNode(value.node) ?? value.node;\n    relatedInformation = [makeRelatedInformation(referenceNode, 'Reference is declared here.')];\n  } else {\n    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n  }\n\n  const chain: ts.DiagnosticMessageChain = {\n    messageText,\n    category: ts.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainedMessage,\n      category: ts.DiagnosticCategory.Message,\n      code: 0,\n    }]\n  };\n\n  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n}\n\n/**\n * Gets the diagnostics for a set of provider classes.\n * @param providerClasses Classes that should be checked.\n * @param providersDeclaration Node that declares the providers array.\n * @param registry Registry that keeps track of the registered injectable classes.\n */\nexport function getProviderDiagnostics(\n    providerClasses: Set<Reference<ClassDeclaration>>, providersDeclaration: ts.Expression,\n    registry: InjectableClassRegistry): ts.Diagnostic[] {\n  const diagnostics: ts.Diagnostic[] = [];\n\n  for (const provider of providerClasses) {\n    const injectableMeta = registry.getInjectableMeta(provider.node);\n    if (injectableMeta !== null) {\n      // The provided type is recognized as injectable, so we don't report a diagnostic for this\n      // provider.\n      continue;\n    }\n\n    const contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n    diagnostics.push(makeDiagnostic(\n        ErrorCode.UNDECORATED_PROVIDER, contextNode,\n        `The class '${\n            provider.node.name\n                .text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\n\nEither add the @Injectable() decorator to '${\n            provider.node.name\n                .text}', or configure a different provider (such as a provider with 'useFactory').\n`,\n        [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));\n  }\n\n  return diagnostics;\n}\n\nexport function getDirectiveDiagnostics(\n    node: ClassDeclaration, injectableRegistry: InjectableClassRegistry,\n    evaluator: PartialEvaluator, reflector: ReflectionHost, scopeRegistry: LocalModuleScopeRegistry,\n    strictInjectionParameters: boolean, kind: 'Directive'|'Component'): ts.Diagnostic[]|null {\n  let diagnostics: ts.Diagnostic[]|null = [];\n\n  const addDiagnostics = (more: ts.Diagnostic|ts.Diagnostic[]|null) => {\n    if (more === null) {\n      return;\n    } else if (diagnostics === null) {\n      diagnostics = Array.isArray(more) ? more : [more];\n    } else if (Array.isArray(more)) {\n      diagnostics.push(...more);\n    } else {\n      diagnostics.push(more);\n    }\n  };\n\n  const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n\n  if (duplicateDeclarations !== null) {\n    addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n  }\n\n  addDiagnostics(checkInheritanceOfInjectable(\n      node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind));\n  return diagnostics;\n}\n\nexport function validateHostDirectives(\n    origin: ts.Expression, hostDirectives: HostDirectiveMeta[], metaReader: MetadataReader) {\n  const diagnostics: ts.DiagnosticWithLocation[] = [];\n\n  for (const current of hostDirectives) {\n    const hostMeta = flattenInheritedDirectiveMetadata(metaReader, current.directive);\n\n    if (hostMeta === null) {\n      diagnostics.push(makeDiagnostic(\n          ErrorCode.HOST_DIRECTIVE_INVALID, current.directive.getOriginForDiagnostics(origin),\n          `${\n              current.directive\n                  .debugName} must be a standalone directive to be used as a host directive`));\n      continue;\n    }\n\n    if (!hostMeta.isStandalone) {\n      diagnostics.push(makeDiagnostic(\n          ErrorCode.HOST_DIRECTIVE_NOT_STANDALONE,\n          current.directive.getOriginForDiagnostics(origin),\n          `Host directive ${hostMeta.name} must be standalone`));\n    }\n\n    if (hostMeta.isComponent) {\n      diagnostics.push(makeDiagnostic(\n          ErrorCode.HOST_DIRECTIVE_COMPONENT, current.directive.getOriginForDiagnostics(origin),\n          `Host directive ${hostMeta.name} cannot be a component`));\n    }\n\n    const requiredInputNames = Array.from(hostMeta.inputs)\n                                   .filter(input => input.required)\n                                   .map(input => input.classPropertyName);\n\n    validateHostDirectiveMappings(\n        'input', current, hostMeta, origin, diagnostics,\n        requiredInputNames.length > 0 ? new Set(requiredInputNames) : null);\n    validateHostDirectiveMappings('output', current, hostMeta, origin, diagnostics, null);\n  }\n\n  return diagnostics;\n}\n\nfunction validateHostDirectiveMappings(\n    bindingType: 'input'|'output', hostDirectiveMeta: HostDirectiveMeta, meta: DirectiveMeta,\n    origin: ts.Expression, diagnostics: ts.DiagnosticWithLocation[],\n    requiredBindings: Set<ClassPropertyName>|null) {\n  const className = meta.name;\n  const hostDirectiveMappings =\n      bindingType === 'input' ? hostDirectiveMeta.inputs : hostDirectiveMeta.outputs;\n  const existingBindings = bindingType === 'input' ? meta.inputs : meta.outputs;\n  const exposedRequiredBindings = new Set<string>();\n\n  for (const publicName in hostDirectiveMappings) {\n    if (hostDirectiveMappings.hasOwnProperty(publicName)) {\n      const bindings = existingBindings.getByBindingPropertyName(publicName);\n\n      if (bindings === null) {\n        diagnostics.push(makeDiagnostic(\n            ErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING,\n            hostDirectiveMeta.directive.getOriginForDiagnostics(origin),\n            `Directive ${className} does not have an ${bindingType} with a public name of ${\n                publicName}.`));\n      } else if (requiredBindings !== null) {\n        for (const field of bindings) {\n          if (requiredBindings.has(field.classPropertyName)) {\n            exposedRequiredBindings.add(field.classPropertyName);\n          }\n        }\n      }\n\n      const remappedPublicName = hostDirectiveMappings[publicName];\n      const bindingsForPublicName = existingBindings.getByBindingPropertyName(remappedPublicName);\n\n      if (bindingsForPublicName !== null) {\n        for (const binding of bindingsForPublicName) {\n          if (binding.bindingPropertyName !== publicName) {\n            diagnostics.push(makeDiagnostic(\n                ErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS,\n                hostDirectiveMeta.directive.getOriginForDiagnostics(origin),\n                `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${\n                    remappedPublicName}, because it already has a different ${\n                    bindingType} with the same public name.`));\n          }\n        }\n      }\n    }\n  }\n\n  if (requiredBindings !== null && requiredBindings.size !== exposedRequiredBindings.size) {\n    const missingBindings: string[] = [];\n\n    for (const publicName of requiredBindings) {\n      if (!exposedRequiredBindings.has(publicName)) {\n        const name = existingBindings.getByClassPropertyName(publicName);\n\n        if (name) {\n          missingBindings.push(`'${name.bindingPropertyName}'`);\n        }\n      }\n    }\n\n    diagnostics.push(makeDiagnostic(\n        ErrorCode.HOST_DIRECTIVE_MISSING_REQUIRED_BINDING,\n        hostDirectiveMeta.directive.getOriginForDiagnostics(origin),\n        `Required ${bindingType}${missingBindings.length === 1 ? '' : 's'} ${\n            missingBindings.join(', ')} from host directive ${className} must be exposed.`));\n  }\n}\n\n\nexport function getUndecoratedClassWithAngularFeaturesDiagnostic(node: ClassDeclaration):\n    ts.Diagnostic {\n  return makeDiagnostic(\n      ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name,\n      `Class is using Angular features but is not decorated. Please add an explicit ` +\n          `Angular decorator.`);\n}\n\nexport function checkInheritanceOfInjectable(\n    node: ClassDeclaration, injectableRegistry: InjectableClassRegistry, reflector: ReflectionHost,\n    evaluator: PartialEvaluator, strictInjectionParameters: boolean,\n    kind: 'Directive'|'Component'|'Pipe'|'Injectable'): ts.Diagnostic|null {\n  const classWithCtor = findInheritedCtor(node, injectableRegistry, reflector, evaluator);\n  if (classWithCtor === null || classWithCtor.isCtorValid) {\n    // The class does not inherit a constructor, or the inherited constructor is compatible\n    // with DI; no need to report a diagnostic.\n    return null;\n  }\n\n  if (!classWithCtor.isDecorated) {\n    // The inherited constructor exists in a class that does not have an Angular decorator.\n    // This is an error, as there won't be a factory definition available for DI to invoke\n    // the constructor.\n    return getInheritedUndecoratedCtorDiagnostic(node, classWithCtor.ref, kind);\n  }\n\n  if (isFromDtsFile(classWithCtor.ref.node)) {\n    // The inherited class is declared in a declaration file, in which case there is not enough\n    // information to detect invalid constructors as `@Inject()` metadata is not present in the\n    // declaration file. Consequently, we have to accept such occurrences, although they might\n    // still fail at runtime.\n    return null;\n  }\n\n  if (!strictInjectionParameters || isAbstractClassDeclaration(node)) {\n    // An invalid constructor is only reported as error under `strictInjectionParameters` and\n    // only for concrete classes; follow the same exclusions for derived types.\n    return null;\n  }\n\n  return getInheritedInvalidCtorDiagnostic(node, classWithCtor.ref, kind);\n}\n\ninterface ClassWithCtor {\n  ref: Reference<ClassDeclaration>;\n  isCtorValid: boolean;\n  isDecorated: boolean;\n}\n\nexport function findInheritedCtor(\n    node: ClassDeclaration, injectableRegistry: InjectableClassRegistry, reflector: ReflectionHost,\n    evaluator: PartialEvaluator): ClassWithCtor|null {\n  if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n    // We should skip nodes that aren't classes. If a constructor exists, then no base class\n    // definition is required on the runtime side - it's legal to inherit from any class.\n    return null;\n  }\n\n  // The extends clause is an expression which can be as dynamic as the user wants. Try to\n  // evaluate it, but fall back on ignoring the clause if it can't be understood. This is a View\n  // Engine compatibility hack: View Engine ignores 'extends' expressions that it cannot understand.\n  let baseClass = readBaseClass(node, reflector, evaluator);\n\n  while (baseClass !== null) {\n    if (baseClass === 'dynamic') {\n      return null;\n    }\n\n    const injectableMeta = injectableRegistry.getInjectableMeta(baseClass.node);\n    if (injectableMeta !== null) {\n      if (injectableMeta.ctorDeps !== null) {\n        // The class has an Angular decorator with a constructor.\n        return {\n          ref: baseClass,\n          isCtorValid: injectableMeta.ctorDeps !== 'invalid',\n          isDecorated: true,\n        };\n      }\n    } else {\n      const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n      if (baseClassConstructorParams !== null) {\n        // The class is not decorated, but it does have constructor. An undecorated class is only\n        // allowed to have a constructor without parameters, otherwise it is invalid.\n        return {\n          ref: baseClass,\n          isCtorValid: baseClassConstructorParams.length === 0,\n          isDecorated: false,\n        };\n      }\n    }\n\n    // Go up the chain and continue\n    baseClass = readBaseClass(baseClass.node, reflector, evaluator);\n  }\n\n  return null;\n}\n\nfunction getInheritedInvalidCtorDiagnostic(\n    node: ClassDeclaration, baseClass: Reference,\n    kind: 'Directive'|'Component'|'Pipe'|'Injectable') {\n  const baseClassName = baseClass.debugName;\n\n  return makeDiagnostic(\n      ErrorCode.INJECTABLE_INHERITS_INVALID_CONSTRUCTOR, node.name,\n      `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${\n          baseClassName}, ` +\n          `but the latter has a constructor parameter that is not compatible with dependency injection. ` +\n          `Either add an explicit constructor to ${node.name.text} or change ${\n              baseClassName}'s constructor to ` +\n          `use parameters that are valid for DI.`);\n}\n\nfunction getInheritedUndecoratedCtorDiagnostic(\n    node: ClassDeclaration, baseClass: Reference,\n    kind: 'Directive'|'Component'|'Pipe'|'Injectable') {\n  const baseClassName = baseClass.debugName;\n  const baseNeedsDecorator =\n      kind === 'Component' || kind === 'Directive' ? 'Directive' : 'Injectable';\n\n  return makeDiagnostic(\n      ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name,\n      `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${\n          baseClassName}, ` +\n          `but the latter does not have an Angular decorator of its own. Dependency injection will not be able to ` +\n          `resolve the parameters of ${baseClassName}'s constructor. Either add a @${\n              baseNeedsDecorator} decorator ` +\n          `to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DirectiveMeta as T2DirectiveMeta, SchemaMetadata} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ClassPropertyMapping, ClassPropertyName, InputOrOutput} from './property_mapping';\n\n/**\n * Metadata collected for an `NgModule`.\n */\nexport interface NgModuleMeta {\n  kind: MetaKind.NgModule;\n  ref: Reference<ClassDeclaration>;\n  declarations: Reference<ClassDeclaration>[];\n  imports: Reference<ClassDeclaration>[];\n  exports: Reference<ClassDeclaration>[];\n  schemas: SchemaMetadata[];\n\n  /**\n   * The raw `ts.Expression` which gave rise to `declarations`, if one exists.\n   *\n   * If this is `null`, then either no declarations exist, or no expression was available (likely\n   * because the module came from a .d.ts file).\n   */\n  rawDeclarations: ts.Expression|null;\n\n  /**\n   * The raw `ts.Expression` which gave rise to `imports`, if one exists.\n   *\n   * If this is `null`, then either no imports exist, or no expression was available (likely\n   * because the module came from a .d.ts file).\n   */\n  rawImports: ts.Expression|null;\n\n  /**\n   * The raw `ts.Expression` which gave rise to `exports`, if one exists.\n   *\n   * If this is `null`, then either no exports exist, or no expression was available (likely\n   * because the module came from a .d.ts file).\n   */\n  rawExports: ts.Expression|null;\n\n  /**\n   * The primary decorator associated with this `ngModule`.\n   *\n   * If this is `null`, no decorator exists, meaning it's probably from a .d.ts file.\n   */\n  decorator: ts.Decorator|null;\n\n  /**\n   * Whether this NgModule may declare providers.\n   *\n   * If the compiler does not know if the NgModule may declare providers, this will be `true` (for\n   * example, NgModules declared outside the current compilation are assumed to declare providers).\n   */\n  mayDeclareProviders: boolean;\n}\n\n/**\n * Typing metadata collected for a directive within an NgModule's scope.\n */\nexport interface DirectiveTypeCheckMeta {\n  /**\n   * List of static `ngTemplateGuard_xx` members found on the Directive's class.\n   * @see `TemplateGuardMeta`\n   */\n  ngTemplateGuards: TemplateGuardMeta[];\n\n  /**\n   * Whether the Directive's class has a static ngTemplateContextGuard function.\n   */\n  hasNgTemplateContextGuard: boolean;\n\n  /**\n   * The set of input fields which have a corresponding static `ngAcceptInputType_` on the\n   * Directive's class. This allows inputs to accept a wider range of types and coerce the input to\n   * a narrower type with a getter/setter. See https://angular.io/guide/template-typecheck.\n   */\n  coercedInputFields: Set<ClassPropertyName>;\n\n  /**\n   * The set of input fields which map to `readonly`, `private`, or `protected` members in the\n   * Directive's class.\n   */\n  restrictedInputFields: Set<ClassPropertyName>;\n\n  /**\n   * The set of input fields which are declared as string literal members in the Directive's class.\n   * We need to track these separately because these fields may not be valid JS identifiers so\n   * we cannot use them with property access expressions when assigning inputs.\n   */\n  stringLiteralInputFields: Set<ClassPropertyName>;\n\n  /**\n   * The set of input fields which do not have corresponding members in the Directive's class.\n   */\n  undeclaredInputFields: Set<ClassPropertyName>;\n\n  /**\n   * Whether the Directive's class is generic, i.e. `class MyDir<T> {...}`.\n   */\n  isGeneric: boolean;\n}\n\n/**\n * Disambiguates different kinds of compiler metadata objects.\n */\nexport enum MetaKind {\n  Directive,\n  Pipe,\n  NgModule,\n}\n\n/**\n * Possible ways that a directive can be matched.\n */\nexport enum MatchSource {\n  /** The directive was matched by its selector. */\n  Selector,\n\n  /** The directive was applied as a host directive. */\n  HostDirective,\n}\n\n/** Metadata for a single input mapping. */\nexport type InputMapping = InputOrOutput&{required: boolean};\n\n/**\n * Metadata collected for a directive within an NgModule's scope.\n */\nexport interface DirectiveMeta extends T2DirectiveMeta, DirectiveTypeCheckMeta {\n  kind: MetaKind.Directive;\n\n  /** Way in which the directive was matched. */\n  matchSource: MatchSource;\n\n  ref: Reference<ClassDeclaration>;\n  /**\n   * Unparsed selector of the directive, or null if the directive does not have a selector.\n   */\n  selector: string|null;\n  queries: string[];\n\n  /**\n   * A mapping of input field names to the property names.\n   */\n  inputs: ClassPropertyMapping<InputMapping>;\n\n  /**\n   * A mapping of output field names to the property names.\n   */\n  outputs: ClassPropertyMapping;\n\n  /**\n   * A `Reference` to the base class for the directive, if one was detected.\n   *\n   * A value of `'dynamic'` indicates that while the analyzer detected that this directive extends\n   * another type, it could not statically determine the base class.\n   */\n  baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n\n  /**\n   * Whether the directive had some issue with its declaration that means it might not have complete\n   * and reliable metadata.\n   */\n  isPoisoned: boolean;\n\n  /**\n   * Whether the directive is likely a structural directive (injects `TemplateRef`).\n   */\n  isStructural: boolean;\n\n  /**\n   * Whether the directive is a standalone entity.\n   */\n  isStandalone: boolean;\n\n  /**\n   * For standalone components, the list of imported types.\n   */\n  imports: Reference<ClassDeclaration>[]|null;\n\n  /**\n   * For standalone components, the list of schemas declared.\n   */\n  schemas: SchemaMetadata[]|null;\n\n  /**\n   * The primary decorator associated with this directive.\n   *\n   * If this is `null`, no decorator exists, meaning it's probably from a .d.ts file.\n   */\n  decorator: ts.Decorator|null;\n\n  /** Additional directives applied to the directive host. */\n  hostDirectives: HostDirectiveMeta[]|null;\n\n  /**\n   * Whether the directive should be assumed to export providers if imported as a standalone type.\n   */\n  assumedToExportProviders: boolean;\n}\n\n/** Metadata collected about an additional directive that is being applied to a directive host. */\nexport interface HostDirectiveMeta {\n  /** Reference to the host directive class. */\n  directive: Reference<ClassDeclaration>;\n\n  /** Whether the reference to the host directive is a forward reference. */\n  isForwardReference: boolean;\n\n  /** Inputs from the host directive that have been exposed. */\n  inputs: {[publicName: string]: string}|null;\n\n  /** Outputs from the host directive that have been exposed. */\n  outputs: {[publicName: string]: string}|null;\n}\n\n/**\n * Metadata that describes a template guard for one of the directive's inputs.\n */\nexport interface TemplateGuardMeta {\n  /**\n   * The input name that this guard should be applied to.\n   */\n  inputName: string;\n\n  /**\n   * Represents the type of the template guard.\n   *\n   * - 'invocation' means that a call to the template guard function is emitted so that its return\n   *   type can result in narrowing of the input type.\n   * - 'binding' means that the input binding expression itself is used as template guard.\n   */\n  type: 'invocation'|'binding';\n}\n\n/**\n * Metadata for a pipe within an NgModule's scope.\n */\nexport interface PipeMeta {\n  kind: MetaKind.Pipe;\n  ref: Reference<ClassDeclaration>;\n  name: string;\n  nameExpr: ts.Expression|null;\n  isStandalone: boolean;\n  decorator: ts.Decorator|null;\n}\n\n/**\n * Reads metadata for directives, pipes, and modules from a particular source, such as .d.ts files\n * or a registry.\n */\nexport interface MetadataReader {\n  getDirectiveMetadata(node: Reference<ClassDeclaration>): DirectiveMeta|null;\n  getNgModuleMetadata(node: Reference<ClassDeclaration>): NgModuleMeta|null;\n  getPipeMetadata(node: Reference<ClassDeclaration>): PipeMeta|null;\n}\n\n/**\n * A MetadataReader which also allows access to the set of all known trait classes.\n */\nexport interface MetadataReaderWithIndex extends MetadataReader {\n  getKnown(kind: MetaKind): Array<ClassDeclaration>;\n}\n\n/**\n * An NgModuleIndex allows access to information about traits exported by NgModules.\n */\nexport interface NgModuleIndex {\n  getNgModulesExporting(directiveOrPipe: ClassDeclaration): Array<Reference<ClassDeclaration>>;\n}\n\n/**\n * Registers new metadata for directives, pipes, and modules.\n */\nexport interface MetadataRegistry {\n  registerDirectiveMetadata(meta: DirectiveMeta): void;\n  registerNgModuleMetadata(meta: NgModuleMeta): void;\n  registerPipeMetadata(meta: PipeMeta): void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {OwningModule, Reference} from '../../imports';\nimport {ClassDeclaration, isNamedClassDeclaration, ReflectionHost, TypeValueReferenceKind} from '../../reflection';\nimport {nodeDebugInfo} from '../../util/src/typescript';\n\nimport {DirectiveMeta, HostDirectiveMeta, InputMapping, MatchSource, MetadataReader, MetaKind, NgModuleMeta, PipeMeta} from './api';\nimport {ClassPropertyMapping} from './property_mapping';\nimport {extractDirectiveTypeCheckMeta, extractReferencesFromType, extraReferenceFromTypeQuery, readBooleanType, readMapType, readStringArrayType, readStringType} from './util';\n\n/**\n * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties\n * from an upstream compilation already.\n */\nexport class DtsMetadataReader implements MetadataReader {\n  constructor(private checker: ts.TypeChecker, private reflector: ReflectionHost) {}\n\n  /**\n   * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts\n   * file, or in a .ts file with a handwritten definition).\n   *\n   * @param ref `Reference` to the class of interest, with the context of how it was obtained.\n   */\n  getNgModuleMetadata(ref: Reference<ClassDeclaration>): NgModuleMeta|null {\n    const clazz = ref.node;\n\n    // This operation is explicitly not memoized, as it depends on `ref.ownedByModuleGuess`.\n    // TODO(alxhub): investigate caching of .d.ts module metadata.\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(\n        member => member.name === 'Éµmod' && member.isStatic);\n    if (ngModuleDef === undefined) {\n      return null;\n    } else if (\n        // Validate that the shape of the ngModuleDef type is correct.\n        ngModuleDef.type === null || !ts.isTypeReferenceNode(ngModuleDef.type) ||\n        ngModuleDef.type.typeArguments === undefined ||\n        ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n\n    // Read the ModuleData out of the type arguments.\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      kind: MetaKind.NgModule,\n      ref,\n      declarations:\n          extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule),\n      exports: extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule),\n      imports: extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule),\n      schemas: [],\n      rawDeclarations: null,\n      rawImports: null,\n      rawExports: null,\n      decorator: null,\n      // NgModules declared outside the current compilation are assumed to contain providers, as it\n      // would be a non-breaking change for a library to introduce providers at any point.\n      mayDeclareProviders: true,\n    };\n  }\n\n  /**\n   * Read directive (or component) metadata from a referenced class in a .d.ts file.\n   */\n  getDirectiveMetadata(ref: Reference<ClassDeclaration>): DirectiveMeta|null {\n    const clazz = ref.node;\n    const def = this.reflector.getMembersOfClass(clazz).find(\n        field => field.isStatic && (field.name === 'Éµcmp' || field.name === 'Éµdir'));\n    if (def === undefined) {\n      // No definition could be found.\n      return null;\n    } else if (\n        def.type === null || !ts.isTypeReferenceNode(def.type) ||\n        def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {\n      // The type metadata was the wrong shape.\n      return null;\n    }\n\n    const isComponent = def.name === 'Éµcmp';\n\n    const ctorParams = this.reflector.getConstructorParameters(clazz);\n\n    // A directive is considered to be structural if:\n    // 1) it's a directive, not a component, and\n    // 2) it injects `TemplateRef`\n    const isStructural = !isComponent && ctorParams !== null && ctorParams.some(param => {\n      return param.typeValueReference.kind === TypeValueReferenceKind.IMPORTED &&\n          param.typeValueReference.moduleName === '@angular/core' &&\n          param.typeValueReference.importedName === 'TemplateRef';\n    });\n\n    const isStandalone =\n        def.type.typeArguments.length > 7 && (readBooleanType(def.type.typeArguments[7]) ?? false);\n\n    const inputs = ClassPropertyMapping.fromMappedObject(readInputsType(def.type.typeArguments[3]));\n    const outputs = ClassPropertyMapping.fromMappedObject(\n        readMapType(def.type.typeArguments[4], readStringType));\n\n    const hostDirectives = def.type.typeArguments.length > 8 ?\n        readHostDirectivesType(this.checker, def.type.typeArguments[8], ref.bestGuessOwningModule) :\n        null;\n\n    return {\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: clazz.name.text,\n      isComponent,\n      selector: readStringType(def.type.typeArguments[1]),\n      exportAs: readStringArrayType(def.type.typeArguments[2]),\n      inputs,\n      outputs,\n      hostDirectives,\n      queries: readStringArrayType(def.type.typeArguments[5]),\n      ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),\n      baseClass: readBaseClass(clazz, this.checker, this.reflector),\n      isPoisoned: false,\n      isStructural,\n      animationTriggerNames: null,\n      isStandalone,\n      // Imports are tracked in metadata only for template type-checking purposes,\n      // so standalone components from .d.ts files don't have any.\n      imports: null,\n      // The same goes for schemas.\n      schemas: null,\n      decorator: null,\n      // Assume that standalone components from .d.ts files may export providers.\n      assumedToExportProviders: isComponent && isStandalone,\n    };\n  }\n\n  /**\n   * Read pipe metadata from a referenced class in a .d.ts file.\n   */\n  getPipeMetadata(ref: Reference<ClassDeclaration>): PipeMeta|null {\n    const def = this.reflector.getMembersOfClass(ref.node).find(\n        field => field.isStatic && field.name === 'Éµpipe');\n    if (def === undefined) {\n      // No definition could be found.\n      return null;\n    } else if (\n        def.type === null || !ts.isTypeReferenceNode(def.type) ||\n        def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {\n      // The type metadata was the wrong shape.\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n      // The type metadata was the wrong type.\n      return null;\n    }\n    const name = type.literal.text;\n\n    const isStandalone =\n        def.type.typeArguments.length > 2 && (readBooleanType(def.type.typeArguments[2]) ?? false);\n\n    return {\n      kind: MetaKind.Pipe,\n      ref,\n      name,\n      nameExpr: null,\n      isStandalone,\n      decorator: null,\n    };\n  }\n}\n\nfunction readInputsType(type: ts.TypeNode): Record<string, InputMapping> {\n  const inputsMap = {} as Record<string, InputMapping>;\n\n  if (ts.isTypeLiteralNode(type)) {\n    for (const member of type.members) {\n      if (!ts.isPropertySignature(member) || member.type === undefined ||\n          member.name === undefined ||\n          (!ts.isStringLiteral(member.name) && !ts.isIdentifier(member.name))) {\n        continue;\n      }\n\n      const stringValue = readStringType(member.type);\n\n      // Before v16 the inputs map has the type of `{[field: string]: string}`.\n      // After v16 it has the type of `{[field: string]: {alias: string, required: boolean}}`.\n      if (stringValue != null) {\n        inputsMap[member.name.text] = {\n          bindingPropertyName: stringValue,\n          classPropertyName: member.name.text,\n          required: false\n        };\n      } else {\n        const config = readMapType(member.type, innerValue => {\n                         return readStringType(innerValue) ?? readBooleanType(innerValue);\n                       }) as {alias: string, required: boolean};\n\n        inputsMap[member.name.text] = {\n          classPropertyName: member.name.text,\n          bindingPropertyName: config.alias,\n          required: config.required\n        };\n      }\n    }\n  }\n\n  return inputsMap;\n}\n\nfunction readBaseClass(clazz: ClassDeclaration, checker: ts.TypeChecker, reflector: ReflectionHost):\n    Reference<ClassDeclaration>|'dynamic'|null {\n  if (!isNamedClassDeclaration(clazz)) {\n    // Technically this is an error in a .d.ts file, but for the purposes of finding the base class\n    // it's ignored.\n    return reflector.hasBaseClass(clazz) ? 'dynamic' : null;\n  }\n\n  if (clazz.heritageClauses !== undefined) {\n    for (const clause of clazz.heritageClauses) {\n      if (clause.token === ts.SyntaxKind.ExtendsKeyword) {\n        const baseExpr = clause.types[0].expression;\n        let symbol = checker.getSymbolAtLocation(baseExpr);\n        if (symbol === undefined) {\n          return 'dynamic';\n        } else if (symbol.flags & ts.SymbolFlags.Alias) {\n          symbol = checker.getAliasedSymbol(symbol);\n        }\n        if (symbol.valueDeclaration !== undefined &&\n            isNamedClassDeclaration(symbol.valueDeclaration)) {\n          return new Reference(symbol.valueDeclaration);\n        } else {\n          return 'dynamic';\n        }\n      }\n    }\n  }\n  return null;\n}\n\n\nfunction readHostDirectivesType(\n    checker: ts.TypeChecker, type: ts.TypeNode,\n    bestGuessOwningModule: OwningModule|null): HostDirectiveMeta[]|null {\n  if (!ts.isTupleTypeNode(type) || type.elements.length === 0) {\n    return null;\n  }\n\n  const result: HostDirectiveMeta[] = [];\n\n  for (const hostDirectiveType of type.elements) {\n    const {directive, inputs, outputs} = readMapType(hostDirectiveType, type => type);\n\n    if (directive) {\n      if (!ts.isTypeQueryNode(directive)) {\n        throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(directive)}`);\n      }\n\n      result.push({\n        directive: extraReferenceFromTypeQuery(checker, directive, type, bestGuessOwningModule),\n        isForwardReference: false,\n        inputs: readMapType(inputs, readStringType),\n        outputs: readMapType(outputs, readStringType)\n      });\n    }\n  }\n\n  return result.length > 0 ? result : null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n/**\n * Metadata extracted from an instance of a decorator on another declaration.\n */\nexport interface Decorator {\n  /**\n   * Name by which the decorator was invoked in the user's code.\n   *\n   * This is distinct from the name by which the decorator was imported (though in practice they\n   * will usually be the same).\n   */\n  name: string;\n\n  /**\n   * Identifier which refers to the decorator in the user's code.\n   */\n  identifier: DecoratorIdentifier;\n\n  /**\n   * `Import` by which the decorator was brought into the module in which it was invoked, or `null`\n   * if the decorator was declared in the same module and not imported.\n   *\n   * Note: this field is declared using computed property syntax to work around a clang-format bug\n   * that resulted in inconsistent indentation of this comment block.\n   */\n  ['import']: Import|null;\n\n  /**\n   * TypeScript reference to the decorator itself.\n   */\n  node: ts.Node;\n\n  /**\n   * Arguments of the invocation of the decorator, if the decorator is invoked, or `null`\n   * otherwise.\n   */\n  args: ts.Expression[]|null;\n}\n\n/**\n * A decorator is identified by either a simple identifier (e.g. `Decorator`) or, in some cases,\n * a namespaced property access (e.g. `core.Decorator`).\n */\nexport type DecoratorIdentifier = ts.Identifier|NamespacedIdentifier;\nexport type NamespacedIdentifier = ts.PropertyAccessExpression&{\n  expression: ts.Identifier;\n  name: ts.Identifier\n};\nexport function isDecoratorIdentifier(exp: ts.Expression): exp is DecoratorIdentifier {\n  return ts.isIdentifier(exp) ||\n      ts.isPropertyAccessExpression(exp) && ts.isIdentifier(exp.expression) &&\n      ts.isIdentifier(exp.name);\n}\n\n/**\n * The `ts.Declaration` of a \"class\".\n *\n * Classes are represented differently in different code formats:\n * - In TS code, they are typically defined using the `class` keyword.\n * - In ES2015 code, they are usually defined using the `class` keyword, but they can also be\n *   variable declarations, which are initialized to a class expression (e.g.\n *   `let Foo = Foo1 = class Foo {}`).\n * - In ES5 code, they are typically defined as variable declarations being assigned the return\n *   value of an IIFE. The actual \"class\" is implemented as a constructor function inside the IIFE,\n *   but the outer variable declaration represents the \"class\" to the rest of the program.\n *\n * For `ReflectionHost` purposes, a class declaration should always have a `name` identifier,\n * because we need to be able to reference it in other parts of the program.\n */\nexport type ClassDeclaration<T extends DeclarationNode = DeclarationNode> = T&{name: ts.Identifier};\n\n/**\n * An enumeration of possible kinds of class members.\n */\nexport enum ClassMemberKind {\n  Constructor,\n  Getter,\n  Setter,\n  Property,\n  Method,\n}\n\n/**\n * A member of a class, such as a property, method, or constructor.\n */\nexport interface ClassMember {\n  /**\n   * TypeScript reference to the class member itself, or null if it is not applicable.\n   */\n  node: ts.Node|null;\n\n  /**\n   * Indication of which type of member this is (property, method, etc).\n   */\n  kind: ClassMemberKind;\n\n  /**\n   * TypeScript `ts.TypeNode` representing the type of the member, or `null` if not present or\n   * applicable.\n   */\n  type: ts.TypeNode|null;\n\n  /**\n   * Name of the class member.\n   */\n  name: string;\n\n  /**\n   * TypeScript `ts.Identifier` or `ts.StringLiteral` representing the name of the member, or `null`\n   * if no such node is present.\n   *\n   * The `nameNode` is useful in writing references to this member that will be correctly source-\n   * mapped back to the original file.\n   */\n  nameNode: ts.Identifier|ts.StringLiteral|null;\n\n  /**\n   * TypeScript `ts.Expression` which represents the value of the member.\n   *\n   * If the member is a property, this will be the property initializer if there is one, or null\n   * otherwise.\n   */\n  value: ts.Expression|null;\n\n  /**\n   * TypeScript `ts.Declaration` which represents the implementation of the member.\n   *\n   * In TypeScript code this is identical to the node, but in downleveled code this should always be\n   * the Declaration which actually represents the member's runtime value.\n   *\n   * For example, the TS code:\n   *\n   * ```\n   * class Clazz {\n   *   static get property(): string {\n   *     return 'value';\n   *   }\n   * }\n   * ```\n   *\n   * Downlevels to:\n   *\n   * ```\n   * var Clazz = (function () {\n   *   function Clazz() {\n   *   }\n   *   Object.defineProperty(Clazz, \"property\", {\n   *       get: function () {\n   *           return 'value';\n   *       },\n   *       enumerable: true,\n   *       configurable: true\n   *   });\n   *   return Clazz;\n   * }());\n   * ```\n   *\n   * In this example, for the property \"property\", the node would be the entire\n   * Object.defineProperty ExpressionStatement, but the implementation would be this\n   * FunctionDeclaration:\n   *\n   * ```\n   * function () {\n   *   return 'value';\n   * },\n   * ```\n   */\n  implementation: ts.Declaration|null;\n\n  /**\n   * Whether the member is static or not.\n   */\n  isStatic: boolean;\n\n  /**\n   * Any `Decorator`s which are present on the member, or `null` if none are present.\n   */\n  decorators: Decorator[]|null;\n}\n\nexport const enum TypeValueReferenceKind {\n  LOCAL,\n  IMPORTED,\n  UNAVAILABLE,\n}\n\n/**\n * A type reference that refers to any type via a `ts.Expression` that's valid within the local file\n * where the type was referenced.\n */\nexport interface LocalTypeValueReference {\n  kind: TypeValueReferenceKind.LOCAL;\n\n  /**\n   * The synthesized expression to reference the type in a value position.\n   */\n  expression: ts.Expression;\n\n  /**\n   * If the type originates from a default import, the import statement is captured here to be able\n   * to track its usages, preventing the import from being elided if it was originally only used in\n   * a type-position. See `DefaultImportTracker` for details.\n   */\n  defaultImportStatement: ts.ImportDeclaration|null;\n}\n\n/**\n * A reference that refers to a type that was imported, and gives the symbol `name` and the\n * `moduleName` of the import. Note that this `moduleName` may be a relative path, and thus is\n * likely only valid within the context of the file which contained the original type reference.\n */\nexport interface ImportedTypeValueReference {\n  kind: TypeValueReferenceKind.IMPORTED;\n\n  /**\n   * The module specifier from which the `importedName` symbol should be imported.\n   */\n  moduleName: string;\n\n  /**\n   * The name of the top-level symbol that is imported from `moduleName`. If `nestedPath` is also\n   * present, a nested object is being referenced from the top-level symbol.\n   */\n  importedName: string;\n\n  /**\n   * If present, represents the symbol names that are referenced from the top-level import.\n   * When `null` or empty, the `importedName` itself is the symbol being referenced.\n   */\n  nestedPath: string[]|null;\n\n  valueDeclaration: DeclarationNode;\n}\n\n/**\n * A representation for a type value reference that is used when no value is available. This can\n * occur due to various reasons, which is indicated in the `reason` field.\n */\nexport interface UnavailableTypeValueReference {\n  kind: TypeValueReferenceKind.UNAVAILABLE;\n\n  /**\n   * The reason why no value reference could be determined for a type.\n   */\n  reason: UnavailableValue;\n}\n\n/**\n * The various reasons why the compiler may be unable to synthesize a value from a type reference.\n */\nexport const enum ValueUnavailableKind {\n  /**\n   * No type node was available.\n   */\n  MISSING_TYPE,\n\n  /**\n   * The type does not have a value declaration, e.g. an interface.\n   */\n  NO_VALUE_DECLARATION,\n\n  /**\n   * The type is imported using a type-only imports, so it is not suitable to be used in a\n   * value-position.\n   */\n  TYPE_ONLY_IMPORT,\n\n  /**\n   * The type reference could not be resolved to a declaration.\n   */\n  UNKNOWN_REFERENCE,\n\n  /**\n   * The type corresponds with a namespace.\n   */\n  NAMESPACE,\n\n  /**\n   * The type is not supported in the compiler, for example union types.\n   */\n  UNSUPPORTED,\n}\n\n\nexport interface UnsupportedType {\n  kind: ValueUnavailableKind.UNSUPPORTED;\n  typeNode: ts.TypeNode;\n}\n\nexport interface NoValueDeclaration {\n  kind: ValueUnavailableKind.NO_VALUE_DECLARATION;\n  typeNode: ts.TypeNode;\n  decl: ts.Declaration|null;\n}\n\nexport interface TypeOnlyImport {\n  kind: ValueUnavailableKind.TYPE_ONLY_IMPORT;\n  typeNode: ts.TypeNode;\n  node: ts.ImportClause|ts.ImportSpecifier;\n}\n\nexport interface NamespaceImport {\n  kind: ValueUnavailableKind.NAMESPACE;\n  typeNode: ts.TypeNode;\n  importClause: ts.ImportClause;\n}\n\nexport interface UnknownReference {\n  kind: ValueUnavailableKind.UNKNOWN_REFERENCE;\n  typeNode: ts.TypeNode;\n}\n\nexport interface MissingType {\n  kind: ValueUnavailableKind.MISSING_TYPE;\n}\n\n/**\n * The various reasons why a type node may not be referred to as a value.\n */\nexport type UnavailableValue =\n    UnsupportedType|NoValueDeclaration|TypeOnlyImport|NamespaceImport|UnknownReference|MissingType;\n\n/**\n * A reference to a value that originated from a type position.\n *\n * For example, a constructor parameter could be declared as `foo: Foo`. A `TypeValueReference`\n * extracted from this would refer to the value of the class `Foo` (assuming it was actually a\n * type).\n *\n * See the individual types for additional information.\n */\nexport type TypeValueReference =\n    LocalTypeValueReference|ImportedTypeValueReference|UnavailableTypeValueReference;\n\n/**\n * A parameter to a constructor.\n */\nexport interface CtorParameter {\n  /**\n   * Name of the parameter, if available.\n   *\n   * Some parameters don't have a simple string name (for example, parameters which are destructured\n   * into multiple variables). In these cases, `name` can be `null`.\n   */\n  name: string|null;\n\n  /**\n   * TypeScript `ts.BindingName` representing the name of the parameter.\n   *\n   * The `nameNode` is useful in writing references to this member that will be correctly source-\n   * mapped back to the original file.\n   */\n  nameNode: ts.BindingName;\n\n  /**\n   * Reference to the value of the parameter's type annotation, if it's possible to refer to the\n   * parameter's type as a value.\n   *\n   * This can either be a reference to a local value, a reference to an imported value, or no\n   * value if no is present or cannot be represented as an expression.\n   */\n  typeValueReference: TypeValueReference;\n\n  /**\n   * TypeScript `ts.TypeNode` representing the type node found in the type position.\n   *\n   * This field can be used for diagnostics reporting if `typeValueReference` is `null`.\n   *\n   * Can be null, if the param has no type declared.\n   */\n  typeNode: ts.TypeNode|null;\n\n  /**\n   * Any `Decorator`s which are present on the parameter, or `null` if none are present.\n   */\n  decorators: Decorator[]|null;\n}\n\n/**\n * Definition of a function or method, including its body if present and any parameters.\n *\n * In TypeScript code this metadata will be a simple reflection of the declarations in the node\n * itself. In ES5 code this can be more complicated, as the default values for parameters may\n * be extracted from certain body statements.\n */\nexport interface FunctionDefinition {\n  /**\n   * A reference to the node which declares the function.\n   */\n  node: ts.MethodDeclaration|ts.FunctionDeclaration|ts.FunctionExpression|ts.VariableDeclaration;\n\n  /**\n   * Statements of the function body, if a body is present, or null if no body is present or the\n   * function is identified to represent a tslib helper function, in which case `helper` will\n   * indicate which helper this function represents.\n   *\n   * This list may have been filtered to exclude statements which perform parameter default value\n   * initialization.\n   */\n  body: ts.Statement[]|null;\n\n  /**\n   * Metadata regarding the function's parameters, including possible default value expressions.\n   */\n  parameters: Parameter[];\n}\n\n/**\n * A parameter to a function or method.\n */\nexport interface Parameter {\n  /**\n   * Name of the parameter, if available.\n   */\n  name: string|null;\n\n  /**\n   * Declaration which created this parameter.\n   */\n  node: ts.ParameterDeclaration;\n\n  /**\n   * Expression which represents the default value of the parameter, if any.\n   */\n  initializer: ts.Expression|null;\n}\n\n/**\n * The source of an imported symbol, including the original symbol name and the module from which it\n * was imported.\n */\nexport interface Import {\n  /**\n   * The name of the imported symbol under which it was exported (not imported).\n   */\n  name: string;\n\n  /**\n   * The module from which the symbol was imported.\n   *\n   * This could either be an absolute module name (@angular/core for example) or a relative path.\n   */\n  from: string;\n}\n\n/**\n * A type that is used to identify a declaration.\n */\nexport type DeclarationNode = ts.Declaration;\n\n/**\n * The declaration of a symbol, along with information about how it was imported into the\n * application.\n */\nexport interface Declaration<T extends ts.Declaration = ts.Declaration> {\n  /**\n   * The absolute module path from which the symbol was imported into the application, if the symbol\n   * was imported via an absolute module (even through a chain of re-exports). If the symbol is part\n   * of the application and was not imported from an absolute path, this will be `null`.\n   */\n  viaModule: string|null;\n\n  /**\n   * TypeScript reference to the declaration itself, if one exists.\n   */\n  node: T;\n}\n\n/**\n * Abstracts reflection operations on a TypeScript AST.\n *\n * Depending on the format of the code being interpreted, different concepts are represented\n * with different syntactical structures. The `ReflectionHost` abstracts over those differences and\n * presents a single API by which the compiler can query specific information about the AST.\n *\n * All operations on the `ReflectionHost` require the use of TypeScript `ts.Node`s with binding\n * information already available (that is, nodes that come from a `ts.Program` that has been\n * type-checked, and are not synthetically created).\n */\nexport interface ReflectionHost {\n  /**\n   * Examine a declaration (for example, of a class or function) and return metadata about any\n   * decorators present on the declaration.\n   *\n   * @param declaration a TypeScript `ts.Declaration` node representing the class or function over\n   * which to reflect. For example, if the intent is to reflect the decorators of a class and the\n   * source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the source is in ES5\n   * format, this might be a `ts.VariableDeclaration` as classes in ES5 are represented as the\n   * result of an IIFE execution.\n   *\n   * @returns an array of `Decorator` metadata if decorators are present on the declaration, or\n   * `null` if either no decorators were present or if the declaration is not of a decoratable type.\n   */\n  getDecoratorsOfDeclaration(declaration: DeclarationNode): Decorator[]|null;\n\n  /**\n   * Examine a declaration which should be of a class, and return metadata about the members of the\n   * class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns an array of `ClassMember` metadata representing the members of the class.\n   *\n   * @throws if `declaration` does not resolve to a class declaration.\n   */\n  getMembersOfClass(clazz: ClassDeclaration): ClassMember[];\n\n  /**\n   * Reflect over the constructor of a class and return metadata about its parameters.\n   *\n   * This method only looks at the constructor of a class directly and not at any inherited\n   * constructors.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns an array of `Parameter` metadata representing the parameters of the constructor, if\n   * a constructor exists. If the constructor exists and has 0 parameters, this array will be empty.\n   * If the class has no constructor, this method returns `null`.\n   */\n  getConstructorParameters(clazz: ClassDeclaration): CtorParameter[]|null;\n\n  /**\n   * Reflect over a function and return metadata about its parameters and body.\n   *\n   * Functions in TypeScript and ES5 code have different AST representations, in particular around\n   * default values for parameters. A TypeScript function has its default value as the initializer\n   * on the parameter declaration, whereas an ES5 function has its default value set in a statement\n   * of the form:\n   *\n   * if (param === void 0) { param = 3; }\n   *\n   * This method abstracts over these details, and interprets the function declaration and body to\n   * extract parameter default values and the \"real\" body.\n   *\n   * A current limitation is that this metadata has no representation for shorthand assignment of\n   * parameter objects in the function signature.\n   *\n   * @param fn a TypeScript `ts.Declaration` node representing the function over which to reflect.\n   *\n   * @returns a `FunctionDefinition` giving metadata about the function definition.\n   */\n  getDefinitionOfFunction(fn: ts.Node): FunctionDefinition|null;\n\n  /**\n   * Determine if an identifier was imported from another module and return `Import` metadata\n   * describing its origin.\n   *\n   * @param id a TypeScript `ts.Identifier` to reflect.\n   *\n   * @returns metadata about the `Import` if the identifier was imported from another module, or\n   * `null` if the identifier doesn't resolve to an import but instead is locally defined.\n   */\n  getImportOfIdentifier(id: ts.Identifier): Import|null;\n\n  /**\n   * Trace an identifier to its declaration, if possible.\n   *\n   * This method attempts to resolve the declaration of the given identifier, tracing back through\n   * imports and re-exports until the original declaration statement is found. A `Declaration`\n   * object is returned if the original declaration is found, or `null` is returned otherwise.\n   *\n   * If the declaration is in a different module, and that module is imported via an absolute path,\n   * this method also returns the absolute path of the imported module. For example, if the code is:\n   *\n   * ```\n   * import {RouterModule} from '@angular/core';\n   *\n   * export const ROUTES = RouterModule.forRoot([...]);\n   * ```\n   *\n   * and if `getDeclarationOfIdentifier` is called on `RouterModule` in the `ROUTES` expression,\n   * then it would trace `RouterModule` via its import from `@angular/core`, and note that the\n   * definition was imported from `@angular/core` into the application where it was referenced.\n   *\n   * If the definition is re-exported several times from different absolute module names, only\n   * the first one (the one by which the application refers to the module) is returned.\n   *\n   * This module name is returned in the `viaModule` field of the `Declaration`. If The declaration\n   * is relative to the application itself and there was no import through an absolute path, then\n   * `viaModule` is `null`.\n   *\n   * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n   *\n   * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n   * otherwise.\n   */\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null;\n\n  /**\n   * Collect the declarations exported from a module by name.\n   *\n   * Iterates over the exports of a module (including re-exports) and returns a map of export\n   * name to its `Declaration`. If an exported value is itself re-exported from another module,\n   * the `Declaration`'s `viaModule` will reflect that.\n   *\n   * @param node a TypeScript `ts.Node` representing the module (for example a `ts.SourceFile`) for\n   * which to collect exports.\n   *\n   * @returns a map of `Declaration`s for the module's exports, by name.\n   */\n  getExportsOfModule(module: ts.Node): Map<string, Declaration>|null;\n\n  /**\n   * Check whether the given node actually represents a class.\n   */\n  isClass(node: ts.Node): node is ClassDeclaration;\n\n  /**\n   * Determines whether the given declaration, which should be a class, has a base class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   */\n  hasBaseClass(clazz: ClassDeclaration): boolean;\n\n  /**\n   * Get an expression representing the base class (if any) of the given `clazz`.\n   *\n   * This expression is most commonly an Identifier, but is possible to inherit from a more dynamic\n   * expression.\n   *\n   * @param clazz the class whose base we want to get.\n   */\n  getBaseClassExpression(clazz: ClassDeclaration): ts.Expression|null;\n\n  /**\n   * Get the number of generic type parameters of a given class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns the number of type parameters of the class, if known, or `null` if the declaration\n   * is not a class or has an unknown number of type parameters.\n   */\n  getGenericArityOfClass(clazz: ClassDeclaration): number|null;\n\n  /**\n   * Find the assigned value of a variable declaration.\n   *\n   * Normally this will be the initializer of the declaration, but where the variable is\n   * not a `const` we may need to look elsewhere for the variable's value.\n   *\n   * @param declaration a TypeScript variable declaration, whose value we want.\n   * @returns the value of the variable, as a TypeScript expression node, or `undefined`\n   * if the value cannot be computed.\n   */\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null;\n\n  /**\n   * Returns `true` if a declaration is exported from the module in which it's defined.\n   *\n   * Not all mechanisms by which a declaration is exported can be statically detected, especially\n   * when processing already compiled JavaScript. A `false` result does not indicate that the\n   * declaration is never visible outside its module, only that it was not exported via one of the\n   * export mechanisms that the `ReflectionHost` is capable of statically checking.\n   */\n  isStaticallyExported(decl: ts.Node): boolean;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {TypeValueReference, TypeValueReferenceKind, UnavailableTypeValueReference, ValueUnavailableKind} from './host';\n\n/**\n * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the\n * type given in the `ts.TypeNode` in a value position.\n *\n * This can return `null` if the `typeNode` is `null`, if it does not refer to a symbol with a value\n * declaration, or if it is not possible to statically understand.\n */\nexport function typeToValue(\n    typeNode: ts.TypeNode|null, checker: ts.TypeChecker): TypeValueReference {\n  // It's not possible to get a value expression if the parameter doesn't even have a type.\n  if (typeNode === null) {\n    return missingType();\n  }\n\n  if (!ts.isTypeReferenceNode(typeNode)) {\n    return unsupportedType(typeNode);\n  }\n\n  const symbols = resolveTypeSymbols(typeNode, checker);\n  if (symbols === null) {\n    return unknownReference(typeNode);\n  }\n\n  const {local, decl} = symbols;\n  // It's only valid to convert a type reference to a value reference if the type actually\n  // has a value declaration associated with it. Note that const enums are an exception,\n  // because while they do have a value declaration, they don't exist at runtime.\n  if (decl.valueDeclaration === undefined || decl.flags & ts.SymbolFlags.ConstEnum) {\n    let typeOnlyDecl: ts.Declaration|null = null;\n    if (decl.declarations !== undefined && decl.declarations.length > 0) {\n      typeOnlyDecl = decl.declarations[0];\n    }\n    return noValueDeclaration(typeNode, typeOnlyDecl);\n  }\n\n  // The type points to a valid value declaration. Rewrite the TypeReference into an\n  // Expression which references the value pointed to by the TypeReference, if possible.\n\n  // Look at the local `ts.Symbol`'s declarations and see if it comes from an import\n  // statement. If so, extract the module specifier and the name of the imported type.\n  const firstDecl = local.declarations && local.declarations[0];\n  if (firstDecl !== undefined) {\n    if (ts.isImportClause(firstDecl) && firstDecl.name !== undefined) {\n      // This is a default import.\n      //   import Foo from 'foo';\n\n      if (firstDecl.isTypeOnly) {\n        // Type-only imports cannot be represented as value.\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n\n      return {\n        kind: TypeValueReferenceKind.LOCAL,\n        expression: firstDecl.name,\n        defaultImportStatement: firstDecl.parent,\n      };\n    } else if (ts.isImportSpecifier(firstDecl)) {\n      // The symbol was imported by name\n      //   import {Foo} from 'foo';\n      // or\n      //   import {Foo as Bar} from 'foo';\n\n      if (firstDecl.isTypeOnly) {\n        // The import specifier can't be type-only (e.g. `import {type Foo} from '...')`.\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n\n      if (firstDecl.parent.parent.isTypeOnly) {\n        // The import specifier can't be inside a type-only import clause\n        // (e.g. `import type {Foo} from '...')`.\n        return typeOnlyImport(typeNode, firstDecl.parent.parent);\n      }\n\n      // Determine the name to import (`Foo`) from the import specifier, as the symbol names of\n      // the imported type could refer to a local alias (like `Bar` in the example above).\n      const importedName = (firstDecl.propertyName || firstDecl.name).text;\n\n      // The first symbol name refers to the local name, which is replaced by `importedName` above.\n      // Any remaining symbol names make up the complete path to the value.\n      const [_localName, ...nestedPath] = symbols.symbolNames;\n\n      const moduleName = extractModuleName(firstDecl.parent.parent.parent);\n      return {\n        kind: TypeValueReferenceKind.IMPORTED,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    } else if (ts.isNamespaceImport(firstDecl)) {\n      // The import is a namespace import\n      //   import * as Foo from 'foo';\n\n      if (firstDecl.parent.isTypeOnly) {\n        // Type-only imports cannot be represented as value.\n        return typeOnlyImport(typeNode, firstDecl.parent);\n      }\n\n      if (symbols.symbolNames.length === 1) {\n        // The type refers to the namespace itself, which cannot be represented as a value.\n        return namespaceImport(typeNode, firstDecl.parent);\n      }\n\n      // The first symbol name refers to the local name of the namespace, which is is discarded\n      // as a new namespace import will be generated. This is followed by the symbol name that needs\n      // to be imported and any remaining names that constitute the complete path to the value.\n      const [_ns, importedName, ...nestedPath] = symbols.symbolNames;\n\n      const moduleName = extractModuleName(firstDecl.parent.parent);\n      return {\n        kind: TypeValueReferenceKind.IMPORTED,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    }\n  }\n\n  // If the type is not imported, the type reference can be converted into an expression as is.\n  const expression = typeNodeToValueExpr(typeNode);\n  if (expression !== null) {\n    return {\n      kind: TypeValueReferenceKind.LOCAL,\n      expression,\n      defaultImportStatement: null,\n    };\n  } else {\n    return unsupportedType(typeNode);\n  }\n}\n\nfunction unsupportedType(typeNode: ts.TypeNode): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.UNSUPPORTED, typeNode},\n  };\n}\n\nfunction noValueDeclaration(\n    typeNode: ts.TypeNode, decl: ts.Declaration|null): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.NO_VALUE_DECLARATION, typeNode, decl},\n  };\n}\n\nfunction typeOnlyImport(typeNode: ts.TypeNode, node: ts.ImportClause|ts.ImportSpecifier):\n    UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.TYPE_ONLY_IMPORT, typeNode, node},\n  };\n}\n\nfunction unknownReference(typeNode: ts.TypeNode): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.UNKNOWN_REFERENCE, typeNode},\n  };\n}\n\nfunction namespaceImport(\n    typeNode: ts.TypeNode, importClause: ts.ImportClause): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.NAMESPACE, typeNode, importClause},\n  };\n}\n\nfunction missingType(): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.MISSING_TYPE},\n  };\n}\n\n/**\n * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have\n * different AST shapes but can reference the same symbols.\n *\n * This will return `null` if an equivalent expression cannot be constructed.\n */\nexport function typeNodeToValueExpr(node: ts.TypeNode): ts.Expression|null {\n  if (ts.isTypeReferenceNode(node)) {\n    return entityNameToValue(node.typeName);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Resolve a `TypeReference` node to the `ts.Symbol`s for both its declaration and its local source.\n *\n * In the event that the `TypeReference` refers to a locally declared symbol, these will be the\n * same. If the `TypeReference` refers to an imported symbol, then `decl` will be the fully resolved\n * `ts.Symbol` of the referenced symbol. `local` will be the `ts.Symbol` of the `ts.Identifier`\n * which points to the import statement by which the symbol was imported.\n *\n * All symbol names that make up the type reference are returned left-to-right into the\n * `symbolNames` array, which is guaranteed to include at least one entry.\n */\nfunction resolveTypeSymbols(typeRef: ts.TypeReferenceNode, checker: ts.TypeChecker):\n    {local: ts.Symbol, decl: ts.Symbol, symbolNames: string[]}|null {\n  const typeName = typeRef.typeName;\n  // typeRefSymbol is the ts.Symbol of the entire type reference.\n  const typeRefSymbol: ts.Symbol|undefined = checker.getSymbolAtLocation(typeName);\n  if (typeRefSymbol === undefined) {\n    return null;\n  }\n\n  // `local` is the `ts.Symbol` for the local `ts.Identifier` for the type.\n  // If the type is actually locally declared or is imported by name, for example:\n  //   import {Foo} from './foo';\n  // then it'll be the same as `typeRefSymbol`.\n  //\n  // If the type is imported via a namespace import, for example:\n  //   import * as foo from './foo';\n  // and then referenced as:\n  //   constructor(f: foo.Foo)\n  // then `local` will be the `ts.Symbol` of `foo`, whereas `typeRefSymbol` will be the `ts.Symbol`\n  // of `foo.Foo`. This allows tracking of the import behind whatever type reference exists.\n  let local = typeRefSymbol;\n\n  // Destructure a name like `foo.X.Y.Z` as follows:\n  // - in `leftMost`, the `ts.Identifier` of the left-most name (`foo`) in the qualified name.\n  //   This identifier is used to resolve the `ts.Symbol` for `local`.\n  // - in `symbolNames`, all names involved in the qualified path, or a single symbol name if the\n  //   type is not qualified.\n  let leftMost = typeName;\n  const symbolNames: string[] = [];\n  while (ts.isQualifiedName(leftMost)) {\n    symbolNames.unshift(leftMost.right.text);\n    leftMost = leftMost.left;\n  }\n  symbolNames.unshift(leftMost.text);\n\n  if (leftMost !== typeName) {\n    const localTmp = checker.getSymbolAtLocation(leftMost);\n    if (localTmp !== undefined) {\n      local = localTmp;\n    }\n  }\n\n  // De-alias the top-level type reference symbol to get the symbol of the actual declaration.\n  let decl = typeRefSymbol;\n  if (typeRefSymbol.flags & ts.SymbolFlags.Alias) {\n    decl = checker.getAliasedSymbol(typeRefSymbol);\n  }\n  return {local, decl, symbolNames};\n}\n\nfunction entityNameToValue(node: ts.EntityName): ts.Expression|null {\n  if (ts.isQualifiedName(node)) {\n    const left = entityNameToValue(node.left);\n    return left !== null ? ts.factory.createPropertyAccessExpression(left, node.right) : null;\n  } else if (ts.isIdentifier(node)) {\n    const clone = ts.setOriginalNode(ts.factory.createIdentifier(node.text), node);\n    (clone as any).parent = node.parent;\n    return clone;\n  } else {\n    return null;\n  }\n}\n\nfunction extractModuleName(node: ts.ImportDeclaration): string {\n  if (!ts.isStringLiteral(node.moduleSpecifier)) {\n    throw new Error('not a module specifier');\n  }\n  return node.moduleSpecifier.text;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ClassDeclaration, ClassMember, ClassMemberKind, CtorParameter, Declaration, DeclarationNode, Decorator, FunctionDefinition, Import, isDecoratorIdentifier, ReflectionHost} from './host';\nimport {typeToValue} from './type_to_value';\nimport {isNamedClassDeclaration} from './util';\n\n/**\n * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.\n */\n\nexport class TypeScriptReflectionHost implements ReflectionHost {\n  constructor(protected checker: ts.TypeChecker) {}\n\n  getDecoratorsOfDeclaration(declaration: DeclarationNode): Decorator[]|null {\n    const decorators =\n        ts.canHaveDecorators(declaration) ? ts.getDecorators(declaration) : undefined;\n\n    return decorators !== undefined && decorators.length ?\n        decorators.map(decorator => this._reflectDecorator(decorator))\n            .filter((dec): dec is Decorator => dec !== null) :\n        null;\n  }\n\n  getMembersOfClass(clazz: ClassDeclaration): ClassMember[] {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n    return tsClazz.members.map(member => this._reflectMember(member))\n        .filter((member): member is ClassMember => member !== null);\n  }\n\n  getConstructorParameters(clazz: ClassDeclaration): CtorParameter[]|null {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n\n    const isDeclaration = tsClazz.getSourceFile().isDeclarationFile;\n    // For non-declaration files, we want to find the constructor with a `body`. The constructors\n    // without a `body` are overloads whereas we want the implementation since it's the one that'll\n    // be executed and which can have decorators. For declaration files, we take the first one that\n    // we get.\n    const ctor = tsClazz.members.find(\n        (member): member is ts.ConstructorDeclaration =>\n            ts.isConstructorDeclaration(member) && (isDeclaration || member.body !== undefined));\n    if (ctor === undefined) {\n      return null;\n    }\n\n    return ctor.parameters.map(node => {\n      // The name of the parameter is easy.\n      const name = parameterName(node.name);\n\n      const decorators = this.getDecoratorsOfDeclaration(node);\n\n      // It may or may not be possible to write an expression that refers to the value side of the\n      // type named for the parameter.\n\n      let originalTypeNode = node.type || null;\n      let typeNode = originalTypeNode;\n\n      // Check if we are dealing with a simple nullable union type e.g. `foo: Foo|null`\n      // and extract the type. More complex union types e.g. `foo: Foo|Bar` are not supported.\n      // We also don't need to support `foo: Foo|undefined` because Angular's DI injects `null` for\n      // optional tokes that don't have providers.\n      if (typeNode && ts.isUnionTypeNode(typeNode)) {\n        let childTypeNodes = typeNode.types.filter(\n            childTypeNode =>\n                !(ts.isLiteralTypeNode(childTypeNode) &&\n                  childTypeNode.literal.kind === ts.SyntaxKind.NullKeyword));\n\n        if (childTypeNodes.length === 1) {\n          typeNode = childTypeNodes[0];\n        }\n      }\n\n      const typeValueReference = typeToValue(typeNode, this.checker);\n\n      return {\n        name,\n        nameNode: node.name,\n        typeValueReference,\n        typeNode: originalTypeNode,\n        decorators,\n      };\n    });\n  }\n\n  getImportOfIdentifier(id: ts.Identifier): Import|null {\n    const directImport = this.getDirectImportOfIdentifier(id);\n    if (directImport !== null) {\n      return directImport;\n    } else if (ts.isQualifiedName(id.parent) && id.parent.right === id) {\n      return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));\n    } else if (ts.isPropertyAccessExpression(id.parent) && id.parent.name === id) {\n      return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));\n    } else {\n      return null;\n    }\n  }\n\n  getExportsOfModule(node: ts.Node): Map<string, Declaration>|null {\n    // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.\n    if (!ts.isSourceFile(node)) {\n      throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);\n    }\n\n    // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported\n    // Symbols.\n    const symbol = this.checker.getSymbolAtLocation(node);\n    if (symbol === undefined) {\n      return null;\n    }\n\n    const map = new Map<string, Declaration>();\n    this.checker.getExportsOfModule(symbol).forEach(exportSymbol => {\n      // Map each exported Symbol to a Declaration and add it to the map.\n      const decl = this.getDeclarationOfSymbol(exportSymbol, null);\n      if (decl !== null) {\n        map.set(exportSymbol.name, decl);\n      }\n    });\n    return map;\n  }\n\n  isClass(node: ts.Node): node is ClassDeclaration {\n    // For our purposes, classes are \"named\" ts.ClassDeclarations;\n    // (`node.name` can be undefined in unnamed default exports: `default export class { ... }`).\n    return isNamedClassDeclaration(node);\n  }\n\n  hasBaseClass(clazz: ClassDeclaration): boolean {\n    return this.getBaseClassExpression(clazz) !== null;\n  }\n\n  getBaseClassExpression(clazz: ClassDeclaration): ts.Expression|null {\n    if (!(ts.isClassDeclaration(clazz) || ts.isClassExpression(clazz)) ||\n        clazz.heritageClauses === undefined) {\n      return null;\n    }\n    const extendsClause =\n        clazz.heritageClauses.find(clause => clause.token === ts.SyntaxKind.ExtendsKeyword);\n    if (extendsClause === undefined) {\n      return null;\n    }\n    const extendsType = extendsClause.types[0];\n    if (extendsType === undefined) {\n      return null;\n    }\n    return extendsType.expression;\n  }\n\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n    // Resolve the identifier to a Symbol, and return the declaration of that.\n    let symbol: ts.Symbol|undefined = this.checker.getSymbolAtLocation(id);\n    if (symbol === undefined) {\n      return null;\n    }\n    return this.getDeclarationOfSymbol(symbol, id);\n  }\n\n  getDefinitionOfFunction(node: ts.Node): FunctionDefinition|null {\n    if (!ts.isFunctionDeclaration(node) && !ts.isMethodDeclaration(node) &&\n        !ts.isFunctionExpression(node)) {\n      return null;\n    }\n    return {\n      node,\n      body: node.body !== undefined ? Array.from(node.body.statements) : null,\n      parameters: node.parameters.map(param => {\n        const name = parameterName(param.name);\n        const initializer = param.initializer || null;\n        return {name, node: param, initializer};\n      }),\n    };\n  }\n\n  getGenericArityOfClass(clazz: ClassDeclaration): number|null {\n    if (!ts.isClassDeclaration(clazz)) {\n      return null;\n    }\n    return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;\n  }\n\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null {\n    return declaration.initializer || null;\n  }\n\n  isStaticallyExported(decl: ts.Node): boolean {\n    // First check if there's an `export` modifier directly on the declaration.\n    let topLevel = decl;\n    if (ts.isVariableDeclaration(decl) && ts.isVariableDeclarationList(decl.parent)) {\n      topLevel = decl.parent.parent;\n    }\n    const modifiers = ts.canHaveModifiers(topLevel) ? ts.getModifiers(topLevel) : undefined;\n    if (modifiers !== undefined &&\n        modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword)) {\n      // The node is part of a declaration that's directly exported.\n      return true;\n    }\n\n    // If `topLevel` is not directly exported via a modifier, then it might be indirectly exported,\n    // e.g.:\n    //\n    // class Foo {}\n    // export {Foo};\n    //\n    // The only way to check this is to look at the module level for exports of the class. As a\n    // performance optimization, this check is only performed if the class is actually declared at\n    // the top level of the file and thus eligible for exporting in the first place.\n    if (topLevel.parent === undefined || !ts.isSourceFile(topLevel.parent)) {\n      return false;\n    }\n\n    const localExports = this.getLocalExportedDeclarationsOfSourceFile(decl.getSourceFile());\n    return localExports.has(decl as ts.Declaration);\n  }\n\n  protected getDirectImportOfIdentifier(id: ts.Identifier): Import|null {\n    const symbol = this.checker.getSymbolAtLocation(id);\n\n    if (symbol === undefined || symbol.declarations === undefined ||\n        symbol.declarations.length !== 1) {\n      return null;\n    }\n\n    const decl = symbol.declarations[0];\n    const importDecl = getContainingImportDeclaration(decl);\n\n    // Ignore declarations that are defined locally (not imported).\n    if (importDecl === null) {\n      return null;\n    }\n\n    // The module specifier is guaranteed to be a string literal, so this should always pass.\n    if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n      // Not allowed to happen in TypeScript ASTs.\n      return null;\n    }\n\n    return {from: importDecl.moduleSpecifier.text, name: getExportedName(decl, id)};\n  }\n\n  /**\n   * Try to get the import info for this identifier as though it is a namespaced import.\n   *\n   * For example, if the identifier is the `Directive` part of a qualified type chain like:\n   *\n   * ```\n   * core.Directive\n   * ```\n   *\n   * then it might be that `core` is a namespace import such as:\n   *\n   * ```\n   * import * as core from 'tslib';\n   * ```\n   *\n   * @param id the TypeScript identifier to find the import info for.\n   * @returns The import info if this is a namespaced import or `null`.\n   */\n  protected getImportOfNamespacedIdentifier(\n      id: ts.Identifier, namespaceIdentifier: ts.Identifier|null): Import|null {\n    if (namespaceIdentifier === null) {\n      return null;\n    }\n    const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);\n    if (!namespaceSymbol || namespaceSymbol.declarations === undefined) {\n      return null;\n    }\n    const declaration =\n        namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;\n    if (!declaration) {\n      return null;\n    }\n    const namespaceDeclaration = ts.isNamespaceImport(declaration) ? declaration : null;\n    if (!namespaceDeclaration) {\n      return null;\n    }\n\n    const importDeclaration = namespaceDeclaration.parent.parent;\n    if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) {\n      // Should not happen as this would be invalid TypesScript\n      return null;\n    }\n\n    return {\n      from: importDeclaration.moduleSpecifier.text,\n      name: id.text,\n    };\n  }\n\n  /**\n   * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.\n   */\n  protected getDeclarationOfSymbol(symbol: ts.Symbol, originalId: ts.Identifier|null): Declaration\n      |null {\n    // If the symbol points to a ShorthandPropertyAssignment, resolve it.\n    let valueDeclaration: ts.Declaration|undefined = undefined;\n    if (symbol.valueDeclaration !== undefined) {\n      valueDeclaration = symbol.valueDeclaration;\n    } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n      valueDeclaration = symbol.declarations[0];\n    }\n    if (valueDeclaration !== undefined && ts.isShorthandPropertyAssignment(valueDeclaration)) {\n      const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);\n      if (shorthandSymbol === undefined) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(shorthandSymbol, originalId);\n    } else if (valueDeclaration !== undefined && ts.isExportSpecifier(valueDeclaration)) {\n      const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);\n      if (targetSymbol === undefined) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(targetSymbol, originalId);\n    }\n\n    const importInfo = originalId && this.getImportOfIdentifier(originalId);\n    const viaModule =\n        importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith('.') ?\n        importInfo.from :\n        null;\n\n    // Now, resolve the Symbol to its declaration by following any and all aliases.\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = this.checker.getAliasedSymbol(symbol);\n    }\n\n    // Look at the resolved Symbol's declarations and pick one of them to return. Value declarations\n    // are given precedence over type declarations.\n    if (symbol.valueDeclaration !== undefined) {\n      return {\n        node: symbol.valueDeclaration,\n        viaModule,\n      };\n    } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n      return {\n        node: symbol.declarations[0],\n        viaModule,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  private _reflectDecorator(node: ts.Decorator): Decorator|null {\n    // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The\n    // expression may contain a call to a function which returns the decorator function, in which\n    // case we want to return the arguments.\n    let decoratorExpr: ts.Expression = node.expression;\n    let args: ts.Expression[]|null = null;\n\n    // Check for call expressions.\n    if (ts.isCallExpression(decoratorExpr)) {\n      args = Array.from(decoratorExpr.arguments);\n      decoratorExpr = decoratorExpr.expression;\n    }\n\n    // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is\n    // wrong and the decorator can't be resolved statically.\n    if (!isDecoratorIdentifier(decoratorExpr)) {\n      return null;\n    }\n\n    const decoratorIdentifier = ts.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;\n    const importDecl = this.getImportOfIdentifier(decoratorIdentifier);\n\n    return {\n      name: decoratorIdentifier.text,\n      identifier: decoratorExpr,\n      import: importDecl,\n      node,\n      args,\n    };\n  }\n\n  private _reflectMember(node: ts.ClassElement): ClassMember|null {\n    let kind: ClassMemberKind|null = null;\n    let value: ts.Expression|null = null;\n    let name: string|null = null;\n    let nameNode: ts.Identifier|ts.StringLiteral|null = null;\n\n    if (ts.isPropertyDeclaration(node)) {\n      kind = ClassMemberKind.Property;\n      value = node.initializer || null;\n    } else if (ts.isGetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Getter;\n    } else if (ts.isSetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Setter;\n    } else if (ts.isMethodDeclaration(node)) {\n      kind = ClassMemberKind.Method;\n    } else if (ts.isConstructorDeclaration(node)) {\n      kind = ClassMemberKind.Constructor;\n    } else {\n      return null;\n    }\n\n    if (ts.isConstructorDeclaration(node)) {\n      name = 'constructor';\n    } else if (ts.isIdentifier(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else if (ts.isStringLiteral(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else {\n      return null;\n    }\n\n    const decorators = this.getDecoratorsOfDeclaration(node);\n    const modifiers = ts.getModifiers(node);\n    const isStatic =\n        modifiers !== undefined && modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n\n    return {\n      node,\n      implementation: node,\n      kind,\n      type: node.type || null,\n      name,\n      nameNode,\n      decorators,\n      value,\n      isStatic,\n    };\n  }\n\n  /**\n   * Get the set of declarations declared in `file` which are exported.\n   */\n  private getLocalExportedDeclarationsOfSourceFile(file: ts.SourceFile): Set<ts.Declaration> {\n    const cacheSf: SourceFileWithCachedExports = file as SourceFileWithCachedExports;\n    if (cacheSf[LocalExportedDeclarations] !== undefined) {\n      // TS does not currently narrow symbol-keyed fields, hence the non-null assert is needed.\n      return cacheSf[LocalExportedDeclarations]!;\n    }\n\n    const exportSet = new Set<ts.Declaration>();\n    cacheSf[LocalExportedDeclarations] = exportSet;\n\n    const sfSymbol = this.checker.getSymbolAtLocation(cacheSf);\n\n    if (sfSymbol === undefined || sfSymbol.exports === undefined) {\n      return exportSet;\n    }\n\n    // Scan the exported symbol of the `ts.SourceFile` for the original `symbol` of the class\n    // declaration.\n    //\n    // Note: when checking multiple classes declared in the same file, this repeats some operations.\n    // In theory, this could be expensive if run in the context of a massive input file. If\n    // performance does become an issue here, it should be possible to create a `Set<>`\n\n    // Unfortunately, `ts.Iterator` doesn't implement the iterator protocol, so iteration here is\n    // done manually.\n    const iter = sfSymbol.exports.values();\n    let item = iter.next();\n    while (item.done !== true) {\n      let exportedSymbol = item.value;\n\n      // If this exported symbol comes from an `export {Foo}` statement, then the symbol is actually\n      // for the export declaration, not the original declaration. Such a symbol will be an alias,\n      // so unwrap aliasing if necessary.\n      if (exportedSymbol.flags & ts.SymbolFlags.Alias) {\n        exportedSymbol = this.checker.getAliasedSymbol(exportedSymbol);\n      }\n\n      if (exportedSymbol.valueDeclaration !== undefined &&\n          exportedSymbol.valueDeclaration.getSourceFile() === file) {\n        exportSet.add(exportedSymbol.valueDeclaration);\n      }\n      item = iter.next();\n    }\n\n    return exportSet;\n  }\n}\n\nexport function reflectNameOfDeclaration(decl: ts.Declaration): string|null {\n  const id = reflectIdentifierOfDeclaration(decl);\n  return id && id.text || null;\n}\n\nexport function reflectIdentifierOfDeclaration(decl: ts.Declaration): ts.Identifier|null {\n  if (ts.isClassDeclaration(decl) || ts.isFunctionDeclaration(decl)) {\n    return decl.name || null;\n  } else if (ts.isVariableDeclaration(decl)) {\n    if (ts.isIdentifier(decl.name)) {\n      return decl.name;\n    }\n  }\n  return null;\n}\n\nexport function reflectTypeEntityToDeclaration(\n    type: ts.EntityName, checker: ts.TypeChecker): {node: ts.Declaration, from: string|null} {\n  let realSymbol = checker.getSymbolAtLocation(type);\n  if (realSymbol === undefined) {\n    throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);\n  }\n  while (realSymbol.flags & ts.SymbolFlags.Alias) {\n    realSymbol = checker.getAliasedSymbol(realSymbol);\n  }\n\n  let node: ts.Declaration|null = null;\n  if (realSymbol.valueDeclaration !== undefined) {\n    node = realSymbol.valueDeclaration;\n  } else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {\n    node = realSymbol.declarations[0];\n  } else {\n    throw new Error(`Cannot resolve type entity symbol to declaration`);\n  }\n\n  if (ts.isQualifiedName(type)) {\n    if (!ts.isIdentifier(type.left)) {\n      throw new Error(`Cannot handle qualified name with non-identifier lhs`);\n    }\n    const symbol = checker.getSymbolAtLocation(type.left);\n    if (symbol === undefined || symbol.declarations === undefined ||\n        symbol.declarations.length !== 1) {\n      throw new Error(`Cannot resolve qualified type entity lhs to symbol`);\n    }\n    const decl = symbol.declarations[0];\n    if (ts.isNamespaceImport(decl)) {\n      const clause = decl.parent!;\n      const importDecl = clause.parent!;\n      if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n        throw new Error(`Module specifier is not a string`);\n      }\n      return {node, from: importDecl.moduleSpecifier.text};\n    } else if (ts.isModuleDeclaration(decl)) {\n      return {node, from: null};\n    } else {\n      throw new Error(`Unknown import type?`);\n    }\n  } else {\n    return {node, from: null};\n  }\n}\n\nexport function filterToMembersWithDecorator(members: ClassMember[], name: string, module?: string):\n    {member: ClassMember, decorators: Decorator[]}[] {\n  return members.filter(member => !member.isStatic)\n      .map(member => {\n        if (member.decorators === null) {\n          return null;\n        }\n\n        const decorators = member.decorators.filter(dec => {\n          if (dec.import !== null) {\n            return dec.import.name === name && (module === undefined || dec.import.from === module);\n          } else {\n            return dec.name === name && module === undefined;\n          }\n        });\n\n        if (decorators.length === 0) {\n          return null;\n        }\n\n        return {member, decorators};\n      })\n      .filter((value): value is {member: ClassMember, decorators: Decorator[]} => value !== null);\n}\n\nexport function findMember(\n    members: ClassMember[], name: string, isStatic: boolean = false): ClassMember|null {\n  return members.find(member => member.isStatic === isStatic && member.name === name) || null;\n}\n\nexport function reflectObjectLiteral(node: ts.ObjectLiteralExpression): Map<string, ts.Expression> {\n  const map = new Map<string, ts.Expression>();\n  node.properties.forEach(prop => {\n    if (ts.isPropertyAssignment(prop)) {\n      const name = propertyNameToString(prop.name);\n      if (name === null) {\n        return;\n      }\n      map.set(name, prop.initializer);\n    } else if (ts.isShorthandPropertyAssignment(prop)) {\n      map.set(prop.name.text, prop.name);\n    } else {\n      return;\n    }\n  });\n  return map;\n}\n\nfunction castDeclarationToClassOrDie(declaration: ClassDeclaration):\n    ClassDeclaration<ts.ClassDeclaration> {\n  if (!ts.isClassDeclaration(declaration)) {\n    throw new Error(\n        `Reflecting on a ${ts.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);\n  }\n  return declaration;\n}\n\nfunction parameterName(name: ts.BindingName): string|null {\n  if (ts.isIdentifier(name)) {\n    return name.text;\n  } else {\n    return null;\n  }\n}\n\nfunction propertyNameToString(node: ts.PropertyName): string|null {\n  if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Compute the left most identifier in a qualified type chain. E.g. the `a` of `a.b.c.SomeType`.\n * @param qualifiedName The starting property access expression from which we want to compute\n * the left most identifier.\n * @returns the left most identifier in the chain or `null` if it is not an identifier.\n */\nfunction getQualifiedNameRoot(qualifiedName: ts.QualifiedName): ts.Identifier|null {\n  while (ts.isQualifiedName(qualifiedName.left)) {\n    qualifiedName = qualifiedName.left;\n  }\n  return ts.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;\n}\n\n/**\n * Compute the left most identifier in a property access chain. E.g. the `a` of `a.b.c.d`.\n * @param propertyAccess The starting property access expression from which we want to compute\n * the left most identifier.\n * @returns the left most identifier in the chain or `null` if it is not an identifier.\n */\nfunction getFarLeftIdentifier(propertyAccess: ts.PropertyAccessExpression): ts.Identifier|null {\n  while (ts.isPropertyAccessExpression(propertyAccess.expression)) {\n    propertyAccess = propertyAccess.expression;\n  }\n  return ts.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;\n}\n\n/**\n * Return the ImportDeclaration for the given `node` if it is either an `ImportSpecifier` or a\n * `NamespaceImport`. If not return `null`.\n */\nfunction getContainingImportDeclaration(node: ts.Node): ts.ImportDeclaration|null {\n  return ts.isImportSpecifier(node) ? node.parent!.parent!.parent! :\n      ts.isNamespaceImport(node)    ? node.parent.parent :\n                                      null;\n}\n\n/**\n * Compute the name by which the `decl` was exported, not imported.\n * If no such declaration can be found (e.g. it is a namespace import)\n * then fallback to the `originalId`.\n */\nfunction getExportedName(decl: ts.Declaration, originalId: ts.Identifier): string {\n  return ts.isImportSpecifier(decl) ?\n      (decl.propertyName !== undefined ? decl.propertyName : decl.name).text :\n      originalId.text;\n}\n\nconst LocalExportedDeclarations = Symbol('LocalExportedDeclarations');\n\n/**\n * A `ts.SourceFile` expando which includes a cached `Set` of local `ts.Declaration`s that are\n * exported either directly (`export class ...`) or indirectly (via `export {...}`).\n *\n * This cache does not cause memory leaks as:\n *\n *  1. The only references cached here are local to the `ts.SourceFile`, and thus also available in\n *     `this.statements`.\n *\n *  2. The only way this `Set` could change is if the source file itself was changed, which would\n *     invalidate the entire `ts.SourceFile` object in favor of a new version. Thus, changing the\n *     source file also invalidates this cache.\n */\ninterface SourceFileWithCachedExports extends ts.SourceFile {\n  /**\n   * Cached `Set` of `ts.Declaration`s which are locally declared in this file and are exported\n   * either directly or indirectly.\n   */\n  [LocalExportedDeclarations]?: Set<ts.Declaration>;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {ClassDeclaration} from './host';\n\nexport function isNamedClassDeclaration(node: ts.Node):\n    node is ClassDeclaration<ts.ClassDeclaration> {\n  return ts.isClassDeclaration(node) && isIdentifier(node.name);\n}\n\nexport function isNamedFunctionDeclaration(node: ts.Node):\n    node is ClassDeclaration<ts.FunctionDeclaration> {\n  return ts.isFunctionDeclaration(node) && isIdentifier(node.name);\n}\n\nexport function isNamedVariableDeclaration(node: ts.Node):\n    node is ClassDeclaration<ts.VariableDeclaration> {\n  return ts.isVariableDeclaration(node) && isIdentifier(node.name);\n}\n\nfunction isIdentifier(node: ts.Node|undefined): node is ts.Identifier {\n  return node !== undefined && ts.isIdentifier(node);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InputOutputPropertySet} from '@angular/compiler';\n\n/**\n * The name of a class property that backs an input or output declared by a directive or component.\n *\n * This type exists for documentation only.\n */\nexport type ClassPropertyName = string;\n\n/**\n * The name by which an input or output of a directive or component is bound in an Angular template.\n *\n * This type exists for documentation only.\n */\nexport type BindingPropertyName = string;\n\n/**\n * An input or output of a directive that has both a named JavaScript class property on a component\n * or directive class, as well as an Angular template property name used for binding.\n */\nexport interface InputOrOutput {\n  /**\n   * The name of the JavaScript property on the component or directive instance for this input or\n   * output.\n   */\n  readonly classPropertyName: ClassPropertyName;\n\n  /**\n   * The property name used to bind this input or output in an Angular template.\n   */\n  readonly bindingPropertyName: BindingPropertyName;\n}\n\n/**\n * A mapping of component property and template binding property names, for example containing the\n * inputs of a particular directive or component.\n *\n * A single component property has exactly one input/output annotation (and therefore one binding\n * property name) associated with it, but the same binding property name may be shared across many\n * component property names.\n *\n * Allows bidirectional querying of the mapping - looking up all inputs/outputs with a given\n * property name, or mapping from a specific class property to its binding property name.\n */\nexport class ClassPropertyMapping<T extends InputOrOutput = InputOrOutput> implements\n    InputOutputPropertySet {\n  /**\n   * Mapping from class property names to the single `InputOrOutput` for that class property.\n   */\n  private forwardMap: Map<ClassPropertyName, T>;\n\n  /**\n   * Mapping from property names to one or more `InputOrOutput`s which share that name.\n   */\n  private reverseMap: Map<BindingPropertyName, T[]>;\n\n  private constructor(forwardMap: Map<ClassPropertyName, T>) {\n    this.forwardMap = forwardMap;\n    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n  }\n\n  /**\n   * Construct a `ClassPropertyMapping` with no entries.\n   */\n  static empty<T extends InputOrOutput>(): ClassPropertyMapping<T> {\n    return new ClassPropertyMapping(new Map());\n  }\n\n  /**\n   * Construct a `ClassPropertyMapping` from a primitive JS object which maps class property names\n   * to either binding property names or an array that contains both names, which is used in on-disk\n   * metadata formats (e.g. in .d.ts files).\n   */\n  static fromMappedObject<T extends InputOrOutput>(obj: {\n    [classPropertyName: string]: BindingPropertyName|[ClassPropertyName, BindingPropertyName]|T\n  }): ClassPropertyMapping<T> {\n    const forwardMap = new Map<ClassPropertyName, T>();\n\n    for (const classPropertyName of Object.keys(obj)) {\n      const value = obj[classPropertyName];\n      let inputOrOutput: T;\n\n      if (typeof value === 'string') {\n        inputOrOutput = {classPropertyName, bindingPropertyName: value} as T;\n      } else if (Array.isArray(value)) {\n        inputOrOutput = {classPropertyName, bindingPropertyName: value[0]} as T;\n      } else {\n        inputOrOutput = value;\n      }\n\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n\n    return new ClassPropertyMapping(forwardMap);\n  }\n\n  /**\n   * Merge two mappings into one, with class properties from `b` taking precedence over class\n   * properties from `a`.\n   */\n  static merge<T extends InputOrOutput>(a: ClassPropertyMapping<T>, b: ClassPropertyMapping<T>):\n      ClassPropertyMapping<T> {\n    const forwardMap = new Map<ClassPropertyName, T>(a.forwardMap.entries());\n    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n\n    return new ClassPropertyMapping(forwardMap);\n  }\n\n  /**\n   * All class property names mapped in this mapping.\n   */\n  get classPropertyNames(): ClassPropertyName[] {\n    return Array.from(this.forwardMap.keys());\n  }\n\n  /**\n   * All binding property names mapped in this mapping.\n   */\n  get propertyNames(): BindingPropertyName[] {\n    return Array.from(this.reverseMap.keys());\n  }\n\n  /**\n   * Check whether a mapping for the given property name exists.\n   */\n  hasBindingPropertyName(propertyName: BindingPropertyName): boolean {\n    return this.reverseMap.has(propertyName);\n  }\n\n  /**\n   * Lookup all `InputOrOutput`s that use this `propertyName`.\n   */\n  getByBindingPropertyName(propertyName: string): ReadonlyArray<T>|null {\n    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName)! : null;\n  }\n\n  /**\n   * Lookup the `InputOrOutput` associated with a `classPropertyName`.\n   */\n  getByClassPropertyName(classPropertyName: string): T|null {\n    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName)! : null;\n  }\n\n  /**\n   * Convert this mapping to a primitive JS object which maps each class property directly to the\n   * binding property name associated with it.\n   */\n  toDirectMappedObject(): {[classPropertyName: string]: BindingPropertyName} {\n    const obj: {[classPropertyName: string]: BindingPropertyName} = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n    }\n    return obj;\n  }\n\n  /**\n   * Convert this mapping to a primitive JS object which maps each class property either to itself\n   * (for cases where the binding property name is the same) or to an array which contains both\n   * names if they differ.\n   *\n   * This object format is used when mappings are serialized (for example into .d.ts files).\n   */\n  toJointMappedObject(): {[classPropertyName: string]: T} {\n    const obj: {[classPropertyName: string]: T} = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput;\n    }\n    return obj;\n  }\n\n  /**\n   * Implement the iterator protocol and return entry objects which contain the class and binding\n   * property names (and are useful for destructuring).\n   */\n  * [Symbol.iterator](): IterableIterator<T> {\n    for (const inputOrOutput of this.forwardMap.values()) {\n      yield inputOrOutput;\n    }\n  }\n}\n\nfunction reverseMapFromForwardMap<T extends InputOrOutput>(forwardMap: Map<ClassPropertyName, T>):\n    Map<BindingPropertyName, T[]> {\n  const reverseMap = new Map<BindingPropertyName, T[]>();\n  for (const [_, inputOrOutput] of forwardMap) {\n    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n    }\n\n    reverseMap.get(inputOrOutput.bindingPropertyName)!.push(inputOrOutput);\n  }\n  return reverseMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {OwningModule, Reference} from '../../imports';\nimport {ClassDeclaration, ClassMember, ClassMemberKind, isNamedClassDeclaration, ReflectionHost, reflectTypeEntityToDeclaration} from '../../reflection';\nimport {nodeDebugInfo} from '../../util/src/typescript';\n\nimport {DirectiveMeta, DirectiveTypeCheckMeta, InputMapping, MetadataReader, NgModuleMeta, PipeMeta, TemplateGuardMeta} from './api';\nimport {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n\nexport function extractReferencesFromType(\n    checker: ts.TypeChecker, def: ts.TypeNode,\n    bestGuessOwningModule: OwningModule|null): Reference<ClassDeclaration>[] {\n  if (!ts.isTupleTypeNode(def)) {\n    return [];\n  }\n\n  return def.elements.map(element => {\n    if (!ts.isTypeQueryNode(element)) {\n      throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);\n    }\n\n    return extraReferenceFromTypeQuery(checker, element, def, bestGuessOwningModule);\n  });\n}\n\nexport function extraReferenceFromTypeQuery(\n    checker: ts.TypeChecker, typeNode: ts.TypeQueryNode, origin: ts.TypeNode,\n    bestGuessOwningModule: OwningModule|null) {\n  const type = typeNode.exprName;\n  const {node, from} = reflectTypeEntityToDeclaration(type, checker);\n  if (!isNamedClassDeclaration(node)) {\n    throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);\n  }\n  if (from !== null && !from.startsWith('.')) {\n    // The symbol was imported using an absolute module specifier so return a reference that\n    // uses that absolute module specifier as its best guess owning module.\n    return new Reference(\n        node, {specifier: from, resolutionContext: origin.getSourceFile().fileName});\n  }\n  // For local symbols or symbols that were imported using a relative module import it is\n  // assumed that the symbol is exported from the provided best guess owning module.\n  return new Reference(node, bestGuessOwningModule);\n}\n\nexport function readBooleanType(type: ts.TypeNode): boolean|null {\n  if (!ts.isLiteralTypeNode(type)) {\n    return null;\n  }\n\n  switch (type.literal.kind) {\n    case ts.SyntaxKind.TrueKeyword:\n      return true;\n    case ts.SyntaxKind.FalseKeyword:\n      return false;\n    default:\n      return null;\n  }\n}\n\nexport function readStringType(type: ts.TypeNode): string|null {\n  if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n    return null;\n  }\n  return type.literal.text;\n}\n\nexport function readMapType<T>(\n    type: ts.TypeNode, valueTransform: (type: ts.TypeNode) => T | null): {[key: string]: T} {\n  if (!ts.isTypeLiteralNode(type)) {\n    return {};\n  }\n  const obj: {[key: string]: T} = {};\n  type.members.forEach(member => {\n    if (!ts.isPropertySignature(member) || member.type === undefined || member.name === undefined ||\n        (!ts.isStringLiteral(member.name) && !ts.isIdentifier(member.name))) {\n      return;\n    }\n    const value = valueTransform(member.type);\n    if (value === null) {\n      return null;\n    }\n    obj[member.name.text] = value;\n  });\n  return obj;\n}\n\nexport function readStringArrayType(type: ts.TypeNode): string[] {\n  if (!ts.isTupleTypeNode(type)) {\n    return [];\n  }\n  const res: string[] = [];\n  type.elements.forEach(el => {\n    if (!ts.isLiteralTypeNode(el) || !ts.isStringLiteral(el.literal)) {\n      return;\n    }\n    res.push(el.literal.text);\n  });\n  return res;\n}\n\n/**\n * Inspects the class' members and extracts the metadata that is used when type-checking templates\n * that use the directive. This metadata does not contain information from a base class, if any,\n * making this metadata invariant to changes of inherited classes.\n */\nexport function extractDirectiveTypeCheckMeta(\n    node: ClassDeclaration, inputs: ClassPropertyMapping<InputMapping>,\n    reflector: ReflectionHost): DirectiveTypeCheckMeta {\n  const members = reflector.getMembersOfClass(node);\n  const staticMembers = members.filter(member => member.isStatic);\n  const ngTemplateGuards = staticMembers.map(extractTemplateGuard)\n                               .filter((guard): guard is TemplateGuardMeta => guard !== null);\n  const hasNgTemplateContextGuard = staticMembers.some(\n      member => member.kind === ClassMemberKind.Method && member.name === 'ngTemplateContextGuard');\n\n  const coercedInputFields =\n      new Set(staticMembers.map(extractCoercedInput)\n                  .filter((inputName): inputName is ClassPropertyName => inputName !== null));\n\n  const restrictedInputFields = new Set<ClassPropertyName>();\n  const stringLiteralInputFields = new Set<ClassPropertyName>();\n  const undeclaredInputFields = new Set<ClassPropertyName>();\n\n  for (const classPropertyName of inputs.classPropertyNames) {\n    const field = members.find(member => member.name === classPropertyName);\n    if (field === undefined || field.node === null) {\n      undeclaredInputFields.add(classPropertyName);\n      continue;\n    }\n    if (isRestricted(field.node)) {\n      restrictedInputFields.add(classPropertyName);\n    }\n    if (field.nameNode !== null && ts.isStringLiteral(field.nameNode)) {\n      stringLiteralInputFields.add(classPropertyName);\n    }\n  }\n\n  const arity = reflector.getGenericArityOfClass(node);\n\n  return {\n    hasNgTemplateContextGuard,\n    ngTemplateGuards,\n    coercedInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    undeclaredInputFields,\n    isGeneric: arity !== null && arity > 0,\n  };\n}\n\nfunction isRestricted(node: ts.Node): boolean {\n  const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;\n\n  return modifiers !== undefined && modifiers.some(({kind}) => {\n    return kind === ts.SyntaxKind.PrivateKeyword || kind === ts.SyntaxKind.ProtectedKeyword ||\n        kind === ts.SyntaxKind.ReadonlyKeyword;\n  });\n}\n\nfunction extractTemplateGuard(member: ClassMember): TemplateGuardMeta|null {\n  if (!member.name.startsWith('ngTemplateGuard_')) {\n    return null;\n  }\n  const inputName = afterUnderscore(member.name);\n  if (member.kind === ClassMemberKind.Property) {\n    let type: string|null = null;\n    if (member.type !== null && ts.isLiteralTypeNode(member.type) &&\n        ts.isStringLiteral(member.type.literal)) {\n      type = member.type.literal.text;\n    }\n\n    // Only property members with string literal type 'binding' are considered as template guard.\n    if (type !== 'binding') {\n      return null;\n    }\n    return {inputName, type};\n  } else if (member.kind === ClassMemberKind.Method) {\n    return {inputName, type: 'invocation'};\n  } else {\n    return null;\n  }\n}\n\nfunction extractCoercedInput(member: ClassMember): string|null {\n  if (member.kind !== ClassMemberKind.Property || !member.name.startsWith('ngAcceptInputType_')) {\n    return null!;\n  }\n  return afterUnderscore(member.name);\n}\n\n/**\n * A `MetadataReader` that reads from an ordered set of child readers until it obtains the requested\n * metadata.\n *\n * This is used to combine `MetadataReader`s that read from different sources (e.g. from a registry\n * and from .d.ts files).\n */\nexport class CompoundMetadataReader implements MetadataReader {\n  constructor(private readers: MetadataReader[]) {}\n\n  getDirectiveMetadata(node: Reference<ClassDeclaration<ts.Declaration>>): DirectiveMeta|null {\n    for (const reader of this.readers) {\n      const meta = reader.getDirectiveMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n\n  getNgModuleMetadata(node: Reference<ClassDeclaration<ts.Declaration>>): NgModuleMeta|null {\n    for (const reader of this.readers) {\n      const meta = reader.getNgModuleMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getPipeMetadata(node: Reference<ClassDeclaration<ts.Declaration>>): PipeMeta|null {\n    for (const reader of this.readers) {\n      const meta = reader.getPipeMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n}\n\nfunction afterUnderscore(str: string): string {\n  const pos = str.indexOf('_');\n  if (pos === -1) {\n    throw new Error(`Expected '${str}' to contain '_'`);\n  }\n  return str.slice(pos + 1);\n}\n\n/** Returns whether a class declaration has the necessary class fields to make it injectable. */\nexport function hasInjectableFields(clazz: ClassDeclaration, host: ReflectionHost): boolean {\n  const members = host.getMembersOfClass(clazz);\n  return members.some(({isStatic, name}) => isStatic && (name === 'Éµprov' || name === 'Éµfac'));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {DirectiveMeta, InputMapping, MetadataReader} from './api';\nimport {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n\n/**\n * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata\n * which includes metadata from its entire inheritance chain.\n *\n * The returned `DirectiveMeta` will either have `baseClass: null` if the inheritance chain could be\n * fully resolved, or `baseClass: 'dynamic'` if the inheritance chain could not be completely\n * followed.\n */\nexport function flattenInheritedDirectiveMetadata(\n    reader: MetadataReader, dir: Reference<ClassDeclaration>): DirectiveMeta|null {\n  const topMeta = reader.getDirectiveMetadata(dir);\n  if (topMeta === null) {\n    return null;\n  }\n  if (topMeta.baseClass === null) {\n    return topMeta;\n  }\n\n  const coercedInputFields = new Set<ClassPropertyName>();\n  const undeclaredInputFields = new Set<ClassPropertyName>();\n  const restrictedInputFields = new Set<ClassPropertyName>();\n  const stringLiteralInputFields = new Set<ClassPropertyName>();\n  let isDynamic = false;\n  let inputs = ClassPropertyMapping.empty<InputMapping>();\n  let outputs = ClassPropertyMapping.empty();\n  let isStructural: boolean = false;\n\n  const addMetadata = (meta: DirectiveMeta): void => {\n    if (meta.baseClass === 'dynamic') {\n      isDynamic = true;\n    } else if (meta.baseClass !== null) {\n      const baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n      if (baseMeta !== null) {\n        addMetadata(baseMeta);\n      } else {\n        // Missing metadata for the base class means it's effectively dynamic.\n        isDynamic = true;\n      }\n    }\n\n    isStructural = isStructural || meta.isStructural;\n\n    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n\n    for (const coercedInputField of meta.coercedInputFields) {\n      coercedInputFields.add(coercedInputField);\n    }\n    for (const undeclaredInputField of meta.undeclaredInputFields) {\n      undeclaredInputFields.add(undeclaredInputField);\n    }\n    for (const restrictedInputField of meta.restrictedInputFields) {\n      restrictedInputFields.add(restrictedInputField);\n    }\n    for (const field of meta.stringLiteralInputFields) {\n      stringLiteralInputFields.add(field);\n    }\n  };\n\n  addMetadata(topMeta);\n\n  return {\n    ...topMeta,\n    inputs,\n    outputs,\n    coercedInputFields,\n    undeclaredInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    baseClass: isDynamic ? 'dynamic' : null,\n    isStructural,\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {DirectiveMeta, MetadataReaderWithIndex, MetadataRegistry, MetaKind, NgModuleMeta, PipeMeta} from './api';\n\n/**\n * A registry of directive, pipe, and module metadata for types defined in the current compilation\n * unit, which supports both reading and registering.\n */\nexport class LocalMetadataRegistry implements MetadataRegistry, MetadataReaderWithIndex {\n  private directives = new Map<ClassDeclaration, DirectiveMeta>();\n  private ngModules = new Map<ClassDeclaration, NgModuleMeta>();\n  private pipes = new Map<ClassDeclaration, PipeMeta>();\n\n  getDirectiveMetadata(ref: Reference<ClassDeclaration>): DirectiveMeta|null {\n    return this.directives.has(ref.node) ? this.directives.get(ref.node)! : null;\n  }\n  getNgModuleMetadata(ref: Reference<ClassDeclaration>): NgModuleMeta|null {\n    return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node)! : null;\n  }\n  getPipeMetadata(ref: Reference<ClassDeclaration>): PipeMeta|null {\n    return this.pipes.has(ref.node) ? this.pipes.get(ref.node)! : null;\n  }\n\n  registerDirectiveMetadata(meta: DirectiveMeta): void {\n    this.directives.set(meta.ref.node, meta);\n  }\n  registerNgModuleMetadata(meta: NgModuleMeta): void {\n    this.ngModules.set(meta.ref.node, meta);\n  }\n  registerPipeMetadata(meta: PipeMeta): void {\n    this.pipes.set(meta.ref.node, meta);\n  }\n\n  getKnown(kind: MetaKind): Array<ClassDeclaration> {\n    switch (kind) {\n      case MetaKind.Directive:\n        return Array.from(this.directives.values()).map(v => v.ref.node);\n      case MetaKind.Pipe:\n        return Array.from(this.pipes.values()).map(v => v.ref.node);\n      case MetaKind.NgModule:\n        return Array.from(this.ngModules.values()).map(v => v.ref.node);\n    }\n  }\n}\n\n/**\n * A `MetadataRegistry` which registers metadata with multiple delegate `MetadataRegistry`\n * instances.\n */\nexport class CompoundMetadataRegistry implements MetadataRegistry {\n  constructor(private registries: MetadataRegistry[]) {}\n\n  registerDirectiveMetadata(meta: DirectiveMeta): void {\n    for (const registry of this.registries) {\n      registry.registerDirectiveMetadata(meta);\n    }\n  }\n\n  registerNgModuleMetadata(meta: NgModuleMeta): void {\n    for (const registry of this.registries) {\n      registry.registerNgModuleMetadata(meta);\n    }\n  }\n\n  registerPipeMetadata(meta: PipeMeta): void {\n    for (const registry of this.registries) {\n      registry.registerPipeMetadata(meta);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {ClassDeclaration} from '../../reflection';\n\n/**\n * Represents an resource for a component and contains the `AbsoluteFsPath`\n * to the file which was resolved by evaluating the `ts.Expression` (generally, a relative or\n * absolute string path to the resource).\n *\n * If the resource is inline, the `path` will be `null`.\n */\nexport interface Resource {\n  path: AbsoluteFsPath|null;\n  expression: ts.Expression;\n}\n\nexport interface ExternalResource extends Resource {\n  path: AbsoluteFsPath;\n}\n\nexport function isExternalResource(resource: Resource): resource is ExternalResource {\n  return resource.path !== null;\n}\n\n/**\n * Represents the either inline or external resources of a component.\n *\n * A resource with a `path` of `null` is considered inline.\n */\nexport interface ComponentResources {\n  template: Resource;\n  styles: ReadonlySet<Resource>;\n}\n\n/**\n * Tracks the mapping between external template/style files and the component(s) which use them.\n *\n * This information is produced during analysis of the program and is used mainly to support\n * external tooling, for which such a mapping is challenging to determine without compiler\n * assistance.\n */\nexport class ResourceRegistry {\n  private externalTemplateToComponentsMap = new Map<AbsoluteFsPath, Set<ClassDeclaration>>();\n  private componentToTemplateMap = new Map<ClassDeclaration, Resource>();\n  private componentToStylesMap = new Map<ClassDeclaration, Set<Resource>>();\n  private externalStyleToComponentsMap = new Map<AbsoluteFsPath, Set<ClassDeclaration>>();\n\n  getComponentsWithTemplate(template: AbsoluteFsPath): ReadonlySet<ClassDeclaration> {\n    if (!this.externalTemplateToComponentsMap.has(template)) {\n      return new Set();\n    }\n\n    return this.externalTemplateToComponentsMap.get(template)!;\n  }\n\n  registerResources(resources: ComponentResources, component: ClassDeclaration) {\n    if (resources.template !== null) {\n      this.registerTemplate(resources.template, component);\n    }\n    for (const style of resources.styles) {\n      this.registerStyle(style, component);\n    }\n  }\n\n  registerTemplate(templateResource: Resource, component: ClassDeclaration): void {\n    const {path} = templateResource;\n    if (path !== null) {\n      if (!this.externalTemplateToComponentsMap.has(path)) {\n        this.externalTemplateToComponentsMap.set(path, new Set());\n      }\n      this.externalTemplateToComponentsMap.get(path)!.add(component);\n    }\n    this.componentToTemplateMap.set(component, templateResource);\n  }\n\n  getTemplate(component: ClassDeclaration): Resource|null {\n    if (!this.componentToTemplateMap.has(component)) {\n      return null;\n    }\n    return this.componentToTemplateMap.get(component)!;\n  }\n\n  registerStyle(styleResource: Resource, component: ClassDeclaration): void {\n    const {path} = styleResource;\n    if (!this.componentToStylesMap.has(component)) {\n      this.componentToStylesMap.set(component, new Set());\n    }\n    if (path !== null) {\n      if (!this.externalStyleToComponentsMap.has(path)) {\n        this.externalStyleToComponentsMap.set(path, new Set());\n      }\n      this.externalStyleToComponentsMap.get(path)!.add(component);\n    }\n    this.componentToStylesMap.get(component)!.add(styleResource);\n  }\n\n  getStyles(component: ClassDeclaration): Set<Resource> {\n    if (!this.componentToStylesMap.has(component)) {\n      return new Set();\n    }\n    return this.componentToStylesMap.get(component)!;\n  }\n\n  getComponentsWithStyle(styleUrl: AbsoluteFsPath): ReadonlySet<ClassDeclaration> {\n    if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n      return new Set();\n    }\n\n    return this.externalStyleToComponentsMap.get(styleUrl)!;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {MetadataReader} from './api';\n\n/**\n * Determines whether types may or may not export providers to NgModules, by transitively walking\n * the NgModule & standalone import graph.\n */\nexport class ExportedProviderStatusResolver {\n  /**\n   * `ClassDeclaration`s that we are in the process of determining the provider status for.\n   *\n   * This is used to detect cycles in the import graph and avoid getting stuck in them.\n   */\n  private calculating = new Set<ClassDeclaration>();\n\n  constructor(private metaReader: MetadataReader) {}\n\n  /**\n   * Determines whether `ref` may or may not export providers to NgModules which import it.\n   *\n   * NgModules export providers if any are declared, and standalone components export providers from\n   * their `imports` array (if any).\n   *\n   * If `true`, then `ref` should be assumed to export providers. In practice, this could mean\n   * either that `ref` is a local type that we _know_ exports providers, or it's imported from a\n   * .d.ts library and is declared in a way where the compiler cannot prove that it doesn't.\n   *\n   * If `false`, then `ref` is guaranteed not to export providers.\n   *\n   * @param `ref` the class for which the provider status should be determined\n   * @param `dependencyCallback` a callback that, if provided, will be called for every type\n   *     which is used in the determination of provider status for `ref`\n   * @returns `true` if `ref` should be assumed to export providers, or `false` if the compiler can\n   *     prove that it does not\n   */\n  mayExportProviders(\n      ref: Reference<ClassDeclaration>,\n      dependencyCallback?: (importRef: Reference<ClassDeclaration>) => void): boolean {\n    if (this.calculating.has(ref.node)) {\n      // For cycles, we treat the cyclic edge as not having providers.\n      return false;\n    }\n    this.calculating.add(ref.node);\n\n    if (dependencyCallback !== undefined) {\n      dependencyCallback(ref);\n    }\n\n    try {\n      const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n      if (dirMeta !== null) {\n        if (!dirMeta.isComponent || !dirMeta.isStandalone) {\n          return false;\n        }\n\n        if (dirMeta.assumedToExportProviders) {\n          return true;\n        }\n\n        // If one of the imports contains providers, then so does this component.\n        return (dirMeta.imports ?? [])\n            .some(importRef => this.mayExportProviders(importRef, dependencyCallback));\n      }\n\n      const pipeMeta = this.metaReader.getPipeMetadata(ref);\n      if (pipeMeta !== null) {\n        return false;\n      }\n\n      const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n      if (ngModuleMeta !== null) {\n        if (ngModuleMeta.mayDeclareProviders) {\n          return true;\n        }\n\n        // If one of the NgModule's imports may contain providers, then so does this NgModule.\n        return ngModuleMeta.imports.some(\n            importRef => this.mayExportProviders(importRef, dependencyCallback));\n      }\n\n      return false;\n    } finally {\n      this.calculating.delete(ref.node);\n    }\n  }\n}\n", "/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DirectiveMeta, InputMapping, MatchSource, MetadataReader} from '../../metadata/src/api';\nimport {ClassDeclaration} from '../../reflection';\nimport {ClassPropertyMapping, InputOrOutput} from '../src/property_mapping';\n\nimport {flattenInheritedDirectiveMetadata} from './inheritance';\n\nconst EMPTY_ARRAY: ReadonlyArray<any> = [];\n\n/** Resolves the host directives of a directive to a flat array of matches. */\nexport class HostDirectivesResolver {\n  private cache = new Map<ClassDeclaration, ReadonlyArray<DirectiveMeta>>();\n\n  constructor(private metaReader: MetadataReader) {}\n\n  /** Resolves all of the host directives that apply to a directive. */\n  resolve(metadata: DirectiveMeta): ReadonlyArray<DirectiveMeta> {\n    if (this.cache.has(metadata.ref.node)) {\n      return this.cache.get(metadata.ref.node)!;\n    }\n\n    const results = metadata.hostDirectives && metadata.hostDirectives.length > 0 ?\n        this.walkHostDirectives(metadata.hostDirectives, []) :\n        EMPTY_ARRAY;\n    this.cache.set(metadata.ref.node, results);\n    return results;\n  }\n\n  /**\n   * Traverses all of the host directive chains and produces a flat array of\n   * directive metadata representing the host directives that apply to the host.\n   */\n  private walkHostDirectives(\n      directives: NonNullable<DirectiveMeta['hostDirectives']>,\n      results: DirectiveMeta[]): ReadonlyArray<DirectiveMeta> {\n    for (const current of directives) {\n      const hostMeta = flattenInheritedDirectiveMetadata(this.metaReader, current.directive);\n\n      // This case has been checked for already and produces a diagnostic\n      if (hostMeta === null) {\n        continue;\n      }\n\n      if (hostMeta.hostDirectives) {\n        this.walkHostDirectives(hostMeta.hostDirectives, results);\n      }\n\n      results.push({\n        ...hostMeta,\n        matchSource: MatchSource.HostDirective,\n        inputs: ClassPropertyMapping.fromMappedObject(\n            this.filterMappings(hostMeta.inputs, current.inputs, resolveInput)),\n        outputs: ClassPropertyMapping.fromMappedObject(\n            this.filterMappings(hostMeta.outputs, current.outputs, resolveOutput)),\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Filters the class property mappings so that only the allowed ones are present.\n   * @param source Property mappings that should be filtered.\n   * @param allowedProperties Property mappings that are allowed in the final results.\n   * @param valueResolver Function used to resolve the value that is assigned to the final mapping.\n   */\n  private filterMappings<T, M extends InputOrOutput>(\n      source: ClassPropertyMapping<M>, allowedProperties: Record<string, string>|null,\n      valueResolver: (bindingName: string, binding: M) => T): Record<string, T> {\n    const result: Record<string, T> = {};\n\n    if (allowedProperties !== null) {\n      for (const publicName in allowedProperties) {\n        if (allowedProperties.hasOwnProperty(publicName)) {\n          const bindings = source.getByBindingPropertyName(publicName);\n\n          if (bindings !== null) {\n            for (const binding of bindings) {\n              result[binding.classPropertyName] =\n                  valueResolver(allowedProperties[publicName], binding);\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n}\n\nfunction resolveInput(bindingName: string, binding: InputMapping): InputMapping {\n  return {\n    bindingPropertyName: bindingName,\n    classPropertyName: binding.classPropertyName,\n    required: binding.required\n  };\n}\n\nfunction resolveOutput(bindingName: string): string {\n  return bindingName;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {makeRelatedInformation} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {FunctionDefinition} from '../../reflection';\n\nimport {DynamicValue, DynamicValueVisitor} from './dynamic';\nimport {EnumValue, KnownFn, ResolvedModule, ResolvedValue} from './result';\nimport {SyntheticValue} from './synthetic';\n\n/**\n * Derives a type representation from a resolved value to be reported in a diagnostic.\n *\n * @param value The resolved value for which a type representation should be derived.\n * @param maxDepth The maximum nesting depth of objects and arrays, defaults to 1 level.\n */\nexport function describeResolvedType(value: ResolvedValue, maxDepth: number = 1): string {\n  if (value === null) {\n    return 'null';\n  } else if (value === undefined) {\n    return 'undefined';\n  } else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string') {\n    return typeof value;\n  } else if (value instanceof Map) {\n    if (maxDepth === 0) {\n      return 'object';\n    }\n    const entries = Array.from(value.entries()).map(([key, v]) => {\n      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n    });\n    return entries.length > 0 ? `{ ${entries.join('; ')} }` : '{}';\n  } else if (value instanceof ResolvedModule) {\n    return '(module)';\n  } else if (value instanceof EnumValue) {\n    return value.enumRef.debugName ?? '(anonymous)';\n  } else if (value instanceof Reference) {\n    return value.debugName ?? '(anonymous)';\n  } else if (Array.isArray(value)) {\n    if (maxDepth === 0) {\n      return 'Array';\n    }\n    return `[${value.map(v => describeResolvedType(v, maxDepth - 1)).join(', ')}]`;\n  } else if (value instanceof DynamicValue) {\n    return '(not statically analyzable)';\n  } else if (value instanceof KnownFn) {\n    return 'Function';\n  } else {\n    return 'unknown';\n  }\n}\n\nfunction quoteKey(key: string): string {\n  if (/^[a-z0-9_]+$/i.test(key)) {\n    return key;\n  } else {\n    return `'${key.replace(/'/g, '\\\\\\'')}'`;\n  }\n}\n\n/**\n * Creates an array of related information diagnostics for a `DynamicValue` that describe the trace\n * of why an expression was evaluated as dynamic.\n *\n * @param node The node for which a `ts.Diagnostic` is to be created with the trace.\n * @param value The dynamic value for which a trace should be created.\n */\nexport function traceDynamicValue(\n    node: ts.Node, value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n  return value.accept(new TraceDynamicValueVisitor(node));\n}\n\nclass TraceDynamicValueVisitor implements DynamicValueVisitor<ts.DiagnosticRelatedInformation[]> {\n  private currentContainerNode: ts.Node|null = null;\n\n  constructor(private node: ts.Node) {}\n\n  visitDynamicInput(value: DynamicValue<DynamicValue>): ts.DiagnosticRelatedInformation[] {\n    const trace = value.reason.accept(this);\n    if (this.shouldTrace(value.node)) {\n      const info =\n          makeRelatedInformation(value.node, 'Unable to evaluate this expression statically.');\n      trace.unshift(info);\n    }\n    return trace;\n  }\n\n  visitSyntheticInput(value: DynamicValue<SyntheticValue<unknown>>):\n      ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unable to evaluate this expression further.')];\n  }\n\n  visitDynamicString(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(\n        value.node, 'A string value could not be determined statically.')];\n  }\n\n  visitExternalReference(value: DynamicValue<Reference<ts.Declaration>>):\n      ts.DiagnosticRelatedInformation[] {\n    const name = value.reason.debugName;\n    const description = name !== null ? `'${name}'` : 'an anonymous declaration';\n    return [makeRelatedInformation(\n        value.node,\n        `A value for ${\n            description} cannot be determined statically, as it is an external declaration.`)];\n  }\n\n  visitComplexFunctionCall(value: DynamicValue<FunctionDefinition>):\n      ts.DiagnosticRelatedInformation[] {\n    return [\n      makeRelatedInformation(\n          value.node,\n          'Unable to evaluate function call of complex function. A function must have exactly one return statement.'),\n      makeRelatedInformation(value.reason.node, 'Function is declared here.')\n    ];\n  }\n\n  visitInvalidExpressionType(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unable to evaluate an invalid expression.')];\n  }\n\n  visitUnknown(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unable to evaluate statically.')];\n  }\n\n  visitUnknownIdentifier(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unknown reference.')];\n  }\n\n  visitDynamicType(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Dynamic type.')];\n  }\n\n  visitUnsupportedSyntax(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'This syntax is not supported.')];\n  }\n\n  /**\n   * Determines whether the dynamic value reported for the node should be traced, i.e. if it is not\n   * part of the container for which the most recent trace was created.\n   */\n  private shouldTrace(node: ts.Node): boolean {\n    if (node === this.node) {\n      // Do not include a dynamic value for the origin node, as the main diagnostic is already\n      // reported on that node.\n      return false;\n    }\n\n    const container = getContainerNode(node);\n    if (container === this.currentContainerNode) {\n      // The node is part of the same container as the previous trace entry, so this dynamic value\n      // should not become part of the trace.\n      return false;\n    }\n\n    this.currentContainerNode = container;\n    return true;\n  }\n}\n\n/**\n * Determines the closest parent node that is to be considered as container, which is used to reduce\n * the granularity of tracing the dynamic values to a single entry per container. Currently, full\n * statements and destructuring patterns are considered as container.\n */\nfunction getContainerNode(node: ts.Node): ts.Node {\n  let currentNode: ts.Node|undefined = node;\n  while (currentNode !== undefined) {\n    switch (currentNode.kind) {\n      case ts.SyntaxKind.ExpressionStatement:\n      case ts.SyntaxKind.VariableStatement:\n      case ts.SyntaxKind.ReturnStatement:\n      case ts.SyntaxKind.IfStatement:\n      case ts.SyntaxKind.SwitchStatement:\n      case ts.SyntaxKind.DoStatement:\n      case ts.SyntaxKind.WhileStatement:\n      case ts.SyntaxKind.ForStatement:\n      case ts.SyntaxKind.ForInStatement:\n      case ts.SyntaxKind.ForOfStatement:\n      case ts.SyntaxKind.ContinueStatement:\n      case ts.SyntaxKind.BreakStatement:\n      case ts.SyntaxKind.ThrowStatement:\n      case ts.SyntaxKind.ObjectBindingPattern:\n      case ts.SyntaxKind.ArrayBindingPattern:\n        return currentNode;\n    }\n\n    currentNode = currentNode.parent;\n  }\n  return node.getSourceFile();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {FunctionDefinition} from '../../reflection';\n\nimport {SyntheticValue} from './synthetic';\n\n/**\n * The reason why a value cannot be determined statically.\n */\nexport const enum DynamicValueReason {\n  /**\n   * A value could not be determined statically, because it contains a term that could not be\n   * determined statically.\n   * (E.g. a property assignment or call expression where the lhs is a `DynamicValue`, a template\n   * literal with a dynamic expression, an object literal with a spread assignment which could not\n   * be determined statically, etc.)\n   */\n  DYNAMIC_INPUT,\n\n  /**\n   * A string could not be statically evaluated.\n   * (E.g. a dynamically constructed object property name or a template literal expression that\n   * could not be statically resolved to a primitive value.)\n   */\n  DYNAMIC_STRING,\n\n  /**\n   * An external reference could not be resolved to a value which can be evaluated.\n   * For example a call expression for a function declared in `.d.ts`, or accessing native globals\n   * such as `window`.\n   */\n  EXTERNAL_REFERENCE,\n\n  /**\n   * Syntax that `StaticInterpreter` doesn't know how to evaluate, for example a type of\n   * `ts.Expression` that is not supported.\n   */\n  UNSUPPORTED_SYNTAX,\n\n  /**\n   * A declaration of a `ts.Identifier` could not be found.\n   */\n  UNKNOWN_IDENTIFIER,\n\n  /**\n   * A value could be resolved, but is not an acceptable type for the operation being performed.\n   *\n   * For example, attempting to call a non-callable expression.\n   */\n  INVALID_EXPRESSION_TYPE,\n\n  /**\n   * A function call could not be evaluated as the function's body is not a single return statement.\n   */\n  COMPLEX_FUNCTION_CALL,\n\n  /**\n   * A value that could not be determined because it contains type information that cannot be\n   * statically evaluated. This happens when producing a value from type information, but the value\n   * of the given type cannot be determined statically.\n   *\n   * E.g. evaluating a tuple.\n   *\n   *   `declare const foo: [string];`\n   *\n   *  Evaluating `foo` gives a DynamicValue wrapped in an array with a reason of DYNAMIC_TYPE. This\n   * is because the static evaluator has a `string` type for the first element of this tuple, and\n   * the value of that string cannot be determined statically. The type `string` permits it to be\n   * 'foo', 'bar' or any arbitrary string, so we evaluate it to a DynamicValue.\n   */\n  DYNAMIC_TYPE,\n\n  /**\n   * A value could not be determined because one of the inputs to its evaluation is a synthetically\n   * produced value.\n   */\n  SYNTHETIC_INPUT,\n\n  /**\n   * A value could not be determined statically for any reason other the above.\n   */\n  UNKNOWN,\n}\n\n/**\n * Represents a value which cannot be determined statically.\n */\nexport class DynamicValue<R = unknown> {\n  private constructor(\n      readonly node: ts.Node, readonly reason: R, private code: DynamicValueReason) {}\n\n  static fromDynamicInput(node: ts.Node, input: DynamicValue): DynamicValue<DynamicValue> {\n    return new DynamicValue(node, input, DynamicValueReason.DYNAMIC_INPUT);\n  }\n\n  static fromDynamicString(node: ts.Node): DynamicValue {\n    return new DynamicValue(node, undefined, DynamicValueReason.DYNAMIC_STRING);\n  }\n\n  static fromExternalReference(node: ts.Node, ref: Reference<ts.Declaration>):\n      DynamicValue<Reference<ts.Declaration>> {\n    return new DynamicValue(node, ref, DynamicValueReason.EXTERNAL_REFERENCE);\n  }\n\n  static fromUnsupportedSyntax(node: ts.Node): DynamicValue {\n    return new DynamicValue(node, undefined, DynamicValueReason.UNSUPPORTED_SYNTAX);\n  }\n\n  static fromUnknownIdentifier(node: ts.Identifier): DynamicValue {\n    return new DynamicValue(node, undefined, DynamicValueReason.UNKNOWN_IDENTIFIER);\n  }\n\n  static fromInvalidExpressionType(node: ts.Node, value: unknown): DynamicValue<unknown> {\n    return new DynamicValue(node, value, DynamicValueReason.INVALID_EXPRESSION_TYPE);\n  }\n\n  static fromComplexFunctionCall(node: ts.Node, fn: FunctionDefinition):\n      DynamicValue<FunctionDefinition> {\n    return new DynamicValue(node, fn, DynamicValueReason.COMPLEX_FUNCTION_CALL);\n  }\n\n  static fromDynamicType(node: ts.TypeNode): DynamicValue {\n    return new DynamicValue(node, undefined, DynamicValueReason.DYNAMIC_TYPE);\n  }\n\n  static fromSyntheticInput(node: ts.Node, value: SyntheticValue<unknown>):\n      DynamicValue<SyntheticValue<unknown>> {\n    return new DynamicValue(node, value, DynamicValueReason.SYNTHETIC_INPUT);\n  }\n\n  static fromUnknown(node: ts.Node): DynamicValue {\n    return new DynamicValue(node, undefined, DynamicValueReason.UNKNOWN);\n  }\n\n  isFromDynamicInput(this: DynamicValue<R>): this is DynamicValue<DynamicValue> {\n    return this.code === DynamicValueReason.DYNAMIC_INPUT;\n  }\n\n  isFromDynamicString(this: DynamicValue<R>): this is DynamicValue {\n    return this.code === DynamicValueReason.DYNAMIC_STRING;\n  }\n\n  isFromExternalReference(this: DynamicValue<R>): this is DynamicValue<Reference<ts.Declaration>> {\n    return this.code === DynamicValueReason.EXTERNAL_REFERENCE;\n  }\n\n  isFromUnsupportedSyntax(this: DynamicValue<R>): this is DynamicValue {\n    return this.code === DynamicValueReason.UNSUPPORTED_SYNTAX;\n  }\n\n  isFromUnknownIdentifier(this: DynamicValue<R>): this is DynamicValue {\n    return this.code === DynamicValueReason.UNKNOWN_IDENTIFIER;\n  }\n\n  isFromInvalidExpressionType(this: DynamicValue<R>): this is DynamicValue<unknown> {\n    return this.code === DynamicValueReason.INVALID_EXPRESSION_TYPE;\n  }\n\n  isFromComplexFunctionCall(this: DynamicValue<R>): this is DynamicValue<FunctionDefinition> {\n    return this.code === DynamicValueReason.COMPLEX_FUNCTION_CALL;\n  }\n\n  isFromDynamicType(this: DynamicValue<R>): this is DynamicValue {\n    return this.code === DynamicValueReason.DYNAMIC_TYPE;\n  }\n\n  isFromUnknown(this: DynamicValue<R>): this is DynamicValue {\n    return this.code === DynamicValueReason.UNKNOWN;\n  }\n\n  accept<R>(visitor: DynamicValueVisitor<R>): R {\n    switch (this.code) {\n      case DynamicValueReason.DYNAMIC_INPUT:\n        return visitor.visitDynamicInput(this as unknown as DynamicValue<DynamicValue>);\n      case DynamicValueReason.DYNAMIC_STRING:\n        return visitor.visitDynamicString(this);\n      case DynamicValueReason.EXTERNAL_REFERENCE:\n        return visitor.visitExternalReference(\n            this as unknown as DynamicValue<Reference<ts.Declaration>>);\n      case DynamicValueReason.UNSUPPORTED_SYNTAX:\n        return visitor.visitUnsupportedSyntax(this);\n      case DynamicValueReason.UNKNOWN_IDENTIFIER:\n        return visitor.visitUnknownIdentifier(this);\n      case DynamicValueReason.INVALID_EXPRESSION_TYPE:\n        return visitor.visitInvalidExpressionType(this);\n      case DynamicValueReason.COMPLEX_FUNCTION_CALL:\n        return visitor.visitComplexFunctionCall(\n            this as unknown as DynamicValue<FunctionDefinition>);\n      case DynamicValueReason.DYNAMIC_TYPE:\n        return visitor.visitDynamicType(this);\n      case DynamicValueReason.SYNTHETIC_INPUT:\n        return visitor.visitSyntheticInput(\n            this as unknown as DynamicValue<SyntheticValue<unknown>>);\n      case DynamicValueReason.UNKNOWN:\n        return visitor.visitUnknown(this);\n    }\n  }\n}\n\nexport interface DynamicValueVisitor<R> {\n  visitDynamicInput(value: DynamicValue<DynamicValue>): R;\n  visitDynamicString(value: DynamicValue): R;\n  visitExternalReference(value: DynamicValue<Reference<ts.Declaration>>): R;\n  visitUnsupportedSyntax(value: DynamicValue): R;\n  visitUnknownIdentifier(value: DynamicValue): R;\n  visitInvalidExpressionType(value: DynamicValue): R;\n  visitComplexFunctionCall(value: DynamicValue<FunctionDefinition>): R;\n  visitDynamicType(value: DynamicValue): R;\n  visitSyntheticInput(value: DynamicValue<SyntheticValue<unknown>>): R;\n  visitUnknown(value: DynamicValue): R;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {Declaration} from '../../reflection';\n\nimport {DynamicValue} from './dynamic';\nimport {SyntheticValue} from './synthetic';\n\n\n/**\n * A value resulting from static resolution.\n *\n * This could be a primitive, collection type, reference to a `ts.Node` that declares a\n * non-primitive value, or a special `DynamicValue` type which indicates the value was not\n * available statically.\n */\nexport type ResolvedValue =\n    number|boolean|string|null|undefined|Reference|EnumValue|ResolvedValueArray|ResolvedValueMap|\n    ResolvedModule|KnownFn|SyntheticValue<unknown>|DynamicValue<unknown>;\n\n/**\n * An array of `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueArray`\n * -> `ResolvedValue`.\n */\nexport interface ResolvedValueArray extends Array<ResolvedValue> {}\n\n/**\n * A map of strings to `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueMap`\n * -> `ResolvedValue`.\n */\nexport interface ResolvedValueMap extends Map<string, ResolvedValue> {}\n\n/**\n * A collection of publicly exported declarations from a module. Each declaration is evaluated\n * lazily upon request.\n */\nexport class ResolvedModule {\n  constructor(\n      private exports: Map<string, Declaration>,\n      private evaluate: (decl: Declaration) => ResolvedValue) {}\n\n  getExport(name: string): ResolvedValue {\n    if (!this.exports.has(name)) {\n      return undefined;\n    }\n\n    return this.evaluate(this.exports.get(name)!);\n  }\n\n  getExports(): ResolvedValueMap {\n    const map = new Map<string, ResolvedValue>();\n    this.exports.forEach((decl, name) => {\n      map.set(name, this.evaluate(decl));\n    });\n    return map;\n  }\n}\n\n/**\n * A value member of an enumeration.\n *\n * Contains a `Reference` to the enumeration itself, and the name of the referenced member.\n */\nexport class EnumValue {\n  constructor(\n      readonly enumRef: Reference<ts.Declaration>, readonly name: string,\n      readonly resolved: ResolvedValue) {}\n}\n\n/**\n * An implementation of a known function that can be statically evaluated.\n * It could be a built-in function or method (such as `Array.prototype.slice`) or a TypeScript\n * helper (such as `__spread`).\n */\nexport abstract class KnownFn {\n  abstract evaluate(node: ts.CallExpression, args: ResolvedValueArray): ResolvedValue;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {OwningModule} from '../../imports/src/references';\nimport {DependencyTracker} from '../../incremental/api';\nimport {Declaration, DeclarationNode, FunctionDefinition, ReflectionHost} from '../../reflection';\nimport {isDeclaration} from '../../util/src/typescript';\n\nimport {ArrayConcatBuiltinFn, ArraySliceBuiltinFn, StringConcatBuiltinFn} from './builtin';\nimport {DynamicValue} from './dynamic';\nimport {ForeignFunctionResolver} from './interface';\nimport {EnumValue, KnownFn, ResolvedModule, ResolvedValue, ResolvedValueArray, ResolvedValueMap} from './result';\nimport {SyntheticValue} from './synthetic';\n\n\n\n/**\n * Tracks the scope of a function body, which includes `ResolvedValue`s for the parameters of that\n * body.\n */\ntype Scope = Map<ts.ParameterDeclaration, ResolvedValue>;\n\ninterface BinaryOperatorDef {\n  literal: boolean;\n  op: (a: any, b: any) => ResolvedValue;\n}\n\nfunction literalBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: true};\n}\n\nfunction referenceBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: false};\n}\n\nconst BINARY_OPERATORS = new Map<ts.SyntaxKind, BinaryOperatorDef>([\n  [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],\n  [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],\n  [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],\n  [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],\n  [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],\n  [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],\n  [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],\n  [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],\n  [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],\n  [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],\n  [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],\n  [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],\n  [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],\n  [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],\n  [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],\n  [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],\n  [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],\n  [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],\n  [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],\n  [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]\n]);\n\nconst UNARY_OPERATORS = new Map<ts.SyntaxKind, (a: any) => any>([\n  [ts.SyntaxKind.TildeToken, a => ~a], [ts.SyntaxKind.MinusToken, a => -a],\n  [ts.SyntaxKind.PlusToken, a => +a], [ts.SyntaxKind.ExclamationToken, a => !a]\n]);\n\ninterface Context {\n  originatingFile: ts.SourceFile;\n  /**\n   * The module name (if any) which was used to reach the currently resolving symbols.\n   */\n  absoluteModuleName: string|null;\n\n  /**\n   * A file name representing the context in which the current `absoluteModuleName`, if any, was\n   * resolved.\n   */\n  resolutionContext: string;\n  scope: Scope;\n  foreignFunctionResolver?: ForeignFunctionResolver;\n}\nexport class StaticInterpreter {\n  constructor(\n      private host: ReflectionHost, private checker: ts.TypeChecker,\n      private dependencyTracker: DependencyTracker|null) {}\n\n  visit(node: ts.Expression, context: Context): ResolvedValue {\n    return this.visitExpression(node, context);\n  }\n\n  private visitExpression(node: ts.Expression, context: Context): ResolvedValue {\n    let result: ResolvedValue;\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (node.kind === ts.SyntaxKind.NullKeyword) {\n      return null;\n    } else if (ts.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts.isTemplateExpression(node)) {\n      result = this.visitTemplateExpression(node, context);\n    } else if (ts.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts.isObjectLiteralExpression(node)) {\n      result = this.visitObjectLiteralExpression(node, context);\n    } else if (ts.isIdentifier(node)) {\n      result = this.visitIdentifier(node, context);\n    } else if (ts.isPropertyAccessExpression(node)) {\n      result = this.visitPropertyAccessExpression(node, context);\n    } else if (ts.isCallExpression(node)) {\n      result = this.visitCallExpression(node, context);\n    } else if (ts.isConditionalExpression(node)) {\n      result = this.visitConditionalExpression(node, context);\n    } else if (ts.isPrefixUnaryExpression(node)) {\n      result = this.visitPrefixUnaryExpression(node, context);\n    } else if (ts.isBinaryExpression(node)) {\n      result = this.visitBinaryExpression(node, context);\n    } else if (ts.isArrayLiteralExpression(node)) {\n      result = this.visitArrayLiteralExpression(node, context);\n    } else if (ts.isParenthesizedExpression(node)) {\n      result = this.visitParenthesizedExpression(node, context);\n    } else if (ts.isElementAccessExpression(node)) {\n      result = this.visitElementAccessExpression(node, context);\n    } else if (ts.isAsExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (ts.isNonNullExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (this.host.isClass(node)) {\n      result = this.visitDeclaration(node, context);\n    } else {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    if (result instanceof DynamicValue && result.node !== node) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n\n  private visitArrayLiteralExpression(node: ts.ArrayLiteralExpression, context: Context):\n      ResolvedValue {\n    const array: ResolvedValueArray = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts.isSpreadElement(element)) {\n        array.push(...this.visitSpreadElement(element, context));\n      } else {\n        array.push(this.visitExpression(element, context));\n      }\n    }\n    return array;\n  }\n\n  protected visitObjectLiteralExpression(node: ts.ObjectLiteralExpression, context: Context):\n      ResolvedValue {\n    const map: ResolvedValueMap = new Map<string, ResolvedValue>();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n        // Check whether the name can be determined statically.\n        if (name === undefined) {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));\n        }\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n          map.set(property.name.text, DynamicValue.fromUnknown(property));\n        } else {\n          map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n        }\n      } else if (ts.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n        if (spread instanceof DynamicValue) {\n          return DynamicValue.fromDynamicInput(node, spread);\n        } else if (spread instanceof Map) {\n          spread.forEach((value, key) => map.set(key, value));\n        } else if (spread instanceof ResolvedModule) {\n          spread.getExports().forEach((value, key) => map.set(key, value));\n        } else {\n          return DynamicValue.fromDynamicInput(\n              node, DynamicValue.fromInvalidExpressionType(property, spread));\n        }\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return map;\n  }\n\n  private visitTemplateExpression(node: ts.TemplateExpression, context: Context): ResolvedValue {\n    const pieces: string[] = [node.head.text];\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = literal(\n          this.visit(span.expression, context),\n          () => DynamicValue.fromDynamicString(span.expression));\n      if (value instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, value);\n      }\n      pieces.push(`${value}`, span.literal.text);\n    }\n    return pieces.join('');\n  }\n\n  private visitIdentifier(node: ts.Identifier, context: Context): ResolvedValue {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n    if (decl === null) {\n      if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n        return undefined;\n      } else {\n        // Check if the symbol here is imported.\n        if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n          // It was, but no declaration for the node could be found. This means that the dependency\n          // graph for the current file cannot be properly updated to account for this (broken)\n          // import. Instead, the originating file is reported as failing dependency analysis,\n          // ensuring that future compilations will always attempt to re-resolve the previously\n          // broken identifier.\n          this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n        }\n        return DynamicValue.fromUnknownIdentifier(node);\n      }\n    }\n    const declContext = {...context, ...joinModuleContext(context, node, decl)};\n    const result = this.visitDeclaration(decl.node, declContext);\n    if (result instanceof Reference) {\n      // Only record identifiers to non-synthetic references. Synthetic references may not have the\n      // same value at runtime as they do at compile time, so it's not legal to refer to them by the\n      // identifier here.\n      if (!result.synthetic) {\n        result.addIdentifier(node);\n      }\n    } else if (result instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n\n  private visitDeclaration(node: DeclarationNode, context: Context): ResolvedValue {\n    if (this.dependencyTracker !== null) {\n      this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n    }\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node)!;\n    } else if (ts.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else if (ts.isBindingElement(node)) {\n      return this.visitBindingElement(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n  private visitVariableDeclaration(node: ts.VariableDeclaration, context: Context): ResolvedValue {\n    const value = this.host.getVariableValue(node);\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      // If the declaration has a literal type that can be statically reduced to a value, resolve to\n      // that value. If not, the historical behavior for variable declarations is to return a\n      // `Reference` to the variable, as the consumer could use it in a context where knowing its\n      // static value is not necessary.\n      //\n      // Arguably, since the value cannot be statically determined, we should return a\n      // `DynamicValue`. This returns a `Reference` because it's the same behavior as before\n      // `visitType` was introduced.\n      //\n      // TODO(zarend): investigate switching to a `DynamicValue` and verify this won't break any\n      // use cases, especially in ngcc\n      if (node.type !== undefined) {\n        const evaluatedType = this.visitType(node.type, context);\n        if (!(evaluatedType instanceof DynamicValue)) {\n          return evaluatedType;\n        }\n      }\n      return this.getReference(node, context);\n    } else {\n      return undefined;\n    }\n  }\n\n  private visitEnumDeclaration(node: ts.EnumDeclaration, context: Context): ResolvedValue {\n    const enumRef = this.getReference(node, context);\n    const map = new Map<string, EnumValue>();\n    node.members.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== undefined) {\n        const resolved = member.initializer && this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n\n  private visitElementAccessExpression(node: ts.ElementAccessExpression, context: Context):\n      ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    const rhs = this.visitExpression(node.argumentExpression, context);\n    if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    }\n    if (typeof rhs !== 'string' && typeof rhs !== 'number') {\n      return DynamicValue.fromInvalidExpressionType(node, rhs);\n    }\n\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n\n  private visitPropertyAccessExpression(node: ts.PropertyAccessExpression, context: Context):\n      ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n    // TODO: handle reference to class declaration.\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n\n  private visitSourceFile(node: ts.SourceFile, context: Context): ResolvedValue {\n    const declarations = this.host.getExportsOfModule(node);\n    if (declarations === null) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    return new ResolvedModule(declarations, decl => {\n      const declContext = {\n        ...context,\n        ...joinModuleContext(context, node, decl),\n      };\n\n      // Visit both concrete and inline declarations.\n      return this.visitDeclaration(decl.node, declContext);\n    });\n  }\n\n  private accessHelper(node: ts.Node, lhs: ResolvedValue, rhs: string|number, context: Context):\n      ResolvedValue {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex)!;\n      } else {\n        return undefined;\n      }\n    } else if (lhs instanceof ResolvedModule) {\n      return lhs.getExport(strIndex);\n    } else if (Array.isArray(lhs)) {\n      if (rhs === 'length') {\n        return lhs.length;\n      } else if (rhs === 'slice') {\n        return new ArraySliceBuiltinFn(lhs);\n      } else if (rhs === 'concat') {\n        return new ArrayConcatBuiltinFn(lhs);\n      }\n      if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {\n        return DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n      return lhs[rhs];\n    } else if (typeof lhs === 'string' && rhs === 'concat') {\n      return new StringConcatBuiltinFn(lhs);\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (this.host.isClass(ref)) {\n        const module = owningModule(context, lhs.bestGuessOwningModule);\n        let value: ResolvedValue = undefined;\n        const member = this.host.getMembersOfClass(ref).find(\n            member => member.isStatic && member.name === strIndex);\n        if (member !== undefined) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new Reference(member.implementation, module);\n          } else if (member.node) {\n            value = new Reference(member.node, module);\n          }\n        }\n        return value;\n      } else if (isDeclaration(ref)) {\n        return DynamicValue.fromDynamicInput(\n            node, DynamicValue.fromExternalReference(ref, lhs as Reference<ts.Declaration>));\n      }\n    } else if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (lhs instanceof SyntheticValue) {\n      return DynamicValue.fromSyntheticInput(node, lhs);\n    }\n\n    return DynamicValue.fromUnknown(node);\n  }\n\n  private visitCallExpression(node: ts.CallExpression, context: Context): ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    // If the call refers to a builtin function, attempt to evaluate the function.\n    if (lhs instanceof KnownFn) {\n      return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n    }\n\n    if (!(lhs instanceof Reference)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n    if (fn === null) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    if (!isFunctionOrMethodReference(lhs)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    const resolveFfrExpr = (expr: ts.Expression) => {\n      let contextExtension: {\n        absoluteModuleName?: string|null,\n        resolutionContext?: string,\n      } = {};\n\n      // TODO(alxhub): the condition `fn.body === null` here is vestigial - we probably _do_ want to\n      // change the context like this even for non-null function bodies. But, this is being\n      // redesigned as a refactoring with no behavior changes so that should be done as a follow-up.\n      if (fn.body === null && expr.getSourceFile() !== node.expression.getSourceFile() &&\n          lhs.bestGuessOwningModule !== null) {\n        contextExtension = {\n          absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n          resolutionContext: lhs.bestGuessOwningModule.resolutionContext,\n        };\n      }\n\n      return this.visitFfrExpression(expr, {...context, ...contextExtension});\n    };\n\n    // If the function is foreign (declared through a d.ts file), attempt to resolve it with the\n    // foreignFunctionResolver, if one is specified.\n    if (fn.body === null && context.foreignFunctionResolver !== undefined) {\n      const unresolvable = DynamicValue.fromDynamicInput(\n          node, DynamicValue.fromExternalReference(node.expression, lhs));\n      return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);\n    }\n\n    const res: ResolvedValue = this.visitFunctionBody(node, fn, context);\n\n    // If the result of attempting to resolve the function body was a DynamicValue, attempt to use\n    // the foreignFunctionResolver if one is present. This could still potentially yield a usable\n    // value.\n    if (res instanceof DynamicValue && context.foreignFunctionResolver !== undefined) {\n      const unresolvable = DynamicValue.fromComplexFunctionCall(node, fn);\n      return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);\n    }\n\n    return res;\n  }\n\n  /**\n   * Visit an expression which was extracted from a foreign-function resolver.\n   *\n   * This will process the result and ensure it's correct for FFR-resolved values, including marking\n   * `Reference`s as synthetic.\n   */\n  private visitFfrExpression(expr: ts.Expression, context: Context): ResolvedValue {\n    const res = this.visitExpression(expr, context);\n    if (res instanceof Reference) {\n      // This Reference was created synthetically, via a foreign function resolver. The real\n      // runtime value of the function expression may be different than the foreign function\n      // resolved value, so mark the Reference as synthetic to avoid it being misinterpreted.\n      res.synthetic = true;\n    }\n    return res;\n  }\n\n  private visitFunctionBody(node: ts.CallExpression, fn: FunctionDefinition, context: Context):\n      ResolvedValue {\n    if (fn.body === null) {\n      return DynamicValue.fromUnknown(node);\n    } else if (fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {\n      return DynamicValue.fromComplexFunctionCall(node, fn);\n    }\n    const ret = fn.body[0] as ts.ReturnStatement;\n\n    const args = this.evaluateFunctionArguments(node, context);\n    const newScope: Scope = new Map<ts.ParameterDeclaration, ResolvedValue>();\n    const calleeContext = {...context, scope: newScope};\n    fn.parameters.forEach((param, index) => {\n      let arg = args[index];\n      if (param.node.dotDotDotToken !== undefined) {\n        arg = args.slice(index);\n      }\n      if (arg === undefined && param.initializer !== null) {\n        arg = this.visitExpression(param.initializer, calleeContext);\n      }\n      newScope.set(param.node, arg);\n    });\n\n    return ret.expression !== undefined ? this.visitExpression(ret.expression, calleeContext) :\n                                          undefined;\n  }\n\n  private visitConditionalExpression(node: ts.ConditionalExpression, context: Context):\n      ResolvedValue {\n    const condition = this.visitExpression(node.condition, context);\n    if (condition instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, condition);\n    }\n\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n\n  private visitPrefixUnaryExpression(node: ts.PrefixUnaryExpression, context: Context):\n      ResolvedValue {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    const op = UNARY_OPERATORS.get(operatorKind)!;\n    const value = this.visitExpression(node.operand, context);\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    } else {\n      return op(value);\n    }\n  }\n\n  private visitBinaryExpression(node: ts.BinaryExpression, context: Context): ResolvedValue {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    const opRecord = BINARY_OPERATORS.get(tokenKind)!;\n    let lhs: ResolvedValue, rhs: ResolvedValue;\n    if (opRecord.literal) {\n      lhs = literal(\n          this.visitExpression(node.left, context),\n          value => DynamicValue.fromInvalidExpressionType(node.left, value));\n      rhs = literal(\n          this.visitExpression(node.right, context),\n          value => DynamicValue.fromInvalidExpressionType(node.right, value));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    } else {\n      return opRecord.op(lhs, rhs);\n    }\n  }\n\n  private visitParenthesizedExpression(node: ts.ParenthesizedExpression, context: Context):\n      ResolvedValue {\n    return this.visitExpression(node.expression, context);\n  }\n\n  private evaluateFunctionArguments(node: ts.CallExpression, context: Context): ResolvedValueArray {\n    const args: ResolvedValueArray = [];\n    for (const arg of node.arguments) {\n      if (ts.isSpreadElement(arg)) {\n        args.push(...this.visitSpreadElement(arg, context));\n      } else {\n        args.push(this.visitExpression(arg, context));\n      }\n    }\n    return args;\n  }\n\n  private visitSpreadElement(node: ts.SpreadElement, context: Context): ResolvedValueArray {\n    const spread = this.visitExpression(node.expression, context);\n    if (spread instanceof DynamicValue) {\n      return [DynamicValue.fromDynamicInput(node, spread)];\n    } else if (!Array.isArray(spread)) {\n      return [DynamicValue.fromInvalidExpressionType(node, spread)];\n    } else {\n      return spread;\n    }\n  }\n\n  private visitBindingElement(node: ts.BindingElement, context: Context): ResolvedValue {\n    const path: ts.BindingElement[] = [];\n    let closestDeclaration: ts.Node = node;\n\n    while (ts.isBindingElement(closestDeclaration) ||\n           ts.isArrayBindingPattern(closestDeclaration) ||\n           ts.isObjectBindingPattern(closestDeclaration)) {\n      if (ts.isBindingElement(closestDeclaration)) {\n        path.unshift(closestDeclaration);\n      }\n\n      closestDeclaration = closestDeclaration.parent;\n    }\n\n    if (!ts.isVariableDeclaration(closestDeclaration) ||\n        closestDeclaration.initializer === undefined) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    let value = this.visit(closestDeclaration.initializer, context);\n    for (const element of path) {\n      let key: number|string;\n      if (ts.isArrayBindingPattern(element.parent)) {\n        key = element.parent.elements.indexOf(element);\n      } else {\n        const name = element.propertyName || element.name;\n        if (ts.isIdentifier(name)) {\n          key = name.text;\n        } else {\n          return DynamicValue.fromUnknown(element);\n        }\n      }\n      value = this.accessHelper(element, value, key, context);\n      if (value instanceof DynamicValue) {\n        return value;\n      }\n    }\n\n    return value;\n  }\n\n  private stringNameFromPropertyName(node: ts.PropertyName, context: Context): string|undefined {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else if (ts.isComputedPropertyName(node)) {\n      const literal = this.visitExpression(node.expression, context);\n      return typeof literal === 'string' ? literal : undefined;\n    } else {\n      return undefined;\n    }\n  }\n\n  private getReference<T extends DeclarationNode>(node: T, context: Context): Reference<T> {\n    return new Reference(node, owningModule(context));\n  }\n\n  private visitType(node: ts.TypeNode, context: Context): ResolvedValue {\n    if (ts.isLiteralTypeNode(node)) {\n      return this.visitExpression(node.literal, context);\n    } else if (ts.isTupleTypeNode(node)) {\n      return this.visitTupleType(node, context);\n    } else if (ts.isNamedTupleMember(node)) {\n      return this.visitType(node.type, context);\n    } else if (ts.isTypeOperatorNode(node) && node.operator === ts.SyntaxKind.ReadonlyKeyword) {\n      return this.visitType(node.type, context);\n    } else if (ts.isTypeQueryNode(node)) {\n      return this.visitTypeQuery(node, context);\n    }\n\n    return DynamicValue.fromDynamicType(node);\n  }\n\n  private visitTupleType(node: ts.TupleTypeNode, context: Context): ResolvedValueArray {\n    const res: ResolvedValueArray = [];\n\n    for (const elem of node.elements) {\n      res.push(this.visitType(elem, context));\n    }\n\n    return res;\n  }\n\n  private visitTypeQuery(node: ts.TypeQueryNode, context: Context): ResolvedValue {\n    if (!ts.isIdentifier(node.exprName)) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    const decl = this.host.getDeclarationOfIdentifier(node.exprName);\n    if (decl === null) {\n      return DynamicValue.fromUnknownIdentifier(node.exprName);\n    }\n\n    const declContext: Context = {...context, ...joinModuleContext(context, node, decl)};\n    return this.visitDeclaration(decl.node, declContext);\n  }\n}\n\nfunction isFunctionOrMethodReference(ref: Reference<ts.Node>):\n    ref is Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression> {\n  return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) ||\n      ts.isFunctionExpression(ref.node);\n}\n\nfunction literal(\n    value: ResolvedValue, reject: (value: ResolvedValue) => ResolvedValue): ResolvedValue {\n  if (value instanceof EnumValue) {\n    value = value.resolved;\n  }\n  if (value instanceof DynamicValue || value === null || value === undefined ||\n      typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n  return reject(value);\n}\n\nfunction isVariableDeclarationDeclared(node: ts.VariableDeclaration): boolean {\n  if (node.parent === undefined || !ts.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n  const declList = node.parent;\n  if (declList.parent === undefined || !ts.isVariableStatement(declList.parent)) {\n    return false;\n  }\n  const varStmt = declList.parent;\n  const modifiers = ts.getModifiers(varStmt);\n  return modifiers !== undefined &&\n      modifiers.some(mod => mod.kind === ts.SyntaxKind.DeclareKeyword);\n}\n\nconst EMPTY = {};\n\nfunction joinModuleContext(existing: Context, node: ts.Node, decl: Declaration): {\n  absoluteModuleName?: string,\n  resolutionContext?: string,\n} {\n  if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n    return {\n      absoluteModuleName: decl.viaModule,\n      resolutionContext: node.getSourceFile().fileName,\n    };\n  } else {\n    return EMPTY;\n  }\n}\n\nfunction owningModule(context: Context, override: OwningModule|null = null): OwningModule|null {\n  let specifier = context.absoluteModuleName;\n  if (override !== null) {\n    specifier = override.specifier;\n  }\n  if (specifier !== null) {\n    return {\n      specifier,\n      resolutionContext: context.resolutionContext,\n    };\n  } else {\n    return null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {DynamicValue} from './dynamic';\nimport {EnumValue, KnownFn, ResolvedValue, ResolvedValueArray} from './result';\n\nexport class ArraySliceBuiltinFn extends KnownFn {\n  constructor(private lhs: ResolvedValueArray) {\n    super();\n  }\n\n  override evaluate(node: ts.CallExpression, args: ResolvedValueArray): ResolvedValue {\n    if (args.length === 0) {\n      return this.lhs;\n    } else {\n      return DynamicValue.fromUnknown(node);\n    }\n  }\n}\n\nexport class ArrayConcatBuiltinFn extends KnownFn {\n  constructor(private lhs: ResolvedValueArray) {\n    super();\n  }\n\n  override evaluate(node: ts.CallExpression, args: ResolvedValueArray): ResolvedValue {\n    const result: ResolvedValueArray = [...this.lhs];\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n    return result;\n  }\n}\n\nexport class StringConcatBuiltinFn extends KnownFn {\n  constructor(private lhs: string) {\n    super();\n  }\n\n  override evaluate(node: ts.CallExpression, args: ResolvedValueArray): ResolvedValue {\n    let result = this.lhs;\n    for (const arg of args) {\n      const resolved = arg instanceof EnumValue ? arg.resolved : arg;\n\n      if (typeof resolved === 'string' || typeof resolved === 'number' ||\n          typeof resolved === 'boolean' || resolved == null) {\n        // Cast to `any`, because `concat` will convert\n        // anything to a string, but TS only allows strings.\n        result = result.concat(resolved as any);\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return result;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A value produced which originated in a `ForeignFunctionResolver` and doesn't come from the\n * template itself.\n *\n * Synthetic values cannot be further evaluated, and attempts to do so produce `DynamicValue`s\n * instead.\n */\nexport class SyntheticValue<T> {\n  constructor(readonly value: T) {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {DependencyTracker} from '../../incremental/api';\nimport {ReflectionHost} from '../../reflection';\n\nimport {DynamicValue} from './dynamic';\nimport {StaticInterpreter} from './interpreter';\nimport {ResolvedValue} from './result';\n\nexport type ForeignFunctionResolver =\n    (fn: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>,\n     callExpr: ts.CallExpression, resolve: (expr: ts.Expression) => ResolvedValue,\n     unresolvable: DynamicValue) => ResolvedValue;\n\nexport class PartialEvaluator {\n  constructor(\n      private host: ReflectionHost, private checker: ts.TypeChecker,\n      private dependencyTracker: DependencyTracker|null) {}\n\n  evaluate(expr: ts.Expression, foreignFunctionResolver?: ForeignFunctionResolver): ResolvedValue {\n    const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);\n    const sourceFile = expr.getSourceFile();\n    return interpreter.visit(expr, {\n      originatingFile: sourceFile,\n      absoluteModuleName: null,\n      resolutionContext: sourceFile.fileName,\n      scope: new Map<ts.ParameterDeclaration, ResolvedValue>(),\n      foreignFunctionResolver,\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../../diagnostics';\nimport {Reference} from '../../../imports';\nimport {EnumValue, PartialEvaluator, ResolvedValue} from '../../../partial_evaluator';\nimport {ClassDeclaration, Decorator} from '../../../reflection';\n\nimport {createValueHasWrongTypeError} from './diagnostics';\nimport {isAngularCoreReference, unwrapExpression} from './util';\n\n\nexport function resolveEnumValue(\n    evaluator: PartialEvaluator, metadata: Map<string, ts.Expression>, field: string,\n    enumSymbolName: string): number|null {\n  let resolved: number|null = null;\n  if (metadata.has(field)) {\n    const expr = metadata.get(field)!;\n    const value = evaluator.evaluate(expr) as any;\n    if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n      resolved = value.resolved as number;\n    } else {\n      throw createValueHasWrongTypeError(\n          expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n    }\n  }\n  return resolved;\n}\n\n/** Determines if the result of an evaluation is a string array. */\nexport function isStringArray(resolvedValue: ResolvedValue): resolvedValue is string[] {\n  return Array.isArray(resolvedValue) && resolvedValue.every(elem => typeof elem === 'string');\n}\n\nexport function isClassReferenceArray(resolvedValue: ResolvedValue):\n    resolvedValue is Reference<ClassDeclaration>[] {\n  return Array.isArray(resolvedValue) &&\n      resolvedValue.every(elem => elem instanceof Reference && ts.isClassDeclaration(elem.node));\n}\n\nexport function isArray(value: ResolvedValue): value is Array<ResolvedValue> {\n  return Array.isArray(value);\n}\n\nexport function resolveLiteral(\n    decorator: Decorator,\n    literalCache: Map<Decorator, ts.ObjectLiteralExpression>): ts.ObjectLiteralExpression {\n  if (literalCache.has(decorator)) {\n    return literalCache.get(decorator)!;\n  }\n  if (decorator.args === null || decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, decorator.node,\n        `Incorrect number of arguments to @${decorator.name} decorator`);\n  }\n  const meta = unwrapExpression(decorator.args[0]);\n\n  if (!ts.isObjectLiteralExpression(meta)) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);\n  }\n\n  literalCache.set(decorator, meta);\n  return meta;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileDeclareFactoryFunction, compileFactoryFunction, R3FactoryMetadata} from '@angular/compiler';\n\nimport {CompileResult} from '../../../transform';\n\nexport type CompileFactoryFn = (metadata: R3FactoryMetadata) => CompileResult;\n\nexport function compileNgFactoryDefField(metadata: R3FactoryMetadata): CompileResult {\n  const res = compileFactoryFunction(metadata);\n  return {name: 'Éµfac', initializer: res.expression, statements: res.statements, type: res.type};\n}\n\nexport function compileDeclareFactory(metadata: R3FactoryMetadata): CompileResult {\n  const res = compileDeclareFactoryFunction(metadata);\n  return {name: 'Éµfac', initializer: res.expression, statements: res.statements, type: res.type};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {R3DependencyMetadata} from '@angular/compiler';\n\nimport {hasInjectableFields} from '../../../metadata';\nimport {ClassDeclaration, ReflectionHost} from '../../../reflection';\n\nimport {getConstructorDependencies, unwrapConstructorDependencies} from './di';\n\n\nexport interface InjectableMeta {\n  ctorDeps: R3DependencyMetadata[]|'invalid'|null;\n}\n\n/**\n * Registry that keeps track of classes that can be constructed via dependency injection (e.g.\n * injectables, directives, pipes).\n */\nexport class InjectableClassRegistry {\n  private classes = new Map<ClassDeclaration, InjectableMeta>();\n\n  constructor(private host: ReflectionHost, private isCore: boolean) {}\n\n  registerInjectable(declaration: ClassDeclaration, meta: InjectableMeta): void {\n    this.classes.set(declaration, meta);\n  }\n\n  getInjectableMeta(declaration: ClassDeclaration): InjectableMeta|null {\n    // Figure out whether the class is injectable based on the registered classes, otherwise\n    // fall back to looking at its members since we might not have been able to register the class\n    // if it was compiled in another compilation unit.\n    if (this.classes.has(declaration)) {\n      return this.classes.get(declaration)!;\n    }\n\n    if (!hasInjectableFields(declaration, this.host)) {\n      return null;\n    }\n\n    const ctorDeps = getConstructorDependencies(declaration, this.host, this.isCore);\n    const meta: InjectableMeta = {\n      ctorDeps: unwrapConstructorDependencies(ctorDeps),\n    };\n    this.classes.set(declaration, meta);\n    return meta;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, FunctionExpr, LiteralArrayExpr, LiteralExpr, literalMap, R3ClassMetadata, ReturnStatement, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {CtorParameter, DeclarationNode, Decorator, ReflectionHost, TypeValueReferenceKind} from '../../../reflection';\n\nimport {valueReferenceToExpression, wrapFunctionExpressionsInParens} from './util';\n\n/**\n * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata\n * present on the class or its member fields. An ngDevMode guard is used to allow the call to be\n * tree-shaken away, as the `setClassMetadata` invocation is only needed for testing purposes.\n *\n * If no such metadata is present, this function returns `null`. Otherwise, the call is returned\n * as a `Statement` for inclusion along with the class.\n */\nexport function extractClassMetadata(\n    clazz: DeclarationNode, reflection: ReflectionHost, isCore: boolean,\n    annotateForClosureCompiler?: boolean,\n    angularDecoratorTransform: (dec: Decorator) => Decorator = dec => dec): R3ClassMetadata|null {\n  if (!reflection.isClass(clazz)) {\n    return null;\n  }\n  const id = clazz.name;\n\n  // Reflect over the class decorators. If none are present, or those that are aren't from\n  // Angular, then return null. Otherwise, turn them into metadata.\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n  if (classDecorators === null) {\n    return null;\n  }\n  const ngClassDecorators =\n      classDecorators.filter(dec => isAngularDecorator(dec, isCore))\n          .map(\n              decorator => decoratorToMetadata(\n                  angularDecoratorTransform(decorator), annotateForClosureCompiler))\n          // Since the `setClassMetadata` call is intended to be emitted after the class\n          // declaration, we have to strip references to the existing identifiers or\n          // TypeScript might generate invalid code when it emits to JS. In particular\n          // this can break when emitting a class to ES5 which has a custom decorator\n          // and is referenced inside of its own metadata (see #39509 for more information).\n          .map(decorator => removeIdentifierReferences(decorator, id.text));\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n  const metaDecorators =\n      new WrappedNodeExpr(ts.factory.createArrayLiteralExpression(ngClassDecorators));\n\n  // Convert the constructor parameters to metadata, passing null if none are present.\n  let metaCtorParameters: Expression|null = null;\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n  if (classCtorParameters !== null) {\n    const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, isCore));\n    metaCtorParameters = new FunctionExpr([], [\n      new ReturnStatement(new LiteralArrayExpr(ctorParameters)),\n    ]);\n  }\n\n  // Do the same for property decorators.\n  let metaPropDecorators: Expression|null = null;\n  const classMembers = reflection.getMembersOfClass(clazz).filter(\n      member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);\n  const duplicateDecoratedMemberNames =\n      classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);\n  if (duplicateDecoratedMemberNames.length > 0) {\n    // This should theoretically never happen, because the only way to have duplicate instance\n    // member names is getter/setter pairs and decorators cannot appear in both a getter and the\n    // corresponding setter.\n    throw new Error(\n        `Duplicate decorated properties found on class '${clazz.name.text}': ` +\n        duplicateDecoratedMemberNames.join(', '));\n  }\n  const decoratedMembers = classMembers.map(\n      member => classMemberToMetadata(member.nameNode ?? member.name, member.decorators!, isCore));\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators =\n        new WrappedNodeExpr(ts.factory.createObjectLiteralExpression(decoratedMembers));\n  }\n\n  return {\n    type: new WrappedNodeExpr(id),\n    decorators: metaDecorators,\n    ctorParameters: metaCtorParameters,\n    propDecorators: metaPropDecorators,\n  };\n}\n\n/**\n * Convert a reflected constructor parameter to metadata.\n */\nfunction ctorParameterToMetadata(param: CtorParameter, isCore: boolean): Expression {\n  // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise\n  // its type is undefined.\n  const type = param.typeValueReference.kind !== TypeValueReferenceKind.UNAVAILABLE ?\n      valueReferenceToExpression(param.typeValueReference) :\n      new LiteralExpr(undefined);\n\n  const mapEntries: {key: string, value: Expression, quoted: false}[] = [\n    {key: 'type', value: type, quoted: false},\n  ];\n\n  // If the parameter has decorators, include the ones from Angular.\n  if (param.decorators !== null) {\n    const ngDecorators = param.decorators.filter(dec => isAngularDecorator(dec, isCore))\n                             .map((decorator: Decorator) => decoratorToMetadata(decorator));\n    const value = new WrappedNodeExpr(ts.factory.createArrayLiteralExpression(ngDecorators));\n    mapEntries.push({key: 'decorators', value, quoted: false});\n  }\n  return literalMap(mapEntries);\n}\n\n/**\n * Convert a reflected class member to metadata.\n */\nfunction classMemberToMetadata(\n    name: ts.PropertyName|string, decorators: Decorator[], isCore: boolean): ts.PropertyAssignment {\n  const ngDecorators = decorators.filter(dec => isAngularDecorator(dec, isCore))\n                           .map((decorator: Decorator) => decoratorToMetadata(decorator));\n  const decoratorMeta = ts.factory.createArrayLiteralExpression(ngDecorators);\n  return ts.factory.createPropertyAssignment(name, decoratorMeta);\n}\n\n/**\n * Convert a reflected decorator to metadata.\n */\nfunction decoratorToMetadata(\n    decorator: Decorator, wrapFunctionsInParens?: boolean): ts.ObjectLiteralExpression {\n  if (decorator.identifier === null) {\n    throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');\n  }\n  // Decorators have a type.\n  const properties: ts.ObjectLiteralElementLike[] = [\n    ts.factory.createPropertyAssignment('type', decorator.identifier),\n  ];\n  // Sometimes they have arguments.\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map(arg => {\n      return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(arg) : arg;\n    });\n    properties.push(\n        ts.factory.createPropertyAssignment('args', ts.factory.createArrayLiteralExpression(args)));\n  }\n  return ts.factory.createObjectLiteralExpression(properties, true);\n}\n\n/**\n * Whether a given decorator should be treated as an Angular decorator.\n *\n * Either it's used in @angular/core, or it's imported from there.\n */\nfunction isAngularDecorator(decorator: Decorator, isCore: boolean): boolean {\n  return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');\n}\n\n/**\n * Recursively recreates all of the `Identifier` descendant nodes with a particular name inside\n * of an AST node, thus removing any references to them. Useful if a particular node has to be\n * taken from one place any emitted to another one exactly as it has been written.\n */\nfunction removeIdentifierReferences<T extends ts.Node>(node: T, name: string): T {\n  const result =\n      ts.transform(node, [context => root => ts.visitNode(root, function walk(current: ts.Node): T {\n                     return (ts.isIdentifier(current) && current.text === name ?\n                                 ts.factory.createIdentifier(current.text) :\n                                 ts.visitEachChild(current, walk, context)) as T;\n                   }) as T]);\n\n  return result.transformed[0];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../../imports';\nimport {DeclarationNode} from '../../../reflection';\n\n/**\n * Implement this interface if you want DecoratorHandlers to register\n * references that they find in their analysis of the code.\n */\nexport interface ReferencesRegistry {\n  /**\n   * Register one or more references in the registry.\n   * @param references A collection of references to register.\n   */\n  add(source: DeclarationNode, ...references: Reference<DeclarationNode>[]): void;\n}\n\n/**\n * This registry does nothing.\n */\nexport class NoopReferencesRegistry implements ReferencesRegistry {\n  add(source: DeclarationNode, ...references: Reference<DeclarationNode>[]): void {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Reference} from '../../../imports';\nimport {PartialEvaluator} from '../../../partial_evaluator';\n\nimport {createValueHasWrongTypeError} from './diagnostics';\n\nexport function extractSchemas(\n    rawExpr: ts.Expression, evaluator: PartialEvaluator, context: string): SchemaMetadata[] {\n  const schemas: SchemaMetadata[] = [];\n  const result = evaluator.evaluate(rawExpr);\n  if (!Array.isArray(result)) {\n    throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array`);\n  }\n\n  for (const schemaRef of result) {\n    if (!(schemaRef instanceof Reference)) {\n      throw createValueHasWrongTypeError(\n          rawExpr, result, `${context}.schemas must be an array of schemas`);\n    }\n    const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n    if (id === null || schemaRef.ownedByModuleGuess !== '@angular/core') {\n      throw createValueHasWrongTypeError(\n          rawExpr, result, `${context}.schemas must be an array of schemas`);\n    }\n    // Since `id` is the `ts.Identifier` within the schema ref's declaration file, it's safe to\n    // use `id.text` here to figure out which schema is in use. Even if the actual reference was\n    // renamed when the user imported it, these names will match.\n    switch (id.text) {\n      case 'CUSTOM_ELEMENTS_SCHEMA':\n        schemas.push(CUSTOM_ELEMENTS_SCHEMA);\n        break;\n      case 'NO_ERRORS_SCHEMA':\n        schemas.push(NO_ERRORS_SCHEMA);\n        break;\n      default:\n        throw createValueHasWrongTypeError(\n            rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid ${context} schema`);\n    }\n  }\n  return schemas;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationTriggerNames, compileClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, ConstantPool, CssSelector, DeclarationListEmitMode, DeclareComponentTemplateInfo, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, Expression, FactoryTarget, makeBindingParser, R3ComponentMetadata, R3DirectiveDependencyMetadata, R3NgModuleDependencyMetadata, R3PipeDependencyMetadata, R3TargetBinder, R3TemplateDependency, R3TemplateDependencyKind, R3TemplateDependencyMetadata, SchemaMetadata, SelectorMatcher, ViewEncapsulation, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Cycle, CycleAnalyzer, CycleHandlingStrategy} from '../../../cycles';\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../../diagnostics';\nimport {absoluteFrom, relative} from '../../../file_system';\nimport {assertSuccessfulReferenceEmit, ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../../imports';\nimport {DependencyTracker} from '../../../incremental/api';\nimport {extractSemanticTypeParameters, SemanticDepGraphUpdater} from '../../../incremental/semantic_graph';\nimport {IndexingContext} from '../../../indexer';\nimport {DirectiveMeta, extractDirectiveTypeCheckMeta, HostDirectivesResolver, MatchSource, MetadataReader, MetadataRegistry, MetaKind, PipeMeta, ResourceRegistry} from '../../../metadata';\nimport {PartialEvaluator} from '../../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../../perf';\nimport {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost, reflectObjectLiteral} from '../../../reflection';\nimport {ComponentScopeKind, ComponentScopeReader, DtsModuleScopeResolver, LocalModuleScopeRegistry, makeNotStandaloneDiagnostic, makeUnknownComponentImportDiagnostic, TypeCheckScopeRegistry} from '../../../scope';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../../transform';\nimport {TypeCheckableDirectiveMeta, TypeCheckContext} from '../../../typecheck/api';\nimport {ExtendedTemplateChecker} from '../../../typecheck/extended/api';\nimport {getSourceFile} from '../../../util/src/typescript';\nimport {Xi18nContext} from '../../../xi18n';\nimport {combineResolvers, compileDeclareFactory, compileNgFactoryDefField, compileResults, extractClassMetadata, extractSchemas, findAngularDecorator, forwardRefResolver, getDirectiveDiagnostics, getProviderDiagnostics, InjectableClassRegistry, isExpressionForwardReference, readBaseClass, ReferencesRegistry, resolveEnumValue, resolveImportedFile, resolveLiteral, resolveProvidersRequiringFactory, ResourceLoader, toFactoryMetadata, validateHostDirectives, wrapFunctionExpressionsInParens,} from '../../common';\nimport {extractDirectiveMetadata, parseFieldStringArrayValue} from '../../directive';\nimport {createModuleWithProvidersResolver, NgModuleSymbol} from '../../ng_module';\n\nimport {checkCustomElementSelectorForErrors, makeCyclicImportInfo} from './diagnostics';\nimport {ComponentAnalysisData, ComponentResolutionData} from './metadata';\nimport {_extractTemplateStyleUrls, extractComponentStyleUrls, extractStyleResources, extractTemplate, makeResourceNotFoundError, ParsedTemplateWithSource, parseTemplateDeclaration, preloadAndParseTemplate, ResourceTypeForDiagnostics, StyleUrlMeta, transformDecoratorResources} from './resources';\nimport {ComponentSymbol} from './symbol';\nimport {animationTriggerResolver, collectAnimationNames, validateAndFlattenComponentImports} from './util';\n\nconst EMPTY_ARRAY: any[] = [];\n\n/**\n * `DecoratorHandler` which handles the `@Component` annotation.\n */\nexport class ComponentDecoratorHandler implements\n    DecoratorHandler<Decorator, ComponentAnalysisData, ComponentSymbol, ComponentResolutionData> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaRegistry: MetadataRegistry, private metaReader: MetadataReader,\n      private scopeReader: ComponentScopeReader, private dtsScopeReader: DtsModuleScopeResolver,\n      private scopeRegistry: LocalModuleScopeRegistry,\n      private typeCheckScopeRegistry: TypeCheckScopeRegistry,\n      private resourceRegistry: ResourceRegistry, private isCore: boolean,\n      private strictCtorDeps: boolean, private resourceLoader: ResourceLoader,\n      private rootDirs: ReadonlyArray<string>, private defaultPreserveWhitespaces: boolean,\n      private i18nUseExternalIds: boolean, private enableI18nLegacyMessageIdFormat: boolean,\n      private usePoisonedData: boolean, private i18nNormalizeLineEndingsInICUs: boolean,\n      private moduleResolver: ModuleResolver, private cycleAnalyzer: CycleAnalyzer,\n      private cycleHandlingStrategy: CycleHandlingStrategy, private refEmitter: ReferenceEmitter,\n      private referencesRegistry: ReferencesRegistry, private depTracker: DependencyTracker|null,\n      private injectableRegistry: InjectableClassRegistry,\n      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n      private annotateForClosureCompiler: boolean, private perf: PerfRecorder,\n      private hostDirectivesResolver: HostDirectivesResolver) {\n    this.extractTemplateOptions = {\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,\n      usePoisonedData: this.usePoisonedData,\n    };\n  }\n\n  private literalCache = new Map<Decorator, ts.ObjectLiteralExpression>();\n  private elementSchemaRegistry = new DomElementSchemaRegistry();\n\n  /**\n   * During the asynchronous preanalyze phase, it's necessary to parse the template to extract\n   * any potential <link> tags which might need to be loaded. This cache ensures that work is not\n   * thrown away, and the parsed template is reused during the analyze phase.\n   */\n  private preanalyzeTemplateCache = new Map<DeclarationNode, ParsedTemplateWithSource>();\n  private preanalyzeStylesCache = new Map<DeclarationNode, string[]|null>();\n\n  private extractTemplateOptions: {\n    enableI18nLegacyMessageIdFormat: boolean; i18nNormalizeLineEndingsInICUs: boolean;\n    usePoisonedData: boolean;\n  };\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = ComponentDecoratorHandler.name;\n\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'Component', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  preanalyze(node: ClassDeclaration, decorator: Readonly<Decorator>): Promise<void>|undefined {\n    // In preanalyze, resource URLs associated with the component are asynchronously preloaded via\n    // the resourceLoader. This is the only time async operations are allowed for a component.\n    // These resources are:\n    //\n    // - the templateUrl, if there is one\n    // - any styleUrls if present\n    // - any stylesheets referenced from <link> tags in the template itself\n    //\n    // As a result of the last one, the template must be parsed as part of preanalysis to extract\n    // <link> tags, which may involve waiting for the templateUrl to be resolved first.\n\n    // If preloading isn't possible, then skip this step.\n    if (!this.resourceLoader.canPreload) {\n      return undefined;\n    }\n\n    const meta = resolveLiteral(decorator, this.literalCache);\n    const component = reflectObjectLiteral(meta);\n    const containingFile = node.getSourceFile().fileName;\n\n    const resolveStyleUrl = (styleUrl: string): Promise<void>|undefined => {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n        return this.resourceLoader.preload(resourceUrl, {type: 'style', containingFile});\n      } catch {\n        // Don't worry about failures to preload. We can handle this problem during analysis by\n        // producing a diagnostic.\n        return undefined;\n      }\n    };\n\n    // A Promise that waits for the template and all <link>ed styles within it to be preloaded.\n    const templateAndTemplateStyleResources =\n        preloadAndParseTemplate(\n            this.evaluator, this.resourceLoader, this.depTracker, this.preanalyzeTemplateCache,\n            node, decorator, component, containingFile, this.defaultPreserveWhitespaces,\n            this.extractTemplateOptions)\n            .then((template: ParsedTemplateWithSource|null): Promise<void>|undefined => {\n              if (template === null) {\n                return undefined;\n              }\n\n              return Promise.all(template.styleUrls.map(styleUrl => resolveStyleUrl(styleUrl)))\n                  .then(() => undefined);\n            });\n\n    // Extract all the styleUrls in the decorator.\n    const componentStyleUrls = extractComponentStyleUrls(this.evaluator, component);\n\n    // Extract inline styles, process, and cache for use in synchronous analyze phase\n    let inlineStyles;\n    if (component.has('styles')) {\n      const litStyles = parseFieldStringArrayValue(component, 'styles', this.evaluator);\n      if (litStyles === null) {\n        this.preanalyzeStylesCache.set(node, null);\n      } else {\n        inlineStyles = Promise\n                           .all(litStyles.map(\n                               style => this.resourceLoader.preprocessInline(\n                                   style, {type: 'style', containingFile})))\n                           .then(styles => {\n                             this.preanalyzeStylesCache.set(node, styles);\n                           });\n      }\n    } else {\n      this.preanalyzeStylesCache.set(node, null);\n    }\n\n    // Wait for both the template and all styleUrl resources to resolve.\n    return Promise\n        .all([\n          templateAndTemplateStyleResources, inlineStyles,\n          ...componentStyleUrls.map(styleUrl => resolveStyleUrl(styleUrl.url))\n        ])\n        .then(() => undefined);\n  }\n\n  analyze(\n      node: ClassDeclaration, decorator: Readonly<Decorator>,\n      flags: HandlerFlags = HandlerFlags.NONE): AnalysisOutput<ComponentAnalysisData> {\n    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n    const containingFile = node.getSourceFile().fileName;\n    this.literalCache.delete(decorator);\n\n    let diagnostics: ts.Diagnostic[]|undefined;\n    let isPoisoned = false;\n    // @Component inherits @Directive, so begin by extracting the @Directive metadata and building\n    // on it.\n    const directiveResult = extractDirectiveMetadata(\n        node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry,\n        this.isCore, flags, this.annotateForClosureCompiler,\n        this.elementSchemaRegistry.getDefaultComponentElementName());\n    if (directiveResult === undefined) {\n      // `extractDirectiveMetadata` returns undefined when the @Directive has `jit: true`. In this\n      // case, compilation of the decorator is skipped. Returning an empty object signifies\n      // that no analysis was produced.\n      return {};\n    }\n\n    // Next, read the `@Component`-specific fields.\n    const {decorator: component, metadata, inputs, outputs, hostDirectives, rawHostDirectives} =\n        directiveResult;\n    const encapsulation: number =\n        resolveEnumValue(this.evaluator, component, 'encapsulation', 'ViewEncapsulation') ??\n        ViewEncapsulation.Emulated;\n    const changeDetection: number|null =\n        resolveEnumValue(this.evaluator, component, 'changeDetection', 'ChangeDetectionStrategy');\n\n    let animations: Expression|null = null;\n    let animationTriggerNames: AnimationTriggerNames|null = null;\n    if (component.has('animations')) {\n      const animationExpression = component.get('animations')!;\n      animations = new WrappedNodeExpr(animationExpression);\n      const animationsValue =\n          this.evaluator.evaluate(animationExpression, animationTriggerResolver);\n      animationTriggerNames = {includesDynamicAnimations: false, staticTriggerNames: []};\n      collectAnimationNames(animationsValue, animationTriggerNames);\n    }\n\n    // Go through the root directories for this project, and select the one with the smallest\n    // relative path representation.\n    const relativeContextFilePath = this.rootDirs.reduce<string|undefined>((previous, rootDir) => {\n      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));\n      if (previous === undefined || candidate.length < previous.length) {\n        return candidate;\n      } else {\n        return previous;\n      }\n    }, undefined)!;\n\n\n    // Note that we could technically combine the `viewProvidersRequiringFactory` and\n    // `providersRequiringFactory` into a single set, but we keep the separate so that\n    // we can distinguish where an error is coming from when logging the diagnostics in `resolve`.\n    let viewProvidersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n    let providersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n    let wrappedViewProviders: Expression|null = null;\n\n    if (component.has('viewProviders')) {\n      const viewProviders = component.get('viewProviders')!;\n      viewProvidersRequiringFactory =\n          resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n      wrappedViewProviders = new WrappedNodeExpr(\n          this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) :\n                                            viewProviders);\n    }\n\n    if (component.has('providers')) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(\n          component.get('providers')!, this.reflector, this.evaluator);\n    }\n\n    let resolvedImports: Reference<ClassDeclaration>[]|null = null;\n    let rawImports: ts.Expression|null = null;\n\n    if (component.has('imports') && !metadata.isStandalone) {\n      if (diagnostics === undefined) {\n        diagnostics = [];\n      }\n      diagnostics.push(makeDiagnostic(\n          ErrorCode.COMPONENT_NOT_STANDALONE, component.get('imports')!,\n          `'imports' is only valid on a component that is standalone.`,\n          [makeRelatedInformation(\n              node.name, `Did you forget to add 'standalone: true' to this @Component?`)]));\n      // Poison the component so that we don't spam further template type-checking errors that\n      // result from misconfigured imports.\n      isPoisoned = true;\n    } else if (component.has('imports')) {\n      const expr = component.get('imports')!;\n      const importResolvers = combineResolvers([\n        createModuleWithProvidersResolver(this.reflector, this.isCore),\n        forwardRefResolver,\n      ]);\n      const imported = this.evaluator.evaluate(expr, importResolvers);\n      const {imports: flattened, diagnostics: importDiagnostics} =\n          validateAndFlattenComponentImports(imported, expr);\n\n      resolvedImports = flattened;\n      rawImports = expr;\n\n      if (importDiagnostics.length > 0) {\n        isPoisoned = true;\n        if (diagnostics === undefined) {\n          diagnostics = [];\n        }\n        diagnostics.push(...importDiagnostics);\n      }\n    }\n\n    let schemas: SchemaMetadata[]|null = null;\n    if (component.has('schemas') && !metadata.isStandalone) {\n      if (diagnostics === undefined) {\n        diagnostics = [];\n      }\n      diagnostics.push(makeDiagnostic(\n          ErrorCode.COMPONENT_NOT_STANDALONE, component.get('schemas')!,\n          `'schemas' is only valid on a component that is standalone.`));\n    } else if (component.has('schemas')) {\n      schemas = extractSchemas(component.get('schemas')!, this.evaluator, 'Component');\n    } else if (metadata.isStandalone) {\n      schemas = [];\n    }\n\n    // Parse the template.\n    // If a preanalyze phase was executed, the template may already exist in parsed form, so check\n    // the preanalyzeTemplateCache.\n    // Extract a closure of the template parsing code so that it can be reparsed with different\n    // options if needed, like in the indexing pipeline.\n    let template: ParsedTemplateWithSource;\n    if (this.preanalyzeTemplateCache.has(node)) {\n      // The template was parsed in preanalyze. Use it and delete it to save memory.\n      const preanalyzed = this.preanalyzeTemplateCache.get(node)!;\n      this.preanalyzeTemplateCache.delete(node);\n\n      template = preanalyzed;\n    } else {\n      const templateDecl = parseTemplateDeclaration(\n          node, decorator, component, containingFile, this.evaluator, this.depTracker,\n          this.resourceLoader, this.defaultPreserveWhitespaces);\n      template = extractTemplate(\n          node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, {\n            enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n            i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,\n            usePoisonedData: this.usePoisonedData,\n          });\n    }\n    const templateResource =\n        template.declaration.isInline ? {path: null, expression: component.get('template')!} : {\n          path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n          expression: template.sourceMapping.node\n        };\n\n    // Figure out the set of styles. The ordering here is important: external resources (styleUrls)\n    // precede inline styles, and styles defined in the template override styles defined in the\n    // component.\n    let styles: string[] = [];\n\n    const styleResources = extractStyleResources(this.resourceLoader, component, containingFile);\n    const styleUrls: StyleUrlMeta[] = [\n      ...extractComponentStyleUrls(this.evaluator, component),\n      ..._extractTemplateStyleUrls(template)\n    ];\n\n    for (const styleUrl of styleUrls) {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n        const resourceStr = this.resourceLoader.load(resourceUrl);\n        styles.push(resourceStr);\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n        }\n      } catch {\n        if (this.depTracker !== null) {\n          // The analysis of this file cannot be re-used if one of the style URLs could\n          // not be resolved or loaded. Future builds should re-analyze and re-attempt\n          // resolution/loading.\n          this.depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n        }\n\n        if (diagnostics === undefined) {\n          diagnostics = [];\n        }\n        const resourceType =\n            styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n            ResourceTypeForDiagnostics.StylesheetFromDecorator :\n            ResourceTypeForDiagnostics.StylesheetFromTemplate;\n        diagnostics.push(\n            makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType)\n                .toDiagnostic());\n      }\n    }\n\n    if (encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null) {\n      const selectorError = checkCustomElementSelectorForErrors(metadata.selector);\n      if (selectorError !== null) {\n        if (diagnostics === undefined) {\n          diagnostics = [];\n        }\n        diagnostics.push(makeDiagnostic(\n            ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get('selector')!,\n            selectorError));\n      }\n    }\n\n    // If inline styles were preprocessed use those\n    let inlineStyles: string[]|null = null;\n    if (this.preanalyzeStylesCache.has(node)) {\n      inlineStyles = this.preanalyzeStylesCache.get(node)!;\n      this.preanalyzeStylesCache.delete(node);\n      if (inlineStyles !== null) {\n        styles.push(...inlineStyles);\n      }\n    } else {\n      // Preprocessing is only supported asynchronously\n      // If no style cache entry is present asynchronous preanalyze was not executed.\n      // This protects against accidental differences in resource contents when preanalysis\n      // is not used with a provided transformResource hook on the ResourceHost.\n      if (this.resourceLoader.canPreprocess) {\n        throw new Error('Inline resource processing requires asynchronous preanalyze.');\n      }\n\n      if (component.has('styles')) {\n        const litStyles = parseFieldStringArrayValue(component, 'styles', this.evaluator);\n        if (litStyles !== null) {\n          inlineStyles = [...litStyles];\n          styles.push(...litStyles);\n        }\n      }\n    }\n    if (template.styles.length > 0) {\n      styles.push(...template.styles);\n    }\n\n    const output: AnalysisOutput<ComponentAnalysisData> = {\n      analysis: {\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        inputs,\n        outputs,\n        hostDirectives,\n        rawHostDirectives,\n        meta: {\n          ...metadata,\n          template: {\n            nodes: template.nodes,\n            ngContentSelectors: template.ngContentSelectors,\n          },\n          encapsulation,\n          interpolation: template.interpolationConfig ?? DEFAULT_INTERPOLATION_CONFIG,\n          styles,\n\n          // These will be replaced during the compilation step, after all `NgModule`s have been\n          // analyzed and the full compilation scope for the component can be realized.\n          animations,\n          viewProviders: wrappedViewProviders,\n          i18nUseExternalIds: this.i18nUseExternalIds,\n          relativeContextFilePath,\n        },\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n        classMetadata: extractClassMetadata(\n            node, this.reflector, this.isCore, this.annotateForClosureCompiler,\n            dec => transformDecoratorResources(dec, component, styles, template)),\n        template,\n        providersRequiringFactory,\n        viewProvidersRequiringFactory,\n        inlineStyles,\n        styleUrls,\n        resources: {\n          styles: styleResources,\n          template: templateResource,\n        },\n        isPoisoned,\n        animationTriggerNames,\n        rawImports,\n        resolvedImports,\n        schemas,\n        decorator: decorator?.node as ts.Decorator | null ?? null,\n      },\n      diagnostics,\n    };\n    if (changeDetection !== null) {\n      output.analysis!.meta.changeDetection = changeDetection;\n    }\n    return output;\n  }\n\n  symbol(node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>): ComponentSymbol {\n    const typeParameters = extractSemanticTypeParameters(node);\n\n    return new ComponentSymbol(\n        node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs,\n        analysis.typeCheckMeta, typeParameters);\n  }\n\n  register(node: ClassDeclaration, analysis: ComponentAnalysisData): void {\n    // Register this component's information with the `MetadataRegistry`. This ensures that\n    // the information about the component is available during the compile() phase.\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: true,\n      baseClass: analysis.baseClass,\n      hostDirectives: analysis.hostDirectives,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: false,\n      isStandalone: analysis.meta.isStandalone,\n      imports: analysis.resolvedImports,\n      animationTriggerNames: analysis.animationTriggerNames,\n      schemas: analysis.schemas,\n      decorator: analysis.decorator,\n      assumedToExportProviders: false,\n    });\n\n    this.resourceRegistry.registerResources(analysis.resources, node);\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps,\n    });\n  }\n\n  index(\n      context: IndexingContext, node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>) {\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return null;\n    }\n    const scope = this.scopeReader.getScopeForComponent(node);\n    const selector = analysis.meta.selector;\n    const matcher = new SelectorMatcher<DirectiveMeta[]>();\n    if (scope !== null) {\n      let {dependencies, isPoisoned} =\n          scope.kind === ComponentScopeKind.NgModule ? scope.compilation : scope;\n      if ((isPoisoned ||\n           (scope.kind === ComponentScopeKind.NgModule && scope.exported.isPoisoned)) &&\n          !this.usePoisonedData) {\n        // Don't bother indexing components which had erroneous scopes, unless specifically\n        // requested.\n        return null;\n      }\n\n      for (const dep of dependencies) {\n        if (dep.kind === MetaKind.Directive && dep.selector !== null) {\n          matcher.addSelectables(\n              CssSelector.parse(dep.selector), [...this.hostDirectivesResolver.resolve(dep), dep]);\n        }\n      }\n    }\n    const binder = new R3TargetBinder(matcher);\n    const boundTemplate = binder.bind({template: analysis.template.diagNodes});\n\n    context.addComponent({\n      declaration: node,\n      selector,\n      boundTemplate,\n      templateMeta: {\n        isInline: analysis.template.declaration.isInline,\n        file: analysis.template.file,\n      },\n    });\n  }\n\n  typeCheck(ctx: TypeCheckContext, node: ClassDeclaration, meta: Readonly<ComponentAnalysisData>):\n      void {\n    if (this.typeCheckScopeRegistry === null || !ts.isClassDeclaration(node)) {\n      return;\n    }\n\n    if (meta.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n    if (scope.isPoisoned && !this.usePoisonedData) {\n      // Don't type-check components that had errors in their scopes, unless requested.\n      return;\n    }\n\n    const binder = new R3TargetBinder<TypeCheckableDirectiveMeta>(scope.matcher);\n    ctx.addTemplate(\n        new Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas,\n        meta.template.sourceMapping, meta.template.file, meta.template.errors,\n        meta.meta.isStandalone);\n  }\n\n  extendedTemplateCheck(\n      component: ts.ClassDeclaration,\n      extendedTemplateChecker: ExtendedTemplateChecker): ts.Diagnostic[] {\n    return extendedTemplateChecker.getDiagnosticsForComponent(component);\n  }\n\n  resolve(\n      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n      symbol: ComponentSymbol): ResolveResult<ComponentResolutionData> {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return {};\n    }\n\n    const context = getSourceFile(node);\n    const metadata = analysis.meta as Readonly<R3ComponentMetadata<R3TemplateDependencyMetadata>>;\n\n\n    const data: ComponentResolutionData = {\n      declarations: EMPTY_ARRAY,\n      declarationListEmitMode: DeclarationListEmitMode.Direct,\n    };\n    const diagnostics: ts.Diagnostic[] = [];\n\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope !== null) {\n      // Replace the empty components and directives from the analyze() step with a fully expanded\n      // scope. This is possible now because during resolve() the whole compilation unit has been\n      // fully analyzed.\n      //\n      // First it needs to be determined if actually importing the directives/pipes used in the\n      // template would create a cycle. Currently ngtsc refuses to generate cycles, so an option\n      // known as \"remote scoping\" is used if a cycle would be created. In remote scoping, the\n      // module file sets the directives/pipes on the Éµcmp of the component, without\n      // requiring new imports (but also in a way that breaks tree shaking).\n      //\n      // Determining this is challenging, because the TemplateDefinitionBuilder is responsible for\n      // matching directives and pipes in the template; however, that doesn't run until the actual\n      // compile() step. It's not possible to run template compilation sooner as it requires the\n      // ConstantPool for the overall file being compiled (which isn't available until the\n      // transform step).\n      //\n      // Instead, directives/pipes are matched independently here, using the R3TargetBinder. This\n      // is an alternative implementation of template matching which is used for template\n      // type-checking and will eventually replace matching in the TemplateDefinitionBuilder.\n\n      // Set up the R3TargetBinder, as well as a 'directives' array and a 'pipes' map that are\n      // later fed to the TemplateDefinitionBuilder. First, a SelectorMatcher is constructed to\n      // match directives that are in scope.\n      const matcher = new SelectorMatcher<DirectiveMeta[]>();\n\n      const pipes = new Map<string, PipeMeta>();\n\n      const dependencies = scope.kind === ComponentScopeKind.NgModule ?\n          scope.compilation.dependencies :\n          scope.dependencies;\n\n      for (const dep of dependencies) {\n        if (dep.kind === MetaKind.Directive && dep.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(dep.selector), [dep]);\n        } else if (dep.kind === MetaKind.Pipe) {\n          pipes.set(dep.name, dep);\n        }\n      }\n\n      // Next, the component template AST is bound using the R3TargetBinder. This produces a\n      // BoundTarget, which is similar to a ts.TypeChecker.\n      const binder = new R3TargetBinder(matcher);\n      const bound = binder.bind({template: metadata.template.nodes});\n\n      // The BoundTarget knows which directives and pipes matched the template.\n      type UsedDirective = R3DirectiveDependencyMetadata&\n          {ref: Reference<ClassDeclaration>, importedFile: ImportedFile};\n\n      const used = new Set<ClassDeclaration>();\n      for (const dir of bound.getUsedDirectives()) {\n        used.add(dir.ref.node);\n      }\n      for (const name of bound.getUsedPipes()) {\n        if (!pipes.has(name)) {\n          continue;\n        }\n        used.add(pipes.get(name)!.ref.node);\n      }\n\n      type UsedPipe = R3PipeDependencyMetadata&{\n        ref: Reference<ClassDeclaration>,\n        importedFile: ImportedFile,\n      };\n\n      type UsedNgModule = R3NgModuleDependencyMetadata&{\n        importedFile: ImportedFile,\n      };\n\n      const declarations: (UsedPipe|UsedDirective|UsedNgModule)[] = [];\n      const seen = new Set<ClassDeclaration>();\n\n      // Transform the dependencies list, filtering out unused dependencies.\n      for (const dep of dependencies) {\n        // Only emit references to each dependency once.\n        if (seen.has(dep.ref.node)) {\n          continue;\n        }\n        seen.add(dep.ref.node);\n\n        switch (dep.kind) {\n          case MetaKind.Directive:\n            if (!used.has(dep.ref.node) || dep.matchSource !== MatchSource.Selector) {\n              continue;\n            }\n            const dirType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(\n                dirType, node.name, dep.isComponent ? 'component' : 'directive');\n\n            declarations.push({\n              kind: R3TemplateDependencyKind.Directive,\n              ref: dep.ref,\n              type: dirType.expression,\n              importedFile: dirType.importedFile,\n              selector: dep.selector!,\n              inputs: dep.inputs.propertyNames,\n              outputs: dep.outputs.propertyNames,\n              exportAs: dep.exportAs,\n              isComponent: dep.isComponent,\n            });\n            break;\n          case MetaKind.Pipe:\n            if (!used.has(dep.ref.node)) {\n              continue;\n            }\n\n            const pipeType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(pipeType, node.name, 'pipe');\n\n            declarations.push({\n              kind: R3TemplateDependencyKind.Pipe,\n              type: pipeType.expression,\n              name: dep.name,\n              ref: dep.ref,\n              importedFile: pipeType.importedFile,\n            });\n            break;\n          case MetaKind.NgModule:\n            const ngModuleType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(ngModuleType, node.name, 'NgModule');\n\n            declarations.push({\n              kind: R3TemplateDependencyKind.NgModule,\n              type: ngModuleType.expression,\n              importedFile: ngModuleType.importedFile,\n            });\n            break;\n        }\n      }\n\n      const isUsedDirective = (decl: UsedDirective|UsedPipe|UsedNgModule): decl is UsedDirective =>\n          decl.kind === R3TemplateDependencyKind.Directive;\n      const isUsedPipe = (decl: UsedDirective|UsedPipe|UsedNgModule): decl is UsedPipe =>\n          decl.kind === R3TemplateDependencyKind.Pipe;\n\n      const getSemanticReference = (decl: UsedDirective|UsedPipe) =>\n          this.semanticDepGraphUpdater!.getSemanticReference(decl.ref.node, decl.type);\n\n      if (this.semanticDepGraphUpdater !== null) {\n        symbol.usedDirectives = declarations.filter(isUsedDirective).map(getSemanticReference);\n        symbol.usedPipes = declarations.filter(isUsedPipe).map(getSemanticReference);\n      }\n\n      const cyclesFromDirectives = new Map<UsedDirective, Cycle>();\n      const cyclesFromPipes = new Map<UsedPipe, Cycle>();\n\n      // Scan through the directives/pipes actually used in the template and check whether any\n      // import which needs to be generated would create a cycle. This check is skipped for\n      // standalone components as the dependencies of a standalone component have already been\n      // imported directly by the user, so Angular won't introduce any imports that aren't already\n      // in the user's program.\n      if (!metadata.isStandalone) {\n        for (const usedDep of declarations) {\n          const cycle = this._checkForCyclicImport(usedDep.importedFile, usedDep.type, context);\n          if (cycle !== null) {\n            switch (usedDep.kind) {\n              case R3TemplateDependencyKind.Directive:\n                cyclesFromDirectives.set(usedDep, cycle);\n                break;\n              case R3TemplateDependencyKind.Pipe:\n                cyclesFromPipes.set(usedDep, cycle);\n                break;\n            }\n          }\n        }\n      }\n      // Check whether any usages of standalone components in imports requires the dependencies\n      // array to be wrapped in a closure. This check is technically a heuristic as there's no\n      // direct way to check whether a `Reference` came from a `forwardRef`. Instead, we check if\n      // the reference is `synthetic`, implying it came from _any_ foreign function resolver,\n      // including the `forwardRef` resolver.\n      const standaloneImportMayBeForwardDeclared =\n          analysis.resolvedImports !== null && analysis.resolvedImports.some(ref => ref.synthetic);\n\n      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n      if (!cycleDetected) {\n        // No cycle was detected. Record the imports that need to be created in the cycle detector\n        // so that future cyclic import checks consider their production.\n        for (const {type, importedFile} of declarations) {\n          this.maybeRecordSyntheticImport(importedFile, type, context);\n        }\n\n        // Check whether the dependencies arrays in Éµcmp need to be wrapped in a closure.\n        // This is required if any dependency reference is to a declaration in the same file\n        // but declared after this component.\n        const declarationIsForwardDeclared =\n            declarations.some(decl => isExpressionForwardReference(decl.type, node.name, context));\n\n        const wrapDirectivesAndPipesInClosure =\n            declarationIsForwardDeclared || standaloneImportMayBeForwardDeclared;\n\n        data.declarations = declarations;\n        data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ?\n            DeclarationListEmitMode.Closure :\n            DeclarationListEmitMode.Direct;\n      } else {\n        if (this.cycleHandlingStrategy === CycleHandlingStrategy.UseRemoteScoping) {\n          // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would\n          // create a cycle. Instead, mark this component as requiring remote scoping, so that the\n          // NgModule file will take care of setting the directives for the component.\n          this.scopeRegistry.setComponentRemoteScope(\n              node, declarations.filter(isUsedDirective).map(dir => dir.ref),\n              declarations.filter(isUsedPipe).map(pipe => pipe.ref));\n          symbol.isRemotelyScoped = true;\n\n          // If a semantic graph is being tracked, record the fact that this component is remotely\n          // scoped with the declaring NgModule symbol as the NgModule's emit becomes dependent on\n          // the directive/pipe usages of this component.\n          if (this.semanticDepGraphUpdater !== null && scope.kind === ComponentScopeKind.NgModule &&\n              scope.ngModule !== null) {\n            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n              throw new Error(\n                  `AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n            }\n\n            moduleSymbol.addRemotelyScopedComponent(\n                symbol, symbol.usedDirectives, symbol.usedPipes);\n          }\n        } else {\n          // We are not able to handle this cycle so throw an error.\n          const relatedMessages: ts.DiagnosticRelatedInformation[] = [];\n          for (const [dir, cycle] of cyclesFromDirectives) {\n            relatedMessages.push(\n                makeCyclicImportInfo(dir.ref, dir.isComponent ? 'component' : 'directive', cycle));\n          }\n          for (const [pipe, cycle] of cyclesFromPipes) {\n            relatedMessages.push(makeCyclicImportInfo(pipe.ref, 'pipe', cycle));\n          }\n          throw new FatalDiagnosticError(\n              ErrorCode.IMPORT_CYCLE_DETECTED, node,\n              'One or more import cycles would need to be created to compile this component, ' +\n                  'which is not supported by the current compiler configuration.',\n              relatedMessages);\n        }\n      }\n    }\n\n    if (analysis.resolvedImports !== null && analysis.rawImports !== null) {\n      const standaloneDiagnostics = validateStandaloneImports(\n          analysis.resolvedImports, analysis.rawImports, this.metaReader, this.scopeReader);\n      diagnostics.push(...standaloneDiagnostics);\n    }\n\n    if (analysis.providersRequiringFactory !== null &&\n        analysis.meta.providers instanceof WrappedNodeExpr) {\n      const providerDiagnostics = getProviderDiagnostics(\n          analysis.providersRequiringFactory, analysis.meta.providers!.node,\n          this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    if (analysis.viewProvidersRequiringFactory !== null &&\n        analysis.meta.viewProviders instanceof WrappedNodeExpr) {\n      const viewProviderDiagnostics = getProviderDiagnostics(\n          analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders!.node,\n          this.injectableRegistry);\n      diagnostics.push(...viewProviderDiagnostics);\n    }\n\n    const directiveDiagnostics = getDirectiveDiagnostics(\n        node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry,\n        this.strictCtorDeps, 'Component');\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n\n    const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives ?\n        validateHostDirectives(\n            analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader) :\n        null;\n    if (hostDirectivesDiagnotics !== null) {\n      diagnostics.push(...hostDirectivesDiagnotics);\n    }\n\n    if (diagnostics.length > 0) {\n      return {diagnostics};\n    }\n\n    return {data};\n  }\n\n  xi18n(ctx: Xi18nContext, node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>):\n      void {\n    ctx.updateFromTemplate(\n        analysis.template.content, analysis.template.declaration.resolvedTemplateUrl,\n        analysis.template.interpolationConfig ?? DEFAULT_INTERPOLATION_CONFIG);\n  }\n\n  updateResources(node: ClassDeclaration, analysis: ComponentAnalysisData): void {\n    const containingFile = node.getSourceFile().fileName;\n\n    // If the template is external, re-parse it.\n    const templateDecl = analysis.template.declaration;\n    if (!templateDecl.isInline) {\n      analysis.template = extractTemplate(\n          node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader,\n          this.extractTemplateOptions);\n    }\n\n    // Update any external stylesheets and rebuild the combined 'styles' list.\n    // TODO(alxhub): write tests for styles when the primary compiler uses the updateResources\n    // path\n    let styles: string[] = [];\n    if (analysis.styleUrls !== null) {\n      for (const styleUrl of analysis.styleUrls) {\n        try {\n          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n          styles.push(styleText);\n        } catch (e) {\n          // Resource resolve failures should already be in the diagnostics list from the analyze\n          // stage. We do not need to do anything with them when updating resources.\n        }\n      }\n    }\n    if (analysis.inlineStyles !== null) {\n      for (const styleText of analysis.inlineStyles) {\n        styles.push(styleText);\n      }\n    }\n    for (const styleText of analysis.template.styles) {\n      styles.push(styleText);\n    }\n\n    analysis.meta.styles = styles.filter(s => s.trim().length > 0);\n  }\n\n  compileFull(\n      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n      resolution: Readonly<ComponentResolutionData>, pool: ConstantPool): CompileResult[] {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const meta: R3ComponentMetadata<R3TemplateDependency> = {...analysis.meta, ...resolution};\n    const fac = compileNgFactoryDefField(toFactoryMetadata(meta, FactoryTarget.Component));\n    const def = compileComponentFromMetadata(meta, pool, makeBindingParser());\n    const classMetadata = analysis.classMetadata !== null ?\n        compileClassMetadata(analysis.classMetadata).toStmt() :\n        null;\n    return compileResults(fac, def, classMetadata, 'Éµcmp');\n  }\n\n  compilePartial(\n      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n      resolution: Readonly<ComponentResolutionData>): CompileResult[] {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const templateInfo: DeclareComponentTemplateInfo = {\n      content: analysis.template.content,\n      sourceUrl: analysis.template.declaration.resolvedTemplateUrl,\n      isInline: analysis.template.declaration.isInline,\n      inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === 'direct' ?\n          new WrappedNodeExpr(analysis.template.sourceMapping.node) :\n          null,\n    };\n    const meta:\n        R3ComponentMetadata<R3TemplateDependencyMetadata> = {...analysis.meta, ...resolution};\n    const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget.Component));\n    const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);\n    const classMetadata = analysis.classMetadata !== null ?\n        compileDeclareClassMetadata(analysis.classMetadata).toStmt() :\n        null;\n    return compileResults(fac, def, classMetadata, 'Éµcmp');\n  }\n\n  /**\n   * Check whether adding an import from `origin` to the source-file corresponding to `expr` would\n   * create a cyclic import.\n   *\n   * @returns a `Cycle` object if a cycle would be created, otherwise `null`.\n   */\n  private _checkForCyclicImport(\n      importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile): Cycle|null {\n    const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);\n    if (imported === null) {\n      return null;\n    }\n    // Check whether the import is legal.\n    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n  }\n\n  private maybeRecordSyntheticImport(\n      importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile): void {\n    const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);\n    if (imported === null) {\n      return;\n    }\n\n    this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n  }\n}\n\nfunction validateStandaloneImports(\n    importRefs: Reference<ClassDeclaration>[], importExpr: ts.Expression,\n    metaReader: MetadataReader, scopeReader: ComponentScopeReader): ts.Diagnostic[] {\n  const diagnostics: ts.Diagnostic[] = [];\n  for (const ref of importRefs) {\n    const dirMeta = metaReader.getDirectiveMetadata(ref);\n    if (dirMeta !== null) {\n      if (!dirMeta.isStandalone) {\n        // Directly importing a directive that's not standalone is an error.\n        diagnostics.push(makeNotStandaloneDiagnostic(\n            scopeReader, ref, importExpr, dirMeta.isComponent ? 'component' : 'directive'));\n      }\n      continue;\n    }\n\n    const pipeMeta = metaReader.getPipeMetadata(ref);\n    if (pipeMeta !== null) {\n      if (!pipeMeta.isStandalone) {\n        diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, 'pipe'));\n      }\n      continue;\n    }\n\n    const ngModuleMeta = metaReader.getNgModuleMetadata(ref);\n    if (ngModuleMeta !== null) {\n      // Importing NgModules is always legal.\n      continue;\n    }\n\n    // Make an error?\n    diagnostics.push(makeUnknownComponentImportDiagnostic(ref, importExpr));\n  }\n\n  return diagnostics;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath} from '../../../file_system';\nimport {ClassDeclaration} from '../../../reflection';\n\n/**\n * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured\n * metadata to be compared to the prior compilation. This allows for semantic understanding of\n * the changes that have been made in a rebuild, which potentially enables more reuse of work\n * from the prior compilation.\n */\nexport abstract class SemanticSymbol {\n  /**\n   * The path of the file that declares this symbol.\n   */\n  public readonly path: AbsoluteFsPath;\n\n  /**\n   * The identifier of this symbol, or null if no identifier could be determined. It should\n   * uniquely identify the symbol relative to `file`. This is typically just the name of a\n   * top-level class declaration, as that uniquely identifies the class within the file.\n   *\n   * If the identifier is null, then this symbol cannot be recognized across rebuilds. In that\n   * case, the symbol is always assumed to have semantically changed to guarantee a proper\n   * rebuild.\n   */\n  public readonly identifier: string|null;\n\n  constructor(\n      /**\n       * The declaration for this symbol.\n       */\n      public readonly decl: ClassDeclaration,\n  ) {\n    this.path = absoluteFromSourceFile(decl.getSourceFile());\n    this.identifier = getSymbolIdentifier(decl);\n  }\n\n  /**\n   * Allows the symbol to be compared to the equivalent symbol in the previous compilation. The\n   * return value indicates whether the symbol has been changed in a way such that its public API\n   * is affected.\n   *\n   * This method determines whether a change to _this_ symbol require the symbols that\n   * use to this symbol to be re-emitted.\n   *\n   * Note: `previousSymbol` is obtained from the most recently succeeded compilation. Symbols of\n   * failed compilations are never provided.\n   *\n   * @param previousSymbol The symbol from a prior compilation.\n   */\n  abstract isPublicApiAffected(previousSymbol: SemanticSymbol): boolean;\n\n  /**\n   * Allows the symbol to determine whether its emit is affected. The equivalent symbol from a prior\n   * build is given, in addition to the set of symbols of which the public API has changed.\n   *\n   * This method determines whether a change to _other_ symbols, i.e. those present in\n   * `publicApiAffected`, should cause _this_ symbol to be re-emitted.\n   *\n   * @param previousSymbol The equivalent symbol from a prior compilation. Note that it may be a\n   * different type of symbol, if e.g. a Component was changed into a Directive with the same name.\n   * @param publicApiAffected The set of symbols of which the public API has changed.\n   */\n  isEmitAffected?(previousSymbol: SemanticSymbol, publicApiAffected: Set<SemanticSymbol>): boolean;\n\n  /**\n   * Similar to `isPublicApiAffected`, but here equivalent symbol from a prior compilation needs\n   * to be compared to see if the type-check block of components that use this symbol is affected.\n   *\n   * This method determines whether a change to _this_ symbol require the symbols that\n   * use to this symbol to have their type-check block regenerated.\n   *\n   * Note: `previousSymbol` is obtained from the most recently succeeded compilation. Symbols of\n   * failed compilations are never provided.\n   *\n   * @param previousSymbol The symbol from a prior compilation.\n   */\n  abstract isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean;\n\n  /**\n   * Similar to `isEmitAffected`, but focused on the type-check block of this symbol. This method\n   * determines whether a change to _other_ symbols, i.e. those present in `typeCheckApiAffected`,\n   * should cause _this_ symbol's type-check block to be regenerated.\n   *\n   * @param previousSymbol The equivalent symbol from a prior compilation. Note that it may be a\n   * different type of symbol, if e.g. a Component was changed into a Directive with the same name.\n   * @param typeCheckApiAffected The set of symbols of which the type-check API has changed.\n   */\n  isTypeCheckBlockAffected?\n      (previousSymbol: SemanticSymbol, typeCheckApiAffected: Set<SemanticSymbol>): boolean;\n}\n\n/**\n * Represents a reference to a semantic symbol that has been emitted into a source file. The\n * reference may refer to the symbol using a different name than the semantic symbol's declared\n * name, e.g. in case a re-export under a different name was chosen by a reference emitter.\n * Consequently, to know that an emitted reference is still valid not only requires that the\n * semantic symbol is still valid, but also that the path by which the symbol is imported has not\n * changed.\n */\nexport interface SemanticReference {\n  symbol: SemanticSymbol;\n\n  /**\n   * The path by which the symbol has been referenced.\n   */\n  importPath: string|null;\n}\n\nfunction getSymbolIdentifier(decl: ClassDeclaration): string|null {\n  if (!ts.isSourceFile(decl.parent)) {\n    return null;\n  }\n\n  // If this is a top-level class declaration, the class name is used as unique identifier.\n  // Other scenarios are currently not supported and causes the symbol not to be identified\n  // across rebuilds, unless the declaration node has not changed.\n  return decl.name.text;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr} from '@angular/compiler';\n\nimport {AbsoluteFsPath} from '../../../file_system';\nimport {ClassDeclaration} from '../../../reflection';\n\nimport {SemanticReference, SemanticSymbol} from './api';\n\nexport interface SemanticDependencyResult {\n  /**\n   * The files that need to be re-emitted.\n   */\n  needsEmit: Set<AbsoluteFsPath>;\n\n  /**\n   * The files for which the type-check block should be regenerated.\n   */\n  needsTypeCheckEmit: Set<AbsoluteFsPath>;\n\n  /**\n   * The newly built graph that represents the current compilation.\n   */\n  newGraph: SemanticDepGraph;\n}\n\n/**\n * Represents a declaration for which no semantic symbol has been registered. For example,\n * declarations from external dependencies have not been explicitly registered and are represented\n * by this symbol. This allows the unresolved symbol to still be compared to a symbol from a prior\n * compilation.\n */\nclass OpaqueSymbol extends SemanticSymbol {\n  override isPublicApiAffected(): false {\n    return false;\n  }\n\n  override isTypeCheckApiAffected(): false {\n    return false;\n  }\n}\n\n/**\n * The semantic dependency graph of a single compilation.\n */\nexport class SemanticDepGraph {\n  readonly files = new Map<AbsoluteFsPath, Map<string, SemanticSymbol>>();\n\n  // Note: the explicit type annotation is used to work around a CI failure on Windows:\n  // error TS2742: The inferred type of 'symbolByDecl' cannot be named without a reference to\n  // '../../../../../../../external/npm/node_modules/typescript/lib/typescript'. This is likely\n  // not portable. A type annotation is necessary.\n  readonly symbolByDecl: Map<ClassDeclaration, SemanticSymbol> =\n      new Map<ClassDeclaration, SemanticSymbol>();\n\n  /**\n   * Registers a symbol in the graph. The symbol is given a unique identifier if possible, such that\n   * its equivalent symbol can be obtained from a prior graph even if its declaration node has\n   * changed across rebuilds. Symbols without an identifier are only able to find themselves in a\n   * prior graph if their declaration node is identical.\n   */\n  registerSymbol(symbol: SemanticSymbol): void {\n    this.symbolByDecl.set(symbol.decl, symbol);\n\n    if (symbol.identifier !== null) {\n      // If the symbol has a unique identifier, record it in the file that declares it. This enables\n      // the symbol to be requested by its unique name.\n      if (!this.files.has(symbol.path)) {\n        this.files.set(symbol.path, new Map<string, SemanticSymbol>());\n      }\n      this.files.get(symbol.path)!.set(symbol.identifier, symbol);\n    }\n  }\n\n  /**\n   * Attempts to resolve a symbol in this graph that represents the given symbol from another graph.\n   * If no matching symbol could be found, null is returned.\n   *\n   * @param symbol The symbol from another graph for which its equivalent in this graph should be\n   * found.\n   */\n  getEquivalentSymbol(symbol: SemanticSymbol): SemanticSymbol|null {\n    // First lookup the symbol by its declaration. It is typical for the declaration to not have\n    // changed across rebuilds, so this is likely to find the symbol. Using the declaration also\n    // allows to diff symbols for which no unique identifier could be determined.\n    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n    if (previousSymbol === null && symbol.identifier !== null) {\n      // The declaration could not be resolved to a symbol in a prior compilation, which may\n      // happen because the file containing the declaration has changed. In that case we want to\n      // lookup the symbol based on its unique identifier, as that allows us to still compare the\n      // changed declaration to the prior compilation.\n      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n    }\n\n    return previousSymbol;\n  }\n\n  /**\n   * Attempts to find the symbol by its identifier.\n   */\n  private getSymbolByName(path: AbsoluteFsPath, identifier: string): SemanticSymbol|null {\n    if (!this.files.has(path)) {\n      return null;\n    }\n    const file = this.files.get(path)!;\n    if (!file.has(identifier)) {\n      return null;\n    }\n    return file.get(identifier)!;\n  }\n\n  /**\n   * Attempts to resolve the declaration to its semantic symbol.\n   */\n  getSymbolByDecl(decl: ClassDeclaration): SemanticSymbol|null {\n    if (!this.symbolByDecl.has(decl)) {\n      return null;\n    }\n    return this.symbolByDecl.get(decl)!;\n  }\n}\n\n/**\n * Implements the logic to go from a previous dependency graph to a new one, along with information\n * on which files have been affected.\n */\nexport class SemanticDepGraphUpdater {\n  private readonly newGraph = new SemanticDepGraph();\n\n  /**\n   * Contains opaque symbols that were created for declarations for which there was no symbol\n   * registered, which happens for e.g. external declarations.\n   */\n  private readonly opaqueSymbols = new Map<ClassDeclaration, OpaqueSymbol>();\n\n  constructor(\n      /**\n       * The semantic dependency graph of the most recently succeeded compilation, or null if this\n       * is the initial build.\n       */\n      private priorGraph: SemanticDepGraph|null) {}\n\n  /**\n   * Registers the symbol in the new graph that is being created.\n   */\n  registerSymbol(symbol: SemanticSymbol): void {\n    this.newGraph.registerSymbol(symbol);\n  }\n\n  /**\n   * Takes all facts that have been gathered to create a new semantic dependency graph. In this\n   * process, the semantic impact of the changes is determined which results in a set of files that\n   * need to be emitted and/or type-checked.\n   */\n  finalize(): SemanticDependencyResult {\n    if (this.priorGraph === null) {\n      // If no prior dependency graph is available then this was the initial build, in which case\n      // we don't need to determine the semantic impact as everything is already considered\n      // logically changed.\n      return {\n        needsEmit: new Set<AbsoluteFsPath>(),\n        needsTypeCheckEmit: new Set<AbsoluteFsPath>(),\n        newGraph: this.newGraph,\n      };\n    }\n\n    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n    return {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph: this.newGraph,\n    };\n  }\n\n  private determineInvalidatedFiles(priorGraph: SemanticDepGraph): Set<AbsoluteFsPath> {\n    const isPublicApiAffected = new Set<SemanticSymbol>();\n\n    // The first phase is to collect all symbols which have their public API affected. Any symbols\n    // that cannot be matched up with a symbol from the prior graph are considered affected.\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n        isPublicApiAffected.add(symbol);\n      }\n    }\n\n    // The second phase is to find all symbols for which the emit result is affected, either because\n    // their used declarations have changed or any of those used declarations has had its public API\n    // affected as determined in the first phase.\n    const needsEmit = new Set<AbsoluteFsPath>();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isEmitAffected === undefined) {\n        continue;\n      }\n\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n        needsEmit.add(symbol.path);\n      }\n    }\n\n    return needsEmit;\n  }\n\n  private determineInvalidatedTypeCheckFiles(priorGraph: SemanticDepGraph): Set<AbsoluteFsPath> {\n    const isTypeCheckApiAffected = new Set<SemanticSymbol>();\n\n    // The first phase is to collect all symbols which have their public API affected. Any symbols\n    // that cannot be matched up with a symbol from the prior graph are considered affected.\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n        isTypeCheckApiAffected.add(symbol);\n      }\n    }\n\n    // The second phase is to find all symbols for which the emit result is affected, either because\n    // their used declarations have changed or any of those used declarations has had its public API\n    // affected as determined in the first phase.\n    const needsTypeCheckEmit = new Set<AbsoluteFsPath>();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isTypeCheckBlockAffected === undefined) {\n        continue;\n      }\n\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null ||\n          symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n        needsTypeCheckEmit.add(symbol.path);\n      }\n    }\n\n    return needsTypeCheckEmit;\n  }\n\n  /**\n   * Creates a `SemanticReference` for the reference to `decl` using the expression `expr`. See\n   * the documentation of `SemanticReference` for details.\n   */\n  getSemanticReference(decl: ClassDeclaration, expr: Expression): SemanticReference {\n    return {\n      symbol: this.getSymbol(decl),\n      importPath: getImportPath(expr),\n    };\n  }\n\n  /**\n   * Gets the `SemanticSymbol` that was registered for `decl` during the current compilation, or\n   * returns an opaque symbol that represents `decl`.\n   */\n  getSymbol(decl: ClassDeclaration): SemanticSymbol {\n    const symbol = this.newGraph.getSymbolByDecl(decl);\n    if (symbol === null) {\n      // No symbol has been recorded for the provided declaration, which would be the case if the\n      // declaration is external. Return an opaque symbol in that case, to allow the external\n      // declaration to be compared to a prior compilation.\n      return this.getOpaqueSymbol(decl);\n    }\n    return symbol;\n  }\n\n  /**\n   * Gets or creates an `OpaqueSymbol` for the provided class declaration.\n   */\n  private getOpaqueSymbol(decl: ClassDeclaration): OpaqueSymbol {\n    if (this.opaqueSymbols.has(decl)) {\n      return this.opaqueSymbols.get(decl)!;\n    }\n\n    const symbol = new OpaqueSymbol(decl);\n    this.opaqueSymbols.set(decl, symbol);\n    return symbol;\n  }\n}\n\nfunction getImportPath(expr: Expression): string|null {\n  if (expr instanceof ExternalExpr) {\n    return `${expr.value.moduleName}\\$${expr.value.name}`;\n  } else {\n    return null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {ClassDeclaration} from '../../../reflection';\nimport {isArrayEqual} from './util';\n\n/**\n * Describes a generic type parameter of a semantic symbol. A class declaration with type parameters\n * needs special consideration in certain contexts. For example, template type-check blocks may\n * contain type constructors of used directives which include the type parameters of the directive.\n * As a consequence, if a change is made that affects the type parameters of said directive, any\n * template type-check blocks that use the directive need to be regenerated.\n *\n * This type represents a single generic type parameter. It currently only tracks whether the\n * type parameter has a constraint, i.e. has an `extends` clause. When a constraint is present, we\n * currently assume that the type parameter is affected in each incremental rebuild; proving that\n * a type parameter with constraint is not affected is non-trivial as it requires full semantic\n * understanding of the type constraint.\n */\nexport interface SemanticTypeParameter {\n  /**\n   * Whether a type constraint, i.e. an `extends` clause is present on the type parameter.\n   */\n  hasGenericTypeBound: boolean;\n}\n\n/**\n * Converts the type parameters of the given class into their semantic representation. If the class\n * does not have any type parameters, then `null` is returned.\n */\nexport function extractSemanticTypeParameters(node: ClassDeclaration): SemanticTypeParameter[]|\n    null {\n  if (!ts.isClassDeclaration(node) || node.typeParameters === undefined) {\n    return null;\n  }\n\n  return node.typeParameters.map(\n      typeParam => ({hasGenericTypeBound: typeParam.constraint !== undefined}));\n}\n\n/**\n * Compares the list of type parameters to determine if they can be considered equal.\n */\nexport function areTypeParametersEqual(\n    current: SemanticTypeParameter[]|null, previous: SemanticTypeParameter[]|null): boolean {\n  // First compare all type parameters one-to-one; any differences mean that the list of type\n  // parameters has changed.\n  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n    return false;\n  }\n\n  // If there is a current list of type parameters and if any of them has a generic type constraint,\n  // then the meaning of that type parameter may have changed without us being aware; as such we\n  // have to assume that the type parameters have in fact changed.\n  if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTypeParameterEqual(a: SemanticTypeParameter, b: SemanticTypeParameter): boolean {\n  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SemanticReference, SemanticSymbol} from './api';\n\n/**\n * Determines whether the provided symbols represent the same declaration.\n */\nexport function isSymbolEqual(a: SemanticSymbol, b: SemanticSymbol): boolean {\n  if (a.decl === b.decl) {\n    // If the declaration is identical then it must represent the same symbol.\n    return true;\n  }\n\n  if (a.identifier === null || b.identifier === null) {\n    // Unidentifiable symbols are assumed to be different.\n    return false;\n  }\n\n  return a.path === b.path && a.identifier === b.identifier;\n}\n\n/**\n * Determines whether the provided references to a semantic symbol are still equal, i.e. represent\n * the same symbol and are imported by the same path.\n */\nexport function isReferenceEqual(a: SemanticReference, b: SemanticReference): boolean {\n  if (!isSymbolEqual(a.symbol, b.symbol)) {\n    // If the reference's target symbols are different, the reference itself is different.\n    return false;\n  }\n\n  // The reference still corresponds with the same symbol, now check that the path by which it is\n  // imported has not changed.\n  return a.importPath === b.importPath;\n}\n\nexport function referenceEquality<T>(a: T, b: T): boolean {\n  return a === b;\n}\n\n/**\n * Determines if the provided arrays are equal to each other, using the provided equality tester\n * that is called for all entries in the array.\n */\nexport function isArrayEqual<T>(\n    a: readonly T[]|null, b: readonly T[]|null,\n    equalityTester: (a: T, b: T) => boolean = referenceEquality): boolean {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return !a.some((item, index) => !equalityTester(item, b[index]));\n}\n\n/**\n * Determines if the provided sets are equal to each other, using the provided equality tester.\n * Sets that only differ in ordering are considered equal.\n */\nexport function isSetEqual<T>(\n    a: ReadonlySet<T>|null, b: ReadonlySet<T>|null,\n    equalityTester: (a: T, b: T) => boolean = referenceEquality): boolean {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const itemA of a) {\n    let found = false;\n    for (const itemB of b) {\n      if (equalityTester(itemA, itemB)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A phase of compilation for which time is tracked in a distinct bucket.\n */\nexport enum PerfPhase {\n  /**\n   * The \"default\" phase which tracks time not spent in any other phase.\n   */\n  Unaccounted,\n\n  /**\n   * Time spent setting up the compiler, before a TypeScript program is created.\n   *\n   * This includes operations like configuring the `ts.CompilerHost` and any wrappers.\n   */\n  Setup,\n\n  /**\n   * Time spent in `ts.createProgram`, including reading and parsing `ts.SourceFile`s in the\n   * `ts.CompilerHost`.\n   *\n   * This might be an incremental program creation operation.\n   */\n  TypeScriptProgramCreate,\n\n  /**\n   * Time spent reconciling the contents of an old `ts.Program` with the new incremental one.\n   *\n   * Only present in incremental compilations.\n   */\n  Reconciliation,\n\n  /**\n   * Time spent updating an `NgCompiler` instance with a resource-only change.\n   *\n   * Only present in incremental compilations where the change was resource-only.\n   */\n  ResourceUpdate,\n\n  /**\n   * Time spent calculating the plain TypeScript diagnostics (structural and semantic).\n   */\n  TypeScriptDiagnostics,\n\n  /**\n   * Time spent in Angular analysis of individual classes in the program.\n   */\n  Analysis,\n\n  /**\n   * Time spent in Angular global analysis (synthesis of analysis information into a complete\n   * understanding of the program).\n   */\n  Resolve,\n\n  /**\n   * Time spent building the import graph of the program in order to perform cycle detection.\n   */\n  CycleDetection,\n\n  /**\n   * Time spent generating the text of Type Check Blocks in order to perform template type checking.\n   */\n  TcbGeneration,\n\n  /**\n   * Time spent updating the `ts.Program` with new Type Check Block code.\n   */\n  TcbUpdateProgram,\n\n  /**\n   * Time spent by TypeScript performing its emit operations, including downleveling and writing\n   * output files.\n   */\n  TypeScriptEmit,\n\n  /**\n   * Time spent by Angular performing code transformations of ASTs as they're about to be emitted.\n   *\n   * This includes the actual code generation step for templates, and occurs during the emit phase\n   * (but is tracked separately from `TypeScriptEmit` time).\n   */\n  Compile,\n\n  /**\n   * Time spent performing a `TemplateTypeChecker` autocompletion operation.\n   */\n  TtcAutocompletion,\n\n  /**\n   * Time spent computing template type-checking diagnostics.\n   */\n  TtcDiagnostics,\n\n  /**\n   * Time spent getting a `Symbol` from the `TemplateTypeChecker`.\n   */\n  TtcSymbol,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get references\" or a renaming\n   * operation.\n   */\n  LsReferencesAndRenames,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"quick info\" operation.\n   */\n  LsQuickInfo,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get type definition\" or \"get\n   * definition\" operation.\n   */\n  LsDefinition,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get completions\" (AKA autocomplete)\n   * operation.\n   */\n  LsCompletions,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"view template typecheck block\"\n   * operation.\n   */\n  LsTcb,\n\n  /**\n   * Time spent by the Angular Language Service calculating diagnostics.\n   */\n  LsDiagnostics,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get component locations for template\"\n   * operation.\n   */\n  LsComponentLocations,\n\n  /**\n   * Time spent by the Angular Language Service calculating signature help.\n   */\n  LsSignatureHelp,\n\n  /**\n   * Tracks the number of `PerfPhase`s, and must appear at the end of the list.\n   */\n  LAST,\n\n  /**\n   * Time spent by the Angular Language Service calculating code fixes.\n   */\n  LsCodeFixes,\n\n  /**\n   * Time spent by the Angular Language Service to fix all detected same type errors.\n   */\n  LsCodeFixesAll,\n}\n\n/**\n * Represents some occurrence during compilation, and is tracked with a counter.\n */\nexport enum PerfEvent {\n  /**\n   * Counts the number of `.d.ts` files in the program.\n   */\n  InputDtsFile,\n\n  /**\n   * Counts the number of non-`.d.ts` files in the program.\n   */\n  InputTsFile,\n\n  /**\n   * An `@Component` class was analyzed.\n   */\n  AnalyzeComponent,\n\n  /**\n   * An `@Directive` class was analyzed.\n   */\n  AnalyzeDirective,\n\n  /**\n   * An `@Injectable` class was analyzed.\n   */\n  AnalyzeInjectable,\n\n  /**\n   * An `@NgModule` class was analyzed.\n   */\n  AnalyzeNgModule,\n\n  /**\n   * An `@Pipe` class was analyzed.\n   */\n  AnalyzePipe,\n\n  /**\n   * A trait was analyzed.\n   *\n   * In theory, this should be the sum of the `Analyze` counters for each decorator type.\n   */\n  TraitAnalyze,\n\n  /**\n   * A trait had a prior analysis available from an incremental program, and did not need to be\n   * re-analyzed.\n   */\n  TraitReuseAnalysis,\n\n  /**\n   * A `ts.SourceFile` directly changed between the prior program and a new incremental compilation.\n   */\n  SourceFilePhysicalChange,\n\n  /**\n   * A `ts.SourceFile` did not physically changed, but according to the file dependency graph, has\n   * logically changed between the prior program and a new incremental compilation.\n   */\n  SourceFileLogicalChange,\n\n  /**\n   * A `ts.SourceFile` has not logically changed and all of its analysis results were thus available\n   * for reuse.\n   */\n  SourceFileReuseAnalysis,\n\n  /**\n   * A Type Check Block (TCB) was generated.\n   */\n  GenerateTcb,\n\n  /**\n   * A Type Check Block (TCB) could not be generated because inlining was disabled, and the block\n   * would've required inlining.\n   */\n  SkipGenerateTcbNoInline,\n\n  /**\n   * A `.ngtypecheck.ts` file could be reused from the previous program and did not need to be\n   * regenerated.\n   */\n  ReuseTypeCheckFile,\n\n  /**\n   * The template type-checking program required changes and had to be updated in an incremental\n   * step.\n   */\n  UpdateTypeCheckProgram,\n\n  /**\n   * The compiler was able to prove that a `ts.SourceFile` did not need to be re-emitted.\n   */\n  EmitSkipSourceFile,\n\n  /**\n   * A `ts.SourceFile` was emitted.\n   */\n  EmitSourceFile,\n\n  /**\n   * Tracks the number of `PrefEvent`s, and must appear at the end of the list.\n   */\n  LAST,\n}\n\n/**\n * Represents a checkpoint during compilation at which the memory usage of the compiler should be\n * recorded.\n */\nexport enum PerfCheckpoint {\n  /**\n   * The point at which the `PerfRecorder` was created, and ideally tracks memory used before any\n   * compilation structures are created.\n   */\n  Initial,\n\n  /**\n   * The point just after the `ts.Program` has been created.\n   */\n  TypeScriptProgramCreate,\n\n  /**\n   * The point just before Angular analysis starts.\n   *\n   * In the main usage pattern for the compiler, TypeScript diagnostics have been calculated at this\n   * point, so the `ts.TypeChecker` has fully ingested the current program, all `ts.Type` structures\n   * and `ts.Symbol`s have been created.\n   */\n  PreAnalysis,\n\n  /**\n   * The point just after Angular analysis completes.\n   */\n  Analysis,\n\n  /**\n   * The point just after Angular resolution is complete.\n   */\n  Resolve,\n\n  /**\n   * The point just after Type Check Blocks (TCBs) have been generated.\n   */\n  TtcGeneration,\n\n  /**\n   * The point just after the template type-checking program has been updated with any new TCBs.\n   */\n  TtcUpdateProgram,\n\n  /**\n   * The point just before emit begins.\n   *\n   * In the main usage pattern for the compiler, all template type-checking diagnostics have been\n   * requested at this point.\n   */\n  PreEmit,\n\n  /**\n   * The point just after the program has been fully emitted.\n   */\n  Emit,\n\n  /**\n   * Tracks the number of `PerfCheckpoint`s, and must appear at the end of the list.\n   */\n  LAST,\n}\n\n/**\n * Records timing, memory, or counts at specific points in the compiler's operation.\n */\nexport interface PerfRecorder {\n  /**\n   * Set the current phase of compilation.\n   *\n   * Time spent in the previous phase will be accounted to that phase. The caller is responsible for\n   * exiting the phase when work that should be tracked within it is completed, and either returning\n   * to the previous phase or transitioning to the next one directly.\n   *\n   * In general, prefer using `inPhase()` to instrument a section of code, as it automatically\n   * handles entering and exiting the phase. `phase()` should only be used when the former API\n   * cannot be cleanly applied to a particular operation.\n   *\n   * @returns the previous phase\n   */\n  phase(phase: PerfPhase): PerfPhase;\n\n  /**\n   * Run `fn` in the given `PerfPhase` and return the result.\n   *\n   * Enters `phase` before executing the given `fn`, then exits the phase and returns the result.\n   * Prefer this API to `phase()` where possible.\n   */\n  inPhase<T>(phase: PerfPhase, fn: () => T): T;\n\n  /**\n   * Record the memory usage of the compiler at the given checkpoint.\n   */\n  memory(after: PerfCheckpoint): void;\n\n  /**\n   * Record that a specific event has occurred, possibly more than once.\n   */\n  eventCount(event: PerfEvent, incrementBy?: number): void;\n\n  /**\n   * Return the `PerfRecorder` to an empty state (clear all tracked statistics) and reset the zero\n   * point to the current time.\n   */\n  reset(): void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {PerfPhase, PerfRecorder} from './api';\n\nclass NoopPerfRecorder implements PerfRecorder {\n  eventCount(): void {}\n\n  memory(): void {}\n\n  phase(): PerfPhase {\n    return PerfPhase.Unaccounted;\n  }\n\n  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n    return fn();\n  }\n\n  reset(): void {}\n}\n\n\nexport const NOOP_PERF_RECORDER: PerfRecorder = new NoopPerfRecorder();\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file uses 'process'\n/// <reference types=\"node\" />\n\nexport type HrTime = [number, number];\n\nexport function mark(): HrTime {\n  return process.hrtime();\n}\n\nexport function timeSinceInMicros(mark: HrTime): number {\n  const delta = process.hrtime(mark);\n  return (delta[0] * 1000000) + Math.floor(delta[1] / 1000);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <reference types=\"node\" />\n\nimport {PerfCheckpoint, PerfEvent, PerfPhase, PerfRecorder} from './api';\nimport {HrTime, mark, timeSinceInMicros} from './clock';\n\n/**\n * Serializable performance data for the compilation, using string names.\n */\nexport interface PerfResults {\n  events: Record<string, number>;\n  phases: Record<string, number>;\n  memory: Record<string, number>;\n}\n\n/**\n * A `PerfRecorder` that actively tracks performance statistics.\n */\nexport class ActivePerfRecorder implements PerfRecorder {\n  private counters: number[];\n  private phaseTime: number[];\n  private bytes: number[];\n\n  private currentPhase = PerfPhase.Unaccounted;\n  private currentPhaseEntered: HrTime;\n\n  /**\n   * Creates an `ActivePerfRecorder` with its zero point set to the current time.\n   */\n  static zeroedToNow(): ActivePerfRecorder {\n    return new ActivePerfRecorder(mark());\n  }\n\n  private constructor(private zeroTime: HrTime) {\n    this.currentPhaseEntered = this.zeroTime;\n    this.counters = Array(PerfEvent.LAST).fill(0);\n    this.phaseTime = Array(PerfPhase.LAST).fill(0);\n    this.bytes = Array(PerfCheckpoint.LAST).fill(0);\n\n    // Take an initial memory snapshot before any other compilation work begins.\n    this.memory(PerfCheckpoint.Initial);\n  }\n\n  reset(): void {\n    this.counters = Array(PerfEvent.LAST).fill(0);\n    this.phaseTime = Array(PerfPhase.LAST).fill(0);\n    this.bytes = Array(PerfCheckpoint.LAST).fill(0);\n    this.zeroTime = mark();\n    this.currentPhase = PerfPhase.Unaccounted;\n    this.currentPhaseEntered = this.zeroTime;\n  }\n\n  memory(after: PerfCheckpoint): void {\n    this.bytes[after] = process.memoryUsage().heapUsed;\n  }\n\n  phase(phase: PerfPhase): PerfPhase {\n    const previous = this.currentPhase;\n    this.phaseTime[this.currentPhase] += timeSinceInMicros(this.currentPhaseEntered);\n    this.currentPhase = phase;\n    this.currentPhaseEntered = mark();\n    return previous;\n  }\n\n  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n    const previousPhase = this.phase(phase);\n    try {\n      return fn();\n    } finally {\n      this.phase(previousPhase);\n    }\n  }\n\n  eventCount(counter: PerfEvent, incrementBy: number = 1): void {\n    this.counters[counter] += incrementBy;\n  }\n\n  /**\n   * Return the current performance metrics as a serializable object.\n   */\n  finalize(): PerfResults {\n    // Track the last segment of time spent in `this.currentPhase` in the time array.\n    this.phase(PerfPhase.Unaccounted);\n\n    const results: PerfResults = {\n      events: {},\n      phases: {},\n      memory: {},\n    };\n\n    for (let i = 0; i < this.phaseTime.length; i++) {\n      if (this.phaseTime[i] > 0) {\n        results.phases[PerfPhase[i]] = this.phaseTime[i];\n      }\n    }\n\n    for (let i = 0; i < this.phaseTime.length; i++) {\n      if (this.counters[i] > 0) {\n        results.events[PerfEvent[i]] = this.counters[i];\n      }\n    }\n\n    for (let i = 0; i < this.bytes.length; i++) {\n      if (this.bytes[i] > 0) {\n        results.memory[PerfCheckpoint[i]] = this.bytes[i];\n      }\n    }\n\n    return results;\n  }\n}\n\n/**\n * A `PerfRecorder` that delegates to a target `PerfRecorder` which can be updated later.\n *\n * `DelegatingPerfRecorder` is useful when a compiler class that needs a `PerfRecorder` can outlive\n * the current compilation. This is true for most compiler classes as resource-only changes reuse\n * the same `NgCompiler` for a new compilation.\n */\nexport class DelegatingPerfRecorder implements PerfRecorder {\n  constructor(public target: PerfRecorder) {}\n\n  eventCount(counter: PerfEvent, incrementBy?: number): void {\n    this.target.eventCount(counter, incrementBy);\n  }\n\n  phase(phase: PerfPhase): PerfPhase {\n    return this.target.phase(phase);\n  }\n\n  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n    // Note: this doesn't delegate to `this.target.inPhase` but instead is implemented manually here\n    // to avoid adding an additional frame of noise to the stack when debugging.\n    const previousPhase = this.target.phase(phase);\n    try {\n      return fn();\n    } finally {\n      this.target.phase(previousPhase);\n    }\n  }\n\n  memory(after: PerfCheckpoint): void {\n    this.target.memory(after);\n  }\n\n  reset(): void {\n    this.target.reset();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SchemaMetadata} from '@angular/compiler';\n\nimport {Reexport, Reference} from '../../imports';\nimport {DirectiveMeta, NgModuleMeta, PipeMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\n\n/**\n * Data for one of a given NgModule's scopes (either compilation scope or export scopes).\n */\nexport interface ScopeData {\n  dependencies: Array<DirectiveMeta|PipeMeta>;\n\n  /**\n   * Whether some module or component in this scope contains errors and is thus semantically\n   * unreliable.\n   */\n  isPoisoned: boolean;\n}\n\n/**\n * An export scope of an NgModule, containing the directives/pipes it contributes to other NgModules\n * which import it.\n */\nexport interface ExportScope {\n  /**\n   * The scope exported by an NgModule, and available for import.\n   */\n  exported: ScopeData;\n}\n\n/**\n * A resolved scope for a given component that cannot be set locally in the component definition,\n * and must be set via remote scoping call in the component's NgModule file.\n */\nexport interface RemoteScope {\n  /**\n   * Those directives used by the component that requires this scope to be set remotely.\n   */\n  directives: Reference[];\n\n  /**\n   * Those pipes used by the component that requires this scope to be set remotely.\n   */\n  pipes: Reference[];\n}\n\nexport enum ComponentScopeKind {\n  NgModule,\n  Standalone,\n}\n\n\nexport interface LocalModuleScope extends ExportScope {\n  kind: ComponentScopeKind.NgModule;\n  ngModule: ClassDeclaration;\n  compilation: ScopeData;\n  reexports: Reexport[]|null;\n  schemas: SchemaMetadata[];\n}\n\nexport interface StandaloneScope {\n  kind: ComponentScopeKind.Standalone;\n  dependencies: Array<DirectiveMeta|PipeMeta|NgModuleMeta>;\n  component: ClassDeclaration;\n  schemas: SchemaMetadata[];\n  isPoisoned: boolean;\n}\n\nexport type ComponentScope = LocalModuleScope|StandaloneScope;\n\n/**\n * Read information about the compilation scope of components.\n */\nexport interface ComponentScopeReader {\n  getScopeForComponent(clazz: ClassDeclaration): ComponentScope|null;\n\n  /**\n   * Get the `RemoteScope` required for this component, if any.\n   *\n   * If the component requires remote scoping, then retrieve the directives/pipes registered for\n   * that component. If remote scoping is not required (the common case), returns `null`.\n   */\n  getRemoteScope(clazz: ClassDeclaration): RemoteScope|null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ComponentScope, ComponentScopeReader, LocalModuleScope, RemoteScope} from './api';\n\n/**\n * A `ComponentScopeReader` that reads from an ordered set of child readers until it obtains the\n * requested scope.\n *\n * This is used to combine `ComponentScopeReader`s that read from different sources (e.g. from a\n * registry and from the incremental state).\n */\nexport class CompoundComponentScopeReader implements ComponentScopeReader {\n  constructor(private readers: ComponentScopeReader[]) {}\n\n  getScopeForComponent(clazz: ClassDeclaration): ComponentScope|null {\n    for (const reader of this.readers) {\n      const meta = reader.getScopeForComponent(clazz);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n\n  getRemoteScope(clazz: ClassDeclaration): RemoteScope|null {\n    for (const reader of this.readers) {\n      const remoteScope = reader.getRemoteScope(clazz);\n      if (remoteScope !== null) {\n        return remoteScope;\n      }\n    }\n    return null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {AliasingHost, Reference} from '../../imports';\nimport {DirectiveMeta, MetadataReader, PipeMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ExportScope} from './api';\n\nexport interface DtsModuleScopeResolver {\n  resolve(ref: Reference<ClassDeclaration>): ExportScope|null;\n}\n\n/**\n * Reads Angular metadata from classes declared in .d.ts files and computes an `ExportScope`.\n *\n * Given an NgModule declared in a .d.ts file, this resolver can produce a transitive `ExportScope`\n * of all of the directives/pipes it exports. It does this by reading metadata off of Ivy static\n * fields on directives, components, pipes, and NgModules.\n */\nexport class MetadataDtsModuleScopeResolver implements DtsModuleScopeResolver {\n  /**\n   * Cache which holds fully resolved scopes for NgModule classes from .d.ts files.\n   */\n  private cache = new Map<ClassDeclaration, ExportScope|null>();\n\n  /**\n   * @param dtsMetaReader a `MetadataReader` which can read metadata from `.d.ts` files.\n   */\n  constructor(private dtsMetaReader: MetadataReader, private aliasingHost: AliasingHost|null) {}\n\n  /**\n   * Resolve a `Reference`'d NgModule from a .d.ts file and produce a transitive `ExportScope`\n   * listing the directives and pipes which that NgModule exports to others.\n   *\n   * This operation relies on a `Reference` instead of a direct TypeScript node as the `Reference`s\n   * produced depend on how the original NgModule was imported.\n   */\n  resolve(ref: Reference<ClassDeclaration>): ExportScope|null {\n    const clazz = ref.node;\n    const sourceFile = clazz.getSourceFile();\n    if (!sourceFile.isDeclarationFile) {\n      throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${\n          sourceFile.fileName}), but not a .d.ts file`);\n    }\n\n    if (this.cache.has(clazz)) {\n      return this.cache.get(clazz)!;\n    }\n\n    // Build up the export scope - those directives and pipes made visible by this module.\n    const dependencies: Array<DirectiveMeta|PipeMeta> = [];\n\n    const meta = this.dtsMetaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      this.cache.set(clazz, null);\n      return null;\n    }\n\n    const declarations = new Set<ClassDeclaration>();\n    for (const declRef of meta.declarations) {\n      declarations.add(declRef.node);\n    }\n\n    // Only the 'exports' field of the NgModule's metadata is important. Imports and declarations\n    // don't affect the export scope.\n    for (const exportRef of meta.exports) {\n      // Attempt to process the export as a directive.\n      const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);\n      if (directive !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        dependencies.push(this.maybeAlias(directive, sourceFile, isReExport));\n        continue;\n      }\n\n      // Attempt to process the export as a pipe.\n      const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);\n      if (pipe !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        dependencies.push(this.maybeAlias(pipe, sourceFile, isReExport));\n        continue;\n      }\n\n      // Attempt to process the export as a module.\n      const exportScope = this.resolve(exportRef);\n      if (exportScope !== null) {\n        // It is a module. Add exported directives and pipes to the current scope. This might\n        // involve rewriting the `Reference`s to those types to have an alias expression if one is\n        // required.\n        if (this.aliasingHost === null) {\n          // Fast path when aliases aren't required.\n          dependencies.push(...exportScope.exported.dependencies);\n        } else {\n          // It's necessary to rewrite the `Reference`s to add alias expressions. This way, imports\n          // generated to these directives and pipes will use a shallow import to `sourceFile`\n          // instead of a deep import directly to the directive or pipe class.\n          //\n          // One important check here is whether the directive/pipe is declared in the same\n          // source file as the re-exporting NgModule. This can happen if both a directive, its\n          // NgModule, and the re-exporting NgModule are all in the same file. In this case,\n          // no import alias is needed as it would go to the same file anyway.\n          for (const dep of exportScope.exported.dependencies) {\n            dependencies.push(this.maybeAlias(dep, sourceFile, /* isReExport */ true));\n          }\n        }\n      }\n      continue;\n\n      // The export was not a directive, a pipe, or a module. This is an error.\n      // TODO(alxhub): produce a ts.Diagnostic\n    }\n\n    const exportScope: ExportScope = {\n      exported: {\n        dependencies,\n        isPoisoned: false,\n      },\n    };\n    this.cache.set(clazz, exportScope);\n    return exportScope;\n  }\n\n  private maybeAlias<T extends DirectiveMeta|PipeMeta>(\n      dirOrPipe: T, maybeAliasFrom: ts.SourceFile, isReExport: boolean): T {\n    const ref = dirOrPipe.ref;\n    if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {\n      return dirOrPipe;\n    }\n\n    const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);\n    if (alias === null) {\n      return dirOrPipe;\n    }\n\n    return {\n      ...dirOrPipe,\n      ref: ref.cloneWithAlias(alias),\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ExternalExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\nimport {AliasingHost, assertSuccessfulReferenceEmit, Reexport, Reference, ReferenceEmitter} from '../../imports';\nimport {DirectiveMeta, MetadataReader, MetadataRegistry, MetaKind, NgModuleMeta, PipeMeta} from '../../metadata';\nimport {ClassDeclaration, DeclarationNode} from '../../reflection';\nimport {identifierOfNode, nodeNameForError} from '../../util/src/typescript';\n\nimport {ComponentScopeKind, ComponentScopeReader, ExportScope, LocalModuleScope, RemoteScope, ScopeData} from './api';\nimport {DtsModuleScopeResolver} from './dependency';\nimport {getDiagnosticNode, makeNotStandaloneDiagnostic} from './util';\n\nexport interface LocalNgModuleData {\n  declarations: Reference<ClassDeclaration>[];\n  imports: Reference<ClassDeclaration>[];\n  exports: Reference<ClassDeclaration>[];\n}\n\n/**\n * A registry which collects information about NgModules, Directives, Components, and Pipes which\n * are local (declared in the ts.Program being compiled), and can produce `LocalModuleScope`s\n * which summarize the compilation scope of a component.\n *\n * This class implements the logic of NgModule declarations, imports, and exports and can produce,\n * for a given component, the set of directives and pipes which are \"visible\" in that component's\n * template.\n *\n * The `LocalModuleScopeRegistry` has two \"modes\" of operation. During analysis, data for each\n * individual NgModule, Directive, Component, and Pipe is added to the registry. No attempt is made\n * to traverse or validate the NgModule graph (imports, exports, etc). After analysis, one of\n * `getScopeOfModule` or `getScopeForComponent` can be called, which traverses the NgModule graph\n * and applies the NgModule logic to generate a `LocalModuleScope`, the full scope for the given\n * module or component.\n *\n * The `LocalModuleScopeRegistry` is also capable of producing `ts.Diagnostic` errors when Angular\n * semantics are violated.\n */\nexport class LocalModuleScopeRegistry implements MetadataRegistry, ComponentScopeReader {\n  /**\n   * Tracks whether the registry has been asked to produce scopes for a module or component. Once\n   * this is true, the registry cannot accept registrations of new directives/pipes/modules as it\n   * would invalidate the cached scope data.\n   */\n  private sealed = false;\n\n  /**\n   * A map of components from the current compilation unit to the NgModule which declared them.\n   *\n   * As components and directives are not distinguished at the NgModule level, this map may also\n   * contain directives. This doesn't cause any problems but isn't useful as there is no concept of\n   * a directive's compilation scope.\n   */\n  private declarationToModule = new Map<ClassDeclaration, DeclarationData>();\n\n  /**\n   * This maps from the directive/pipe class to a map of data for each NgModule that declares the\n   * directive/pipe. This data is needed to produce an error for the given class.\n   */\n  private duplicateDeclarations =\n      new Map<ClassDeclaration, Map<ClassDeclaration, DeclarationData>>();\n\n  private moduleToRef = new Map<ClassDeclaration, Reference<ClassDeclaration>>();\n\n  /**\n   * A cache of calculated `LocalModuleScope`s for each NgModule declared in the current program.\n\n   */\n  private cache = new Map<ClassDeclaration, LocalModuleScope|null>();\n\n  /**\n   * Tracks the `RemoteScope` for components requiring \"remote scoping\".\n   *\n   * Remote scoping is when the set of directives which apply to a given component is set in the\n   * NgModule's file instead of directly on the component def (which is sometimes needed to get\n   * around cyclic import issues). This is not used in calculation of `LocalModuleScope`s, but is\n   * tracked here for convenience.\n   */\n  private remoteScoping = new Map<ClassDeclaration, RemoteScope>();\n\n  /**\n   * Tracks errors accumulated in the processing of scopes for each module declaration.\n   */\n  private scopeErrors = new Map<ClassDeclaration, ts.Diagnostic[]>();\n\n  /**\n   * Tracks which NgModules have directives/pipes that are declared in more than one module.\n   */\n  private modulesWithStructuralErrors = new Set<ClassDeclaration>();\n\n  constructor(\n      private localReader: MetadataReader, private fullReader: MetadataReader,\n      private dependencyScopeReader: DtsModuleScopeResolver, private refEmitter: ReferenceEmitter,\n      private aliasingHost: AliasingHost|null) {}\n\n  /**\n   * Add an NgModule's data to the registry.\n   */\n  registerNgModuleMetadata(data: NgModuleMeta): void {\n    this.assertCollecting();\n    const ngModule = data.ref.node;\n    this.moduleToRef.set(data.ref.node, data.ref);\n    // Iterate over the module's declarations, and add them to declarationToModule. If duplicates\n    // are found, they're instead tracked in duplicateDeclarations.\n    for (const decl of data.declarations) {\n      this.registerDeclarationOfModule(ngModule, decl, data.rawDeclarations);\n    }\n  }\n\n  registerDirectiveMetadata(directive: DirectiveMeta): void {}\n\n  registerPipeMetadata(pipe: PipeMeta): void {}\n\n  getScopeForComponent(clazz: ClassDeclaration): LocalModuleScope|null {\n    const scope = !this.declarationToModule.has(clazz) ?\n        null :\n        this.getScopeOfModule(this.declarationToModule.get(clazz)!.ngModule);\n    return scope;\n  }\n\n  /**\n   * If `node` is declared in more than one NgModule (duplicate declaration), then get the\n   * `DeclarationData` for each offending declaration.\n   *\n   * Ordinarily a class is only declared in one NgModule, in which case this function returns\n   * `null`.\n   */\n  getDuplicateDeclarations(node: ClassDeclaration): DeclarationData[]|null {\n    if (!this.duplicateDeclarations.has(node)) {\n      return null;\n    }\n\n    return Array.from(this.duplicateDeclarations.get(node)!.values());\n  }\n\n  /**\n   * Collects registered data for a module and its directives/pipes and convert it into a full\n   * `LocalModuleScope`.\n   *\n   * This method implements the logic of NgModule imports and exports. It returns the\n   * `LocalModuleScope` for the given NgModule if one can be produced, `null` if no scope was ever\n   * defined, or the string `'error'` if the scope contained errors.\n   */\n  getScopeOfModule(clazz: ClassDeclaration): LocalModuleScope|null {\n    return this.moduleToRef.has(clazz) ?\n        this.getScopeOfModuleReference(this.moduleToRef.get(clazz)!) :\n        null;\n  }\n\n  /**\n   * Retrieves any `ts.Diagnostic`s produced during the calculation of the `LocalModuleScope` for\n   * the given NgModule, or `null` if no errors were present.\n   */\n  getDiagnosticsOfModule(clazz: ClassDeclaration): ts.Diagnostic[]|null {\n    // Required to ensure the errors are populated for the given class. If it has been processed\n    // before, this will be a no-op due to the scope cache.\n    this.getScopeOfModule(clazz);\n\n    if (this.scopeErrors.has(clazz)) {\n      return this.scopeErrors.get(clazz)!;\n    } else {\n      return null;\n    }\n  }\n\n  private registerDeclarationOfModule(\n      ngModule: ClassDeclaration, decl: Reference<ClassDeclaration>,\n      rawDeclarations: ts.Expression|null): void {\n    const declData: DeclarationData = {\n      ngModule,\n      ref: decl,\n      rawDeclarations,\n    };\n\n    // First, check for duplicate declarations of the same directive/pipe.\n    if (this.duplicateDeclarations.has(decl.node)) {\n      // This directive/pipe has already been identified as being duplicated. Add this module to the\n      // map of modules for which a duplicate declaration exists.\n      this.duplicateDeclarations.get(decl.node)!.set(ngModule, declData);\n    } else if (\n        this.declarationToModule.has(decl.node) &&\n        this.declarationToModule.get(decl.node)!.ngModule !== ngModule) {\n      // This directive/pipe is already registered as declared in another module. Mark it as a\n      // duplicate instead.\n      const duplicateDeclMap = new Map<ClassDeclaration, DeclarationData>();\n      const firstDeclData = this.declarationToModule.get(decl.node)!;\n\n      // Mark both modules as having duplicate declarations.\n      this.modulesWithStructuralErrors.add(firstDeclData.ngModule);\n      this.modulesWithStructuralErrors.add(ngModule);\n\n      // Being detected as a duplicate means there are two NgModules (for now) which declare this\n      // directive/pipe. Add both of them to the duplicate tracking map.\n      duplicateDeclMap.set(firstDeclData.ngModule, firstDeclData);\n      duplicateDeclMap.set(ngModule, declData);\n      this.duplicateDeclarations.set(decl.node, duplicateDeclMap);\n\n      // Remove the directive/pipe from `declarationToModule` as it's a duplicate declaration, and\n      // therefore not valid.\n      this.declarationToModule.delete(decl.node);\n    } else {\n      // This is the first declaration of this directive/pipe, so map it.\n      this.declarationToModule.set(decl.node, declData);\n    }\n  }\n\n  /**\n   * Implementation of `getScopeOfModule` which accepts a reference to a class.\n   */\n  private getScopeOfModuleReference(ref: Reference<ClassDeclaration>): LocalModuleScope|null {\n    if (this.cache.has(ref.node)) {\n      return this.cache.get(ref.node)!;\n    }\n\n    // Seal the registry to protect the integrity of the `LocalModuleScope` cache.\n    this.sealed = true;\n\n    // `ref` should be an NgModule previously added to the registry. If not, a scope for it\n    // cannot be produced.\n    const ngModule = this.localReader.getNgModuleMetadata(ref);\n    if (ngModule === null) {\n      this.cache.set(ref.node, null);\n      return null;\n    }\n\n    // Errors produced during computation of the scope are recorded here. At the end, if this array\n    // isn't empty then `undefined` will be cached and returned to indicate this scope is invalid.\n    const diagnostics: ts.Diagnostic[] = [];\n\n    // At this point, the goal is to produce two distinct transitive sets:\n    // - the directives and pipes which are visible to components declared in the NgModule.\n    // - the directives and pipes which are exported to any NgModules which import this one.\n\n    // Directives and pipes in the compilation scope.\n    const compilationDirectives = new Map<DeclarationNode, DirectiveMeta>();\n    const compilationPipes = new Map<DeclarationNode, PipeMeta>();\n\n    const declared = new Set<DeclarationNode>();\n\n    // Directives and pipes exported to any importing NgModules.\n    const exportDirectives = new Map<DeclarationNode, DirectiveMeta>();\n    const exportPipes = new Map<DeclarationNode, PipeMeta>();\n\n    // The algorithm is as follows:\n    // 1) Add all of the directives/pipes from each NgModule imported into the current one to the\n    //    compilation scope.\n    // 2) Add directives/pipes declared in the NgModule to the compilation scope. At this point, the\n    //    compilation scope is complete.\n    // 3) For each entry in the NgModule's exports:\n    //    a) Attempt to resolve it as an NgModule with its own exported directives/pipes. If it is\n    //       one, add them to the export scope of this NgModule.\n    //    b) Otherwise, it should be a class in the compilation scope of this NgModule. If it is,\n    //       add it to the export scope.\n    //    c) If it's neither an NgModule nor a directive/pipe in the compilation scope, then this\n    //       is an error.\n\n    //\n    let isPoisoned = false;\n    if (this.modulesWithStructuralErrors.has(ngModule.ref.node)) {\n      // If the module contains declarations that are duplicates, then it's considered poisoned.\n      isPoisoned = true;\n    }\n\n    // 1) process imports.\n    for (const decl of ngModule.imports) {\n      const importScope = this.getExportedScope(decl, diagnostics, ref.node, 'import');\n      if (importScope !== null) {\n        if (importScope === 'invalid' || importScope.exported.isPoisoned) {\n          // An import was an NgModule but contained errors of its own. Record this as an error too,\n          // because this scope is always going to be incorrect if one of its imports could not be\n          // read.\n          diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawImports, 'import'));\n          isPoisoned = true;\n\n          if (importScope === 'invalid') {\n            continue;\n          }\n        }\n\n        for (const dep of importScope.exported.dependencies) {\n          if (dep.kind === MetaKind.Directive) {\n            compilationDirectives.set(dep.ref.node, dep);\n          } else if (dep.kind === MetaKind.Pipe) {\n            compilationPipes.set(dep.ref.node, dep);\n          }\n        }\n\n        // Successfully processed the import as an NgModule (even if it had errors).\n        continue;\n      }\n\n      // The import wasn't an NgModule. Maybe it's a standalone entity?\n      const directive = this.fullReader.getDirectiveMetadata(decl);\n      if (directive !== null) {\n        if (directive.isStandalone) {\n          compilationDirectives.set(directive.ref.node, directive);\n        } else {\n          // Error: can't import a non-standalone component/directive.\n          diagnostics.push(makeNotStandaloneDiagnostic(\n              this, decl, ngModule.rawImports, directive.isComponent ? 'component' : 'directive'));\n          isPoisoned = true;\n        }\n\n        continue;\n      }\n\n      // It wasn't a directive (standalone or otherwise). Maybe a pipe?\n      const pipe = this.fullReader.getPipeMetadata(decl);\n      if (pipe !== null) {\n        if (pipe.isStandalone) {\n          compilationPipes.set(pipe.ref.node, pipe);\n        } else {\n          diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, 'pipe'));\n          isPoisoned = true;\n        }\n\n        continue;\n      }\n\n      // This reference was neither another NgModule nor a standalone entity. Report it as invalid.\n      diagnostics.push(invalidRef(decl, ngModule.rawImports, 'import'));\n      isPoisoned = true;\n    }\n\n    // 2) add declarations.\n    for (const decl of ngModule.declarations) {\n      const directive = this.localReader.getDirectiveMetadata(decl);\n      const pipe = this.localReader.getPipeMetadata(decl);\n      if (directive !== null) {\n        if (directive.isStandalone) {\n          const refType = directive.isComponent ? 'Component' : 'Directive';\n          diagnostics.push(makeDiagnostic(\n              ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE,\n              decl.getOriginForDiagnostics(ngModule.rawDeclarations!),\n              `${refType} ${\n                  decl.node.name\n                      .text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));\n          isPoisoned = true;\n          continue;\n        }\n\n        compilationDirectives.set(decl.node, {...directive, ref: decl});\n\n        if (directive.isPoisoned) {\n          isPoisoned = true;\n        }\n      } else if (pipe !== null) {\n        if (pipe.isStandalone) {\n          diagnostics.push(makeDiagnostic(\n              ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE,\n              decl.getOriginForDiagnostics(ngModule.rawDeclarations!),\n              `Pipe ${\n                  decl.node.name\n                      .text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));\n          isPoisoned = true;\n          continue;\n        }\n        compilationPipes.set(decl.node, {...pipe, ref: decl});\n      } else {\n        const errorNode = decl.getOriginForDiagnostics(ngModule.rawDeclarations!);\n        diagnostics.push(makeDiagnostic(\n            ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode,\n            `The class '${decl.node.name.text}' is listed in the declarations ` +\n                `of the NgModule '${\n                    ngModule.ref.node.name\n                        .text}', but is not a directive, a component, or a pipe. ` +\n                `Either remove it from the NgModule's declarations, or add an appropriate Angular decorator.`,\n            [makeRelatedInformation(\n                decl.node.name, `'${decl.node.name.text}' is declared here.`)]));\n        isPoisoned = true;\n        continue;\n      }\n\n      declared.add(decl.node);\n    }\n\n    // 3) process exports.\n    // Exports can contain modules, components, or directives. They're processed differently.\n    // Modules are straightforward. Directives and pipes from exported modules are added to the\n    // export maps. Directives/pipes are different - they might be exports of declared types or\n    // imported types.\n    for (const decl of ngModule.exports) {\n      // Attempt to resolve decl as an NgModule.\n      const exportScope = this.getExportedScope(decl, diagnostics, ref.node, 'export');\n      if (exportScope === 'invalid' || (exportScope !== null && exportScope.exported.isPoisoned)) {\n        // An export was an NgModule but contained errors of its own. Record this as an error too,\n        // because this scope is always going to be incorrect if one of its exports could not be\n        // read.\n        diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawExports, 'export'));\n        isPoisoned = true;\n\n        if (exportScope === 'invalid') {\n          continue;\n        }\n      } else if (exportScope !== null) {\n        // decl is an NgModule.\n        for (const dep of exportScope.exported.dependencies) {\n          if (dep.kind == MetaKind.Directive) {\n            exportDirectives.set(dep.ref.node, dep);\n          } else if (dep.kind === MetaKind.Pipe) {\n            exportPipes.set(dep.ref.node, dep);\n          }\n        }\n      } else if (compilationDirectives.has(decl.node)) {\n        // decl is a directive or component in the compilation scope of this NgModule.\n        const directive = compilationDirectives.get(decl.node)!;\n        exportDirectives.set(decl.node, directive);\n      } else if (compilationPipes.has(decl.node)) {\n        // decl is a pipe in the compilation scope of this NgModule.\n        const pipe = compilationPipes.get(decl.node)!;\n        exportPipes.set(decl.node, pipe);\n      } else {\n        // decl is an unknown export.\n        const dirMeta = this.fullReader.getDirectiveMetadata(decl);\n        const pipeMeta = this.fullReader.getPipeMetadata(decl);\n        if (dirMeta !== null || pipeMeta !== null) {\n          const isStandalone = dirMeta !== null ? dirMeta.isStandalone : pipeMeta!.isStandalone;\n          diagnostics.push(invalidReexport(decl, ngModule.rawExports, isStandalone));\n        } else {\n          diagnostics.push(invalidRef(decl, ngModule.rawExports, 'export'));\n        }\n        isPoisoned = true;\n        continue;\n      }\n    }\n\n    const exported: ScopeData = {\n      dependencies: [...exportDirectives.values(), ...exportPipes.values()],\n      isPoisoned,\n    };\n\n    const reexports =\n        this.getReexports(ngModule, ref, declared, exported.dependencies, diagnostics);\n\n\n    // Finally, produce the `LocalModuleScope` with both the compilation and export scopes.\n    const scope: LocalModuleScope = {\n      kind: ComponentScopeKind.NgModule,\n      ngModule: ngModule.ref.node,\n      compilation: {\n        dependencies: [...compilationDirectives.values(), ...compilationPipes.values()],\n        isPoisoned,\n      },\n      exported,\n      reexports,\n      schemas: ngModule.schemas,\n    };\n\n    // Check if this scope had any errors during production.\n    if (diagnostics.length > 0) {\n      // Save the errors for retrieval.\n      this.scopeErrors.set(ref.node, diagnostics);\n\n      // Mark this module as being tainted.\n      this.modulesWithStructuralErrors.add(ref.node);\n    }\n\n    this.cache.set(ref.node, scope);\n    return scope;\n  }\n\n  /**\n   * Check whether a component requires remote scoping.\n   */\n  getRemoteScope(node: ClassDeclaration): RemoteScope|null {\n    return this.remoteScoping.has(node) ? this.remoteScoping.get(node)! : null;\n  }\n\n  /**\n   * Set a component as requiring remote scoping, with the given directives and pipes to be\n   * registered remotely.\n   */\n  setComponentRemoteScope(node: ClassDeclaration, directives: Reference[], pipes: Reference[]):\n      void {\n    this.remoteScoping.set(node, {directives, pipes});\n  }\n\n  /**\n   * Look up the `ExportScope` of a given `Reference` to an NgModule.\n   *\n   * The NgModule in question may be declared locally in the current ts.Program, or it may be\n   * declared in a .d.ts file.\n   *\n   * @returns `null` if no scope could be found, or `'invalid'` if the `Reference` is not a valid\n   *     NgModule.\n   *\n   * May also contribute diagnostics of its own by adding to the given `diagnostics`\n   * array parameter.\n   */\n  private getExportedScope(\n      ref: Reference<ClassDeclaration>, diagnostics: ts.Diagnostic[],\n      ownerForErrors: DeclarationNode, type: 'import'|'export'): ExportScope|null|'invalid' {\n    if (ref.node.getSourceFile().isDeclarationFile) {\n      // The NgModule is declared in a .d.ts file. Resolve it with the `DependencyScopeReader`.\n      if (!ts.isClassDeclaration(ref.node)) {\n        // The NgModule is in a .d.ts file but is not declared as a ts.ClassDeclaration. This is an\n        // error in the .d.ts metadata.\n        const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT :\n                                         ErrorCode.NGMODULE_INVALID_EXPORT;\n        diagnostics.push(makeDiagnostic(\n            code, identifierOfNode(ref.node) || ref.node,\n            `Appears in the NgModule.${type}s of ${\n                nodeNameForError(ownerForErrors)}, but could not be resolved to an NgModule`));\n        return 'invalid';\n      }\n      return this.dependencyScopeReader.resolve(ref);\n    } else {\n      // The NgModule is declared locally in the current program. Resolve it from the registry.\n      return this.getScopeOfModuleReference(ref);\n    }\n  }\n\n  private getReexports(\n      ngModule: NgModuleMeta, ref: Reference<ClassDeclaration>, declared: Set<DeclarationNode>,\n      exported: Array<DirectiveMeta|PipeMeta>, diagnostics: ts.Diagnostic[]): Reexport[]|null {\n    let reexports: Reexport[]|null = null;\n    const sourceFile = ref.node.getSourceFile();\n    if (this.aliasingHost === null) {\n      return null;\n    }\n    reexports = [];\n    // Track re-exports by symbol name, to produce diagnostics if two alias re-exports would share\n    // the same name.\n    const reexportMap = new Map<string, Reference<ClassDeclaration>>();\n    // Alias ngModuleRef added for readability below.\n    const ngModuleRef = ref;\n    const addReexport = (exportRef: Reference<ClassDeclaration>) => {\n      if (exportRef.node.getSourceFile() === sourceFile) {\n        return;\n      }\n      const isReExport = !declared.has(exportRef.node);\n      const exportName = this.aliasingHost!.maybeAliasSymbolAs(\n          exportRef, sourceFile, ngModule.ref.node.name.text, isReExport);\n      if (exportName === null) {\n        return;\n      }\n      if (!reexportMap.has(exportName)) {\n        if (exportRef.alias && exportRef.alias instanceof ExternalExpr) {\n          reexports!.push({\n            fromModule: exportRef.alias.value.moduleName!,\n            symbolName: exportRef.alias.value.name!,\n            asAlias: exportName,\n          });\n        } else {\n          const emittedRef = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);\n          assertSuccessfulReferenceEmit(emittedRef, ngModuleRef.node.name, 'class');\n          const expr = emittedRef.expression;\n          if (!(expr instanceof ExternalExpr) || expr.value.moduleName === null ||\n              expr.value.name === null) {\n            throw new Error('Expected ExternalExpr');\n          }\n          reexports!.push({\n            fromModule: expr.value.moduleName,\n            symbolName: expr.value.name,\n            asAlias: exportName,\n          });\n        }\n        reexportMap.set(exportName, exportRef);\n      } else {\n        // Another re-export already used this name. Produce a diagnostic.\n        const prevRef = reexportMap.get(exportName)!;\n        diagnostics.push(reexportCollision(ngModuleRef.node, prevRef, exportRef));\n      }\n    };\n    for (const {ref} of exported) {\n      addReexport(ref);\n    }\n    return reexports;\n  }\n\n  private assertCollecting(): void {\n    if (this.sealed) {\n      throw new Error(`Assertion: LocalModuleScopeRegistry is not COLLECTING`);\n    }\n  }\n}\n\n/**\n * Produce a `ts.Diagnostic` for an invalid import or export from an NgModule.\n */\nfunction invalidRef(\n    decl: Reference<ClassDeclaration>, rawExpr: ts.Expression|null,\n    type: 'import'|'export'): ts.Diagnostic {\n  const code =\n      type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n  const resolveTarget = type === 'import' ? 'NgModule' : 'NgModule, Component, Directive, or Pipe';\n  const message = `'${decl.node.name.text}' does not appear to be an ${resolveTarget} class.`;\n  const library = decl.ownedByModuleGuess !== null ? ` (${decl.ownedByModuleGuess})` : '';\n  const sf = decl.node.getSourceFile();\n\n  let relatedMessage: string;\n\n  // Provide extra context to the error for the user.\n  if (!sf.isDeclarationFile) {\n    // This is a file in the user's program. Highlight the class as undecorated.\n    const annotationType = type === 'import' ? '@NgModule' : 'Angular';\n    relatedMessage = `Is it missing an ${annotationType} annotation?`;\n  } else if (sf.fileName.indexOf('node_modules') !== -1) {\n    // This file comes from a third-party library in node_modules.\n    relatedMessage =\n        `This likely means that the library${library} which declares ${decl.debugName} is not ` +\n        'compatible with Angular Ivy. Check if a newer version of the library is available, ' +\n        'and update if so. Also consider checking with the library\\'s authors to see if the ' +\n        'library is expected to be compatible with Ivy.';\n  } else {\n    // This is a monorepo style local dependency. Unfortunately these are too different to really\n    // offer much moreÂ advice than this.\n    relatedMessage = `This likely means that the dependency${library} which declares ${\n        decl.debugName} is not compatible with Angular Ivy.`;\n  }\n\n  return makeDiagnostic(\n      code, getDiagnosticNode(decl, rawExpr), message,\n      [makeRelatedInformation(decl.node.name, relatedMessage)]);\n}\n\n/**\n * Produce a `ts.Diagnostic` for an import or export which itself has errors.\n */\nfunction invalidTransitiveNgModuleRef(\n    decl: Reference<ClassDeclaration>, rawExpr: ts.Expression|null,\n    type: 'import'|'export'): ts.Diagnostic {\n  const code =\n      type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n  return makeDiagnostic(\n      code, getDiagnosticNode(decl, rawExpr),\n      `This ${type} contains errors, which may affect components that depend on this NgModule.`);\n}\n\n/**\n * Produce a `ts.Diagnostic` for an exported directive or pipe which was not declared or imported\n * by the NgModule in question.\n */\nfunction invalidReexport(\n    decl: Reference<ClassDeclaration>, rawExpr: ts.Expression|null,\n    isStandalone: boolean): ts.Diagnostic {\n  // The root error is the same here - this export is not valid. Give a helpful error message based\n  // on the specific circumstance.\n  let message = `Can't be exported from this NgModule, as `;\n  if (isStandalone) {\n    // Standalone types need to be imported into an NgModule before they can be re-exported.\n    message += 'it must be imported first';\n  } else if (decl.node.getSourceFile().isDeclarationFile) {\n    // Non-standalone types can be re-exported, but need to be imported into the NgModule first.\n    // This requires importing their own NgModule.\n    message += 'it must be imported via its NgModule first';\n  } else {\n    // Local non-standalone types must either be declared directly by this NgModule, or imported as\n    // above.\n    message +=\n        'it must be either declared by this NgModule, or imported here via its NgModule first';\n  }\n  return makeDiagnostic(\n      ErrorCode.NGMODULE_INVALID_REEXPORT, getDiagnosticNode(decl, rawExpr), message);\n}\n\n/**\n * Produce a `ts.Diagnostic` for a collision in re-export names between two directives/pipes.\n */\nfunction reexportCollision(\n    module: ClassDeclaration, refA: Reference<ClassDeclaration>,\n    refB: Reference<ClassDeclaration>): ts.Diagnostic {\n  const childMessageText = `This directive/pipe is part of the exports of '${\n      module.name.text}' and shares the same name as another exported directive/pipe.`;\n  return makeDiagnostic(\n      ErrorCode.NGMODULE_REEXPORT_NAME_COLLISION, module.name,\n      `\n    There was a name collision between two classes named '${\n          refA.node.name.text}', which are both part of the exports of '${module.name.text}'.\n\n    Angular generates re-exports of an NgModule's exported directives/pipes from the module's source file in certain cases, using the declared name of the class. If two classes of the same name are exported, this automatic naming does not work.\n\n    To fix this problem please re-export one or both classes directly from this file.\n  `.trim(),\n      [\n        makeRelatedInformation(refA.node.name, childMessageText),\n        makeRelatedInformation(refB.node.name, childMessageText),\n      ]);\n}\n\nexport interface DeclarationData {\n  ngModule: ClassDeclaration;\n  ref: Reference;\n  rawDeclarations: ts.Expression|null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ComponentScopeKind, ComponentScopeReader} from './api';\n\nexport function getDiagnosticNode(\n    ref: Reference<ClassDeclaration>, rawExpr: ts.Expression|null): ts.Expression {\n  // Show the diagnostic on the node within `rawExpr` which references the declaration\n  // in question. `rawExpr` represents the raw expression from which `ref` was partially evaluated,\n  // so use that to find the right node. Note that by the type system, `rawExpr` might be `null`, so\n  // fall back on the declaration identifier in that case (even though in practice this should never\n  // happen since local NgModules always have associated expressions).\n  return rawExpr !== null ? ref.getOriginForDiagnostics(rawExpr) : ref.node.name;\n}\n\nexport function makeNotStandaloneDiagnostic(\n    scopeReader: ComponentScopeReader, ref: Reference<ClassDeclaration>,\n    rawExpr: ts.Expression|null, kind: 'component'|'directive'|'pipe'): ts.Diagnostic {\n  const scope = scopeReader.getScopeForComponent(ref.node);\n\n  let message = `The ${kind} '${\n      ref.node.name\n          .text}' appears in 'imports', but is not standalone and cannot be imported directly.`;\n  let relatedInformation: ts.DiagnosticRelatedInformation[]|undefined = undefined;\n  if (scope !== null && scope.kind === ComponentScopeKind.NgModule) {\n    // The directive/pipe in question is declared in an NgModule. Check if it's also exported.\n    const isExported = scope.exported.dependencies.some(dep => dep.ref.node === ref.node);\n    const relatedInfoMessageText = isExported ?\n        `It can be imported using its '${scope.ngModule.name.text}' NgModule instead.` :\n        `It's declared in the '${scope.ngModule.name.text}' NgModule, but is not exported. ` +\n            'Consider exporting it and importing the NgModule instead.';\n    relatedInformation = [makeRelatedInformation(scope.ngModule.name, relatedInfoMessageText)];\n  } else {\n    // TODO(alxhub): the above case handles directives/pipes in NgModules that are declared in the\n    // current compilation, but not those imported from .d.ts dependencies. We could likely scan the\n    // program here and find NgModules to suggest, to improve the error in that case.\n  }\n  if (relatedInformation === undefined) {\n    // If no contextual pointers can be provided to suggest a specific remedy, then at least tell\n    // the user broadly what they need to do.\n    message += ' It must be imported via an NgModule.';\n  }\n  return makeDiagnostic(\n      ErrorCode.COMPONENT_IMPORT_NOT_STANDALONE, getDiagnosticNode(ref, rawExpr), message,\n      relatedInformation);\n}\n\nexport function makeUnknownComponentImportDiagnostic(\n    ref: Reference<ClassDeclaration>, rawExpr: ts.Expression) {\n  return makeDiagnostic(\n      ErrorCode.COMPONENT_UNKNOWN_IMPORT, getDiagnosticNode(ref, rawExpr),\n      `Component imports must be standalone components, directives, pipes, or must be NgModules.`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CssSelector, SchemaMetadata, SelectorMatcher} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {DirectiveMeta, flattenInheritedDirectiveMetadata, HostDirectivesResolver, MetadataReader, MetaKind} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ComponentScopeKind, ComponentScopeReader} from './api';\n\n/**\n * The scope that is used for type-check code generation of a component template.\n */\nexport interface TypeCheckScope {\n  /**\n   * A `SelectorMatcher` instance that contains the flattened directive metadata of all directives\n   * that are in the compilation scope of the declaring NgModule.\n   */\n  matcher: SelectorMatcher<DirectiveMeta[]>;\n\n  /**\n   * All of the directives available in the compilation scope of the declaring NgModule.\n   */\n  directives: DirectiveMeta[];\n\n  /**\n   * The pipes that are available in the compilation scope.\n   */\n  pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>;\n\n  /**\n   * The schemas that are used in this scope.\n   */\n  schemas: SchemaMetadata[];\n\n  /**\n   * Whether the original compilation scope which produced this `TypeCheckScope` was itself poisoned\n   * (contained semantic errors during its production).\n   */\n  isPoisoned: boolean;\n}\n\n/**\n * Computes scope information to be used in template type checking.\n */\nexport class TypeCheckScopeRegistry {\n  /**\n   * Cache of flattened directive metadata. Because flattened metadata is scope-invariant it's\n   * cached individually, such that all scopes refer to the same flattened metadata.\n   */\n  private flattenedDirectiveMetaCache = new Map<ClassDeclaration, DirectiveMeta>();\n\n  /**\n   * Cache of the computed type check scope per NgModule declaration.\n   */\n  private scopeCache = new Map<ClassDeclaration, TypeCheckScope>();\n\n  constructor(\n      private scopeReader: ComponentScopeReader, private metaReader: MetadataReader,\n      private hostDirectivesResolver: HostDirectivesResolver) {}\n\n  /**\n   * Computes the type-check scope information for the component declaration. If the NgModule\n   * contains an error, then 'error' is returned. If the component is not declared in any NgModule,\n   * an empty type-check scope is returned.\n   */\n  getTypeCheckScope(node: ClassDeclaration): TypeCheckScope {\n    const matcher = new SelectorMatcher<DirectiveMeta[]>();\n    const directives: DirectiveMeta[] = [];\n    const pipes = new Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>();\n\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope === null) {\n      return {\n        matcher,\n        directives,\n        pipes,\n        schemas: [],\n        isPoisoned: false,\n      };\n    }\n\n    const cacheKey = scope.kind === ComponentScopeKind.NgModule ? scope.ngModule : scope.component;\n    const dependencies = scope.kind === ComponentScopeKind.NgModule ?\n        scope.compilation.dependencies :\n        scope.dependencies;\n\n    if (this.scopeCache.has(cacheKey)) {\n      return this.scopeCache.get(cacheKey)!;\n    }\n\n    for (const meta of dependencies) {\n      if (meta.kind === MetaKind.Directive && meta.selector !== null) {\n        const extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);\n        if (extMeta === null) {\n          continue;\n        }\n        matcher.addSelectables(\n            CssSelector.parse(meta.selector),\n            [...this.hostDirectivesResolver.resolve(extMeta), extMeta]);\n        directives.push(extMeta);\n      } else if (meta.kind === MetaKind.Pipe) {\n        if (!ts.isClassDeclaration(meta.ref.node)) {\n          throw new Error(`Unexpected non-class declaration ${\n              ts.SyntaxKind[meta.ref.node.kind]} for pipe ${meta.ref.debugName}`);\n        }\n        pipes.set(meta.name, meta.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>);\n      }\n    }\n\n    const typeCheckScope: TypeCheckScope = {\n      matcher,\n      directives,\n      pipes,\n      schemas: scope.schemas,\n      isPoisoned: scope.kind === ComponentScopeKind.NgModule ?\n          scope.compilation.isPoisoned || scope.exported.isPoisoned :\n          scope.isPoisoned,\n    };\n    this.scopeCache.set(cacheKey, typeCheckScope);\n    return typeCheckScope;\n  }\n\n  getTypeCheckDirectiveMetadata(ref: Reference<ClassDeclaration>): DirectiveMeta|null {\n    const clazz = ref.node;\n    if (this.flattenedDirectiveMetaCache.has(clazz)) {\n      return this.flattenedDirectiveMetaCache.get(clazz)!;\n    }\n\n    const meta = flattenInheritedDirectiveMetadata(this.metaReader, ref);\n    if (meta === null) {\n      return null;\n    }\n    this.flattenedDirectiveMetaCache.set(clazz, meta);\n    return meta;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool, Expression, Statement, Type} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Reexport} from '../../imports';\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\nimport {IndexingContext} from '../../indexer';\nimport {ClassDeclaration, Decorator} from '../../reflection';\nimport {ImportManager} from '../../translator';\nimport {TypeCheckContext} from '../../typecheck/api';\nimport {ExtendedTemplateChecker} from '../../typecheck/extended/api';\nimport {Xi18nContext} from '../../xi18n';\n\n/**\n * Specifies the compilation mode that is used for the compilation.\n */\nexport enum CompilationMode {\n  /**\n   * Generates fully AOT compiled code using Ivy instructions.\n   */\n  FULL,\n\n  /**\n   * Generates code using a stable, but intermediate format suitable to be published to NPM.\n   */\n  PARTIAL,\n\n  /**\n   * Generates code based on each individual source file without using its\n   * dependencies (suitable for local dev edit/refresh workflow).\n   */\n  LOCAL,\n}\n\nexport enum HandlerPrecedence {\n  /**\n   * Handler with PRIMARY precedence cannot overlap - there can only be one on a given class.\n   *\n   * If more than one PRIMARY handler matches a class, an error is produced.\n   */\n  PRIMARY,\n\n  /**\n   * Handlers with SHARED precedence can match any class, possibly in addition to a single PRIMARY\n   * handler.\n   *\n   * It is not an error for a class to have any number of SHARED handlers.\n   */\n  SHARED,\n\n  /**\n   * Handlers with WEAK precedence that match a class are ignored if any handlers with stronger\n   * precedence match a class.\n   */\n  WEAK,\n}\n\n/**\n * A set of options which can be passed to a `DecoratorHandler` by a consumer, to tailor the output\n * of compilation beyond the decorators themselves.\n */\nexport enum HandlerFlags {\n  /**\n   * No flags set.\n   */\n  NONE = 0x0,\n\n  /**\n   * Indicates that this decorator is fully inherited from its parent at runtime. In addition to\n   * normally inherited aspects such as inputs and queries, full inheritance applies to every aspect\n   * of the component or directive, such as the template function itself.\n   *\n   * Its primary effect is to cause the `CopyDefinitionFeature` to be applied to the definition\n   * being compiled. See that class for more information.\n   */\n  FULL_INHERITANCE = 0x00000001,\n}\n\n\n/**\n * Provides the interface between a decorator compiler from @angular/compiler and the Typescript\n * compiler/transform.\n *\n * The decorator compilers in @angular/compiler do not depend on Typescript. The handler is\n * responsible for extracting the information required to perform compilation from the decorators\n * and Typescript source, invoking the decorator compiler, and returning the result.\n *\n * @param `D` The type of decorator metadata produced by `detect`.\n * @param `A` The type of analysis metadata produced by `analyze`.\n * @param `R` The type of resolution metadata produced by `resolve`.\n */\nexport interface DecoratorHandler<D, A, S extends SemanticSymbol|null, R> {\n  readonly name: string;\n\n  /**\n   * The precedence of a handler controls how it interacts with other handlers that match the same\n   * class.\n   *\n   * See the descriptions on `HandlerPrecedence` for an explanation of the behaviors involved.\n   */\n  readonly precedence: HandlerPrecedence;\n\n  /**\n   * Scan a set of reflected decorators and determine if this handler is responsible for compilation\n   * of one of them.\n   */\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<D>|undefined;\n\n\n  /**\n   * Asynchronously perform pre-analysis on the decorator/class combination.\n   *\n   * `preanalyze` is optional and is not guaranteed to be called through all compilation flows. It\n   * will only be called if asynchronicity is supported in the CompilerHost.\n   */\n  preanalyze?(node: ClassDeclaration, metadata: Readonly<D>): Promise<void>|undefined;\n\n  /**\n   * Perform analysis on the decorator/class combination, extracting information from the class\n   * required for compilation.\n   *\n   * Returns analyzed metadata if successful, or an array of diagnostic messages if the analysis\n   * fails or the decorator isn't valid.\n   *\n   * Analysis should always be a \"pure\" operation, with no side effects. This is because the\n   * detect/analysis steps might be skipped for files which have not changed during incremental\n   * builds. Any side effects required for compilation (e.g. registration of metadata) should happen\n   * in the `register` phase, which is guaranteed to run even for incremental builds.\n   */\n  analyze(node: ClassDeclaration, metadata: Readonly<D>, handlerFlags?: HandlerFlags):\n      AnalysisOutput<A>;\n\n  /**\n   * React to a change in a resource file by updating the `analysis` or `resolution`, under the\n   * assumption that nothing in the TypeScript code has changed.\n   */\n  updateResources?(node: ClassDeclaration, analysis: A, resolution: R): void;\n\n  /**\n   * Produces a `SemanticSymbol` that represents the class, which is registered into the semantic\n   * dependency graph. The symbol is used in incremental compilations to let the compiler determine\n   * how a change to the class affects prior emit results. See the `incremental` target's README for\n   * details on how this works.\n   *\n   * The symbol is passed in to `resolve`, where it can be extended with references into other parts\n   * of the compilation as needed.\n   *\n   * Only primary handlers are allowed to have symbols; handlers with `precedence` other than\n   * `HandlerPrecedence.PRIMARY` must return a `null` symbol.\n   */\n  symbol(node: ClassDeclaration, analysis: Readonly<A>): S;\n\n  /**\n   * Post-process the analysis of a decorator/class combination and record any necessary information\n   * in the larger compilation.\n   *\n   * Registration always occurs for a given decorator/class, regardless of whether analysis was\n   * performed directly or whether the analysis results were reused from the previous program.\n   */\n  register?(node: ClassDeclaration, analysis: A): void;\n\n  /**\n   * Registers information about the decorator for the indexing phase in a\n   * `IndexingContext`, which stores information about components discovered in the\n   * program.\n   */\n  index?\n      (context: IndexingContext, node: ClassDeclaration, analysis: Readonly<A>,\n       resolution: Readonly<R>): void;\n\n  /**\n   * Perform resolution on the given decorator along with the result of analysis.\n   *\n   * The resolution phase happens after the entire `ts.Program` has been analyzed, and gives the\n   * `DecoratorHandler` a chance to leverage information from the whole compilation unit to enhance\n   * the `analysis` before the emit phase.\n   */\n  resolve?(node: ClassDeclaration, analysis: Readonly<A>, symbol: S): ResolveResult<R>;\n\n  /**\n   * Extract i18n messages into the `Xi18nContext`, which is useful for generating various formats\n   * of message file outputs.\n   */\n  xi18n?(bundle: Xi18nContext, node: ClassDeclaration, analysis: Readonly<A>): void;\n\n  typeCheck?\n      (ctx: TypeCheckContext, node: ClassDeclaration, analysis: Readonly<A>,\n       resolution: Readonly<R>): void;\n\n  extendedTemplateCheck?\n      (component: ts.ClassDeclaration, extendedTemplateChecker: ExtendedTemplateChecker):\n          ts.Diagnostic[];\n\n  /**\n   * Generate a description of the field which should be added to the class, including any\n   * initialization code to be generated.\n   *\n   * If the compilation mode is configured as partial, and an implementation of `compilePartial` is\n   * provided, then this method is not called.\n   */\n  compileFull(\n      node: ClassDeclaration, analysis: Readonly<A>, resolution: Readonly<R>,\n      constantPool: ConstantPool): CompileResult|CompileResult[];\n\n  /**\n   * Generates code for the decorator using a stable, but intermediate format suitable to be\n   * published to NPM. This code is meant to be processed by the linker to achieve the final AOT\n   * compiled code.\n   *\n   * If present, this method is used if the compilation mode is configured as partial, otherwise\n   * `compileFull` is.\n   */\n  compilePartial?\n      (node: ClassDeclaration, analysis: Readonly<A>, resolution: Readonly<R>): CompileResult\n      |CompileResult[];\n}\n\n/**\n * The output of detecting a trait for a declaration as the result of the first phase of the\n * compilation pipeline.\n */\nexport interface DetectResult<M> {\n  /**\n   * The node that triggered the match, which is typically a decorator.\n   */\n  trigger: ts.Node|null;\n\n  /**\n   * Refers to the decorator that was recognized for this detection, if any. This can be a concrete\n   * decorator that is actually present in a file, or a synthetic decorator as inserted\n   * programmatically.\n   */\n  decorator: Decorator|null;\n\n  /**\n   * An arbitrary object to carry over from the detection phase into the analysis phase.\n   */\n  metadata: Readonly<M>;\n}\n\n/**\n * The output of an analysis operation, consisting of possibly an arbitrary analysis object (used as\n * the input to code generation) and potentially diagnostics if there were errors uncovered during\n * analysis.\n */\nexport interface AnalysisOutput<A> {\n  analysis?: Readonly<A>;\n  diagnostics?: ts.Diagnostic[];\n}\n\n/**\n * A description of the static field to add to a class, including an initialization expression\n * and a type for the .d.ts file.\n */\nexport interface CompileResult {\n  name: string;\n  initializer: Expression;\n  statements: Statement[];\n  type: Type;\n}\n\nexport interface ResolveResult<R> {\n  reexports?: Reexport[];\n  diagnostics?: ts.Diagnostic[];\n  data?: Readonly<R>;\n}\n\nexport interface DtsTransform {\n  transformClassElement?(element: ts.ClassElement, imports: ImportManager): ts.ClassElement;\n  transformFunctionDeclaration?\n      (element: ts.FunctionDeclaration, imports: ImportManager): ts.FunctionDeclaration;\n  transformClass?\n      (clazz: ts.ClassDeclaration, elements: ReadonlyArray<ts.ClassElement>,\n       imports: ImportManager): ts.ClassDeclaration;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nexport function aliasTransformFactory(exportStatements: Map<string, Map<string, [string, string]>>):\n    ts.TransformerFactory<ts.SourceFile> {\n  return () => {\n    return (file: ts.SourceFile) => {\n      if (ts.isBundle(file) || !exportStatements.has(file.fileName)) {\n        return file;\n      }\n\n      const statements = [...file.statements];\n      exportStatements.get(file.fileName)!.forEach(([moduleName, symbolName], aliasName) => {\n        const stmt = ts.factory.createExportDeclaration(\n            /* modifiers */ undefined,\n            /* isTypeOnly */ false,\n            /* exportClause */ ts.factory.createNamedExports([ts.factory.createExportSpecifier(\n                false, symbolName, aliasName)]),\n            /* moduleSpecifier */ ts.factory.createStringLiteral(moduleName));\n        statements.push(stmt);\n      });\n\n      return ts.factory.updateSourceFile(file, statements);\n    };\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {SourceFileTypeIdentifier} from '../../core/api';\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {IncrementalBuild} from '../../incremental/api';\nimport {SemanticDepGraphUpdater, SemanticSymbol} from '../../incremental/semantic_graph';\nimport {IndexingContext} from '../../indexer';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, DeclarationNode, Decorator, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ProgramTypeCheckAdapter, TypeCheckContext} from '../../typecheck/api';\nimport {ExtendedTemplateChecker} from '../../typecheck/extended/api';\nimport {getSourceFile} from '../../util/src/typescript';\nimport {Xi18nContext} from '../../xi18n';\n\nimport {AnalysisOutput, CompilationMode, CompileResult, DecoratorHandler, HandlerFlags, HandlerPrecedence, ResolveResult} from './api';\nimport {DtsTransformRegistry} from './declaration';\nimport {PendingTrait, Trait, TraitState} from './trait';\n\n\n/**\n * Records information about a specific class that has matched traits.\n */\nexport interface ClassRecord {\n  /**\n   * The `ClassDeclaration` of the class which has Angular traits applied.\n   */\n  node: ClassDeclaration;\n\n  /**\n   * All traits which matched on the class.\n   */\n  traits: Trait<unknown, unknown, SemanticSymbol|null, unknown>[];\n\n  /**\n   * Meta-diagnostics about the class, which are usually related to whether certain combinations of\n   * Angular decorators are not permitted.\n   */\n  metaDiagnostics: ts.Diagnostic[]|null;\n\n  // Subsequent fields are \"internal\" and used during the matching of `DecoratorHandler`s. This is\n  // mutable state during the `detect`/`analyze` phases of compilation.\n\n  /**\n   * Whether `traits` contains traits matched from `DecoratorHandler`s marked as `WEAK`.\n   */\n  hasWeakHandlers: boolean;\n\n  /**\n   * Whether `traits` contains a trait from a `DecoratorHandler` matched as `PRIMARY`.\n   */\n  hasPrimaryHandler: boolean;\n}\n\n/**\n * The heart of Angular compilation.\n *\n * The `TraitCompiler` is responsible for processing all classes in the program. Any time a\n * `DecoratorHandler` matches a class, a \"trait\" is created to represent that Angular aspect of the\n * class (such as the class having a component definition).\n *\n * The `TraitCompiler` transitions each trait through the various phases of compilation, culminating\n * in the production of `CompileResult`s instructing the compiler to apply various mutations to the\n * class (like adding fields or type declarations).\n */\nexport class TraitCompiler implements ProgramTypeCheckAdapter {\n  /**\n   * Maps class declarations to their `ClassRecord`, which tracks the Ivy traits being applied to\n   * those classes.\n   */\n  private classes = new Map<ClassDeclaration, ClassRecord>();\n\n  /**\n   * Maps source files to any class declaration(s) within them which have been discovered to contain\n   * Ivy traits.\n   */\n  private fileToClasses = new Map<ts.SourceFile, Set<ClassDeclaration>>();\n\n  /**\n   * Tracks which source files have been analyzed but did not contain any traits. This set allows\n   * the compiler to skip analyzing these files in an incremental rebuild.\n   */\n  private filesWithoutTraits = new Set<ts.SourceFile>();\n\n  private reexportMap = new Map<string, Map<string, [string, string]>>();\n\n  private handlersByName =\n      new Map<string, DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>>();\n\n  constructor(\n      private handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[],\n      private reflector: ReflectionHost,\n      private perf: PerfRecorder,\n      private incrementalBuild: IncrementalBuild<ClassRecord, unknown>,\n      private compileNonExportedClasses: boolean,\n      private compilationMode: CompilationMode,\n      private dtsTransforms: DtsTransformRegistry,\n      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n      private sourceFileTypeIdentifier: SourceFileTypeIdentifier,\n  ) {\n    for (const handler of handlers) {\n      this.handlersByName.set(handler.name, handler);\n    }\n  }\n\n  analyzeSync(sf: ts.SourceFile): void {\n    this.analyze(sf, false);\n  }\n\n  analyzeAsync(sf: ts.SourceFile): Promise<void>|undefined {\n    return this.analyze(sf, true);\n  }\n\n  private analyze(sf: ts.SourceFile, preanalyze: false): void;\n  private analyze(sf: ts.SourceFile, preanalyze: true): Promise<void>|undefined;\n  private analyze(sf: ts.SourceFile, preanalyze: boolean): Promise<void>|undefined {\n    // We shouldn't analyze declaration, shim, or resource files.\n    if (sf.isDeclarationFile || this.sourceFileTypeIdentifier.isShim(sf) ||\n        this.sourceFileTypeIdentifier.isResource(sf)) {\n      return undefined;\n    }\n\n    // analyze() really wants to return `Promise<void>|void`, but TypeScript cannot narrow a return\n    // type of 'void', so `undefined` is used instead.\n    const promises: Promise<void>[] = [];\n\n    const priorWork = this.incrementalBuild.priorAnalysisFor(sf);\n    if (priorWork !== null) {\n      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n\n      if (priorWork.length > 0) {\n        for (const priorRecord of priorWork) {\n          this.adopt(priorRecord);\n        }\n\n        this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n      } else {\n        this.filesWithoutTraits.add(sf);\n      }\n\n      // Skip the rest of analysis, as this file's prior traits are being reused.\n      return;\n    }\n\n    const visit = (node: ts.Node): void => {\n      if (this.reflector.isClass(node)) {\n        this.analyzeClass(node, preanalyze ? promises : null);\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(sf);\n\n    if (!this.fileToClasses.has(sf)) {\n      // If no traits were detected in the source file we record the source file itself to not have\n      // any traits, such that analysis of the source file can be skipped during incremental\n      // rebuilds.\n      this.filesWithoutTraits.add(sf);\n    }\n\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => undefined as void);\n    } else {\n      return undefined;\n    }\n  }\n\n  recordFor(clazz: ClassDeclaration): ClassRecord|null {\n    if (this.classes.has(clazz)) {\n      return this.classes.get(clazz)!;\n    } else {\n      return null;\n    }\n  }\n\n  getAnalyzedRecords(): Map<ts.SourceFile, ClassRecord[]> {\n    const result = new Map<ts.SourceFile, ClassRecord[]>();\n    for (const [sf, classes] of this.fileToClasses) {\n      const records: ClassRecord[] = [];\n      for (const clazz of classes) {\n        records.push(this.classes.get(clazz)!);\n      }\n      result.set(sf, records);\n    }\n    for (const sf of this.filesWithoutTraits) {\n      result.set(sf, []);\n    }\n    return result;\n  }\n\n  /**\n   * Import a `ClassRecord` from a previous compilation.\n   *\n   * Traits from the `ClassRecord` have accurate metadata, but the `handler` is from the old program\n   * and needs to be updated (matching is done by name). A new pending trait is created and then\n   * transitioned to analyzed using the previous analysis. If the trait is in the errored state,\n   * instead the errors are copied over.\n   */\n  private adopt(priorRecord: ClassRecord): void {\n    const record: ClassRecord = {\n      hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n      hasWeakHandlers: priorRecord.hasWeakHandlers,\n      metaDiagnostics: priorRecord.metaDiagnostics,\n      node: priorRecord.node,\n      traits: [],\n    };\n\n    for (const priorTrait of priorRecord.traits) {\n      const handler = this.handlersByName.get(priorTrait.handler.name)!;\n      let trait: Trait<unknown, unknown, SemanticSymbol|null, unknown> =\n          Trait.pending(handler, priorTrait.detected);\n\n      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n        if (trait.analysis !== null && trait.handler.register !== undefined) {\n          trait.handler.register(record.node, trait.analysis);\n        }\n      } else if (priorTrait.state === TraitState.Skipped) {\n        trait = trait.toSkipped();\n      }\n\n      record.traits.push(trait);\n    }\n\n    this.classes.set(record.node, record);\n    const sf = record.node.getSourceFile();\n    if (!this.fileToClasses.has(sf)) {\n      this.fileToClasses.set(sf, new Set<ClassDeclaration>());\n    }\n    this.fileToClasses.get(sf)!.add(record.node);\n  }\n\n  private scanClassForTraits(clazz: ClassDeclaration):\n      PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[]|null {\n    if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {\n      return null;\n    }\n\n    const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n\n    return this.detectTraits(clazz, decorators);\n  }\n\n  protected detectTraits(clazz: ClassDeclaration, decorators: Decorator[]|null):\n      PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[]|null {\n    let record: ClassRecord|null = this.recordFor(clazz);\n    let foundTraits: PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[] = [];\n\n    for (const handler of this.handlers) {\n      const result = handler.detect(clazz, decorators);\n      if (result === undefined) {\n        continue;\n      }\n\n      const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;\n      const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;\n      const trait = Trait.pending(handler, result);\n\n      foundTraits.push(trait);\n\n      if (record === null) {\n        // This is the first handler to match this class. This path is a fast path through which\n        // most classes will flow.\n        record = {\n          node: clazz,\n          traits: [trait],\n          metaDiagnostics: null,\n          hasPrimaryHandler: isPrimaryHandler,\n          hasWeakHandlers: isWeakHandler,\n        };\n\n        this.classes.set(clazz, record);\n        const sf = clazz.getSourceFile();\n        if (!this.fileToClasses.has(sf)) {\n          this.fileToClasses.set(sf, new Set<ClassDeclaration>());\n        }\n        this.fileToClasses.get(sf)!.add(clazz);\n      } else {\n        // This is at least the second handler to match this class. This is a slower path that some\n        // classes will go through, which validates that the set of decorators applied to the class\n        // is valid.\n\n        // Validate according to rules as follows:\n        //\n        // * WEAK handlers are removed if a non-WEAK handler matches.\n        // * Only one PRIMARY handler can match at a time. Any other PRIMARY handler matching a\n        //   class with an existing PRIMARY handler is an error.\n\n        if (!isWeakHandler && record.hasWeakHandlers) {\n          // The current handler is not a WEAK handler, but the class has other WEAK handlers.\n          // Remove them.\n          record.traits =\n              record.traits.filter(field => field.handler.precedence !== HandlerPrecedence.WEAK);\n          record.hasWeakHandlers = false;\n        } else if (isWeakHandler && !record.hasWeakHandlers) {\n          // The current handler is a WEAK handler, but the class has non-WEAK handlers already.\n          // Drop the current one.\n          continue;\n        }\n\n        if (isPrimaryHandler && record.hasPrimaryHandler) {\n          // The class already has a PRIMARY handler, and another one just matched.\n          record.metaDiagnostics = [{\n            category: ts.DiagnosticCategory.Error,\n            code: Number('-99' + ErrorCode.DECORATOR_COLLISION),\n            file: getSourceFile(clazz),\n            start: clazz.getStart(undefined, false),\n            length: clazz.getWidth(),\n            messageText: 'Two incompatible decorators on class',\n          }];\n          record.traits = foundTraits = [];\n          break;\n        }\n\n        // Otherwise, it's safe to accept the multiple decorators here. Update some of the metadata\n        // regarding this class.\n        record.traits.push(trait);\n        record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n      }\n    }\n\n    return foundTraits.length > 0 ? foundTraits : null;\n  }\n\n  private makeSymbolForTrait(\n      handler: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>,\n      decl: ClassDeclaration, analysis: Readonly<unknown>|null): SemanticSymbol|null {\n    if (analysis === null) {\n      return null;\n    }\n    const symbol = handler.symbol(decl, analysis);\n    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n      if (!isPrimary) {\n        throw new Error(\n            `AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n      }\n      this.semanticDepGraphUpdater.registerSymbol(symbol);\n    }\n\n    return symbol;\n  }\n\n  private analyzeClass(clazz: ClassDeclaration, preanalyzeQueue: Promise<void>[]|null): void {\n    const traits = this.scanClassForTraits(clazz);\n\n    if (traits === null) {\n      // There are no Ivy traits on the class, so it can safely be skipped.\n      return;\n    }\n\n    for (const trait of traits) {\n      const analyze = () => this.analyzeTrait(clazz, trait);\n\n      let preanalysis: Promise<void>|null = null;\n      if (preanalyzeQueue !== null && trait.handler.preanalyze !== undefined) {\n        // Attempt to run preanalysis. This could fail with a `FatalDiagnosticError`; catch it if it\n        // does.\n        try {\n          preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n            return;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (preanalysis !== null) {\n        preanalyzeQueue!.push(preanalysis.then(analyze));\n      } else {\n        analyze();\n      }\n    }\n  }\n\n  private analyzeTrait(\n      clazz: ClassDeclaration, trait: Trait<unknown, unknown, SemanticSymbol|null, unknown>,\n      flags?: HandlerFlags): void {\n    if (trait.state !== TraitState.Pending) {\n      throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${\n          TraitState[trait.state]} (expected DETECTED)`);\n    }\n\n    this.perf.eventCount(PerfEvent.TraitAnalyze);\n\n    // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.\n    let result: AnalysisOutput<unknown>;\n    try {\n      result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n    } catch (err) {\n      if (err instanceof FatalDiagnosticError) {\n        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n        return;\n      } else {\n        throw err;\n      }\n    }\n\n    const symbol = this.makeSymbolForTrait(trait.handler, clazz, result.analysis ?? null);\n    if (result.analysis !== undefined && trait.handler.register !== undefined) {\n      trait.handler.register(clazz, result.analysis);\n    }\n    trait = trait.toAnalyzed(result.analysis ?? null, result.diagnostics ?? null, symbol);\n  }\n\n  resolve(): void {\n    const classes = Array.from(this.classes.keys());\n    for (const clazz of classes) {\n      const record = this.classes.get(clazz)!;\n      for (let trait of record.traits) {\n        const handler = trait.handler;\n        switch (trait.state) {\n          case TraitState.Skipped:\n            continue;\n          case TraitState.Pending:\n            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${\n                Object.getPrototypeOf(trait.handler).constructor.name}`);\n          case TraitState.Resolved:\n            throw new Error(`Resolving an already resolved trait`);\n        }\n\n        if (trait.analysis === null) {\n          // No analysis results, cannot further process this trait.\n          continue;\n        }\n\n        if (handler.resolve === undefined) {\n          // No resolution of this trait needed - it's considered successful by default.\n          trait = trait.toResolved(null, null);\n          continue;\n        }\n\n        let result: ResolveResult<unknown>;\n        try {\n          result = handler.resolve(clazz, trait.analysis as Readonly<unknown>, trait.symbol);\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait = trait.toResolved(null, [err.toDiagnostic()]);\n            continue;\n          } else {\n            throw err;\n          }\n        }\n\n        trait = trait.toResolved(result.data ?? null, result.diagnostics ?? null);\n\n        if (result.reexports !== undefined) {\n          const fileName = clazz.getSourceFile().fileName;\n          if (!this.reexportMap.has(fileName)) {\n            this.reexportMap.set(fileName, new Map<string, [string, string]>());\n          }\n          const fileReexports = this.reexportMap.get(fileName)!;\n          for (const reexport of result.reexports) {\n            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Generate type-checking code into the `TypeCheckContext` for any components within the given\n   * `ts.SourceFile`.\n   */\n  typeCheck(sf: ts.SourceFile, ctx: TypeCheckContext): void {\n    if (!this.fileToClasses.has(sf)) {\n      return;\n    }\n\n    for (const clazz of this.fileToClasses.get(sf)!) {\n      const record = this.classes.get(clazz)!;\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.typeCheck === undefined) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n\n  extendedTemplateCheck(sf: ts.SourceFile, extendedTemplateChecker: ExtendedTemplateChecker):\n      ts.Diagnostic[] {\n    const classes = this.fileToClasses.get(sf);\n    if (classes === undefined) {\n      return [];\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n    for (const clazz of classes) {\n      if (!isNamedClassDeclaration(clazz)) {\n        continue;\n      }\n      const record = this.classes.get(clazz)!;\n      for (const trait of record.traits) {\n        if (trait.handler.extendedTemplateCheck === undefined) {\n          continue;\n        }\n        diagnostics.push(...trait.handler.extendedTemplateCheck(clazz, extendedTemplateChecker));\n      }\n    }\n    return diagnostics;\n  }\n\n  index(ctx: IndexingContext): void {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz)!;\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          // Skip traits that haven't been resolved successfully.\n          continue;\n        } else if (trait.handler.index === undefined) {\n          // Skip traits that don't affect indexing.\n          continue;\n        }\n\n        if (trait.resolution !== null) {\n          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n\n  xi18n(bundle: Xi18nContext): void {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz)!;\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {\n          // Skip traits that haven't been analyzed successfully.\n          continue;\n        } else if (trait.handler.xi18n === undefined) {\n          // Skip traits that don't support xi18n.\n          continue;\n        }\n\n        if (trait.analysis !== null) {\n          trait.handler.xi18n(bundle, clazz, trait.analysis);\n        }\n      }\n    }\n  }\n\n  updateResources(clazz: DeclarationNode): void {\n    if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n      return;\n    }\n    const record = this.classes.get(clazz)!;\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.handler.updateResources === undefined) {\n        continue;\n      }\n\n      trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n    }\n  }\n\n  compile(clazz: DeclarationNode, constantPool: ConstantPool): CompileResult[]|null {\n    const original = ts.getOriginalNode(clazz) as typeof clazz;\n    if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) ||\n        !this.classes.has(original)) {\n      return null;\n    }\n\n    const record = this.classes.get(original)!;\n\n    let res: CompileResult[] = [];\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || containsErrors(trait.analysisDiagnostics) ||\n          containsErrors(trait.resolveDiagnostics)) {\n        // Cannot compile a trait that is not resolved, or had any errors in its declaration.\n        continue;\n      }\n\n      // `trait.resolution` is non-null asserted here because TypeScript does not recognize that\n      // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that\n      // `Readonly` works.\n\n      let compileRes: CompileResult|CompileResult[];\n      if (this.compilationMode === CompilationMode.PARTIAL &&\n          trait.handler.compilePartial !== undefined) {\n        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution!);\n      } else {\n        compileRes =\n            trait.handler.compileFull(clazz, trait.analysis, trait.resolution!, constantPool);\n      }\n\n      const compileMatchRes = compileRes;\n      if (Array.isArray(compileMatchRes)) {\n        for (const result of compileMatchRes) {\n          if (!res.some(r => r.name === result.name)) {\n            res.push(result);\n          }\n        }\n      } else if (!res.some(result => result.name === compileMatchRes.name)) {\n        res.push(compileMatchRes);\n      }\n    }\n\n    // Look up the .d.ts transformer for the input file and record that at least one field was\n    // generated, which will allow the .d.ts to be transformed later.\n    this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile())\n        .addFields(original, res);\n\n    // Return the instruction to the transformer so the fields will be added.\n    return res.length > 0 ? res : null;\n  }\n\n  decoratorsFor(node: ts.Declaration): ts.Decorator[] {\n    const original = ts.getOriginalNode(node) as typeof node;\n    if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n      return [];\n    }\n\n    const record = this.classes.get(original)!;\n    const decorators: ts.Decorator[] = [];\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved) {\n        continue;\n      }\n\n      if (trait.detected.trigger !== null && ts.isDecorator(trait.detected.trigger)) {\n        decorators.push(trait.detected.trigger);\n      }\n    }\n\n    return decorators;\n  }\n\n  get diagnostics(): ReadonlyArray<ts.Diagnostic> {\n    const diagnostics: ts.Diagnostic[] = [];\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz)!;\n      if (record.metaDiagnostics !== null) {\n        diagnostics.push(...record.metaDiagnostics);\n      }\n      for (const trait of record.traits) {\n        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) &&\n            trait.analysisDiagnostics !== null) {\n          diagnostics.push(...trait.analysisDiagnostics);\n        }\n        if (trait.state === TraitState.Resolved) {\n          diagnostics.push(...(trait.resolveDiagnostics ?? []));\n        }\n      }\n    }\n    return diagnostics;\n  }\n\n  get exportStatements(): Map<string, Map<string, [string, string]>> {\n    return this.reexportMap;\n  }\n}\n\nfunction containsErrors(diagnostics: ts.Diagnostic[]|null): boolean {\n  return diagnostics !== null &&\n      diagnostics.some(diag => diag.category === ts.DiagnosticCategory.Error);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\n\nimport {DecoratorHandler, DetectResult} from './api';\n\nexport enum TraitState {\n  /**\n   * Pending traits are freshly created and have never been analyzed.\n   */\n  Pending,\n\n  /**\n   * Analyzed traits have successfully been analyzed, but are pending resolution.\n   */\n  Analyzed,\n\n  /**\n   * Resolved traits have successfully been analyzed and resolved and are ready for compilation.\n   */\n  Resolved,\n\n  /**\n   * Skipped traits are no longer considered for compilation.\n   */\n  Skipped,\n}\n\n/**\n * An Ivy aspect added to a class (for example, the compilation of a component definition).\n *\n * Traits are created when a `DecoratorHandler` matches a class. Each trait begins in a pending\n * state and undergoes transitions as compilation proceeds through the various steps.\n *\n * In practice, traits are instances of the private class `TraitImpl` declared below. Through the\n * various interfaces included in this union type, the legal API of a trait in any given state is\n * represented in the type system. This includes any possible transitions from one type to the next.\n *\n * This not only simplifies the implementation, but ensures traits are monomorphic objects as\n * they're all just \"views\" in the type system of the same object (which never changes shape).\n */\nexport type Trait<D, A, S extends SemanticSymbol|null, R> = PendingTrait<D, A, S, R>|\n    SkippedTrait<D, A, S, R>|AnalyzedTrait<D, A, S, R>|ResolvedTrait<D, A, S, R>;\n\n/**\n * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating\n * to `TraitImpl`).\n */\nexport const Trait = {\n  pending: <D, A, S extends SemanticSymbol|null, R>(\n      handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>): PendingTrait<D, A, S, R> =>\n      TraitImpl.pending(handler, detected),\n};\n\n/**\n * The part of the `Trait` interface that's common to all trait states.\n */\nexport interface TraitBase<D, A, S extends SemanticSymbol|null, R> {\n  /**\n   * Current state of the trait.\n   *\n   * This will be narrowed in the interfaces for each specific state.\n   */\n  state: TraitState;\n\n  /**\n   * The `DecoratorHandler` which matched on the class to create this trait.\n   */\n  handler: DecoratorHandler<D, A, S, R>;\n\n  /**\n   * The detection result (of `handler.detect`) which indicated that this trait applied to the\n   * class.\n   *\n   * This is mainly used to cache the detection between pre-analysis and analysis.\n   */\n  detected: DetectResult<D>;\n}\n\n/**\n * A trait in the pending state.\n *\n * Pending traits have yet to be analyzed in any way.\n */\nexport interface PendingTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Pending;\n\n  /**\n   * This pending trait has been successfully analyzed, and should transition to the \"analyzed\"\n   * state.\n   */\n  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null, symbol: S):\n      AnalyzedTrait<D, A, S, R>;\n\n  /**\n   * During analysis it was determined that this trait is not eligible for compilation after all,\n   * and should be transitioned to the \"skipped\" state.\n   */\n  toSkipped(): SkippedTrait<D, A, S, R>;\n}\n\n/**\n * A trait in the \"skipped\" state.\n *\n * Skipped traits aren't considered for compilation.\n *\n * This is a terminal state.\n */\nexport interface SkippedTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Skipped;\n}\n\n/**\n * A trait in the \"analyzed\" state.\n *\n * Analyzed traits have analysis results available, and are eligible for resolution.\n */\nexport interface AnalyzedTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Analyzed;\n  symbol: S;\n\n  /**\n   * Analysis results of the given trait (if able to be produced), or `null` if analysis failed\n   * completely.\n   */\n  analysis: Readonly<A>|null;\n\n  /**\n   * Any diagnostics that resulted from analysis, or `null` if none.\n   */\n  analysisDiagnostics: ts.Diagnostic[]|null;\n\n  /**\n   * This analyzed trait has been successfully resolved, and should be transitioned to the\n   * \"resolved\" state.\n   */\n  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, S, R>;\n}\n\n/**\n * A trait in the \"resolved\" state.\n *\n * Resolved traits have been successfully analyzed and resolved, contain no errors, and are ready\n * for the compilation phase.\n *\n * This is a terminal state.\n */\nexport interface ResolvedTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Resolved;\n  symbol: S;\n\n  /**\n   * Resolved traits must have produced valid analysis results.\n   */\n  analysis: Readonly<A>;\n\n  /**\n   * Analysis may have still resulted in diagnostics.\n   */\n  analysisDiagnostics: ts.Diagnostic[]|null;\n\n  /**\n   * Diagnostics resulting from resolution are tracked separately from\n   */\n  resolveDiagnostics: ts.Diagnostic[]|null;\n\n  /**\n   * The results returned by a successful resolution of the given class/`DecoratorHandler`\n   * combination.\n   */\n  resolution: Readonly<R>|null;\n}\n\n/**\n * An implementation of the `Trait` type which transitions safely between the various\n * `TraitState`s.\n */\nclass TraitImpl<D, A, S extends SemanticSymbol|null, R> {\n  state: TraitState = TraitState.Pending;\n  handler: DecoratorHandler<D, A, S, R>;\n  detected: DetectResult<D>;\n  analysis: Readonly<A>|null = null;\n  symbol: S|null = null;\n  resolution: Readonly<R>|null = null;\n  analysisDiagnostics: ts.Diagnostic[]|null = null;\n  resolveDiagnostics: ts.Diagnostic[]|null = null;\n  typeCheckDiagnostics: ts.Diagnostic[]|null = null;\n\n  constructor(handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>) {\n    this.handler = handler;\n    this.detected = detected;\n  }\n\n  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null, symbol: S):\n      AnalyzedTrait<D, A, S, R> {\n    // Only pending traits can be analyzed.\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n    this.analysis = analysis;\n    this.analysisDiagnostics = diagnostics;\n    this.symbol = symbol;\n    this.state = TraitState.Analyzed;\n    return this as AnalyzedTrait<D, A, S, R>;\n  }\n\n  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, S, R> {\n    // Only analyzed traits can be resolved.\n    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n    if (this.analysis === null) {\n      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n    }\n    this.resolution = resolution;\n    this.state = TraitState.Resolved;\n    this.resolveDiagnostics = diagnostics;\n    this.typeCheckDiagnostics = null;\n    return this as ResolvedTrait<D, A, S, R>;\n  }\n\n  toSkipped(): SkippedTrait<D, A, S, R> {\n    // Only pending traits can be skipped.\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n    this.state = TraitState.Skipped;\n    return this as SkippedTrait<D, A, S, R>;\n  }\n\n  /**\n   * Verifies that the trait is currently in one of the `allowedState`s.\n   *\n   * If correctly used, the `Trait` type and transition methods prevent illegal transitions from\n   * occurring. However, if a reference to the `TraitImpl` instance typed with the previous\n   * interface is retained after calling one of its transition methods, it will allow for illegal\n   * transitions to take place. Hence, this assertion provides a little extra runtime protection.\n   */\n  private assertTransitionLegal(allowedState: TraitState, transitionTo: TraitState): void {\n    if (!(this.state === allowedState)) {\n      throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${\n          TraitState[transitionTo]}.`);\n    }\n  }\n\n  /**\n   * Construct a new `TraitImpl` in the pending state.\n   */\n  static pending<D, A, S extends SemanticSymbol|null, R>(\n      handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>): PendingTrait<D, A, S, R> {\n    return new TraitImpl(handler, detected) as PendingTrait<D, A, S, R>;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ImportRewriter} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\nimport {ImportManager, translateType} from '../../translator';\n\nimport {DtsTransform} from './api';\nimport {addImports} from './utils';\n\n/**\n * Keeps track of `DtsTransform`s per source file, so that it is known which source files need to\n * have their declaration file transformed.\n */\nexport class DtsTransformRegistry {\n  private ivyDeclarationTransforms = new Map<ts.SourceFile, IvyDeclarationDtsTransform>();\n\n  getIvyDeclarationTransform(sf: ts.SourceFile): IvyDeclarationDtsTransform {\n    if (!this.ivyDeclarationTransforms.has(sf)) {\n      this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n    }\n    return this.ivyDeclarationTransforms.get(sf)!;\n  }\n\n  /**\n   * Gets the dts transforms to be applied for the given source file, or `null` if no transform is\n   * necessary.\n   */\n  getAllTransforms(sf: ts.SourceFile): DtsTransform[]|null {\n    // No need to transform if it's not a declarations file, or if no changes have been requested\n    // to the input file. Due to the way TypeScript afterDeclarations transformers work, the\n    // `ts.SourceFile` path is the same as the original .ts. The only way we know it's actually a\n    // declaration file is via the `isDeclarationFile` property.\n    if (!sf.isDeclarationFile) {\n      return null;\n    }\n    const originalSf = ts.getOriginalNode(sf) as ts.SourceFile;\n\n    let transforms: DtsTransform[]|null = null;\n    if (this.ivyDeclarationTransforms.has(originalSf)) {\n      transforms = [];\n      transforms.push(this.ivyDeclarationTransforms.get(originalSf)!);\n    }\n    return transforms;\n  }\n}\n\nexport function declarationTransformFactory(\n    transformRegistry: DtsTransformRegistry, importRewriter: ImportRewriter,\n    importPrefix?: string): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const transformer = new DtsTransformer(context, importRewriter, importPrefix);\n    return (fileOrBundle) => {\n      if (ts.isBundle(fileOrBundle)) {\n        // Only attempt to transform source files.\n        return fileOrBundle;\n      }\n      const transforms = transformRegistry.getAllTransforms(fileOrBundle);\n      if (transforms === null) {\n        return fileOrBundle;\n      }\n      return transformer.transform(fileOrBundle, transforms);\n    };\n  };\n}\n\n/**\n * Processes .d.ts file text and adds static field declarations, with types.\n */\nclass DtsTransformer {\n  constructor(\n      private ctx: ts.TransformationContext, private importRewriter: ImportRewriter,\n      private importPrefix?: string) {}\n\n  /**\n   * Transform the declaration file and add any declarations which were recorded.\n   */\n  transform(sf: ts.SourceFile, transforms: DtsTransform[]): ts.SourceFile {\n    const imports = new ImportManager(this.importRewriter, this.importPrefix);\n\n    const visitor: ts.Visitor = (node: ts.Node): ts.VisitResult<ts.Node> => {\n      if (ts.isClassDeclaration(node)) {\n        return this.transformClassDeclaration(node, transforms, imports);\n      } else if (ts.isFunctionDeclaration(node)) {\n        return this.transformFunctionDeclaration(node, transforms, imports);\n      } else {\n        // Otherwise return node as is.\n        return ts.visitEachChild(node, visitor, this.ctx);\n      }\n    };\n\n    // Recursively scan through the AST and process all nodes as desired.\n    sf = ts.visitNode(sf, visitor, ts.isSourceFile) || sf;\n\n    // Add new imports for this file.\n    return addImports(imports, sf);\n  }\n\n  private transformClassDeclaration(\n      clazz: ts.ClassDeclaration, transforms: DtsTransform[],\n      imports: ImportManager): ts.ClassDeclaration {\n    let elements: ts.ClassElement[]|ReadonlyArray<ts.ClassElement> = clazz.members;\n    let elementsChanged = false;\n\n    for (const transform of transforms) {\n      if (transform.transformClassElement !== undefined) {\n        for (let i = 0; i < elements.length; i++) {\n          const res = transform.transformClassElement(elements[i], imports);\n          if (res !== elements[i]) {\n            if (!elementsChanged) {\n              elements = [...elements];\n              elementsChanged = true;\n            }\n            (elements as ts.ClassElement[])[i] = res;\n          }\n        }\n      }\n    }\n\n    let newClazz: ts.ClassDeclaration = clazz;\n\n    for (const transform of transforms) {\n      if (transform.transformClass !== undefined) {\n        // If no DtsTransform has changed the class yet, then the (possibly mutated) elements have\n        // not yet been incorporated. Otherwise, `newClazz.members` holds the latest class members.\n        const inputMembers = (clazz === newClazz ? elements : newClazz.members);\n\n        newClazz = transform.transformClass(newClazz, inputMembers, imports);\n      }\n    }\n\n    // If some elements have been transformed but the class itself has not been transformed, create\n    // an updated class declaration with the updated elements.\n    if (elementsChanged && clazz === newClazz) {\n      newClazz = ts.factory.updateClassDeclaration(\n          /* node */ clazz,\n          /* modifiers */ clazz.modifiers,\n          /* name */ clazz.name,\n          /* typeParameters */ clazz.typeParameters,\n          /* heritageClauses */ clazz.heritageClauses,\n          /* members */ elements);\n    }\n\n    return newClazz;\n  }\n\n  private transformFunctionDeclaration(\n      declaration: ts.FunctionDeclaration, transforms: DtsTransform[],\n      imports: ImportManager): ts.FunctionDeclaration {\n    let newDecl = declaration;\n\n    for (const transform of transforms) {\n      if (transform.transformFunctionDeclaration !== undefined) {\n        newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n      }\n    }\n\n    return newDecl;\n  }\n}\n\nexport interface IvyDeclarationField {\n  name: string;\n  type: Type;\n}\n\nexport class IvyDeclarationDtsTransform implements DtsTransform {\n  private declarationFields = new Map<ClassDeclaration, IvyDeclarationField[]>();\n\n  addFields(decl: ClassDeclaration, fields: IvyDeclarationField[]): void {\n    this.declarationFields.set(decl, fields);\n  }\n\n  transformClass(\n      clazz: ts.ClassDeclaration, members: ReadonlyArray<ts.ClassElement>,\n      imports: ImportManager): ts.ClassDeclaration {\n    const original = ts.getOriginalNode(clazz) as ClassDeclaration;\n\n    if (!this.declarationFields.has(original)) {\n      return clazz;\n    }\n    const fields = this.declarationFields.get(original)!;\n\n    const newMembers = fields.map(decl => {\n      const modifiers = [ts.factory.createModifier(ts.SyntaxKind.StaticKeyword)];\n      const typeRef = translateType(decl.type, imports);\n      markForEmitAsSingleLine(typeRef);\n      return ts.factory.createPropertyDeclaration(\n          /* modifiers */ modifiers,\n          /* name */ decl.name,\n          /* questionOrExclamationToken */ undefined,\n          /* type */ typeRef,\n          /* initializer */ undefined);\n    });\n\n    return ts.factory.updateClassDeclaration(\n        /* node */ clazz,\n        /* modifiers */ clazz.modifiers,\n        /* name */ clazz.name,\n        /* typeParameters */ clazz.typeParameters,\n        /* heritageClauses */ clazz.heritageClauses,\n        /* members */[...members, ...newMembers]);\n  }\n}\n\nfunction markForEmitAsSingleLine(node: ts.Node) {\n  ts.setEmitFlags(node, ts.EmitFlags.SingleLine);\n  ts.forEachChild(node, markForEmitAsSingleLine);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The current context of a translator visitor as it traverses the AST tree.\n *\n * It tracks whether we are in the process of outputting a statement or an expression.\n */\nexport class Context {\n  constructor(readonly isStatement: boolean) {}\n\n  get withExpressionMode(): Context {\n    return this.isStatement ? new Context(false) : this;\n  }\n\n  get withStatementMode(): Context {\n    return !this.isStatement ? new Context(true) : this;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {ImportRewriter, NoopImportRewriter} from '../../imports';\n\nimport {ImportGenerator, NamedImport} from './api/import_generator';\n\n/**\n * Information about an import that has been added to a module.\n */\nexport interface Import {\n  /** The name of the module that has been imported. */\n  specifier: string;\n  /** The `ts.Identifier` by which the imported module is known. */\n  qualifier: ts.Identifier;\n}\n\nexport class ImportManager implements ImportGenerator<ts.Identifier> {\n  private specifierToIdentifier = new Map<string, ts.Identifier>();\n  private nextIndex = 0;\n\n  constructor(protected rewriter: ImportRewriter = new NoopImportRewriter(), private prefix = 'i') {\n  }\n\n  generateNamespaceImport(moduleName: string): ts.Identifier {\n    if (!this.specifierToIdentifier.has(moduleName)) {\n      this.specifierToIdentifier.set(\n          moduleName, ts.factory.createIdentifier(`${this.prefix}${this.nextIndex++}`));\n    }\n    return this.specifierToIdentifier.get(moduleName)!;\n  }\n\n  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport<ts.Identifier> {\n    // First, rewrite the symbol name.\n    const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n\n    // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced\n    // directly (moduleImport: null).\n    if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n      // The symbol should be referenced directly.\n      return {moduleImport: null, symbol};\n    }\n\n    // If not, this symbol will be imported using a generated namespace import.\n    const moduleImport = this.generateNamespaceImport(moduleName);\n\n    return {moduleImport, symbol};\n  }\n\n  getAllImports(contextPath: string): Import[] {\n    const imports: Import[] = [];\n    for (const [originalSpecifier, qualifier] of this.specifierToIdentifier) {\n      const specifier = this.rewriter.rewriteSpecifier(originalSpecifier, contextPath);\n      imports.push({\n        specifier,\n        qualifier,\n      });\n    }\n    return imports;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '@angular/compiler';\n\nimport {AstFactory, BinaryOperator, ObjectLiteralProperty, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator} from './api/ast_factory';\nimport {ImportGenerator} from './api/import_generator';\nimport {Context} from './context';\n\nconst UNARY_OPERATORS = new Map<o.UnaryOperator, UnaryOperator>([\n  [o.UnaryOperator.Minus, '-'],\n  [o.UnaryOperator.Plus, '+'],\n]);\n\nconst BINARY_OPERATORS = new Map<o.BinaryOperator, BinaryOperator>([\n  [o.BinaryOperator.And, '&&'],\n  [o.BinaryOperator.Bigger, '>'],\n  [o.BinaryOperator.BiggerEquals, '>='],\n  [o.BinaryOperator.BitwiseAnd, '&'],\n  [o.BinaryOperator.Divide, '/'],\n  [o.BinaryOperator.Equals, '=='],\n  [o.BinaryOperator.Identical, '==='],\n  [o.BinaryOperator.Lower, '<'],\n  [o.BinaryOperator.LowerEquals, '<='],\n  [o.BinaryOperator.Minus, '-'],\n  [o.BinaryOperator.Modulo, '%'],\n  [o.BinaryOperator.Multiply, '*'],\n  [o.BinaryOperator.NotEquals, '!='],\n  [o.BinaryOperator.NotIdentical, '!=='],\n  [o.BinaryOperator.Or, '||'],\n  [o.BinaryOperator.Plus, '+'],\n  [o.BinaryOperator.NullishCoalesce, '??'],\n]);\n\nexport type RecordWrappedNodeFn<TExpression> = (node: o.WrappedNodeExpr<TExpression>) => void;\n\nexport interface TranslatorOptions<TExpression> {\n  downlevelTaggedTemplates?: boolean;\n  downlevelVariableDeclarations?: boolean;\n  recordWrappedNode?: RecordWrappedNodeFn<TExpression>;\n  annotateForClosureCompiler?: boolean;\n}\n\nexport class ExpressionTranslatorVisitor<TStatement, TExpression> implements o.ExpressionVisitor,\n                                                                             o.StatementVisitor {\n  private downlevelTaggedTemplates: boolean;\n  private downlevelVariableDeclarations: boolean;\n  private recordWrappedNode: RecordWrappedNodeFn<TExpression>;\n\n  constructor(\n      private factory: AstFactory<TStatement, TExpression>,\n      private imports: ImportGenerator<TExpression>, options: TranslatorOptions<TExpression>) {\n    this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;\n    this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;\n    this.recordWrappedNode = options.recordWrappedNode || (() => {});\n  }\n\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, context: Context): TStatement {\n    const varType = this.downlevelVariableDeclarations ? 'var' :\n        stmt.hasModifier(o.StmtModifier.Final)         ? 'const' :\n                                                         'let';\n    return this.attachComments(\n        this.factory.createVariableDeclaration(\n            stmt.name, stmt.value?.visitExpression(this, context.withExpressionMode), varType),\n        stmt.leadingComments);\n  }\n\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createFunctionDeclaration(\n            stmt.name, stmt.params.map(param => param.name),\n            this.factory.createBlock(\n                this.visitStatements(stmt.statements, context.withStatementMode))),\n        stmt.leadingComments);\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createExpressionStatement(\n            stmt.expr.visitExpression(this, context.withStatementMode)),\n        stmt.leadingComments);\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createReturnStatement(\n            stmt.value.visitExpression(this, context.withExpressionMode)),\n        stmt.leadingComments);\n  }\n\n  visitIfStmt(stmt: o.IfStmt, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createIfStatement(\n            stmt.condition.visitExpression(this, context),\n            this.factory.createBlock(\n                this.visitStatements(stmt.trueCase, context.withStatementMode)),\n            stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(\n                                            stmt.falseCase, context.withStatementMode)) :\n                                        null),\n        stmt.leadingComments);\n  }\n\n  visitReadVarExpr(ast: o.ReadVarExpr, _context: Context): TExpression {\n    const identifier = this.factory.createIdentifier(ast.name!);\n    this.setSourceMapRange(identifier, ast.sourceSpan);\n    return identifier;\n  }\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, context: Context): TExpression {\n    const assignment = this.factory.createAssignment(\n        this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan),\n        expr.value.visitExpression(this, context),\n    );\n    return context.isStatement ? assignment :\n                                 this.factory.createParenthesizedExpression(assignment);\n  }\n\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, context: Context): TExpression {\n    const exprContext = context.withExpressionMode;\n    const target = this.factory.createElementAccess(\n        expr.receiver.visitExpression(this, exprContext),\n        expr.index.visitExpression(this, exprContext),\n    );\n    const assignment =\n        this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));\n    return context.isStatement ? assignment :\n                                 this.factory.createParenthesizedExpression(assignment);\n  }\n\n  visitWritePropExpr(expr: o.WritePropExpr, context: Context): TExpression {\n    const target =\n        this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);\n    return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n  }\n\n  visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): TExpression {\n    return this.setSourceMapRange(\n        this.factory.createCallExpression(\n            ast.fn.visitExpression(this, context),\n            ast.args.map(arg => arg.visitExpression(this, context)), ast.pure),\n        ast.sourceSpan);\n  }\n\n  visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, context: Context): TExpression {\n    return this.setSourceMapRange(\n        this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), {\n          elements: ast.template.elements.map(e => createTemplateElement({\n                                                cooked: e.text,\n                                                raw: e.rawText,\n                                                range: e.sourceSpan ?? ast.sourceSpan,\n                                              })),\n          expressions: ast.template.expressions.map(e => e.visitExpression(this, context))\n        }),\n        ast.sourceSpan);\n  }\n\n  visitInstantiateExpr(ast: o.InstantiateExpr, context: Context): TExpression {\n    return this.factory.createNewExpression(\n        ast.classExpr.visitExpression(this, context),\n        ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, _context: Context): TExpression {\n    return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, context: Context): TExpression {\n    // A `$localize` message consists of `messageParts` and `expressions`, which get interleaved\n    // together. The interleaved pieces look like:\n    // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n    //\n    // Note that there is always a message part at the start and end, and so therefore\n    // `messageParts.length === expressions.length + 1`.\n    //\n    // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n    // The metadata is attached to the first and subsequent message parts by calls to\n    // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n    //\n    // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`\n    // array.\n    const elements: TemplateElement[] = [createTemplateElement(ast.serializeI18nHead())];\n    const expressions: TExpression[] = [];\n    for (let i = 0; i < ast.expressions.length; i++) {\n      const placeholder = this.setSourceMapRange(\n          ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));\n      expressions.push(placeholder);\n      elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));\n    }\n\n    const localizeTag = this.factory.createIdentifier('$localize');\n    return this.setSourceMapRange(\n        this.createTaggedTemplateExpression(localizeTag, {elements, expressions}), ast.sourceSpan);\n  }\n\n  private createTaggedTemplateExpression(tag: TExpression, template: TemplateLiteral<TExpression>):\n      TExpression {\n    return this.downlevelTaggedTemplates ? this.createES5TaggedTemplateFunctionCall(tag, template) :\n                                           this.factory.createTaggedTemplate(tag, template);\n  }\n\n  /**\n   * Translate the tagged template literal into a call that is compatible with ES5, using the\n   * imported `__makeTemplateObject` helper for ES5 formatted output.\n   */\n  private createES5TaggedTemplateFunctionCall(\n      tagHandler: TExpression, {elements, expressions}: TemplateLiteral<TExpression>): TExpression {\n    // Ensure that the `__makeTemplateObject()` helper has been imported.\n    const {moduleImport, symbol} =\n        this.imports.generateNamedImport('tslib', '__makeTemplateObject');\n    const __makeTemplateObjectHelper = (moduleImport === null) ?\n        this.factory.createIdentifier(symbol) :\n        this.factory.createPropertyAccess(moduleImport, symbol);\n\n    // Collect up the cooked and raw strings into two separate arrays.\n    const cooked: TExpression[] = [];\n    const raw: TExpression[] = [];\n    for (const element of elements) {\n      cooked.push(this.factory.setSourceMapRange(\n          this.factory.createLiteral(element.cooked), element.range));\n      raw.push(\n          this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));\n    }\n\n    // Generate the helper call in the form: `__makeTemplateObject([cooked], [raw]);`\n    const templateHelperCall = this.factory.createCallExpression(\n        __makeTemplateObjectHelper,\n        [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)],\n        /* pure */ false);\n\n    // Finally create the tagged handler call in the form:\n    // `tag(__makeTemplateObject([cooked], [raw]), ...expressions);`\n    return this.factory.createCallExpression(\n        tagHandler, [templateHelperCall, ...expressions],\n        /* pure */ false);\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, _context: Context): TExpression {\n    if (ast.value.name === null) {\n      if (ast.value.moduleName === null) {\n        throw new Error('Invalid import without name nor moduleName');\n      }\n      return this.imports.generateNamespaceImport(ast.value.moduleName);\n    }\n    // If a moduleName is specified, this is a normal import. If there's no module name, it's a\n    // reference to a global/ambient symbol.\n    if (ast.value.moduleName !== null) {\n      // This is a normal import. Find the imported module.\n      const {moduleImport, symbol} =\n          this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n      if (moduleImport === null) {\n        // The symbol was ambient after all.\n        return this.factory.createIdentifier(symbol);\n      } else {\n        return this.factory.createPropertyAccess(moduleImport, symbol);\n      }\n    } else {\n      // The symbol is ambient, so just reference it.\n      return this.factory.createIdentifier(ast.value.name);\n    }\n  }\n\n  visitConditionalExpr(ast: o.ConditionalExpr, context: Context): TExpression {\n    let cond: TExpression = ast.condition.visitExpression(this, context);\n\n    // Ordinarily the ternary operator is right-associative. The following are equivalent:\n    //   `a ? b : c ? d : e` => `a ? b : (c ? d : e)`\n    //\n    // However, occasionally Angular needs to produce a left-associative conditional, such as in\n    // the case of a null-safe navigation production: `{{a?.b ? c : d}}`. This template produces\n    // a ternary of the form:\n    //   `a == null ? null : rest of expression`\n    // If the rest of the expression is also a ternary though, this would produce the form:\n    //   `a == null ? null : a.b ? c : d`\n    // which, if left as right-associative, would be incorrectly associated as:\n    //   `a == null ? null : (a.b ? c : d)`\n    //\n    // In such cases, the left-associativity needs to be enforced with parentheses:\n    //   `(a == null ? null : a.b) ? c : d`\n    //\n    // Such parentheses could always be included in the condition (guaranteeing correct behavior) in\n    // all cases, but this has a code size cost. Instead, parentheses are added only when a\n    // conditional expression is directly used as the condition of another.\n    //\n    // TODO(alxhub): investigate better logic for precendence of conditional operators\n    if (ast.condition instanceof o.ConditionalExpr) {\n      // The condition of this ternary needs to be wrapped in parentheses to maintain\n      // left-associativity.\n      cond = this.factory.createParenthesizedExpression(cond);\n    }\n\n    return this.factory.createConditional(\n        cond, ast.trueCase.visitExpression(this, context),\n        ast.falseCase!.visitExpression(this, context));\n  }\n\n  visitNotExpr(ast: o.NotExpr, context: Context): TExpression {\n    return this.factory.createUnaryExpression('!', ast.condition.visitExpression(this, context));\n  }\n\n  visitFunctionExpr(ast: o.FunctionExpr, context: Context): TExpression {\n    return this.factory.createFunctionExpression(\n        ast.name ?? null, ast.params.map(param => param.name),\n        this.factory.createBlock(this.visitStatements(ast.statements, context)));\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, context: Context): TExpression {\n    if (!BINARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown binary operator: ${o.BinaryOperator[ast.operator]}`);\n    }\n    return this.factory.createBinaryExpression(\n        ast.lhs.visitExpression(this, context),\n        BINARY_OPERATORS.get(ast.operator)!,\n        ast.rhs.visitExpression(this, context),\n    );\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, context: Context): TExpression {\n    return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n  }\n\n  visitReadKeyExpr(ast: o.ReadKeyExpr, context: Context): TExpression {\n    return this.factory.createElementAccess(\n        ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: Context): TExpression {\n    return this.factory.createArrayLiteral(ast.entries.map(\n        expr => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: Context): TExpression {\n    const properties: ObjectLiteralProperty<TExpression>[] = ast.entries.map(entry => {\n      return {\n        propertyName: entry.key,\n        quoted: entry.quoted,\n        value: entry.value.visitExpression(this, context)\n      };\n    });\n    return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);\n  }\n\n  visitCommaExpr(ast: o.CommaExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, _context: Context): any {\n    this.recordWrappedNode(ast);\n    return ast.node;\n  }\n\n  visitTypeofExpr(ast: o.TypeofExpr, context: Context): TExpression {\n    return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));\n  }\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, context: Context): TExpression {\n    if (!UNARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown unary operator: ${o.UnaryOperator[ast.operator]}`);\n    }\n    return this.factory.createUnaryExpression(\n        UNARY_OPERATORS.get(ast.operator)!, ast.expr.visitExpression(this, context));\n  }\n\n  private visitStatements(statements: o.Statement[], context: Context): TStatement[] {\n    return statements.map(stmt => stmt.visitStatement(this, context))\n        .filter(stmt => stmt !== undefined);\n  }\n\n  private setSourceMapRange<T extends TExpression|TStatement>(ast: T, span: o.ParseSourceSpan|null):\n      T {\n    return this.factory.setSourceMapRange(ast, createRange(span));\n  }\n\n  private attachComments(statement: TStatement, leadingComments: o.LeadingComment[]|undefined):\n      TStatement {\n    if (leadingComments !== undefined) {\n      this.factory.attachComments(statement, leadingComments);\n    }\n    return statement;\n  }\n}\n\n/**\n * Convert a cooked-raw string object into one that can be used by the AST factories.\n */\nfunction createTemplateElement(\n    {cooked, raw, range}: {cooked: string, raw: string, range: o.ParseSourceSpan|null}):\n    TemplateElement {\n  return {cooked, raw, range: createRange(range)};\n}\n\n/**\n * Convert an OutputAST source-span into a range that can be used by the AST factories.\n */\nfunction createRange(span: o.ParseSourceSpan|null): SourceMapRange|null {\n  if (span === null) {\n    return null;\n  }\n  const {start, end} = span;\n  const {url, content} = start.file;\n  if (!url) {\n    return null;\n  }\n  return {\n    url,\n    content,\n    start: {offset: start.offset, line: start.line, column: start.col},\n    end: {offset: end.offset, line: end.line, column: end.col},\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Context} from './context';\nimport {ImportManager} from './import_manager';\n\n\nexport function translateType(type: o.Type, imports: ImportManager): ts.TypeNode {\n  return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));\n}\n\nexport class TypeTranslatorVisitor implements o.ExpressionVisitor, o.TypeVisitor {\n  constructor(private imports: ImportManager) {}\n\n  visitBuiltinType(type: o.BuiltinType, context: Context): ts.KeywordTypeNode {\n    switch (type.name) {\n      case o.BuiltinTypeName.Bool:\n        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n      case o.BuiltinTypeName.Dynamic:\n        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n      case o.BuiltinTypeName.Int:\n      case o.BuiltinTypeName.Number:\n        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n      case o.BuiltinTypeName.String:\n        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n      case o.BuiltinTypeName.None:\n        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\n      default:\n        throw new Error(`Unsupported builtin type: ${o.BuiltinTypeName[type.name]}`);\n    }\n  }\n\n  visitExpressionType(type: o.ExpressionType, context: Context): ts.TypeNode {\n    const typeNode = this.translateExpression(type.value, context);\n    if (type.typeParams === null) {\n      return typeNode;\n    }\n\n    if (!ts.isTypeReferenceNode(typeNode)) {\n      throw new Error(\n          'An ExpressionType with type arguments must translate into a TypeReferenceNode');\n    } else if (typeNode.typeArguments !== undefined) {\n      throw new Error(\n          `An ExpressionType with type arguments cannot have multiple levels of type arguments`);\n    }\n\n    const typeArgs = type.typeParams.map(param => this.translateType(param, context));\n    return ts.factory.createTypeReferenceNode(typeNode.typeName, typeArgs);\n  }\n\n  visitArrayType(type: o.ArrayType, context: Context): ts.ArrayTypeNode {\n    return ts.factory.createArrayTypeNode(this.translateType(type.of, context));\n  }\n\n  visitMapType(type: o.MapType, context: Context): ts.TypeLiteralNode {\n    const parameter = ts.factory.createParameterDeclaration(\n        undefined, undefined, 'key', undefined,\n        ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));\n    const typeArgs = type.valueType !== null ?\n        this.translateType(type.valueType, context) :\n        ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n    const indexSignature = ts.factory.createIndexSignature(undefined, [parameter], typeArgs);\n    return ts.factory.createTypeLiteralNode([indexSignature]);\n  }\n\n  visitReadVarExpr(ast: o.ReadVarExpr, context: Context): ts.TypeQueryNode {\n    if (ast.name === null) {\n      throw new Error(`ReadVarExpr with no variable name in type`);\n    }\n    return ts.factory.createTypeQueryNode(ts.factory.createIdentifier(ast.name));\n  }\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWritePropExpr(expr: o.WritePropExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInstantiateExpr(ast: o.InstantiateExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, context: Context): ts.TypeNode {\n    if (ast.value === null) {\n      return ts.factory.createLiteralTypeNode(ts.factory.createNull());\n    } else if (ast.value === undefined) {\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n    } else if (typeof ast.value === 'boolean') {\n      return ts.factory.createLiteralTypeNode(\n          ast.value ? ts.factory.createTrue() : ts.factory.createFalse());\n    } else if (typeof ast.value === 'number') {\n      return ts.factory.createLiteralTypeNode(ts.factory.createNumericLiteral(ast.value));\n    } else {\n      return ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(ast.value));\n    }\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, context: Context): ts.EntityName|ts.TypeReferenceNode {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol`);\n    }\n    const {moduleImport, symbol} =\n        this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n    const symbolIdentifier = ts.factory.createIdentifier(symbol);\n\n    const typeName = moduleImport ? ts.factory.createQualifiedName(moduleImport, symbolIdentifier) :\n                                    symbolIdentifier;\n\n    const typeArguments = ast.typeParams !== null ?\n        ast.typeParams.map(type => this.translateType(type, context)) :\n        undefined;\n    return ts.factory.createTypeReferenceNode(typeName, typeArguments);\n  }\n\n  visitConditionalExpr(ast: o.ConditionalExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitNotExpr(ast: o.NotExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitFunctionExpr(ast: o.FunctionExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadKeyExpr(ast: o.ReadKeyExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: Context): ts.TupleTypeNode {\n    const values = ast.entries.map(expr => this.translateExpression(expr, context));\n    return ts.factory.createTupleTypeNode(values);\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: Context): ts.TypeLiteralNode {\n    const entries = ast.entries.map(entry => {\n      const {key, quoted} = entry;\n      const type = this.translateExpression(entry.value, context);\n      return ts.factory.createPropertySignature(\n          /* modifiers */ undefined,\n          /* name */ quoted ? ts.factory.createStringLiteral(key) : key,\n          /* questionToken */ undefined,\n          /* type */ type);\n    });\n    return ts.factory.createTypeLiteralNode(entries);\n  }\n\n  visitCommaExpr(ast: o.CommaExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, context: Context): ts.TypeNode {\n    const node: ts.Node = ast.node;\n    if (ts.isEntityName(node)) {\n      return ts.factory.createTypeReferenceNode(node, /* typeArguments */ undefined);\n    } else if (ts.isTypeNode(node)) {\n      return node;\n    } else if (ts.isLiteralExpression(node)) {\n      return ts.factory.createLiteralTypeNode(node);\n    } else {\n      throw new Error(\n          `Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);\n    }\n  }\n\n  visitTypeofExpr(ast: o.TypeofExpr, context: Context): ts.TypeQueryNode {\n    const typeNode = this.translateExpression(ast.expr, context);\n    if (!ts.isTypeReferenceNode(typeNode)) {\n      throw new Error(`The target of a typeof expression must be a type reference, but it was\n          ${ts.SyntaxKind[typeNode.kind]}`);\n    }\n    return ts.factory.createTypeQueryNode(typeNode.typeName);\n  }\n\n  private translateType(type: o.Type, context: Context): ts.TypeNode {\n    const typeNode = type.visitType(this, context);\n    if (!ts.isTypeNode(typeNode)) {\n      throw new Error(\n          `A Type must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n\n  private translateExpression(expr: o.Expression, context: Context): ts.TypeNode {\n    const typeNode = expr.visitExpression(this, context);\n    if (!ts.isTypeNode(typeNode)) {\n      throw new Error(\n          `An Expression must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapRange, TemplateLiteral, UnaryOperator, VariableDeclarationType} from './api/ast_factory';\n\n/**\n * Different optimizers use different annotations on a function or method call to indicate its pure\n * status.\n */\nenum PureAnnotation {\n  /**\n   * Closure's annotation for purity is `@pureOrBreakMyCode`, but this needs to be in a semantic\n   * (jsdoc) enabled comment. Thus, the actual comment text for Closure must include the `*` that\n   * turns a `/*` comment into a `/**` comment, as well as surrounding whitespace.\n   */\n  CLOSURE = '* @pureOrBreakMyCode ',\n\n  TERSER = '@__PURE__',\n}\n\nconst UNARY_OPERATORS: Record<UnaryOperator, ts.PrefixUnaryOperator> = {\n  '+': ts.SyntaxKind.PlusToken,\n  '-': ts.SyntaxKind.MinusToken,\n  '!': ts.SyntaxKind.ExclamationToken,\n};\n\nconst BINARY_OPERATORS: Record<BinaryOperator, ts.BinaryOperator> = {\n  '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n  '>': ts.SyntaxKind.GreaterThanToken,\n  '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n  '&': ts.SyntaxKind.AmpersandToken,\n  '/': ts.SyntaxKind.SlashToken,\n  '==': ts.SyntaxKind.EqualsEqualsToken,\n  '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n  '<': ts.SyntaxKind.LessThanToken,\n  '<=': ts.SyntaxKind.LessThanEqualsToken,\n  '-': ts.SyntaxKind.MinusToken,\n  '%': ts.SyntaxKind.PercentToken,\n  '*': ts.SyntaxKind.AsteriskToken,\n  '!=': ts.SyntaxKind.ExclamationEqualsToken,\n  '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n  '||': ts.SyntaxKind.BarBarToken,\n  '+': ts.SyntaxKind.PlusToken,\n  '??': ts.SyntaxKind.QuestionQuestionToken,\n};\n\nconst VAR_TYPES: Record<VariableDeclarationType, ts.NodeFlags> = {\n  'const': ts.NodeFlags.Const,\n  'let': ts.NodeFlags.Let,\n  'var': ts.NodeFlags.None,\n};\n\n/**\n * A TypeScript flavoured implementation of the AstFactory.\n */\nexport class TypeScriptAstFactory implements AstFactory<ts.Statement, ts.Expression> {\n  private externalSourceFiles = new Map<string, ts.SourceMapSource>();\n\n  constructor(private annotateForClosureCompiler: boolean) {}\n\n  attachComments = attachComments;\n\n  createArrayLiteral = ts.factory.createArrayLiteralExpression;\n\n  createAssignment(target: ts.Expression, value: ts.Expression): ts.Expression {\n    return ts.factory.createBinaryExpression(target, ts.SyntaxKind.EqualsToken, value);\n  }\n\n  createBinaryExpression(\n      leftOperand: ts.Expression, operator: BinaryOperator,\n      rightOperand: ts.Expression): ts.Expression {\n    return ts.factory.createBinaryExpression(leftOperand, BINARY_OPERATORS[operator], rightOperand);\n  }\n\n  createBlock(body: ts.Statement[]): ts.Statement {\n    return ts.factory.createBlock(body);\n  }\n\n  createCallExpression(callee: ts.Expression, args: ts.Expression[], pure: boolean): ts.Expression {\n    const call = ts.factory.createCallExpression(callee, undefined, args);\n    if (pure) {\n      ts.addSyntheticLeadingComment(\n          call, ts.SyntaxKind.MultiLineCommentTrivia,\n          this.annotateForClosureCompiler ? PureAnnotation.CLOSURE : PureAnnotation.TERSER,\n          /* trailing newline */ false);\n    }\n    return call;\n  }\n\n  createConditional(condition: ts.Expression, whenTrue: ts.Expression, whenFalse: ts.Expression):\n      ts.Expression {\n    return ts.factory.createConditionalExpression(\n        condition, undefined, whenTrue, undefined, whenFalse);\n  }\n\n  createElementAccess = ts.factory.createElementAccessExpression;\n\n  createExpressionStatement = ts.factory.createExpressionStatement;\n\n  createFunctionDeclaration(functionName: string, parameters: string[], body: ts.Statement):\n      ts.Statement {\n    if (!ts.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);\n    }\n    return ts.factory.createFunctionDeclaration(\n        undefined, undefined, functionName, undefined,\n        parameters.map(param => ts.factory.createParameterDeclaration(undefined, undefined, param)),\n        undefined, body);\n  }\n\n  createFunctionExpression(functionName: string|null, parameters: string[], body: ts.Statement):\n      ts.Expression {\n    if (!ts.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);\n    }\n    return ts.factory.createFunctionExpression(\n        undefined, undefined, functionName ?? undefined, undefined,\n        parameters.map(param => ts.factory.createParameterDeclaration(undefined, undefined, param)),\n        undefined, body);\n  }\n\n  createIdentifier = ts.factory.createIdentifier;\n\n  createIfStatement(\n      condition: ts.Expression, thenStatement: ts.Statement,\n      elseStatement: ts.Statement|null): ts.Statement {\n    return ts.factory.createIfStatement(condition, thenStatement, elseStatement ?? undefined);\n  }\n\n  createLiteral(value: string|number|boolean|null|undefined): ts.Expression {\n    if (value === undefined) {\n      return ts.factory.createIdentifier('undefined');\n    } else if (value === null) {\n      return ts.factory.createNull();\n    } else if (typeof value === 'boolean') {\n      return value ? ts.factory.createTrue() : ts.factory.createFalse();\n    } else if (typeof value === 'number') {\n      return ts.factory.createNumericLiteral(value);\n    } else {\n      return ts.factory.createStringLiteral(value);\n    }\n  }\n\n  createNewExpression(expression: ts.Expression, args: ts.Expression[]): ts.Expression {\n    return ts.factory.createNewExpression(expression, undefined, args);\n  }\n\n  createObjectLiteral(properties: ObjectLiteralProperty<ts.Expression>[]): ts.Expression {\n    return ts.factory.createObjectLiteralExpression(properties.map(\n        prop => ts.factory.createPropertyAssignment(\n            prop.quoted ? ts.factory.createStringLiteral(prop.propertyName) :\n                          ts.factory.createIdentifier(prop.propertyName),\n            prop.value)));\n  }\n\n  createParenthesizedExpression = ts.factory.createParenthesizedExpression;\n\n  createPropertyAccess = ts.factory.createPropertyAccessExpression;\n\n  createReturnStatement(expression: ts.Expression|null): ts.Statement {\n    return ts.factory.createReturnStatement(expression ?? undefined);\n  }\n\n  createTaggedTemplate(tag: ts.Expression, template: TemplateLiteral<ts.Expression>):\n      ts.Expression {\n    let templateLiteral: ts.TemplateLiteral;\n    const length = template.elements.length;\n    const head = template.elements[0];\n    if (length === 1) {\n      templateLiteral = ts.factory.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);\n    } else {\n      const spans: ts.TemplateSpan[] = [];\n      // Create the middle parts\n      for (let i = 1; i < length - 1; i++) {\n        const {cooked, raw, range} = template.elements[i];\n        const middle = createTemplateMiddle(cooked, raw);\n        if (range !== null) {\n          this.setSourceMapRange(middle, range);\n        }\n        spans.push(ts.factory.createTemplateSpan(template.expressions[i - 1], middle));\n      }\n      // Create the tail part\n      const resolvedExpression = template.expressions[length - 2];\n      const templatePart = template.elements[length - 1];\n      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n      if (templatePart.range !== null) {\n        this.setSourceMapRange(templateTail, templatePart.range);\n      }\n      spans.push(ts.factory.createTemplateSpan(resolvedExpression, templateTail));\n      // Put it all together\n      templateLiteral = ts.factory.createTemplateExpression(\n          ts.factory.createTemplateHead(head.cooked, head.raw), spans);\n    }\n    if (head.range !== null) {\n      this.setSourceMapRange(templateLiteral, head.range);\n    }\n    return ts.factory.createTaggedTemplateExpression(tag, undefined, templateLiteral);\n  }\n\n  createThrowStatement = ts.factory.createThrowStatement;\n\n  createTypeOfExpression = ts.factory.createTypeOfExpression;\n\n\n  createUnaryExpression(operator: UnaryOperator, operand: ts.Expression): ts.Expression {\n    return ts.factory.createPrefixUnaryExpression(UNARY_OPERATORS[operator], operand);\n  }\n\n  createVariableDeclaration(\n      variableName: string, initializer: ts.Expression|null,\n      type: VariableDeclarationType): ts.Statement {\n    return ts.factory.createVariableStatement(\n        undefined,\n        ts.factory.createVariableDeclarationList(\n            [ts.factory.createVariableDeclaration(\n                variableName, undefined, undefined, initializer ?? undefined)],\n            VAR_TYPES[type]),\n    );\n  }\n\n  setSourceMapRange<T extends ts.Node>(node: T, sourceMapRange: SourceMapRange|null): T {\n    if (sourceMapRange === null) {\n      return node;\n    }\n\n    const url = sourceMapRange.url;\n    if (!this.externalSourceFiles.has(url)) {\n      this.externalSourceFiles.set(\n          url, ts.createSourceMapSource(url, sourceMapRange.content, pos => pos));\n    }\n    const source = this.externalSourceFiles.get(url);\n    ts.setSourceMapRange(\n        node, {pos: sourceMapRange.start.offset, end: sourceMapRange.end.offset, source});\n    return node;\n  }\n}\n\n// HACK: Use this in place of `ts.createTemplateMiddle()`.\n// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\nexport function createTemplateMiddle(cooked: string, raw: string): ts.TemplateMiddle {\n  const node: ts.TemplateLiteralLikeNode = ts.factory.createTemplateHead(cooked, raw);\n  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateMiddle;\n  return node as ts.TemplateMiddle;\n}\n\n// HACK: Use this in place of `ts.createTemplateTail()`.\n// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\nexport function createTemplateTail(cooked: string, raw: string): ts.TemplateTail {\n  const node: ts.TemplateLiteralLikeNode = ts.factory.createTemplateHead(cooked, raw);\n  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateTail;\n  return node as ts.TemplateTail;\n}\n\n/**\n * Attach the given `leadingComments` to the `statement` node.\n *\n * @param statement The statement that will have comments attached.\n * @param leadingComments The comments to attach to the statement.\n */\nexport function attachComments(statement: ts.Statement, leadingComments: LeadingComment[]): void {\n  for (const comment of leadingComments) {\n    const commentKind = comment.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :\n                                            ts.SyntaxKind.SingleLineCommentTrivia;\n    if (comment.multiline) {\n      ts.addSyntheticLeadingComment(\n          statement, commentKind, comment.toString(), comment.trailingNewline);\n    } else {\n      for (const line of comment.toString().split('\\n')) {\n        ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ImportGenerator} from './api/import_generator';\nimport {Context} from './context';\nimport {ExpressionTranslatorVisitor, TranslatorOptions} from './translator';\nimport {TypeScriptAstFactory} from './typescript_ast_factory';\n\nexport function translateExpression(\n    expression: o.Expression, imports: ImportGenerator<ts.Expression>,\n    options: TranslatorOptions<ts.Expression> = {}): ts.Expression {\n  return expression.visitExpression(\n      new ExpressionTranslatorVisitor<ts.Statement, ts.Expression>(\n          new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options),\n      new Context(false));\n}\n\nexport function translateStatement(\n    statement: o.Statement, imports: ImportGenerator<ts.Expression>,\n    options: TranslatorOptions<ts.Expression> = {}): ts.Statement {\n  return statement.visitStatement(\n      new ExpressionTranslatorVisitor<ts.Statement, ts.Expression>(\n          new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options),\n      new Context(true));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {ImportManager} from '../../translator';\n\n/**\n * Adds extra imports in the import manage for this source file, after the existing imports\n * and before the module body.\n * Can optionally add extra statements (e.g. new constants) before the body as well.\n */\nexport function addImports(\n    importManager: ImportManager, sf: ts.SourceFile,\n    extraStatements: ts.Statement[] = []): ts.SourceFile {\n  // Generate the import statements to prepend.\n  const addedImports = importManager.getAllImports(sf.fileName).map(i => {\n    const qualifier = ts.factory.createIdentifier(i.qualifier.text);\n    const importClause = ts.factory.createImportClause(\n        /* isTypeOnly */ false,\n        /* name */ undefined,\n        /* namedBindings */ ts.factory.createNamespaceImport(qualifier));\n    const decl = ts.factory.createImportDeclaration(\n        /* modifiers */ undefined,\n        /* importClause */ importClause,\n        /* moduleSpecifier */ ts.factory.createStringLiteral(i.specifier));\n\n    // Set the qualifier's original TS node to the `ts.ImportDeclaration`. This allows downstream\n    // transforms such as tsickle to properly process references to this import.\n    //\n    // This operation is load-bearing in g3 as some imported modules contain special metadata\n    // generated by clutz, which tsickle uses to transform imports and references to those imports.\n    //\n    // TODO(alxhub): add a test for this when tsickle is updated externally to depend on this\n    // behavior.\n    ts.setOriginalNode(i.qualifier, decl);\n\n    return decl;\n  });\n\n  // Filter out the existing imports and the source file body. All new statements\n  // will be inserted between them.\n  const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));\n  const body = sf.statements.filter(stmt => !isImportStatement(stmt));\n  // Prepend imports if needed.\n  if (addedImports.length > 0) {\n    // If we prepend imports, we also prepend NotEmittedStatement to use it as an anchor\n    // for @fileoverview Closure annotation. If there is no @fileoverview annotations, this\n    // statement would be a noop.\n    const fileoverviewAnchorStmt = ts.factory.createNotEmittedStatement(sf);\n    return ts.factory.updateSourceFile(sf, ts.factory.createNodeArray([\n      fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body\n    ]));\n  }\n\n  return sf;\n}\n\nfunction isImportStatement(stmt: ts.Statement): boolean {\n  return ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) ||\n      ts.isNamespaceImport(stmt);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {DefaultImportTracker, ImportRewriter} from '../../imports';\nimport {getDefaultImportDeclaration} from '../../imports/src/default';\nimport {PerfPhase, PerfRecorder} from '../../perf';\nimport {Decorator, ReflectionHost} from '../../reflection';\nimport {ImportManager, RecordWrappedNodeFn, translateExpression, translateStatement, TranslatorOptions} from '../../translator';\nimport {visit, VisitListEntryResult, Visitor} from '../../util/src/visitor';\n\nimport {CompileResult} from './api';\nimport {TraitCompiler} from './compilation';\nimport {addImports} from './utils';\n\nconst NO_DECORATORS = new Set<ts.Decorator>();\n\nconst CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\n\n/**\n * Metadata to support @fileoverview blocks (Closure annotations) extracting/restoring.\n */\ninterface FileOverviewMeta {\n  comments: ts.SynthesizedComment[];\n  host: ts.Statement;\n  trailing: boolean;\n}\n\nexport function ivyTransformFactory(\n    compilation: TraitCompiler, reflector: ReflectionHost, importRewriter: ImportRewriter,\n    defaultImportTracker: DefaultImportTracker, perf: PerfRecorder, isCore: boolean,\n    isClosureCompilerEnabled: boolean): ts.TransformerFactory<ts.SourceFile> {\n  const recordWrappedNode = createRecorderFn(defaultImportTracker);\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return perf.inPhase(\n          PerfPhase.Compile,\n          () => transformIvySourceFile(\n              compilation, context, reflector, importRewriter, file, isCore,\n              isClosureCompilerEnabled, recordWrappedNode));\n    };\n  };\n}\n\n/**\n * Visits all classes, performs Ivy compilation where Angular decorators are present and collects\n * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor\n * does NOT perform any TS transformations.\n */\nclass IvyCompilationVisitor extends Visitor {\n  public classCompilationMap = new Map<ts.ClassDeclaration, CompileResult[]>();\n\n  constructor(private compilation: TraitCompiler, private constantPool: ConstantPool) {\n    super();\n  }\n\n  override visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    // Determine if this class has an Ivy field that needs to be added, and compile the field\n    // to an expression if so.\n    const result = this.compilation.compile(node, this.constantPool);\n    if (result !== null) {\n      this.classCompilationMap.set(node, result);\n    }\n    return {node};\n  }\n}\n\n/**\n * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy\n * compilation results (provided as an argument).\n */\nclass IvyTransformationVisitor extends Visitor {\n  constructor(\n      private compilation: TraitCompiler,\n      private classCompilationMap: Map<ts.ClassDeclaration, CompileResult[]>,\n      private reflector: ReflectionHost, private importManager: ImportManager,\n      private recordWrappedNodeExpr: RecordWrappedNodeFn<ts.Expression>,\n      private isClosureCompilerEnabled: boolean, private isCore: boolean) {\n    super();\n  }\n\n  override visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    // If this class is not registered in the map, it means that it doesn't have Angular decorators,\n    // thus no further processing is required.\n    if (!this.classCompilationMap.has(node)) {\n      return {node};\n    }\n\n    const translateOptions: TranslatorOptions<ts.Expression> = {\n      recordWrappedNode: this.recordWrappedNodeExpr,\n      annotateForClosureCompiler: this.isClosureCompilerEnabled,\n    };\n\n    // There is at least one field to add.\n    const statements: ts.Statement[] = [];\n    const members = [...node.members];\n\n    for (const field of this.classCompilationMap.get(node)!) {\n      // Translate the initializer for the field into TS nodes.\n      const exprNode = translateExpression(field.initializer, this.importManager, translateOptions);\n\n      // Create a static property declaration for the new field.\n      const property = ts.factory.createPropertyDeclaration(\n          [ts.factory.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined, undefined,\n          exprNode);\n\n      if (this.isClosureCompilerEnabled) {\n        // Closure compiler transforms the form `Service.Éµprov = X` into `Service$Éµprov = X`. To\n        // prevent this transformation, such assignments need to be annotated with @nocollapse.\n        // Note that tsickle is typically responsible for adding such annotations, however it\n        // doesn't yet handle synthetic fields added during other transformations.\n        ts.addSyntheticLeadingComment(\n            property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n            /* hasTrailingNewLine */ false);\n      }\n\n      field.statements.map(stmt => translateStatement(stmt, this.importManager, translateOptions))\n          .forEach(stmt => statements.push(stmt));\n\n      members.push(property);\n    }\n\n    const filteredDecorators =\n        // Remove the decorator which triggered this compilation, leaving the others alone.\n        maybeFilterDecorator(ts.getDecorators(node), this.compilation.decoratorsFor(node));\n\n    const nodeModifiers = ts.getModifiers(node);\n    let updatedModifiers: ts.ModifierLike[]|undefined;\n\n    if (filteredDecorators?.length || nodeModifiers?.length) {\n      updatedModifiers = [...(filteredDecorators || []), ...(nodeModifiers || [])];\n    }\n\n    // Replace the class declaration with an updated version.\n    node = ts.factory.updateClassDeclaration(\n        node, updatedModifiers, node.name, node.typeParameters, node.heritageClauses || [],\n        // Map over the class members and remove any Angular decorators from them.\n        members.map(member => this._stripAngularDecorators(member)));\n    return {node, after: statements};\n  }\n\n  /**\n   * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none\n   * are.\n   */\n  private _angularCoreDecorators(decl: ts.Declaration): Set<ts.Decorator> {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n    const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec))\n                               .map(dec => dec.node as ts.Decorator);\n    if (coreDecorators.length > 0) {\n      return new Set<ts.Decorator>(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n\n  private _nonCoreDecoratorsOnly(node: ts.HasDecorators): ts.NodeArray<ts.Decorator>|undefined {\n    const decorators = ts.getDecorators(node);\n\n    // Shortcut if the node has no decorators.\n    if (decorators === undefined) {\n      return undefined;\n    }\n    // Build a Set of the decorators on this node from @angular/core.\n    const coreDecorators = this._angularCoreDecorators(node);\n\n    if (coreDecorators.size === decorators.length) {\n      // If all decorators are to be removed, return `undefined`.\n      return undefined;\n    } else if (coreDecorators.size === 0) {\n      // If no decorators need to be removed, return the original decorators array.\n      return nodeArrayFromDecoratorsArray(decorators);\n    }\n\n    // Filter out the core decorators.\n    const filtered = decorators.filter(dec => !coreDecorators.has(dec));\n\n    // If no decorators survive, return `undefined`. This can only happen if a core decorator is\n    // repeated on the node.\n    if (filtered.length === 0) {\n      return undefined;\n    }\n\n    // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.\n    return nodeArrayFromDecoratorsArray(filtered);\n  }\n\n  /**\n   * Remove Angular decorators from a `ts.Node` in a shallow manner.\n   *\n   * This will remove decorators from class elements (getters, setters, properties, methods) as well\n   * as parameters of constructors.\n   */\n  private _stripAngularDecorators<T extends ts.Node>(node: T): T {\n    const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;\n    const nonCoreDecorators =\n        ts.canHaveDecorators(node) ? this._nonCoreDecoratorsOnly(node) : undefined;\n    const combinedModifiers = [...(nonCoreDecorators || []), ...(modifiers || [])];\n\n    if (ts.isParameter(node)) {\n      // Strip decorators from parameters (probably of the constructor).\n      node = ts.factory.updateParameterDeclaration(\n                 node, combinedModifiers, node.dotDotDotToken, node.name, node.questionToken,\n                 node.type, node.initializer) as T &\n          ts.ParameterDeclaration;\n    } else if (ts.isMethodDeclaration(node)) {\n      // Strip decorators of methods.\n      node = ts.factory.updateMethodDeclaration(\n                 node, combinedModifiers, node.asteriskToken, node.name, node.questionToken,\n                 node.typeParameters, node.parameters, node.type, node.body) as T &\n          ts.MethodDeclaration;\n    } else if (ts.isPropertyDeclaration(node)) {\n      // Strip decorators of properties.\n      node = ts.factory.updatePropertyDeclaration(\n                 node, combinedModifiers, node.name, node.questionToken, node.type,\n                 node.initializer) as T &\n          ts.PropertyDeclaration;\n    } else if (ts.isGetAccessor(node)) {\n      // Strip decorators of getters.\n      node = ts.factory.updateGetAccessorDeclaration(\n                 node, combinedModifiers, node.name, node.parameters, node.type, node.body) as T &\n          ts.GetAccessorDeclaration;\n    } else if (ts.isSetAccessor(node)) {\n      // Strip decorators of setters.\n      node = ts.factory.updateSetAccessorDeclaration(\n                 node, combinedModifiers, node.name, node.parameters, node.body) as T &\n          ts.SetAccessorDeclaration;\n    } else if (ts.isConstructorDeclaration(node)) {\n      // For constructors, strip decorators of the parameters.\n      const parameters = node.parameters.map(param => this._stripAngularDecorators(param));\n      node = ts.factory.updateConstructorDeclaration(node, modifiers, parameters, node.body) as T &\n          ts.ConstructorDeclaration;\n    }\n    return node;\n  }\n}\n\n/**\n * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.\n */\nfunction transformIvySourceFile(\n    compilation: TraitCompiler, context: ts.TransformationContext, reflector: ReflectionHost,\n    importRewriter: ImportRewriter, file: ts.SourceFile, isCore: boolean,\n    isClosureCompilerEnabled: boolean,\n    recordWrappedNode: RecordWrappedNodeFn<ts.Expression>): ts.SourceFile {\n  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n  const importManager = new ImportManager(importRewriter);\n\n  // The transformation process consists of 2 steps:\n  //\n  //  1. Visit all classes, perform compilation and collect the results.\n  //  2. Perform actual transformation of required TS nodes using compilation results from the first\n  //     step.\n  //\n  // This is needed to have all `o.Expression`s generated before any TS transforms happen. This\n  // allows `ConstantPool` to properly identify expressions that can be shared across multiple\n  // components declared in the same file.\n\n  // Step 1. Go though all classes in AST, perform compilation and collect the results.\n  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n  visit(file, compilationVisitor, context);\n\n  // Step 2. Scan through the AST again and perform transformations based on Ivy compilation\n  // results obtained at Step 1.\n  const transformationVisitor = new IvyTransformationVisitor(\n      compilation, compilationVisitor.classCompilationMap, reflector, importManager,\n      recordWrappedNode, isClosureCompilerEnabled, isCore);\n  let sf = visit(file, transformationVisitor, context);\n\n  // Generate the constant statements first, as they may involve adding additional imports\n  // to the ImportManager.\n  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts.ScriptTarget.ES2015;\n  const constants =\n      constantPool.statements.map(stmt => translateStatement(stmt, importManager, {\n                                    recordWrappedNode,\n                                    downlevelTaggedTemplates: downlevelTranslatedCode,\n                                    downlevelVariableDeclarations: downlevelTranslatedCode,\n                                    annotateForClosureCompiler: isClosureCompilerEnabled,\n                                  }));\n\n  // Preserve @fileoverview comments required by Closure, since the location might change as a\n  // result of adding extra imports and constant pool statements.\n  const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;\n\n  // Add new imports for this file.\n  sf = addImports(importManager, sf, constants);\n\n  if (fileOverviewMeta !== null) {\n    setFileOverviewComment(sf, fileOverviewMeta);\n  }\n\n  return sf;\n}\n\n/**\n * Compute the correct target output for `$localize` messages generated by Angular\n *\n * In some versions of TypeScript, the transformation of synthetic `$localize` tagged template\n * literals is broken. See https://github.com/microsoft/TypeScript/issues/38485\n *\n * Here we compute what the expected final output target of the compilation will\n * be so that we can generate ES5 compliant `$localize` calls instead of relying upon TS to do the\n * downleveling for us.\n */\nfunction getLocalizeCompileTarget(context: ts.TransformationContext):\n    Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON> {\n  const target = context.getCompilerOptions().target || ts.ScriptTarget.ES2015;\n  return target !== ts.ScriptTarget.JSON ? target : ts.ScriptTarget.ES2015;\n}\n\nfunction getFileOverviewComment(statements: ts.NodeArray<ts.Statement>): FileOverviewMeta|null {\n  if (statements.length > 0) {\n    const host = statements[0];\n    let trailing = false;\n    let comments = ts.getSyntheticLeadingComments(host);\n    // If @fileoverview tag is not found in source file, tsickle produces fake node with trailing\n    // comment and inject it at the very beginning of the generated file. So we need to check for\n    // leading as well as trailing comments.\n    if (!comments || comments.length === 0) {\n      trailing = true;\n      comments = ts.getSyntheticTrailingComments(host);\n    }\n    if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n      return {comments, host, trailing};\n    }\n  }\n  return null;\n}\n\nfunction setFileOverviewComment(sf: ts.SourceFile, fileoverview: FileOverviewMeta): void {\n  const {comments, host, trailing} = fileoverview;\n  // If host statement is no longer the first one, it means that extra statements were added at the\n  // very beginning, so we need to relocate @fileoverview comment and cleanup the original statement\n  // that hosted it.\n  if (sf.statements.length > 0 && host !== sf.statements[0]) {\n    if (trailing) {\n      ts.setSyntheticTrailingComments(host, undefined);\n    } else {\n      ts.setSyntheticLeadingComments(host, undefined);\n    }\n    ts.setSyntheticLeadingComments(sf.statements[0], comments);\n  }\n}\n\nfunction maybeFilterDecorator(\n    decorators: readonly ts.Decorator[]|undefined,\n    toRemove: ts.Decorator[]): ts.NodeArray<ts.Decorator>|undefined {\n  if (decorators === undefined) {\n    return undefined;\n  }\n  const filtered = decorators.filter(\n      dec => toRemove.find(decToRemove => ts.getOriginalNode(dec) === decToRemove) === undefined);\n  if (filtered.length === 0) {\n    return undefined;\n  }\n  return ts.factory.createNodeArray(filtered);\n}\n\nfunction isFromAngularCore(decorator: Decorator): boolean {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\nfunction createRecorderFn(defaultImportTracker: DefaultImportTracker):\n    RecordWrappedNodeFn<ts.Expression> {\n  return node => {\n    const importDecl = getDefaultImportDeclaration(node);\n    if (importDecl !== null) {\n      defaultImportTracker.recordUsedImport(importDecl);\n    }\n  };\n}\n\n/** Creates a `NodeArray` with the correct offsets from an array of decorators. */\nfunction nodeArrayFromDecoratorsArray(decorators: readonly ts.Decorator[]):\n    ts.NodeArray<ts.Decorator> {\n  const array = ts.factory.createNodeArray(decorators);\n\n  if (array.length > 0) {\n    (array.pos as number) = decorators[0].pos;\n    (array.end as number) = decorators[decorators.length - 1].end;\n  }\n\n  return array;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n/**\n * Result type of visiting a node that's typically an entry in a list, which allows specifying that\n * nodes should be added before the visited node in the output.\n */\nexport type VisitListEntryResult<B extends ts.Node, T extends B> = {\n  node: T,\n  before?: B[],\n  after?: B[],\n};\n\n/**\n * Visit a node with the given visitor and return a transformed copy.\n */\nexport function visit<T extends ts.Node>(\n    node: T, visitor: Visitor, context: ts.TransformationContext): T {\n  return visitor._visit(node, context);\n}\n\n/**\n * Abstract base class for visitors, which processes certain nodes specially to allow insertion\n * of other nodes before them.\n */\nexport abstract class Visitor {\n  /**\n   * Maps statements to an array of statements that should be inserted before them.\n   */\n  private _before = new Map<ts.Node, ts.Statement[]>();\n\n  /**\n   * Maps statements to an array of statements that should be inserted after them.\n   */\n  private _after = new Map<ts.Node, ts.Statement[]>();\n\n  /**\n   * Visit a class declaration, returning at least the transformed declaration and optionally other\n   * nodes to insert before the declaration.\n   */\n  abstract visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration>;\n\n  private _visitListEntryNode<T extends ts.Statement>(\n      node: T, visitor: (node: T) => VisitListEntryResult<ts.Statement, T>): T {\n    const result = visitor(node);\n    if (result.before !== undefined) {\n      // Record that some nodes should be inserted before the given declaration. The declaration's\n      // parent's _visit call is responsible for performing this insertion.\n      this._before.set(result.node, result.before);\n    }\n    if (result.after !== undefined) {\n      // Same with nodes that should be inserted after.\n      this._after.set(result.node, result.after);\n    }\n    return result.node;\n  }\n\n  /**\n   * Visit types of nodes which don't have their own explicit visitor.\n   */\n  visitOtherNode<T extends ts.Node>(node: T): T {\n    return node;\n  }\n\n  /**\n   * @internal\n   */\n  _visit<T extends ts.Node>(node: T, context: ts.TransformationContext): T {\n    // First, visit the node. visitedNode starts off as `null` but should be set after visiting\n    // is completed.\n    let visitedNode: T|null = null;\n\n    node = ts.visitEachChild(node, child => this._visit(child, context), context) as T;\n\n    if (ts.isClassDeclaration(node)) {\n      visitedNode =\n          this._visitListEntryNode(\n              node, (node: ts.ClassDeclaration) => this.visitClassDeclaration(node)) as typeof node;\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n\n    // If the visited node has a `statements` array then process them, maybe replacing the visited\n    // node and adding additional statements.\n    if (ts.isBlock(visitedNode) || ts.isSourceFile(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n\n    return visitedNode;\n  }\n\n  private _maybeProcessStatements<T extends ts.Block|ts.SourceFile>(node: T): T {\n    // Shortcut - if every statement doesn't require nodes to be prepended or appended,\n    // this is a no-op.\n    if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n\n    // Build a new list of statements and patch it onto the clone.\n    const newStatements: ts.Statement[] = [];\n    node.statements.forEach(stmt => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...(this._before.get(stmt)! as ts.Statement[]));\n        this._before.delete(stmt);\n      }\n      newStatements.push(stmt);\n      if (this._after.has(stmt)) {\n        newStatements.push(...(this._after.get(stmt)! as ts.Statement[]));\n        this._after.delete(stmt);\n      }\n    });\n\n    const statementsArray =\n        ts.factory.createNodeArray(newStatements, node.statements.hasTrailingComma);\n\n    if (ts.isBlock(node)) {\n      return ts.factory.updateBlock(node, statementsArray) as T;\n    } else {\n      return ts.factory.updateSourceFile(\n                 node, statementsArray, node.isDeclarationFile, node.referencedFiles,\n                 node.typeReferenceDirectives, node.hasNoDefaultLib, node.libReferenceDirectives) as\n          T;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createMayBeForwardRefExpression, emitDistinctChangesOnlyDefaultValue, Expression, ExternalExpr, ForwardRefHandling, getSafePropertyAccessString, MaybeForwardRefExpression, ParsedHostBindings, ParseError, parseHostBindings, R3DirectiveMetadata, R3HostDirectiveMetadata, R3QueryMetadata, verifyHostBindings, WrappedNodeExpr,} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../../diagnostics';\nimport {Reference, ReferenceEmitter} from '../../../imports';\nimport {ClassPropertyMapping, HostDirectiveMeta, InputMapping} from '../../../metadata';\nimport {DynamicValue, EnumValue, PartialEvaluator, ResolvedValue} from '../../../partial_evaluator';\nimport {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembersWithDecorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral,} from '../../../reflection';\nimport {HandlerFlags} from '../../../transform';\nimport {createSourceSpan, createValueHasWrongTypeError, forwardRefResolver, getConstructorDependencies, ReferencesRegistry, toR3Reference, tryUnwrapForwardRef, unwrapConstructorDependencies, unwrapExpression, validateConstructorDependencies, wrapFunctionExpressionsInParens, wrapTypeReference,} from '../../common';\n\nconst EMPTY_OBJECT: {[key: string]: string} = {};\nconst QUERY_TYPES = new Set([\n  'ContentChild',\n  'ContentChildren',\n  'ViewChild',\n  'ViewChildren',\n]);\n\n/**\n * Helper function to extract metadata from a `Directive` or `Component`. `Directive`s without a\n * selector are allowed to be used for abstract base classes. These abstract directives should not\n * appear in the declarations of an `NgModule` and additional verification is done when processing\n * the module.\n */\nexport function extractDirectiveMetadata(\n    clazz: ClassDeclaration, decorator: Readonly<Decorator|null>, reflector: ReflectionHost,\n    evaluator: PartialEvaluator, refEmitter: ReferenceEmitter,\n    referencesRegistry: ReferencesRegistry, isCore: boolean, flags: HandlerFlags,\n    annotateForClosureCompiler: boolean, defaultSelector: string|null = null): {\n  decorator: Map<string, ts.Expression>,\n  metadata: R3DirectiveMetadata,\n  inputs: ClassPropertyMapping<InputMapping>,\n  outputs: ClassPropertyMapping,\n  isStructural: boolean;\n  hostDirectives: HostDirectiveMeta[] | null, rawHostDirectives: ts.Expression | null,\n}|undefined {\n  let directive: Map<string, ts.Expression>;\n  if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n    directive = new Map<string, ts.Expression>();\n  } else if (decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, decorator.node,\n        `Incorrect number of arguments to @${decorator.name} decorator`);\n  } else {\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta,\n          `@${decorator.name} argument must be an object literal`);\n    }\n    directive = reflectObjectLiteral(meta);\n  }\n\n  if (directive.has('jit')) {\n    // The only allowed value is true, so there's no need to expand further.\n    return undefined;\n  }\n\n  const members = reflector.getMembersOfClass(clazz);\n\n  // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,\n  // @Output, @HostBinding, etc.\n  const decoratedElements =\n      members.filter(member => !member.isStatic && member.decorators !== null);\n\n  const coreModule = isCore ? undefined : '@angular/core';\n\n  // Construct the map of inputs both from the @Directive/@Component\n  // decorator, and the decorated fields.\n  const inputsFromMeta = parseInputsArray(directive, evaluator);\n  const inputsFromFields = parseInputFields(\n      filterToMembersWithDecorator(decoratedElements, 'Input', coreModule), evaluator);\n  const inputs = ClassPropertyMapping.fromMappedObject({...inputsFromMeta, ...inputsFromFields});\n\n  // And outputs.\n  const outputsFromMeta = parseOutputsArray(directive, evaluator);\n  const outputsFromFields = parseOutputFields(\n      filterToMembersWithDecorator(decoratedElements, 'Output', coreModule), evaluator);\n  const outputs = ClassPropertyMapping.fromMappedObject({...outputsFromMeta, ...outputsFromFields});\n\n  // Construct the list of queries.\n  const contentChildFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ContentChild', coreModule), reflector,\n      evaluator);\n  const contentChildrenFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ContentChildren', coreModule), reflector,\n      evaluator);\n\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n\n  // Construct the list of view queries.\n  const viewChildFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ViewChild', coreModule), reflector,\n      evaluator);\n  const viewChildrenFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ViewChildren', coreModule), reflector,\n      evaluator);\n  const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n\n  if (directive.has('queries')) {\n    const queriesFromDecorator =\n        extractQueriesFromDecorator(directive.get('queries')!, reflector, evaluator, isCore);\n    queries.push(...queriesFromDecorator.content);\n    viewQueries.push(...queriesFromDecorator.view);\n  }\n\n  // Parse the selector.\n  let selector = defaultSelector;\n  if (directive.has('selector')) {\n    const expr = directive.get('selector')!;\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== 'string') {\n      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n    }\n    // use default selector in case selector is an empty string\n    selector = resolved === '' ? defaultSelector : resolved;\n    if (!selector) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr,\n          `Directive ${clazz.name.text} has no selector, please add it!`);\n    }\n  }\n\n  const host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n\n  const providers: Expression|null = directive.has('providers') ?\n      new WrappedNodeExpr(\n          annotateForClosureCompiler ?\n              wrapFunctionExpressionsInParens(directive.get('providers')!) :\n              directive.get('providers')!) :\n      null;\n\n  // Determine if `ngOnChanges` is a lifecycle hook defined on the component.\n  const usesOnChanges = members.some(\n      member => !member.isStatic && member.kind === ClassMemberKind.Method &&\n          member.name === 'ngOnChanges');\n\n  // Parse exportAs.\n  let exportAs: string[]|null = null;\n  if (directive.has('exportAs')) {\n    const expr = directive.get('exportAs')!;\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== 'string') {\n      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n    }\n    exportAs = resolved.split(',').map(part => part.trim());\n  }\n\n  const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n\n  // Non-abstract directives (those with a selector) require valid constructor dependencies, whereas\n  // abstract directives are allowed to have invalid dependencies, given that a subclass may call\n  // the constructor explicitly.\n  const ctorDeps = selector !== null ? validateConstructorDependencies(clazz, rawCtorDeps) :\n                                       unwrapConstructorDependencies(rawCtorDeps);\n\n  // Structural directives must have a `TemplateRef` dependency.\n  const isStructural = ctorDeps !== null && ctorDeps !== 'invalid' &&\n      ctorDeps.some(\n          dep => (dep.token instanceof ExternalExpr) &&\n              dep.token.value.moduleName === '@angular/core' &&\n              dep.token.value.name === 'TemplateRef');\n\n  let isStandalone = false;\n  if (directive.has('standalone')) {\n    const expr = directive.get('standalone')!;\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== 'boolean') {\n      throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);\n    }\n    isStandalone = resolved;\n  }\n\n  // Detect if the component inherits from another class\n  const usesInheritance = reflector.hasBaseClass(clazz);\n  const sourceFile = clazz.getSourceFile();\n  const type = wrapTypeReference(reflector, clazz);\n  const rawHostDirectives = directive.get('hostDirectives') || null;\n  const hostDirectives =\n      rawHostDirectives === null ? null : extractHostDirectives(rawHostDirectives, evaluator);\n\n  if (hostDirectives !== null) {\n    // The template type-checker will need to import host directive types, so add them\n    // as referenced by `clazz`. This will ensure that libraries are required to export\n    // host directives which are visible from publicly exported components.\n    referencesRegistry.add(clazz, ...hostDirectives.map(hostDir => hostDir.directive));\n  }\n\n  const metadata: R3DirectiveMetadata = {\n    name: clazz.name.text,\n    deps: ctorDeps,\n    host,\n    lifecycle: {\n      usesOnChanges,\n    },\n    inputs: inputs.toJointMappedObject(),\n    outputs: outputs.toDirectMappedObject(),\n    queries,\n    viewQueries,\n    selector,\n    fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),\n    type,\n    typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n    typeSourceSpan: createSourceSpan(clazz.name),\n    usesInheritance,\n    exportAs,\n    providers,\n    isStandalone,\n    hostDirectives:\n        hostDirectives?.map(hostDir => toHostDirectiveMetadata(hostDir, sourceFile, refEmitter)) ||\n        null,\n  };\n  return {\n    decorator: directive,\n    metadata,\n    inputs,\n    outputs,\n    isStructural,\n    hostDirectives,\n    rawHostDirectives,\n  };\n}\n\nexport function extractQueryMetadata(\n    exprNode: ts.Node, name: string, args: ReadonlyArray<ts.Expression>, propertyName: string,\n    reflector: ReflectionHost, evaluator: PartialEvaluator): R3QueryMetadata {\n  if (args.length === 0) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);\n  }\n  const first = name === 'ViewChild' || name === 'ContentChild';\n  const forwardReferenceTarget = tryUnwrapForwardRef(args[0], reflector);\n  const node = forwardReferenceTarget ?? args[0];\n\n  const arg = evaluator.evaluate(node);\n\n  /** Whether or not this query should collect only static results (see view/api.ts)  */\n  let isStatic: boolean = false;\n\n  // Extract the predicate\n  let predicate: MaybeForwardRefExpression|string[]|null = null;\n  if (arg instanceof Reference || arg instanceof DynamicValue) {\n    // References and predicates that could not be evaluated statically are emitted as is.\n    predicate = createMayBeForwardRefExpression(\n        new WrappedNodeExpr(node),\n        forwardReferenceTarget !== null ? ForwardRefHandling.Unwrapped : ForwardRefHandling.None);\n  } else if (typeof arg === 'string') {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n    predicate = arg;\n  } else {\n    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n  }\n\n  // Extract the read and descendants options.\n  let read: Expression|null = null;\n  // The default value for descendants is true for every decorator except @ContentChildren.\n  let descendants: boolean = name !== 'ContentChildren';\n  let emitDistinctChangesOnly: boolean = emitDistinctChangesOnlyDefaultValue;\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n    if (!ts.isObjectLiteralExpression(optionsExpr)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr,\n          `@${name} options must be an object literal`);\n    }\n    const options = reflectObjectLiteral(optionsExpr);\n    if (options.has('read')) {\n      read = new WrappedNodeExpr(options.get('read')!);\n    }\n\n    if (options.has('descendants')) {\n      const descendantsExpr = options.get('descendants')!;\n      const descendantsValue = evaluator.evaluate(descendantsExpr);\n      if (typeof descendantsValue !== 'boolean') {\n        throw createValueHasWrongTypeError(\n            descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n      }\n      descendants = descendantsValue;\n    }\n\n    if (options.has('emitDistinctChangesOnly')) {\n      const emitDistinctChangesOnlyExpr = options.get('emitDistinctChangesOnly')!;\n      const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n      if (typeof emitDistinctChangesOnlyValue !== 'boolean') {\n        throw createValueHasWrongTypeError(\n            emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue,\n            `@${name} options.emitDistinctChangesOnly must be a boolean`);\n      }\n      emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n    }\n\n    if (options.has('static')) {\n      const staticValue = evaluator.evaluate(options.get('static')!);\n      if (typeof staticValue !== 'boolean') {\n        throw createValueHasWrongTypeError(\n            node, staticValue, `@${name} options.static must be a boolean`);\n      }\n      isStatic = staticValue;\n    }\n\n  } else if (args.length > 2) {\n    // Too many arguments.\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);\n  }\n\n  return {\n    propertyName,\n    predicate,\n    first,\n    descendants,\n    read,\n    static: isStatic,\n    emitDistinctChangesOnly,\n  };\n}\n\n\nexport function extractHostBindings(\n    members: ClassMember[], evaluator: PartialEvaluator, coreModule: string|undefined,\n    metadata?: Map<string, ts.Expression>): ParsedHostBindings {\n  let bindings: ParsedHostBindings;\n  if (metadata && metadata.has('host')) {\n    bindings = evaluateHostExpressionBindings(metadata.get('host')!, evaluator);\n  } else {\n    bindings = parseHostBindings({});\n  }\n\n  filterToMembersWithDecorator(members, 'HostBinding', coreModule)\n      .forEach(({member, decorators}) => {\n        decorators.forEach(decorator => {\n          let hostPropertyName: string = member.name;\n          if (decorator.args !== null && decorator.args.length > 0) {\n            if (decorator.args.length !== 1) {\n              throw new FatalDiagnosticError(\n                  ErrorCode.DECORATOR_ARITY_WRONG, decorator.node,\n                  `@HostBinding can have at most one argument, got ${\n                      decorator.args.length} argument(s)`);\n            }\n\n            const resolved = evaluator.evaluate(decorator.args[0]);\n            if (typeof resolved !== 'string') {\n              throw createValueHasWrongTypeError(\n                  decorator.node, resolved, `@HostBinding's argument must be a string`);\n            }\n\n            hostPropertyName = resolved;\n          }\n\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`). There is no size penalty, because all\n          // values (except literals) are converted to `ctx.propName` eventually.\n          bindings.properties[hostPropertyName] = getSafePropertyAccessString('this', member.name);\n        });\n      });\n\n  filterToMembersWithDecorator(members, 'HostListener', coreModule)\n      .forEach(({member, decorators}) => {\n        decorators.forEach(decorator => {\n          let eventName: string = member.name;\n          let args: string[] = [];\n          if (decorator.args !== null && decorator.args.length > 0) {\n            if (decorator.args.length > 2) {\n              throw new FatalDiagnosticError(\n                  ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2],\n                  `@HostListener can have at most two arguments`);\n            }\n\n            const resolved = evaluator.evaluate(decorator.args[0]);\n            if (typeof resolved !== 'string') {\n              throw createValueHasWrongTypeError(\n                  decorator.args[0], resolved,\n                  `@HostListener's event name argument must be a string`);\n            }\n\n            eventName = resolved;\n\n            if (decorator.args.length === 2) {\n              const expression = decorator.args[1];\n              const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n              if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {\n                throw createValueHasWrongTypeError(\n                    decorator.args[1], resolvedArgs,\n                    `@HostListener's second argument must be a string array`);\n              }\n              args = resolvedArgs;\n            }\n          }\n\n          bindings.listeners[eventName] = `${member.name}(${args.join(',')})`;\n        });\n      });\n  return bindings;\n}\n\nfunction extractQueriesFromDecorator(\n    queryData: ts.Expression, reflector: ReflectionHost, evaluator: PartialEvaluator,\n    isCore: boolean): {\n  content: R3QueryMetadata[],\n  view: R3QueryMetadata[],\n} {\n  const content: R3QueryMetadata[] = [], view: R3QueryMetadata[] = [];\n  if (!ts.isObjectLiteralExpression(queryData)) {\n    throw new FatalDiagnosticError(\n        ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n        'Decorator queries metadata must be an object literal');\n  }\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n    if (!ts.isNewExpression(queryExpr)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n          'Decorator query metadata must be an instance of a query type');\n    }\n    const queryType = ts.isPropertyAccessExpression(queryExpr.expression) ?\n        queryExpr.expression.name :\n        queryExpr.expression;\n    if (!ts.isIdentifier(queryType)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n          'Decorator query metadata must be an instance of a query type');\n    }\n    const type = reflector.getImportOfIdentifier(queryType);\n    if (type === null || (!isCore && type.from !== '@angular/core') ||\n        !QUERY_TYPES.has(type.name)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n          'Decorator query metadata must be an instance of a query type');\n    }\n\n    const query = extractQueryMetadata(\n        queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n    if (type.name.startsWith('Content')) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return {content, view};\n}\n\nexport function parseFieldStringArrayValue(\n    directive: Map<string, ts.Expression>, field: string, evaluator: PartialEvaluator): null|\n    string[] {\n  if (!directive.has(field)) {\n    return null;\n  }\n\n  // Resolve the field of interest from the directive metadata to a string[].\n  const expression = directive.get(field)!;\n  const value = evaluator.evaluate(expression);\n  if (!isStringArrayOrDie(value, field, expression)) {\n    throw createValueHasWrongTypeError(\n        expression, value, `Failed to resolve @Directive.${field} to a string array`);\n  }\n\n  return value;\n}\n\nfunction isStringArrayOrDie(value: any, name: string, node: ts.Expression): value is string[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== 'string') {\n      throw createValueHasWrongTypeError(\n          node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n    }\n  }\n  return true;\n}\n\nfunction queriesFromFields(\n    fields: {member: ClassMember, decorators: Decorator[]}[], reflector: ReflectionHost,\n    evaluator: PartialEvaluator): R3QueryMetadata[] {\n  return fields.map(({member, decorators}) => {\n    const decorator = decorators[0];\n    const node = member.node || decorator.node;\n\n    // Throw in case of `@Input() @ContentChild('foo') foo: any`, which is not supported in Ivy\n    if (member.decorators!.some(v => v.name === 'Input')) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_COLLISION, node,\n          'Cannot combine @Input decorators with query decorators');\n    }\n    if (decorators.length !== 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_COLLISION, node,\n          'Cannot have multiple query decorators on the same class member');\n    } else if (!isPropertyTypeMember(member)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_UNEXPECTED, node,\n          'Query decorator must go on a property-type member');\n    }\n    return extractQueryMetadata(\n        node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n  });\n}\n\nfunction isPropertyTypeMember(member: ClassMember): boolean {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter ||\n      member.kind === ClassMemberKind.Property;\n}\n\nfunction parseMappingStringArray(values: string[]) {\n  return values.reduce((results, value) => {\n    if (typeof value !== 'string') {\n      throw new Error('Mapping value must be a string');\n    }\n\n    const [bindingPropertyName, fieldName] = parseMappingString(value);\n    results[fieldName] = bindingPropertyName;\n    return results;\n  }, {} as {[field: string]: string});\n}\n\nfunction parseMappingString(value: string): [bindingPropertyName: string, fieldName: string] {\n  // Either the value is 'field' or 'field: property'. In the first case, `property` will\n  // be undefined, in which case the field name should also be used as the property name.\n  const [fieldName, bindingPropertyName] = value.split(':', 2).map(str => str.trim());\n  return [bindingPropertyName ?? fieldName, fieldName];\n}\n\n/**\n * Parse property decorators (e.g. `Input` or `Output`) and invoke callback with the parsed data.\n */\nfunction parseDecoratedFields(\n    fields: {member: ClassMember, decorators: Decorator[]}[], evaluator: PartialEvaluator,\n    callback: (fieldName: string, fieldValue: ResolvedValue, decorator: Decorator) => void): void {\n  for (const field of fields) {\n    const fieldName = field.member.name;\n\n    for (const decorator of field.decorators) {\n      if (decorator.args != null && decorator.args.length > 1) {\n        throw new FatalDiagnosticError(\n            ErrorCode.DECORATOR_ARITY_WRONG, decorator.node,\n            `@${decorator.name} can have at most one argument, got ${\n                decorator.args.length} argument(s)`);\n      }\n\n      const value = decorator.args != null && decorator.args.length > 0 ?\n          evaluator.evaluate(decorator.args[0]) :\n          null;\n\n      callback(fieldName, value, decorator);\n    }\n  }\n}\n\n/** Parses the `inputs` array of a directive/component decorator. */\nfunction parseInputsArray(\n    decoratorMetadata: Map<string, ts.Expression>,\n    evaluator: PartialEvaluator): Record<string, InputMapping> {\n  const inputsField = decoratorMetadata.get('inputs');\n\n  if (inputsField === undefined) {\n    return {};\n  }\n\n  const inputs = {} as Record<string, InputMapping>;\n  const inputsArray = evaluator.evaluate(inputsField);\n\n  if (!Array.isArray(inputsArray)) {\n    throw createValueHasWrongTypeError(\n        inputsField, inputsArray, `Failed to resolve @Directive.inputs to an array`);\n  }\n\n  for (let i = 0; i < inputsArray.length; i++) {\n    const value = inputsArray[i];\n\n    if (typeof value === 'string') {\n      // If the value is a string, we treat it as a mapping string.\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      inputs[classPropertyName] = {bindingPropertyName, classPropertyName, required: false};\n    } else if (value instanceof Map) {\n      // If it's a map, we treat it as a config object.\n      const name = value.get('name');\n      const alias = value.get('alias');\n      const required = value.get('required');\n\n      if (typeof name !== 'string') {\n        throw createValueHasWrongTypeError(\n            inputsField, name,\n            `Value at position ${i} of @Directive.inputs array must have a \"name\" property`);\n      }\n\n      inputs[name] = {\n        classPropertyName: name,\n        bindingPropertyName: typeof alias === 'string' ? alias : name,\n        required: required === true\n      };\n    } else {\n      throw createValueHasWrongTypeError(\n          inputsField, value,\n          `@Directive.inputs array can only contain strings or object literals`);\n    }\n  }\n\n  return inputs;\n}\n\n/** Parses the class members that are decorated as inputs. */\nfunction parseInputFields(\n    inputMembers: {member: ClassMember, decorators: Decorator[]}[],\n    evaluator: PartialEvaluator): Record<string, InputMapping> {\n  const inputs = {} as Record<string, InputMapping>;\n\n  parseDecoratedFields(inputMembers, evaluator, (classPropertyName, options, decorator) => {\n    let bindingPropertyName: string;\n    let required = false;\n\n    if (options === null) {\n      bindingPropertyName = classPropertyName;\n    } else if (typeof options === 'string') {\n      bindingPropertyName = options;\n    } else if (options instanceof Map) {\n      const aliasInConfig = options.get('alias');\n      bindingPropertyName = typeof aliasInConfig === 'string' ? aliasInConfig : classPropertyName;\n      required = options.get('required') === true;\n    } else {\n      throw createValueHasWrongTypeError(\n          decorator.node, options,\n          `@${decorator.name} decorator argument must resolve to a string or an object literal`);\n    }\n\n    inputs[classPropertyName] = {bindingPropertyName, classPropertyName, required};\n  });\n\n  return inputs;\n}\n\n/** Parses the `outputs` array of a directive/component. */\nfunction parseOutputsArray(\n    directive: Map<string, ts.Expression>, evaluator: PartialEvaluator): Record<string, string> {\n  const metaValues = parseFieldStringArrayValue(directive, 'outputs', evaluator);\n  return metaValues ? parseMappingStringArray(metaValues) : EMPTY_OBJECT;\n}\n\n/** Parses the class members that are decorated as outputs. */\nfunction parseOutputFields(\n    outputMembers: {member: ClassMember, decorators: Decorator[]}[],\n    evaluator: PartialEvaluator): Record<string, string> {\n  const outputs = {} as Record<string, string>;\n\n  parseDecoratedFields(outputMembers, evaluator, (fieldName, bindingPropertyName, decorator) => {\n    if (bindingPropertyName != null && typeof bindingPropertyName !== 'string') {\n      throw createValueHasWrongTypeError(\n          decorator.node, bindingPropertyName,\n          `@${decorator.name} decorator argument must resolve to a string`);\n    }\n\n    outputs[fieldName] = bindingPropertyName ?? fieldName;\n  });\n\n  return outputs;\n}\n\nfunction evaluateHostExpressionBindings(\n    hostExpr: ts.Expression, evaluator: PartialEvaluator): ParsedHostBindings {\n  const hostMetaMap = evaluator.evaluate(hostExpr);\n  if (!(hostMetaMap instanceof Map)) {\n    throw createValueHasWrongTypeError(\n        hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n  }\n  const hostMetadata: Record<string, string|Expression> = {};\n  hostMetaMap.forEach((value, key) => {\n    // Resolve Enum references to their declared value.\n    if (value instanceof EnumValue) {\n      value = value.resolved;\n    }\n\n    if (typeof key !== 'string') {\n      throw createValueHasWrongTypeError(\n          hostExpr, key,\n          `Decorator host metadata must be a string -> string object, but found unparseable key`);\n    }\n\n    if (typeof value == 'string') {\n      hostMetadata[key] = value;\n    } else if (value instanceof DynamicValue) {\n      hostMetadata[key] = new WrappedNodeExpr(value.node as ts.Expression);\n    } else {\n      throw createValueHasWrongTypeError(\n          hostExpr, value,\n          `Decorator host metadata must be a string -> string object, but found unparseable value`);\n    }\n  });\n\n  const bindings = parseHostBindings(hostMetadata);\n\n  const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));\n  if (errors.length > 0) {\n    throw new FatalDiagnosticError(\n        // TODO: provide more granular diagnostic and output specific host expression that\n        // triggered an error instead of the whole host object.\n        ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr,\n        errors.map((error: ParseError) => error.msg).join('\\n'));\n  }\n\n  return bindings;\n}\n\n/**\n * Extracts and prepares the host directives metadata from an array literal expression.\n * @param rawHostDirectives Expression that defined the `hostDirectives`.\n */\nfunction extractHostDirectives(\n    rawHostDirectives: ts.Expression, evaluator: PartialEvaluator): HostDirectiveMeta[] {\n  const resolved = evaluator.evaluate(rawHostDirectives, forwardRefResolver);\n  if (!Array.isArray(resolved)) {\n    throw createValueHasWrongTypeError(\n        rawHostDirectives, resolved, 'hostDirectives must be an array');\n  }\n\n  return resolved.map(value => {\n    const hostReference = value instanceof Map ? value.get('directive') : value;\n\n    if (!(hostReference instanceof Reference)) {\n      throw createValueHasWrongTypeError(\n          rawHostDirectives, hostReference, 'Host directive must be a reference');\n    }\n\n    if (!isNamedClassDeclaration(hostReference.node)) {\n      throw createValueHasWrongTypeError(\n          rawHostDirectives, hostReference, 'Host directive reference must be a class');\n    }\n\n    const meta: HostDirectiveMeta = {\n      directive: hostReference as Reference<ClassDeclaration>,\n      isForwardReference: hostReference.synthetic,\n      inputs: parseHostDirectivesMapping('inputs', value, hostReference.node, rawHostDirectives),\n      outputs: parseHostDirectivesMapping('outputs', value, hostReference.node, rawHostDirectives),\n    };\n\n    return meta;\n  });\n}\n\n/**\n * Parses the expression that defines the `inputs` or `outputs` of a host directive.\n * @param field Name of the field that is being parsed.\n * @param resolvedValue Evaluated value of the expression that defined the field.\n * @param classReference Reference to the host directive class.\n * @param sourceExpression Expression that the host directive is referenced in.\n */\nfunction parseHostDirectivesMapping(\n    field: 'inputs'|'outputs', resolvedValue: ResolvedValue, classReference: ClassDeclaration,\n    sourceExpression: ts.Expression): {[bindingPropertyName: string]: string}|null {\n  if (resolvedValue instanceof Map && resolvedValue.has(field)) {\n    const nameForErrors = `@Directive.hostDirectives.${classReference.name.text}.${field}`;\n    const rawInputs = resolvedValue.get(field);\n\n    if (isStringArrayOrDie(rawInputs, nameForErrors, sourceExpression)) {\n      return parseMappingStringArray(rawInputs);\n    }\n  }\n\n  return null;\n}\n\n/** Converts the parsed host directive information into metadata. */\nfunction toHostDirectiveMetadata(\n    hostDirective: HostDirectiveMeta, context: ts.SourceFile,\n    refEmitter: ReferenceEmitter): R3HostDirectiveMetadata {\n  return {\n    directive:\n        toR3Reference(hostDirective.directive.node, hostDirective.directive, context, refEmitter),\n    isForwardReference: hostDirective.isForwardReference,\n    inputs: hostDirective.inputs || null,\n    outputs: hostDirective.outputs || null\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {areTypeParametersEqual, isArrayEqual, isSetEqual, isSymbolEqual, SemanticSymbol, SemanticTypeParameter} from '../../../incremental/semantic_graph';\nimport {ClassPropertyMapping, DirectiveTypeCheckMeta, InputMapping, InputOrOutput, TemplateGuardMeta} from '../../../metadata';\nimport {ClassDeclaration} from '../../../reflection';\n\n/**\n * Represents an Angular directive. Components are represented by `ComponentSymbol`, which inherits\n * from this symbol.\n */\nexport class DirectiveSymbol extends SemanticSymbol {\n  baseClass: SemanticSymbol|null = null;\n\n  constructor(\n      decl: ClassDeclaration, public readonly selector: string|null,\n      public readonly inputs: ClassPropertyMapping<InputMapping>,\n      public readonly outputs: ClassPropertyMapping, public readonly exportAs: string[]|null,\n      public readonly typeCheckMeta: DirectiveTypeCheckMeta,\n      public readonly typeParameters: SemanticTypeParameter[]|null) {\n    super(decl);\n  }\n\n  override isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n    // Note: since components and directives have exactly the same items contributing to their\n    // public API, it is okay for a directive to change into a component and vice versa without\n    // the API being affected.\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n\n    // Directives and components have a public API of:\n    //  1. Their selector.\n    //  2. The binding names of their inputs and outputs; a change in ordering is also considered\n    //     to be a change in public API.\n    //  3. The list of exportAs names and its ordering.\n    return this.selector !== previousSymbol.selector ||\n        !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) ||\n        !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) ||\n        !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n  }\n\n  override isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n    // If the public API of the directive has changed, then so has its type-check API.\n    if (this.isPublicApiAffected(previousSymbol)) {\n      return true;\n    }\n\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n\n    // The type-check block also depends on the class property names, as writes property bindings\n    // directly into the backing fields.\n    if (!isArrayEqual(\n            Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) ||\n        !isArrayEqual(\n            Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputOrOutputEqual)) {\n      return true;\n    }\n\n    // The type parameters of a directive are emitted into the type constructors in the type-check\n    // block of a component, so if the type parameters are not considered equal then consider the\n    // type-check API of this directive to be affected.\n    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n      return true;\n    }\n\n    // The type-check metadata is used during TCB code generation, so any changes should invalidate\n    // prior type-check files.\n    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n      return true;\n    }\n\n    // Changing the base class of a directive means that its inputs/outputs etc may have changed,\n    // so the type-check block of components that use this directive needs to be regenerated.\n    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nfunction isInputMappingEqual(current: InputMapping, previous: InputMapping): boolean {\n  return isInputOrOutputEqual(current, previous) && current.required === previous.required;\n}\n\nfunction isInputOrOutputEqual(current: InputOrOutput, previous: InputOrOutput): boolean {\n  return current.classPropertyName === previous.classPropertyName &&\n      current.bindingPropertyName === previous.bindingPropertyName;\n}\n\nfunction isTypeCheckMetaEqual(\n    current: DirectiveTypeCheckMeta, previous: DirectiveTypeCheckMeta): boolean {\n  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n    return false;\n  }\n  if (current.isGeneric !== previous.isGeneric) {\n    // Note: changes in the number of type parameters is also considered in `areTypeParametersEqual`\n    // so this check is technically not needed; it is done anyway for completeness in terms of\n    // whether the `DirectiveTypeCheckMeta` struct itself compares equal or not.\n    return false;\n  }\n  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n    return false;\n  }\n  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTemplateGuardEqual(current: TemplateGuardMeta, previous: TemplateGuardMeta): boolean {\n  return current.inputName === previous.inputName && current.type === previous.type;\n}\n\nfunction isBaseClassEqual(current: SemanticSymbol|null, previous: SemanticSymbol|null): boolean {\n  if (current === null || previous === null) {\n    return current === previous;\n  }\n\n  return isSymbolEqual(current, previous);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileClassMetadata, compileDeclareClassMetadata, compileDeclareDirectiveFromMetadata, compileDirectiveFromMetadata, ConstantPool, FactoryTarget, makeBindingParser, R3ClassMetadata, R3DirectiveMetadata, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Reference, ReferenceEmitter} from '../../../imports';\nimport {extractSemanticTypeParameters, SemanticDepGraphUpdater} from '../../../incremental/semantic_graph';\nimport {ClassPropertyMapping, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, HostDirectiveMeta, InputMapping, MatchSource, MetadataReader, MetadataRegistry, MetaKind} from '../../../metadata';\nimport {PartialEvaluator} from '../../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../../perf';\nimport {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, ReflectionHost} from '../../../reflection';\nimport {LocalModuleScopeRegistry} from '../../../scope';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../../transform';\nimport {compileDeclareFactory, compileNgFactoryDefField, compileResults, extractClassMetadata, findAngularDecorator, getDirectiveDiagnostics, getProviderDiagnostics, getUndecoratedClassWithAngularFeaturesDiagnostic, InjectableClassRegistry, isAngularDecorator, readBaseClass, ReferencesRegistry, resolveProvidersRequiringFactory, toFactoryMetadata, validateHostDirectives} from '../../common';\n\nimport {extractDirectiveMetadata} from './shared';\nimport {DirectiveSymbol} from './symbol';\n\nconst FIELD_DECORATORS = [\n  'Input', 'Output', 'ViewChild', 'ViewChildren', 'ContentChild', 'ContentChildren', 'HostBinding',\n  'HostListener'\n];\nconst LIFECYCLE_HOOKS = new Set([\n  'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n  'ngAfterContentInit', 'ngAfterContentChecked'\n]);\n\nexport interface DirectiveHandlerData {\n  baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n  typeCheckMeta: DirectiveTypeCheckMeta;\n  meta: R3DirectiveMetadata;\n  classMetadata: R3ClassMetadata|null;\n  providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n  inputs: ClassPropertyMapping<InputMapping>;\n  outputs: ClassPropertyMapping;\n  isPoisoned: boolean;\n  isStructural: boolean;\n  decorator: ts.Decorator|null;\n  hostDirectives: HostDirectiveMeta[]|null;\n  rawHostDirectives: ts.Expression|null;\n}\n\nexport class DirectiveDecoratorHandler implements\n    DecoratorHandler<Decorator|null, DirectiveHandlerData, DirectiveSymbol, unknown> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n      private metaReader: MetadataReader, private injectableRegistry: InjectableClassRegistry,\n      private refEmitter: ReferenceEmitter, private referencesRegistry: ReferencesRegistry,\n      private isCore: boolean, private strictCtorDeps: boolean,\n      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n      private annotateForClosureCompiler: boolean, private perf: PerfRecorder) {}\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = DirectiveDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null):\n      DetectResult<Decorator|null>|undefined {\n    // If a class is undecorated but uses Angular features, we detect it as an\n    // abstract directive. This is an unsupported pattern as of v10, but we want\n    // to still detect these patterns so that we can report diagnostics.\n    if (!decorators) {\n      const angularField = this.findClassFieldWithAngularFeatures(node);\n      return angularField ? {trigger: angularField.node, decorator: null, metadata: null} :\n                            undefined;\n    } else {\n      const decorator = findAngularDecorator(decorators, 'Directive', this.isCore);\n      return decorator ? {trigger: decorator.node, decorator, metadata: decorator} : undefined;\n    }\n  }\n\n  analyze(node: ClassDeclaration, decorator: Readonly<Decorator|null>, flags = HandlerFlags.NONE):\n      AnalysisOutput<DirectiveHandlerData> {\n    // Skip processing of the class declaration if compilation of undecorated classes\n    // with Angular features is disabled. Previously in ngtsc, such classes have always\n    // been processed, but we want to enforce a consistent decorator mental model.\n    // See: https://v9.angular.io/guide/migration-undecorated-classes.\n    if (decorator === null) {\n      // If compiling @angular/core, skip the diagnostic as core occasionally hand-writes\n      // definitions.\n      if (this.isCore) {\n        return {};\n      }\n      return {diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)]};\n    }\n\n    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n\n    const directiveResult = extractDirectiveMetadata(\n        node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry,\n        this.isCore, flags, this.annotateForClosureCompiler);\n    if (directiveResult === undefined) {\n      return {};\n    }\n    const analysis = directiveResult.metadata;\n\n    let providersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n    if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(\n          directiveResult.decorator.get('providers')!, this.reflector, this.evaluator);\n    }\n\n    return {\n      analysis: {\n        inputs: directiveResult.inputs,\n        outputs: directiveResult.outputs,\n        meta: analysis,\n        hostDirectives: directiveResult.hostDirectives,\n        rawHostDirectives: directiveResult.rawHostDirectives,\n        classMetadata: extractClassMetadata(\n            node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n        providersRequiringFactory,\n        isPoisoned: false,\n        isStructural: directiveResult.isStructural,\n        decorator: decorator?.node as ts.Decorator | null ?? null,\n      }\n    };\n  }\n\n  symbol(node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>): DirectiveSymbol {\n    const typeParameters = extractSemanticTypeParameters(node);\n\n    return new DirectiveSymbol(\n        node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs,\n        analysis.typeCheckMeta, typeParameters);\n  }\n\n  register(node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>): void {\n    // Register this directive's information with the `MetadataRegistry`. This ensures that\n    // the information about the directive is available during the compile() phase.\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: false,\n      baseClass: analysis.baseClass,\n      hostDirectives: analysis.hostDirectives,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: analysis.isStructural,\n      animationTriggerNames: null,\n      isStandalone: analysis.meta.isStandalone,\n      imports: null,\n      schemas: null,\n      decorator: analysis.decorator,\n      // Directives analyzed within our own compilation are not _assumed_ to export providers.\n      // Instead, we statically analyze their imports to make a direct determination.\n      assumedToExportProviders: false,\n    });\n\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps,\n    });\n  }\n\n  resolve(node: ClassDeclaration, analysis: DirectiveHandlerData, symbol: DirectiveSymbol):\n      ResolveResult<unknown> {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n    if (analysis.providersRequiringFactory !== null &&\n        analysis.meta.providers instanceof WrappedNodeExpr) {\n      const providerDiagnostics = getProviderDiagnostics(\n          analysis.providersRequiringFactory, analysis.meta.providers!.node,\n          this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    const directiveDiagnostics = getDirectiveDiagnostics(\n        node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry,\n        this.strictCtorDeps, 'Directive');\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n\n    const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives ?\n        validateHostDirectives(\n            analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader) :\n        null;\n    if (hostDirectivesDiagnotics !== null) {\n      diagnostics.push(...hostDirectivesDiagnotics);\n    }\n\n    return {diagnostics: diagnostics.length > 0 ? diagnostics : undefined};\n  }\n\n  compileFull(\n      node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>,\n      resolution: Readonly<unknown>, pool: ConstantPool): CompileResult[] {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());\n    const classMetadata = analysis.classMetadata !== null ?\n        compileClassMetadata(analysis.classMetadata).toStmt() :\n        null;\n    return compileResults(fac, def, classMetadata, 'Éµdir');\n  }\n\n  compilePartial(\n      node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>,\n      resolution: Readonly<unknown>): CompileResult[] {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDeclareDirectiveFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ?\n        compileDeclareClassMetadata(analysis.classMetadata).toStmt() :\n        null;\n    return compileResults(fac, def, classMetadata, 'Éµdir');\n  }\n\n  /**\n   * Checks if a given class uses Angular features and returns the TypeScript node\n   * that indicated the usage. Classes are considered using Angular features if they\n   * contain class members that are either decorated with a known Angular decorator,\n   * or if they correspond to a known Angular lifecycle hook.\n   */\n  private findClassFieldWithAngularFeatures(node: ClassDeclaration): ClassMember|undefined {\n    return this.reflector.getMembersOfClass(node).find(member => {\n      if (!member.isStatic && member.kind === ClassMemberKind.Method &&\n          LIFECYCLE_HOOKS.has(member.name)) {\n        return true;\n      }\n      if (member.decorators) {\n        return member.decorators.some(\n            decorator => FIELD_DECORATORS.some(\n                decoratorName => isAngularDecorator(decorator, decoratorName, this.isCore)));\n      }\n      return false;\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileClassMetadata, compileDeclareClassMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileInjector, compileNgModule, Expression, ExternalExpr, FactoryTarget, FunctionExpr, InvokeFunctionExpr, LiteralArrayExpr, R3ClassMetadata, R3CompiledExpression, R3FactoryMetadata, R3Identifiers, R3InjectorMetadata, R3NgModuleMetadata, R3Reference, R3SelectorScopeMode, ReturnStatement, SchemaMetadata, Statement, WrappedNodeExpr,} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../../diagnostics';\nimport {assertSuccessfulReferenceEmit, Reference, ReferenceEmitter} from '../../../imports';\nimport {isArrayEqual, isReferenceEqual, isSymbolEqual, SemanticDepGraphUpdater, SemanticReference, SemanticSymbol,} from '../../../incremental/semantic_graph';\nimport {ExportedProviderStatusResolver, MetadataReader, MetadataRegistry, MetaKind} from '../../../metadata';\nimport {PartialEvaluator, ResolvedValue, SyntheticValue} from '../../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../../perf';\nimport {ClassDeclaration, DeclarationNode, Decorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral,} from '../../../reflection';\nimport {LocalModuleScopeRegistry, ScopeData} from '../../../scope';\nimport {getDiagnosticNode} from '../../../scope/src/util';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../../transform';\nimport {getSourceFile} from '../../../util/src/typescript';\nimport {combineResolvers, compileDeclareFactory, compileNgFactoryDefField, createValueHasWrongTypeError, extractClassMetadata, extractSchemas, findAngularDecorator, forwardRefResolver, getProviderDiagnostics, getValidConstructorDependencies, InjectableClassRegistry, isExpressionForwardReference, ReferencesRegistry, resolveProvidersRequiringFactory, toR3Reference, unwrapExpression, wrapFunctionExpressionsInParens, wrapTypeReference,} from '../../common';\n\nimport {createModuleWithProvidersResolver, isResolvedModuleWithProviders} from './module_with_providers';\n\nexport interface NgModuleAnalysis {\n  mod: R3NgModuleMetadata;\n  inj: Omit<R3InjectorMetadata, 'imports'>;\n  fac: R3FactoryMetadata;\n  classMetadata: R3ClassMetadata|null;\n  declarations: Reference<ClassDeclaration>[];\n  rawDeclarations: ts.Expression|null;\n  schemas: SchemaMetadata[];\n  imports: TopLevelImportedExpression[];\n  importRefs: Reference<ClassDeclaration>[];\n  rawImports: ts.Expression|null;\n  exports: Reference<ClassDeclaration>[];\n  rawExports: ts.Expression|null;\n  id: Expression|null;\n  factorySymbolName: string;\n  providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n  providers: ts.Expression|null;\n  remoteScopesMayRequireCycleProtection: boolean;\n  decorator: ts.Decorator|null;\n}\n\nexport interface NgModuleResolution {\n  injectorImports: Expression[];\n}\n\n/**\n * Represents an Angular NgModule.\n */\nexport class NgModuleSymbol extends SemanticSymbol {\n  private remotelyScopedComponents: {\n    component: SemanticSymbol,\n    usedDirectives: SemanticReference[],\n    usedPipes: SemanticReference[]\n  }[] = [];\n\n  /**\n   * `SemanticSymbol`s of the transitive imports of this NgModule which came from imported\n   * standalone components.\n   *\n   * Standalone components are excluded/included in the `InjectorDef` emit output of the NgModule\n   * based on whether the compiler can prove that their transitive imports may contain exported\n   * providers, so a change in this set of symbols may affect the compilation output of this\n   * NgModule.\n   */\n  private transitiveImportsFromStandaloneComponents = new Set<SemanticSymbol>();\n\n  constructor(decl: ClassDeclaration, public readonly hasProviders: boolean) {\n    super(decl);\n  }\n\n  override isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    // Changes in the provider status of this NgModule affect downstream dependencies, which may\n    // consider provider status in their own emits.\n    if (previousSymbol.hasProviders !== this.hasProviders) {\n      return true;\n    }\n\n    return false;\n  }\n\n  override isEmitAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    // compare our remotelyScopedComponents to the previous symbol\n    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n      return true;\n    }\n\n    for (const currEntry of this.remotelyScopedComponents) {\n      const prevEntry = previousSymbol.remotelyScopedComponents.find(prevEntry => {\n        return isSymbolEqual(prevEntry.component, currEntry.component);\n      });\n\n      if (prevEntry === undefined) {\n        // No previous entry was found, which means that this component became remotely scoped and\n        // hence this NgModule needs to be re-emitted.\n        return true;\n      }\n\n      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n        // The list of used directives or their order has changed. Since this NgModule emits\n        // references to the list of used directives, it should be re-emitted to update this list.\n        // Note: the NgModule does not have to be re-emitted when any of the directives has had\n        // their public API changed, as the NgModule only emits a reference to the symbol by its\n        // name. Therefore, testing for symbol equality is sufficient.\n        return true;\n      }\n\n      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n        return true;\n      }\n    }\n\n    if (previousSymbol.transitiveImportsFromStandaloneComponents.size !==\n        this.transitiveImportsFromStandaloneComponents.size) {\n      return true;\n    }\n\n    const previousImports = Array.from(previousSymbol.transitiveImportsFromStandaloneComponents);\n    for (const transitiveImport of this.transitiveImportsFromStandaloneComponents) {\n      const prevEntry =\n          previousImports.find(prevEntry => isSymbolEqual(prevEntry, transitiveImport));\n      if (prevEntry === undefined) {\n        return true;\n      }\n\n      if (transitiveImport.isPublicApiAffected(prevEntry)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  override isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  addRemotelyScopedComponent(\n      component: SemanticSymbol, usedDirectives: SemanticReference[],\n      usedPipes: SemanticReference[]): void {\n    this.remotelyScopedComponents.push({component, usedDirectives, usedPipes});\n  }\n\n  addTransitiveImportFromStandaloneComponent(importedSymbol: SemanticSymbol): void {\n    this.transitiveImportsFromStandaloneComponents.add(importedSymbol);\n  }\n}\n\n/**\n * Compiles @NgModule annotations to ngModuleDef fields.\n */\nexport class NgModuleDecoratorHandler implements\n    DecoratorHandler<Decorator, NgModuleAnalysis, NgModuleSymbol, NgModuleResolution> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaReader: MetadataReader, private metaRegistry: MetadataRegistry,\n      private scopeRegistry: LocalModuleScopeRegistry,\n      private referencesRegistry: ReferencesRegistry,\n      private exportedProviderStatusResolver: ExportedProviderStatusResolver,\n      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null, private isCore: boolean,\n      private refEmitter: ReferenceEmitter, private annotateForClosureCompiler: boolean,\n      private onlyPublishPublicTypings: boolean,\n      private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder) {}\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = NgModuleDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'NgModule', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator: decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  analyze(node: ClassDeclaration, decorator: Readonly<Decorator>):\n      AnalysisOutput<NgModuleAnalysis> {\n    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n\n    const name = node.name.text;\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, decorator.node,\n          `Incorrect number of arguments to @NgModule decorator`);\n    }\n\n    // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object\n    // literal was specified. This simplifies the code below.\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) :\n                                               ts.factory.createObjectLiteralExpression([]);\n\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta,\n          '@NgModule argument must be an object literal');\n    }\n    const ngModule = reflectObjectLiteral(meta);\n\n    if (ngModule.has('jit')) {\n      // The only allowed value is true, so there's no need to expand further.\n      return {};\n    }\n\n    const moduleResolvers = combineResolvers([\n      createModuleWithProvidersResolver(this.reflector, this.isCore),\n      forwardRefResolver,\n    ]);\n\n    const diagnostics: ts.Diagnostic[] = [];\n\n    // Extract the module declarations, imports, and exports.\n    let declarationRefs: Reference<ClassDeclaration>[] = [];\n    let rawDeclarations: ts.Expression|null = null;\n    if (ngModule.has('declarations')) {\n      rawDeclarations = ngModule.get('declarations')!;\n      const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);\n      declarationRefs =\n          this.resolveTypeList(rawDeclarations, declarationMeta, name, 'declarations', 0)\n              .references;\n\n      // Look through the declarations to make sure they're all a part of the current compilation.\n      for (const ref of declarationRefs) {\n        if (ref.node.getSourceFile().isDeclarationFile) {\n          const errorNode = ref.getOriginForDiagnostics(rawDeclarations);\n\n          diagnostics.push(makeDiagnostic(\n              ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode,\n              `Cannot declare '${\n                  ref.node.name\n                      .text}' in an NgModule as it's not a part of the current compilation.`,\n              [makeRelatedInformation(\n                  ref.node.name, `'${ref.node.name.text}' is declared here.`)]));\n        }\n      }\n    }\n\n    if (diagnostics.length > 0) {\n      return {diagnostics};\n    }\n\n    let importRefs: Reference<ClassDeclaration>[] = [];\n    let rawImports: ts.Expression|null = null;\n    if (ngModule.has('imports')) {\n      rawImports = ngModule.get('imports')!;\n      const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n      importRefs = this.resolveTypeList(rawImports, importsMeta, name, 'imports', 0).references;\n    }\n    let exportRefs: Reference<ClassDeclaration>[] = [];\n    let rawExports: ts.Expression|null = null;\n    if (ngModule.has('exports')) {\n      rawExports = ngModule.get('exports')!;\n      const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n      exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports', 0).references;\n      this.referencesRegistry.add(node, ...exportRefs);\n    }\n    let bootstrapRefs: Reference<ClassDeclaration>[] = [];\n    if (ngModule.has('bootstrap')) {\n      const expr = ngModule.get('bootstrap')!;\n      const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);\n      bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, 'bootstrap', 0).references;\n\n      // Verify that the `@NgModule.bootstrap` list doesn't have Standalone Components.\n      for (const ref of bootstrapRefs) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n        if (dirMeta?.isStandalone) {\n          diagnostics.push(makeStandaloneBootstrapDiagnostic(node, ref, expr));\n        }\n      }\n    }\n\n    const schemas = ngModule.has('schemas') ?\n        extractSchemas(ngModule.get('schemas')!, this.evaluator, 'NgModule') :\n        [];\n\n    let id: Expression|null = null;\n    if (ngModule.has('id')) {\n      const idExpr = ngModule.get('id')!;\n      if (!isModuleIdExpression(idExpr)) {\n        id = new WrappedNodeExpr(idExpr);\n      } else {\n        const diag = makeDiagnostic(\n            ErrorCode.WARN_NGMODULE_ID_UNNECESSARY, idExpr,\n            `Using 'module.id' for NgModule.id is a common anti-pattern that is ignored by the Angular compiler.`);\n        diag.category = ts.DiagnosticCategory.Warning;\n        diagnostics.push(diag);\n      }\n    }\n\n    const valueContext = node.getSourceFile();\n\n    const exportedNodes = new Set(exportRefs.map(ref => ref.node));\n    const declarations: R3Reference[] = [];\n    const exportedDeclarations: Expression[] = [];\n\n    const bootstrap = bootstrapRefs.map(\n        bootstrap => this._toR3Reference(\n            bootstrap.getOriginForDiagnostics(meta, node.name), bootstrap, valueContext));\n\n    for (const ref of declarationRefs) {\n      const decl =\n          this._toR3Reference(ref.getOriginForDiagnostics(meta, node.name), ref, valueContext);\n      declarations.push(decl);\n      if (exportedNodes.has(ref.node)) {\n        exportedDeclarations.push(decl.type);\n      }\n    }\n    const imports = importRefs.map(\n        imp =>\n            this._toR3Reference(imp.getOriginForDiagnostics(meta, node.name), imp, valueContext));\n    const exports = exportRefs.map(\n        exp =>\n            this._toR3Reference(exp.getOriginForDiagnostics(meta, node.name), exp, valueContext));\n\n\n    const isForwardReference = (ref: R3Reference) =>\n        isExpressionForwardReference(ref.value, node.name!, valueContext);\n    const containsForwardDecls = bootstrap.some(isForwardReference) ||\n        declarations.some(isForwardReference) || imports.some(isForwardReference) ||\n        exports.some(isForwardReference);\n\n    const type = wrapTypeReference(this.reflector, node);\n\n    const ngModuleMetadata: R3NgModuleMetadata = {\n      type,\n      bootstrap,\n      declarations,\n      publicDeclarationTypes: this.onlyPublishPublicTypings ? exportedDeclarations : null,\n      exports,\n      imports,\n      // Imported types are generally private, so include them unless restricting the .d.ts emit to\n      // only public types.\n      includeImportTypes: !this.onlyPublishPublicTypings,\n      containsForwardDecls,\n      id,\n      // Use `ÉµÉµsetNgModuleScope` to patch selector scopes onto the generated definition in a\n      // tree-shakeable way.\n      selectorScopeMode: R3SelectorScopeMode.SideEffect,\n      // TODO: to be implemented as a part of FW-1004.\n      schemas: [],\n    };\n\n    const rawProviders = ngModule.has('providers') ? ngModule.get('providers')! : null;\n    let wrappedProviders: WrappedNodeExpr<ts.Expression>|null = null;\n\n    // In most cases the providers will be an array literal. Check if it has any elements\n    // and don't include the providers if it doesn't which saves us a few bytes.\n    if (rawProviders !== null &&\n        (!ts.isArrayLiteralExpression(rawProviders) || rawProviders.elements.length > 0)) {\n      wrappedProviders = new WrappedNodeExpr(\n          this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) :\n                                            rawProviders);\n    }\n\n    const topLevelImports: TopLevelImportedExpression[] = [];\n    if (ngModule.has('imports')) {\n      const rawImports = unwrapExpression(ngModule.get('imports')!);\n\n      let topLevelExpressions: ts.Expression[] = [];\n      if (ts.isArrayLiteralExpression(rawImports)) {\n        for (const element of rawImports.elements) {\n          if (ts.isSpreadElement(element)) {\n            // Because `imports` allows nested arrays anyway, a spread expression (`...foo`) can be\n            // treated the same as a direct reference to `foo`.\n            topLevelExpressions.push(element.expression);\n            continue;\n          }\n          topLevelExpressions.push(element);\n        }\n      } else {\n        // Treat the whole `imports` expression as top-level.\n        topLevelExpressions.push(rawImports);\n      }\n\n      let absoluteIndex = 0;\n      for (const importExpr of topLevelExpressions) {\n        const resolved = this.evaluator.evaluate(importExpr, moduleResolvers);\n\n        const {references, hasModuleWithProviders} =\n            this.resolveTypeList(importExpr, [resolved], node.name.text, 'imports', absoluteIndex);\n        absoluteIndex += references.length;\n\n        topLevelImports.push({\n          expression: importExpr,\n          resolvedReferences: references,\n          hasModuleWithProviders,\n        });\n      }\n    }\n\n    const injectorMetadata: Omit<R3InjectorMetadata, 'imports'> = {\n      name,\n      type,\n      providers: wrappedProviders,\n    };\n\n    const factoryMetadata: R3FactoryMetadata = {\n      name,\n      type,\n      typeArgumentCount: 0,\n      deps: getValidConstructorDependencies(node, this.reflector, this.isCore),\n      target: FactoryTarget.NgModule,\n    };\n\n    // Remote scoping is used when adding imports to a component file would create a cycle. In such\n    // circumstances the component scope is monkey-patched from the NgModule file instead.\n    //\n    // However, if the NgModule itself has a cycle with the desired component/directive\n    // reference(s), then we need to be careful. This can happen for example if an NgModule imports\n    // a standalone component and the component also imports the NgModule.\n    //\n    // In this case, it'd be tempting to rely on the compiler's cycle detector to automatically put\n    // such circular references behind a function/closure. This requires global knowledge of the\n    // import graph though, and we don't want to depend on such techniques for new APIs like\n    // standalone components.\n    //\n    // Instead, we look for `forwardRef`s in the NgModule dependencies - an explicit signal from the\n    // user that a reference may not be defined until a circular import is resolved. If an NgModule\n    // contains forward-referenced declarations or imports, we assume that remotely scoped\n    // components should also guard against cycles using a closure-wrapped scope.\n    //\n    // The actual detection here is done heuristically. The compiler doesn't actually know whether\n    // any given `Reference` came from a `forwardRef`, but it does know when a `Reference` came from\n    // a `ForeignFunctionResolver` _like_ the `forwardRef` resolver. So we know when it's safe to\n    // not use a closure, and will use one just in case otherwise.\n    const remoteScopesMayRequireCycleProtection =\n        declarationRefs.some(isSyntheticReference) || importRefs.some(isSyntheticReference);\n\n    return {\n      diagnostics: diagnostics.length > 0 ? diagnostics : undefined,\n      analysis: {\n        id,\n        schemas,\n        mod: ngModuleMetadata,\n        inj: injectorMetadata,\n        fac: factoryMetadata,\n        declarations: declarationRefs,\n        rawDeclarations,\n        imports: topLevelImports,\n        rawImports,\n        importRefs,\n        exports: exportRefs,\n        rawExports,\n        providers: rawProviders,\n        providersRequiringFactory: rawProviders ?\n            resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) :\n            null,\n        classMetadata: extractClassMetadata(\n            node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        factorySymbolName: node.name.text,\n        remoteScopesMayRequireCycleProtection,\n        decorator: decorator?.node as ts.Decorator | null ?? null,\n      },\n    };\n  }\n\n  symbol(node: ClassDeclaration, analysis: NgModuleAnalysis): NgModuleSymbol {\n    return new NgModuleSymbol(node, analysis.providers !== null);\n  }\n\n  register(node: ClassDeclaration, analysis: NgModuleAnalysis): void {\n    // Register this module's information with the LocalModuleScopeRegistry. This ensures that\n    // during the compile() phase, the module's metadata is available for selector scope\n    // computation.\n    this.metaRegistry.registerNgModuleMetadata({\n      kind: MetaKind.NgModule,\n      ref: new Reference(node),\n      schemas: analysis.schemas,\n      declarations: analysis.declarations,\n      imports: analysis.importRefs,\n      exports: analysis.exports,\n      rawDeclarations: analysis.rawDeclarations,\n      rawImports: analysis.rawImports,\n      rawExports: analysis.rawExports,\n      decorator: analysis.decorator,\n      mayDeclareProviders: analysis.providers !== null,\n    });\n\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.fac.deps,\n    });\n  }\n\n  resolve(node: ClassDeclaration, analysis: Readonly<NgModuleAnalysis>):\n      ResolveResult<NgModuleResolution> {\n    const scope = this.scopeRegistry.getScopeOfModule(node);\n    const diagnostics: ts.Diagnostic[] = [];\n\n    const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n    if (scopeDiagnostics !== null) {\n      diagnostics.push(...scopeDiagnostics);\n    }\n\n    if (analysis.providersRequiringFactory !== null) {\n      const providerDiagnostics = getProviderDiagnostics(\n          analysis.providersRequiringFactory, analysis.providers!, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    const data: NgModuleResolution = {\n      injectorImports: [],\n    };\n\n    // Add all top-level imports from the `imports` field to the injector imports.\n    for (const topLevelImport of analysis.imports) {\n      if (topLevelImport.hasModuleWithProviders) {\n        // We have no choice but to emit expressions which contain MWPs, as we cannot filter on\n        // individual references.\n        data.injectorImports.push(new WrappedNodeExpr(topLevelImport.expression));\n        continue;\n      }\n\n      const refsToEmit: Reference<ClassDeclaration>[] = [];\n      let symbol: NgModuleSymbol|null = null;\n      if (this.semanticDepGraphUpdater !== null) {\n        const sym = this.semanticDepGraphUpdater.getSymbol(node) as NgModuleSymbol;\n        if (sym instanceof NgModuleSymbol) {\n          symbol = sym;\n        }\n      }\n\n      for (const ref of topLevelImport.resolvedReferences) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n        if (dirMeta !== null) {\n          if (!dirMeta.isComponent) {\n            // Skip emit of directives in imports - directives can't carry providers.\n            continue;\n          }\n\n          // Check whether this component has providers.\n          const mayExportProviders =\n              this.exportedProviderStatusResolver.mayExportProviders(dirMeta.ref, (importRef) => {\n                // We need to keep track of which transitive imports were used to decide\n                // `mayExportProviders`, since if those change in a future compilation this\n                // NgModule will need to be re-emitted.\n                if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n                  const importSymbol = this.semanticDepGraphUpdater.getSymbol(importRef.node);\n                  symbol.addTransitiveImportFromStandaloneComponent(importSymbol);\n                }\n              });\n\n          if (!mayExportProviders) {\n            // Skip emit of components that don't carry providers.\n            continue;\n          }\n        }\n\n        const pipeMeta = dirMeta === null ? this.metaReader.getPipeMetadata(ref) : null;\n        if (pipeMeta !== null) {\n          // Skip emit of pipes in imports - pipes can't carry providers.\n          continue;\n        }\n\n        refsToEmit.push(ref);\n      }\n\n      if (refsToEmit.length === topLevelImport.resolvedReferences.length) {\n        // All references within this top-level import should be emitted, so just use the user's\n        // expression.\n        data.injectorImports.push(new WrappedNodeExpr(topLevelImport.expression));\n      } else {\n        // Some references have been filtered out. Emit references to individual classes.\n        const context = node.getSourceFile();\n        for (const ref of refsToEmit) {\n          const emittedRef = this.refEmitter.emit(ref, context);\n          assertSuccessfulReferenceEmit(emittedRef, topLevelImport.expression, 'class');\n          data.injectorImports.push(emittedRef.expression);\n        }\n      }\n    }\n\n    if (scope !== null && !scope.compilation.isPoisoned) {\n      // Using the scope information, extend the injector's imports using the modules that are\n      // specified as module exports.\n      const context = getSourceFile(node);\n      for (const exportRef of analysis.exports) {\n        if (isNgModule(exportRef.node, scope.compilation)) {\n          const type = this.refEmitter.emit(exportRef, context);\n          assertSuccessfulReferenceEmit(type, node, 'NgModule');\n          data.injectorImports.push(type.expression);\n        }\n      }\n\n      for (const decl of analysis.declarations) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(decl);\n        if (dirMeta !== null) {\n          const refType = dirMeta.isComponent ? 'Component' : 'Directive';\n\n          if (dirMeta.selector === null) {\n            throw new FatalDiagnosticError(\n                ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node,\n                `${refType} ${decl.node.name.text} has no selector, please add it!`);\n          }\n\n          continue;\n        }\n      }\n    }\n\n    if (diagnostics.length > 0) {\n      return {diagnostics};\n    }\n\n    if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned ||\n        scope.reexports === null) {\n      return {data};\n    } else {\n      return {\n        data,\n        reexports: scope.reexports,\n      };\n    }\n  }\n\n  compileFull(\n      node: ClassDeclaration,\n      {inj, mod, fac, classMetadata, declarations, remoteScopesMayRequireCycleProtection}:\n          Readonly<NgModuleAnalysis>,\n      {injectorImports}: Readonly<NgModuleResolution>): CompileResult[] {\n    const factoryFn = compileNgFactoryDefField(fac);\n    const ngInjectorDef = compileInjector({\n      ...inj,\n      imports: injectorImports,\n    });\n    const ngModuleDef = compileNgModule(mod);\n    const statements = ngModuleDef.statements;\n    const metadata = classMetadata !== null ? compileClassMetadata(classMetadata) : null;\n    this.insertMetadataStatement(statements, metadata);\n    this.appendRemoteScopingStatements(\n        statements, node, declarations, remoteScopesMayRequireCycleProtection);\n\n    return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);\n  }\n\n  compilePartial(\n      node: ClassDeclaration, {inj, fac, mod, classMetadata}: Readonly<NgModuleAnalysis>,\n      {injectorImports}: Readonly<NgModuleResolution>): CompileResult[] {\n    const factoryFn = compileDeclareFactory(fac);\n    const injectorDef = compileDeclareInjectorFromMetadata({\n      ...inj,\n      imports: injectorImports,\n    });\n    const ngModuleDef = compileDeclareNgModuleFromMetadata(mod);\n    const metadata = classMetadata !== null ? compileDeclareClassMetadata(classMetadata) : null;\n    this.insertMetadataStatement(ngModuleDef.statements, metadata);\n    // NOTE: no remote scoping required as this is banned in partial compilation.\n    return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);\n  }\n\n  /**\n   * Add class metadata statements, if provided, to the `ngModuleStatements`.\n   */\n  private insertMetadataStatement(ngModuleStatements: Statement[], metadata: Expression|null):\n      void {\n    if (metadata !== null) {\n      ngModuleStatements.unshift(metadata.toStmt());\n    }\n  }\n\n  /**\n   * Add remote scoping statements, as needed, to the `ngModuleStatements`.\n   */\n  private appendRemoteScopingStatements(\n      ngModuleStatements: Statement[], node: ClassDeclaration,\n      declarations: Reference<ClassDeclaration>[],\n      remoteScopesMayRequireCycleProtection: boolean): void {\n    const context = getSourceFile(node);\n    for (const decl of declarations) {\n      const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n      if (remoteScope !== null) {\n        const directives = remoteScope.directives.map(directive => {\n          const type = this.refEmitter.emit(directive, context);\n          assertSuccessfulReferenceEmit(type, node, 'directive');\n          return type.expression;\n        });\n        const pipes = remoteScope.pipes.map(pipe => {\n          const type = this.refEmitter.emit(pipe, context);\n          assertSuccessfulReferenceEmit(type, node, 'pipe');\n          return type.expression;\n        });\n        const directiveArray = new LiteralArrayExpr(directives);\n        const pipesArray = new LiteralArrayExpr(pipes);\n\n        const directiveExpr = remoteScopesMayRequireCycleProtection && directives.length > 0 ?\n            new FunctionExpr([], [new ReturnStatement(directiveArray)]) :\n            directiveArray;\n        const pipesExpr = remoteScopesMayRequireCycleProtection && pipes.length > 0 ?\n            new FunctionExpr([], [new ReturnStatement(pipesArray)]) :\n            pipesArray;\n        const componentType = this.refEmitter.emit(decl, context);\n        assertSuccessfulReferenceEmit(componentType, node, 'component');\n        const declExpr = componentType.expression;\n        const setComponentScope = new ExternalExpr(R3Identifiers.setComponentScope);\n        const callExpr =\n            new InvokeFunctionExpr(setComponentScope, [declExpr, directiveExpr, pipesExpr]);\n\n        ngModuleStatements.push(callExpr.toStmt());\n      }\n    }\n  }\n\n  private compileNgModule(\n      factoryFn: CompileResult, injectorDef: R3CompiledExpression,\n      ngModuleDef: R3CompiledExpression): CompileResult[] {\n    const res: CompileResult[] = [\n      factoryFn,\n      {\n        name: 'Éµmod',\n        initializer: ngModuleDef.expression,\n        statements: ngModuleDef.statements,\n        type: ngModuleDef.type,\n      },\n      {\n        name: 'Éµinj',\n        initializer: injectorDef.expression,\n        statements: injectorDef.statements,\n        type: injectorDef.type,\n      },\n    ];\n    return res;\n  }\n\n  private _toR3Reference(\n      origin: ts.Node, valueRef: Reference<ClassDeclaration>,\n      valueContext: ts.SourceFile): R3Reference {\n    if (valueRef.hasOwningModuleGuess) {\n      return toR3Reference(origin, valueRef, valueContext, this.refEmitter);\n    } else {\n      return toR3Reference(origin, valueRef, valueContext, this.refEmitter);\n    }\n  }\n\n  // Verify that a \"Declaration\" reference is a `ClassDeclaration` reference.\n  private isClassDeclarationReference(ref: Reference): ref is Reference<ClassDeclaration> {\n    return this.reflector.isClass(ref.node);\n  }\n\n  /**\n   * Compute a list of `Reference`s from a resolved metadata value.\n   */\n  private resolveTypeList(\n      expr: ts.Node, resolvedList: ResolvedValue, className: string, arrayName: string,\n      absoluteIndex: number):\n      {references: Reference<ClassDeclaration>[], hasModuleWithProviders: boolean} {\n    let hasModuleWithProviders = false;\n    const refList: Reference<ClassDeclaration>[] = [];\n    if (!Array.isArray(resolvedList)) {\n      throw createValueHasWrongTypeError(\n          expr, resolvedList,\n          `Expected array when reading the NgModule.${arrayName} of ${className}`);\n    }\n\n    for (let idx = 0; idx < resolvedList.length; idx++) {\n      let entry = resolvedList[idx];\n      // Unwrap ModuleWithProviders for modules that are locally declared (and thus static\n      // resolution was able to descend into the function and return an object literal, a Map).\n      if (entry instanceof SyntheticValue && isResolvedModuleWithProviders(entry)) {\n        entry = entry.value.ngModule;\n        hasModuleWithProviders = true;\n      } else if (entry instanceof Map && entry.has('ngModule')) {\n        entry = entry.get('ngModule')!;\n        hasModuleWithProviders = true;\n      }\n\n      if (Array.isArray(entry)) {\n        // Recurse into nested arrays.\n        const recursiveResult =\n            this.resolveTypeList(expr, entry, className, arrayName, absoluteIndex);\n        refList.push(...recursiveResult.references);\n        absoluteIndex += recursiveResult.references.length;\n        hasModuleWithProviders = hasModuleWithProviders || recursiveResult.hasModuleWithProviders;\n      } else if (entry instanceof Reference) {\n        if (!this.isClassDeclarationReference(entry)) {\n          throw createValueHasWrongTypeError(\n              entry.node, entry,\n              `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${\n                  className} is not a class`);\n        }\n        refList.push(entry);\n        absoluteIndex += 1;\n      } else {\n        // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.\n        throw createValueHasWrongTypeError(\n            expr, entry,\n            `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${\n                className} is not a reference`);\n      }\n    }\n\n    return {\n      references: refList,\n      hasModuleWithProviders,\n    };\n  }\n}\n\nfunction isNgModule(node: ClassDeclaration, compilation: ScopeData): boolean {\n  return !compilation.dependencies.some(dep => dep.ref.node === node);\n}\n\n/**\n * Checks whether the given `ts.Expression` is the expression `module.id`.\n */\nfunction isModuleIdExpression(expr: ts.Expression): boolean {\n  return ts.isPropertyAccessExpression(expr) && ts.isIdentifier(expr.expression) &&\n      expr.expression.text === 'module' && expr.name.text === 'id';\n}\n\nexport interface TopLevelImportedExpression {\n  expression: ts.Expression;\n  resolvedReferences: Array<Reference<ClassDeclaration>>;\n  hasModuleWithProviders: boolean;\n}\n\n/**\n * Helper method to produce a diagnostics for a situation when a standalone component\n * is referenced in the `@NgModule.bootstrap` array.\n */\nfunction makeStandaloneBootstrapDiagnostic(\n    ngModuleClass: ClassDeclaration, bootstrappedClassRef: Reference<ClassDeclaration>,\n    rawBootstrapExpr: ts.Expression|null): ts.Diagnostic {\n  const componentClassName = bootstrappedClassRef.node.name.text;\n  // Note: this error message should be aligned with the one produced by JIT.\n  const message =  //\n      `The \\`${componentClassName}\\` class is a standalone component, which can ` +\n      `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n      `function for bootstrap instead.`;\n  const relatedInformation: ts.DiagnosticRelatedInformation[]|undefined =\n      [makeRelatedInformation(ngModuleClass, `The 'bootstrap' array is present on this NgModule.`)];\n\n  return makeDiagnostic(\n      ErrorCode.NGMODULE_BOOTSTRAP_IS_STANDALONE,\n      getDiagnosticNode(bootstrappedClassRef, rawBootstrapExpr), message, relatedInformation);\n}\n\nfunction isSyntheticReference(ref: Reference<DeclarationNode>): boolean {\n  return ref.synthetic;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../../diagnostics';\nimport {Reference} from '../../../imports';\nimport {ForeignFunctionResolver, SyntheticValue} from '../../../partial_evaluator';\nimport {ClassDeclaration, isNamedClassDeclaration, ReflectionHost, typeNodeToValueExpr} from '../../../reflection';\n\n/**\n * Creates a foreign function resolver to detect a `ModuleWithProviders<T>` type in a return type\n * position of a function or method declaration. A `SyntheticValue` is produced if such a return\n * type is recognized.\n *\n * @param reflector The reflection host to use for analyzing the syntax.\n * @param isCore Whether the @angular/core package is being compiled.\n */\nexport function createModuleWithProvidersResolver(\n    reflector: ReflectionHost, isCore: boolean): ForeignFunctionResolver {\n  /**\n   * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:\n   * `ModuleWithProviders<T>`\n   * @param type The type to reflect on.\n   * @returns the identifier of the NgModule type if found, or null otherwise.\n   */\n  function _reflectModuleFromTypeParam(\n      type: ts.TypeNode,\n      node: ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression): ts.Expression|null {\n    // Examine the type of the function to see if it's a ModuleWithProviders reference.\n    if (!ts.isTypeReferenceNode(type)) {\n      return null;\n    }\n\n    const typeName = type &&\n            (ts.isIdentifier(type.typeName) && type.typeName ||\n             ts.isQualifiedName(type.typeName) && type.typeName.right) ||\n        null;\n    if (typeName === null) {\n      return null;\n    }\n\n    // Look at the type itself to see where it comes from.\n    const id = reflector.getImportOfIdentifier(typeName);\n\n    // If it's not named ModuleWithProviders, bail.\n    if (id === null || id.name !== 'ModuleWithProviders') {\n      return null;\n    }\n\n    // If it's not from @angular/core, bail.\n    if (!isCore && id.from !== '@angular/core') {\n      return null;\n    }\n\n    // If there's no type parameter specified, bail.\n    if (type.typeArguments === undefined || type.typeArguments.length !== 1) {\n      const parent =\n          ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) ? node.parent : null;\n      const symbolName = (parent && parent.name ? parent.name.getText() + '.' : '') +\n          (node.name ? node.name.getText() : 'anonymous');\n      throw new FatalDiagnosticError(\n          ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type,\n          `${symbolName} returns a ModuleWithProviders type without a generic type argument. ` +\n              `Please add a generic type argument to the ModuleWithProviders type. If this ` +\n              `occurrence is in library code you don't control, please contact the library authors.`);\n    }\n\n    const arg = type.typeArguments[0];\n\n    return typeNodeToValueExpr(arg);\n  }\n\n  /**\n   * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:\n   * `A|B|{ngModule: T}|C`.\n   * @param type The type to reflect on.\n   * @returns the identifier of the NgModule type if found, or null otherwise.\n   */\n  function _reflectModuleFromLiteralType(type: ts.TypeNode): ts.Expression|null {\n    if (!ts.isIntersectionTypeNode(type)) {\n      return null;\n    }\n    for (const t of type.types) {\n      if (ts.isTypeLiteralNode(t)) {\n        for (const m of t.members) {\n          const ngModuleType = ts.isPropertySignature(m) && ts.isIdentifier(m.name) &&\n                  m.name.text === 'ngModule' && m.type ||\n              null;\n          const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);\n          if (ngModuleExpression) {\n            return ngModuleExpression;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  return (fn, callExpr, resolve, unresolvable) => {\n    const rawType = fn.node.type;\n    if (rawType === undefined) {\n      return unresolvable;\n    }\n\n    const type =\n        _reflectModuleFromTypeParam(rawType, fn.node) ?? _reflectModuleFromLiteralType(rawType);\n    if (type === null) {\n      return unresolvable;\n    }\n    const ngModule = resolve(type);\n    if (!(ngModule instanceof Reference) || !isNamedClassDeclaration(ngModule.node)) {\n      return unresolvable;\n    }\n\n    return new SyntheticValue({\n      ngModule: ngModule as Reference<ClassDeclaration>,\n      mwpCall: callExpr,\n    });\n  };\n}\n\nexport interface ResolvedModuleWithProviders {\n  ngModule: Reference<ClassDeclaration>;\n  mwpCall: ts.CallExpression;\n}\n\nexport function isResolvedModuleWithProviders(sv: SyntheticValue<unknown>):\n    sv is SyntheticValue<ResolvedModuleWithProviders> {\n  return typeof sv.value === 'object' && sv.value != null &&\n      sv.value.hasOwnProperty('ngModule' as keyof ResolvedModuleWithProviders) &&\n      sv.value.hasOwnProperty('mwpCall' as keyof ResolvedModuleWithProviders);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {Cycle} from '../../../cycles';\nimport {makeRelatedInformation} from '../../../diagnostics';\nimport {Reference} from '../../../imports';\n\n\n/**\n * Generate a diagnostic related information object that describes a potential cyclic import path.\n */\nexport function makeCyclicImportInfo(\n    ref: Reference, type: string, cycle: Cycle): ts.DiagnosticRelatedInformation {\n  const name = ref.debugName || '(unknown)';\n  const path = cycle.getPath().map(sf => sf.fileName).join(' -> ');\n  const message =\n      `The ${type} '${name}' is used in the template but importing it would create a cycle: `;\n  return makeRelatedInformation(ref.node, message + path);\n}\n\n\n/**\n * Checks whether a selector is a valid custom element tag name.\n * Based loosely on https://github.com/sindresorhus/validate-element-name.\n */\nexport function checkCustomElementSelectorForErrors(selector: string): string|null {\n  // Avoid flagging components with an attribute or class selector. This isn't bulletproof since it\n  // won't catch cases like `foo[]bar`, but we don't need it to be. This is mainly to avoid flagging\n  // something like `foo-bar[baz]` incorrectly.\n  if (selector.includes('.') || (selector.includes('[') && selector.includes(']'))) {\n    return null;\n  }\n\n  if (!(/^[a-z]/.test(selector))) {\n    return 'Selector of a ShadowDom-encapsulated component must start with a lower case letter.';\n  }\n\n  if (/[A-Z]/.test(selector)) {\n    return 'Selector of a ShadowDom-encapsulated component must all be in lower case.';\n  }\n\n  if (!selector.includes('-')) {\n    return 'Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.';\n  }\n\n  return null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, LexerRange, ParsedTemplate, ParseSourceFile, parseTemplate, TmplAstNode,} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../../diagnostics';\nimport {absoluteFrom} from '../../../file_system';\nimport {DependencyTracker} from '../../../incremental/api';\nimport {Resource} from '../../../metadata';\nimport {PartialEvaluator} from '../../../partial_evaluator';\nimport {ClassDeclaration, DeclarationNode, Decorator} from '../../../reflection';\nimport {TemplateSourceMapping} from '../../../typecheck/api';\nimport {createValueHasWrongTypeError, isStringArray, ResourceLoader} from '../../common';\n\n/**\n * The literal style url extracted from the decorator, along with metadata for diagnostics.\n */\nexport interface StyleUrlMeta {\n  url: string;\n  nodeForError: ts.Node;\n  source: ResourceTypeForDiagnostics.StylesheetFromTemplate|\n      ResourceTypeForDiagnostics.StylesheetFromDecorator;\n}\n\n/**\n * Information about the origin of a resource in the application code. This is used for creating\n * diagnostics, so we can point to the root cause of an error in the application code.\n *\n * A template resource comes from the `templateUrl` property on the component decorator.\n *\n * Stylesheets resources can come from either the `styleUrls` property on the component decorator,\n * or from inline `style` tags and style links on the external template.\n */\nexport const enum ResourceTypeForDiagnostics {\n  Template,\n  StylesheetFromTemplate,\n  StylesheetFromDecorator,\n}\n\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedComponentTemplate extends ParsedTemplate {\n  /**\n   * The template AST, parsed in a manner which preserves source map information for diagnostics.\n   *\n   * Not useful for emit.\n   */\n  diagNodes: TmplAstNode[];\n\n  /**\n   * The `ParseSourceFile` for the template.\n   */\n  file: ParseSourceFile;\n}\n\nexport interface ParsedTemplateWithSource extends ParsedComponentTemplate {\n  /** The string contents of the template. */\n  content: string;\n  sourceMapping: TemplateSourceMapping;\n  declaration: TemplateDeclaration;\n}\n\n\n\n/**\n * Common fields extracted from the declaration of a template.\n */\ninterface CommonTemplateDeclaration {\n  preserveWhitespaces: boolean;\n  interpolationConfig: InterpolationConfig;\n  templateUrl: string;\n  resolvedTemplateUrl: string;\n}\n\n/**\n * Information extracted from the declaration of an inline template.\n */\nexport interface InlineTemplateDeclaration extends CommonTemplateDeclaration {\n  isInline: true;\n  expression: ts.Expression;\n}\n\n/**\n * Information extracted from the declaration of an external template.\n */\nexport interface ExternalTemplateDeclaration extends CommonTemplateDeclaration {\n  isInline: false;\n  templateUrlExpression: ts.Expression;\n}\n\n/**\n * The declaration of a template extracted from a component decorator.\n *\n * This data is extracted and stored separately to facilitate re-interpreting the template\n * declaration whenever the compiler is notified of a change to a template file. With this\n * information, `ComponentDecoratorHandler` is able to re-read the template and update the component\n * record without needing to parse the original decorator again.\n */\nexport type TemplateDeclaration = InlineTemplateDeclaration|ExternalTemplateDeclaration;\n\n/** Determines the node to use for debugging purposes for the given TemplateDeclaration. */\nexport function getTemplateDeclarationNodeForError(declaration: TemplateDeclaration): ts.Node {\n  return declaration.isInline ? declaration.expression : declaration.templateUrlExpression;\n}\n\nexport interface ExtractTemplateOptions {\n  usePoisonedData: boolean;\n  enableI18nLegacyMessageIdFormat: boolean;\n  i18nNormalizeLineEndingsInICUs: boolean;\n}\n\nexport function extractTemplate(\n    node: ClassDeclaration, template: TemplateDeclaration, evaluator: PartialEvaluator,\n    depTracker: DependencyTracker|null, resourceLoader: ResourceLoader,\n    options: ExtractTemplateOptions): ParsedTemplateWithSource {\n  if (template.isInline) {\n    let sourceStr: string;\n    let sourceParseRange: LexerRange|null = null;\n    let templateContent: string;\n    let sourceMapping: TemplateSourceMapping;\n    let escapedString = false;\n    let sourceMapUrl: string|null;\n    // We only support SourceMaps for inline templates that are simple string literals.\n    if (ts.isStringLiteral(template.expression) ||\n        ts.isNoSubstitutionTemplateLiteral(template.expression)) {\n      // the start and end of the `templateExpr` node includes the quotation marks, which we must\n      // strip\n      sourceParseRange = getTemplateRange(template.expression);\n      sourceStr = template.expression.getSourceFile().text;\n      templateContent = template.expression.text;\n      escapedString = true;\n      sourceMapping = {\n        type: 'direct',\n        node: template.expression,\n      };\n      sourceMapUrl = template.resolvedTemplateUrl;\n    } else {\n      const resolvedTemplate = evaluator.evaluate(template.expression);\n      if (typeof resolvedTemplate !== 'string') {\n        throw createValueHasWrongTypeError(\n            template.expression, resolvedTemplate, 'template must be a string');\n      }\n      // We do not parse the template directly from the source file using a lexer range, so\n      // the template source and content are set to the statically resolved template.\n      sourceStr = resolvedTemplate;\n      templateContent = resolvedTemplate;\n      sourceMapping = {\n        type: 'indirect',\n        node: template.expression,\n        componentClass: node,\n        template: templateContent,\n      };\n\n      // Indirect templates cannot be mapped to a particular byte range of any input file, since\n      // they're computed by expressions that may span many files. Don't attempt to map them back\n      // to a given file.\n      sourceMapUrl = null;\n    }\n\n    return {\n      ...parseExtractedTemplate(\n          template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options),\n      content: templateContent,\n      sourceMapping,\n      declaration: template,\n    };\n  } else {\n    const templateContent = resourceLoader.load(template.resolvedTemplateUrl);\n    if (depTracker !== null) {\n      depTracker.addResourceDependency(\n          node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n    }\n\n    return {\n      ...parseExtractedTemplate(\n          template, /* sourceStr */ templateContent, /* sourceParseRange */ null,\n          /* escapedString */ false,\n          /* sourceMapUrl */ template.resolvedTemplateUrl, options),\n      content: templateContent,\n      sourceMapping: {\n        type: 'external',\n        componentClass: node,\n        node: template.templateUrlExpression,\n        template: templateContent,\n        templateUrl: template.resolvedTemplateUrl,\n      },\n      declaration: template,\n    };\n  }\n}\n\nfunction parseExtractedTemplate(\n    template: TemplateDeclaration, sourceStr: string, sourceParseRange: LexerRange|null,\n    escapedString: boolean, sourceMapUrl: string|null,\n    options: ExtractTemplateOptions): ParsedComponentTemplate {\n  // We always normalize line endings if the template has been escaped (i.e. is inline).\n  const i18nNormalizeLineEndingsInICUs = escapedString || options.i18nNormalizeLineEndingsInICUs;\n\n  const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl ?? '', {\n    preserveWhitespaces: template.preserveWhitespaces,\n    interpolationConfig: template.interpolationConfig,\n    range: sourceParseRange ?? undefined,\n    escapedString,\n    enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,\n    i18nNormalizeLineEndingsInICUs,\n    alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData,\n  });\n\n  // Unfortunately, the primary parse of the template above may not contain accurate source map\n  // information. If used directly, it would result in incorrect code locations in template\n  // errors, etc. There are three main problems:\n  //\n  // 1. `preserveWhitespaces: false` annihilates the correctness of template source mapping, as\n  //    the whitespace transformation changes the contents of HTML text nodes before they're\n  //    parsed into Angular expressions.\n  // 2. `preserveLineEndings: false` causes growing misalignments in templates that use '\\r\\n'\n  //    line endings, by normalizing them to '\\n'.\n  // 3. By default, the template parser strips leading trivia characters (like spaces, tabs, and\n  //    newlines). This also destroys source mapping information.\n  //\n  // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n  // with the above options set to preserve source mappings.\n\n  const {nodes: diagNodes} = parseTemplate(sourceStr, sourceMapUrl ?? '', {\n    preserveWhitespaces: true,\n    preserveLineEndings: true,\n    interpolationConfig: template.interpolationConfig,\n    range: sourceParseRange ?? undefined,\n    escapedString,\n    enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,\n    i18nNormalizeLineEndingsInICUs,\n    leadingTriviaChars: [],\n    alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData,\n  });\n\n  return {\n    ...parsedTemplate,\n    diagNodes,\n    file: new ParseSourceFile(sourceStr, sourceMapUrl ?? ''),\n  };\n}\n\nexport function parseTemplateDeclaration(\n    node: ClassDeclaration, decorator: Decorator, component: Map<string, ts.Expression>,\n    containingFile: string, evaluator: PartialEvaluator, depTracker: DependencyTracker|null,\n    resourceLoader: ResourceLoader, defaultPreserveWhitespaces: boolean): TemplateDeclaration {\n  let preserveWhitespaces: boolean = defaultPreserveWhitespaces;\n  if (component.has('preserveWhitespaces')) {\n    const expr = component.get('preserveWhitespaces')!;\n    const value = evaluator.evaluate(expr);\n    if (typeof value !== 'boolean') {\n      throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');\n    }\n    preserveWhitespaces = value;\n  }\n\n  let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n  if (component.has('interpolation')) {\n    const expr = component.get('interpolation')!;\n    const value = evaluator.evaluate(expr);\n    if (!Array.isArray(value) || value.length !== 2 ||\n        !value.every(element => typeof element === 'string')) {\n      throw createValueHasWrongTypeError(\n          expr, value, 'interpolation must be an array with 2 elements of string type');\n    }\n    interpolationConfig = InterpolationConfig.fromArray(value as [string, string]);\n  }\n\n  if (component.has('templateUrl')) {\n    const templateUrlExpr = component.get('templateUrl')!;\n    const templateUrl = evaluator.evaluate(templateUrlExpr);\n    if (typeof templateUrl !== 'string') {\n      throw createValueHasWrongTypeError(\n          templateUrlExpr, templateUrl, 'templateUrl must be a string');\n    }\n    try {\n      const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);\n      return {\n        isInline: false,\n        interpolationConfig,\n        preserveWhitespaces,\n        templateUrl,\n        templateUrlExpression: templateUrlExpr,\n        resolvedTemplateUrl: resourceUrl,\n      };\n    } catch (e) {\n      if (depTracker !== null) {\n        // The analysis of this file cannot be re-used if the template URL could\n        // not be resolved. Future builds should re-analyze and re-attempt resolution.\n        depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n      }\n\n      throw makeResourceNotFoundError(\n          templateUrl, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n    }\n  } else if (component.has('template')) {\n    return {\n      isInline: true,\n      interpolationConfig,\n      preserveWhitespaces,\n      expression: component.get('template')!,\n      templateUrl: containingFile,\n      resolvedTemplateUrl: containingFile,\n    };\n  } else {\n    throw new FatalDiagnosticError(\n        ErrorCode.COMPONENT_MISSING_TEMPLATE, decorator.node, 'component is missing a template');\n  }\n}\n\nexport function preloadAndParseTemplate(\n    evaluator: PartialEvaluator, resourceLoader: ResourceLoader, depTracker: DependencyTracker|null,\n    preanalyzeTemplateCache: Map<DeclarationNode, ParsedTemplateWithSource>, node: ClassDeclaration,\n    decorator: Decorator, component: Map<string, ts.Expression>, containingFile: string,\n    defaultPreserveWhitespaces: boolean,\n    options: ExtractTemplateOptions): Promise<ParsedTemplateWithSource|null> {\n  if (component.has('templateUrl')) {\n    // Extract the templateUrl and preload it.\n    const templateUrlExpr = component.get('templateUrl')!;\n    const templateUrl = evaluator.evaluate(templateUrlExpr);\n    if (typeof templateUrl !== 'string') {\n      throw createValueHasWrongTypeError(\n          templateUrlExpr, templateUrl, 'templateUrl must be a string');\n    }\n    try {\n      const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);\n      const templatePromise =\n          resourceLoader.preload(resourceUrl, {type: 'template', containingFile});\n\n      // If the preload worked, then actually load and parse the template, and wait for any\n      // style URLs to resolve.\n      if (templatePromise !== undefined) {\n        return templatePromise.then(() => {\n          const templateDecl = parseTemplateDeclaration(\n              node, decorator, component, containingFile, evaluator, depTracker, resourceLoader,\n              defaultPreserveWhitespaces);\n          const template =\n              extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options);\n          preanalyzeTemplateCache.set(node, template);\n          return template;\n        });\n      } else {\n        return Promise.resolve(null);\n      }\n    } catch (e) {\n      if (depTracker !== null) {\n        // The analysis of this file cannot be re-used if the template URL could\n        // not be resolved. Future builds should re-analyze and re-attempt resolution.\n        depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n      }\n\n      throw makeResourceNotFoundError(\n          templateUrl, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n    }\n  } else {\n    const templateDecl = parseTemplateDeclaration(\n        node, decorator, component, containingFile, evaluator, depTracker, resourceLoader,\n        defaultPreserveWhitespaces);\n    const template =\n        extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options);\n    preanalyzeTemplateCache.set(node, template);\n    return Promise.resolve(template);\n  }\n}\n\nfunction getTemplateRange(templateExpr: ts.Expression) {\n  const startPos = templateExpr.getStart() + 1;\n  const {line, character} =\n      ts.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);\n  return {\n    startPos,\n    startLine: line,\n    startCol: character,\n    endPos: templateExpr.getEnd() - 1,\n  };\n}\n\nexport function makeResourceNotFoundError(\n    file: string, nodeForError: ts.Node,\n    resourceType: ResourceTypeForDiagnostics): FatalDiagnosticError {\n  let errorText: string;\n  switch (resourceType) {\n    case ResourceTypeForDiagnostics.Template:\n      errorText = `Could not find template file '${file}'.`;\n      break;\n    case ResourceTypeForDiagnostics.StylesheetFromTemplate:\n      errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n      break;\n    case ResourceTypeForDiagnostics.StylesheetFromDecorator:\n      errorText = `Could not find stylesheet file '${file}'.`;\n      break;\n  }\n\n  return new FatalDiagnosticError(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n}\n\n\n/**\n * Transforms the given decorator to inline external resources. i.e. if the decorator\n * resolves to `@Component`, the `templateUrl` and `styleUrls` metadata fields will be\n * transformed to their semantically-equivalent inline variants.\n *\n * This method is used for serializing decorators into the class metadata. The emitted\n * class metadata should not refer to external resources as this would be inconsistent\n * with the component definitions/declarations which already inline external resources.\n *\n * Additionally, the references to external resources would require libraries to ship\n * external resources exclusively for the class metadata.\n */\nexport function transformDecoratorResources(\n    dec: Decorator, component: Map<string, ts.Expression>, styles: string[],\n    template: ParsedTemplateWithSource): Decorator {\n  if (dec.name !== 'Component') {\n    return dec;\n  }\n\n  // If no external resources are referenced, preserve the original decorator\n  // for the best source map experience when the decorator is emitted in TS.\n  if (!component.has('templateUrl') && !component.has('styleUrls') && !component.has('styles')) {\n    return dec;\n  }\n\n  const metadata = new Map(component);\n\n  // Set the `template` property if the `templateUrl` property is set.\n  if (metadata.has('templateUrl')) {\n    metadata.delete('templateUrl');\n    metadata.set('template', ts.factory.createStringLiteral(template.content));\n  }\n\n  if (metadata.has('styleUrls') || metadata.has('styles')) {\n    metadata.delete('styles');\n    metadata.delete('styleUrls');\n\n    if (styles.length > 0) {\n      const styleNodes = styles.reduce((result, style) => {\n        if (style.trim().length > 0) {\n          result.push(ts.factory.createStringLiteral(style));\n        }\n        return result;\n      }, [] as ts.StringLiteral[]);\n\n      if (styleNodes.length > 0) {\n        metadata.set('styles', ts.factory.createArrayLiteralExpression(styleNodes));\n      }\n    }\n  }\n\n  // Convert the metadata to TypeScript AST object literal element nodes.\n  const newMetadataFields: ts.ObjectLiteralElementLike[] = [];\n  for (const [name, value] of metadata.entries()) {\n    newMetadataFields.push(ts.factory.createPropertyAssignment(name, value));\n  }\n\n  // Return the original decorator with the overridden metadata argument.\n  return {...dec, args: [ts.factory.createObjectLiteralExpression(newMetadataFields)]};\n}\n\nexport function extractComponentStyleUrls(\n    evaluator: PartialEvaluator,\n    component: Map<string, ts.Expression>,\n    ): StyleUrlMeta[] {\n  if (!component.has('styleUrls')) {\n    return [];\n  }\n\n  return extractStyleUrlsFromExpression(evaluator, component.get('styleUrls')!);\n}\n\nfunction extractStyleUrlsFromExpression(\n    evaluator: PartialEvaluator, styleUrlsExpr: ts.Expression): StyleUrlMeta[] {\n  const styleUrls: StyleUrlMeta[] = [];\n\n  if (ts.isArrayLiteralExpression(styleUrlsExpr)) {\n    for (const styleUrlExpr of styleUrlsExpr.elements) {\n      if (ts.isSpreadElement(styleUrlExpr)) {\n        styleUrls.push(...extractStyleUrlsFromExpression(evaluator, styleUrlExpr.expression));\n      } else {\n        const styleUrl = evaluator.evaluate(styleUrlExpr);\n\n        if (typeof styleUrl !== 'string') {\n          throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');\n        }\n\n        styleUrls.push({\n          url: styleUrl,\n          source: ResourceTypeForDiagnostics.StylesheetFromDecorator,\n          nodeForError: styleUrlExpr,\n        });\n      }\n    }\n  } else {\n    const evaluatedStyleUrls = evaluator.evaluate(styleUrlsExpr);\n    if (!isStringArray(evaluatedStyleUrls)) {\n      throw createValueHasWrongTypeError(\n          styleUrlsExpr, evaluatedStyleUrls, 'styleUrls must be an array of strings');\n    }\n\n    for (const styleUrl of evaluatedStyleUrls) {\n      styleUrls.push({\n        url: styleUrl,\n        source: ResourceTypeForDiagnostics.StylesheetFromDecorator,\n        nodeForError: styleUrlsExpr,\n      });\n    }\n  }\n\n  return styleUrls;\n}\nexport function extractStyleResources(\n    resourceLoader: ResourceLoader, component: Map<string, ts.Expression>,\n    containingFile: string): ReadonlySet<Resource> {\n  const styles = new Set<Resource>();\n  function stringLiteralElements(array: ts.ArrayLiteralExpression): ts.StringLiteralLike[] {\n    return array.elements.filter(\n        (e: ts.Expression): e is ts.StringLiteralLike => ts.isStringLiteralLike(e));\n  }\n\n  // If styleUrls is a literal array, process each resource url individually and\n  // register ones that are string literals.\n  const styleUrlsExpr = component.get('styleUrls');\n  if (styleUrlsExpr !== undefined && ts.isArrayLiteralExpression(styleUrlsExpr)) {\n    for (const expression of stringLiteralElements(styleUrlsExpr)) {\n      try {\n        const resourceUrl = resourceLoader.resolve(expression.text, containingFile);\n        styles.add({path: absoluteFrom(resourceUrl), expression});\n      } catch {\n        // Errors in style resource extraction do not need to be handled here. We will produce\n        // diagnostics for each one that fails in the analysis, after we evaluate the\n        // `styleUrls` expression to determine _all_ style resources, not just the string\n        // literals.\n      }\n    }\n  }\n\n  const stylesExpr = component.get('styles');\n  if (stylesExpr !== undefined && ts.isArrayLiteralExpression(stylesExpr)) {\n    for (const expression of stringLiteralElements(stylesExpr)) {\n      styles.add({path: null, expression});\n    }\n  }\n\n  return styles;\n}\n\nexport function _extractTemplateStyleUrls(template: ParsedTemplateWithSource): StyleUrlMeta[] {\n  if (template.styleUrls === null) {\n    return [];\n  }\n\n  const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n  return template.styleUrls.map(\n      url => ({url, source: ResourceTypeForDiagnostics.StylesheetFromTemplate, nodeForError}));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isArrayEqual, isReferenceEqual, SemanticReference, SemanticSymbol} from '../../../incremental/semantic_graph';\nimport {DirectiveSymbol} from '../../directive';\n\n/**\n * Represents an Angular component.\n */\nexport class ComponentSymbol extends DirectiveSymbol {\n  usedDirectives: SemanticReference[] = [];\n  usedPipes: SemanticReference[] = [];\n  isRemotelyScoped = false;\n\n  override isEmitAffected(previousSymbol: SemanticSymbol, publicApiAffected: Set<SemanticSymbol>):\n      boolean {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n\n    // Create an equality function that considers symbols equal if they represent the same\n    // declaration, but only if the symbol in the current compilation does not have its public API\n    // affected.\n    const isSymbolUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n        isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n\n    // The emit of a component is affected if either of the following is true:\n    //  1. The component used to be remotely scoped but no longer is, or vice versa.\n    //  2. The list of used directives has changed or any of those directives have had their public\n    //     API changed. If the used directives have been reordered but not otherwise affected then\n    //     the component must still be re-emitted, as this may affect directive instantiation order.\n    //  3. The list of used pipes has changed, or any of those pipes have had their public API\n    //     changed.\n    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped ||\n        !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) ||\n        !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n  }\n\n  override isTypeCheckBlockAffected(\n      previousSymbol: SemanticSymbol, typeCheckApiAffected: Set<SemanticSymbol>): boolean {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n\n    // To verify that a used directive is not affected we need to verify that its full inheritance\n    // chain is not present in `typeCheckApiAffected`.\n    const isInheritanceChainAffected = (symbol: SemanticSymbol): boolean => {\n      let currentSymbol: SemanticSymbol|null = symbol;\n      while (currentSymbol instanceof DirectiveSymbol) {\n        if (typeCheckApiAffected.has(currentSymbol)) {\n          return true;\n        }\n        currentSymbol = currentSymbol.baseClass;\n      }\n\n      return false;\n    };\n\n    // Create an equality function that considers directives equal if they represent the same\n    // declaration and if the symbol and all symbols it inherits from in the current compilation\n    // do not have their type-check API affected.\n    const isDirectiveUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n        isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n\n    // Create an equality function that considers pipes equal if they represent the same\n    // declaration and if the symbol in the current compilation does not have its type-check\n    // API affected.\n    const isPipeUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n        isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n\n    // The emit of a type-check block of a component is affected if either of the following is true:\n    //  1. The list of used directives has changed or any of those directives have had their\n    //     type-check API changed.\n    //  2. The list of used pipes has changed, or any of those pipes have had their type-check API\n    //     changed.\n    return !isArrayEqual(\n               this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) ||\n        !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationTriggerNames} from '@angular/compiler';\nimport {isResolvedModuleWithProviders, ResolvedModuleWithProviders,} from '@angular/compiler-cli/src/ngtsc/annotations/ng_module';\nimport {ErrorCode, makeDiagnostic} from '@angular/compiler-cli/src/ngtsc/diagnostics';\nimport ts from 'typescript';\n\nimport {Reference} from '../../../imports';\nimport {ForeignFunctionResolver, ResolvedValue, ResolvedValueMap, SyntheticValue} from '../../../partial_evaluator';\nimport {ClassDeclaration, isNamedClassDeclaration} from '../../../reflection';\nimport {createValueHasWrongTypeError, getOriginNodeForDiagnostics} from '../../common';\n\n/**\n * Collect the animation names from the static evaluation result.\n * @param value the static evaluation result of the animations\n * @param animationTriggerNames the animation names collected and whether some names could not be\n *     statically evaluated.\n */\nexport function collectAnimationNames(\n    value: ResolvedValue, animationTriggerNames: AnimationTriggerNames) {\n  if (value instanceof Map) {\n    const name = value.get('name');\n    if (typeof name === 'string') {\n      animationTriggerNames.staticTriggerNames.push(name);\n    } else {\n      animationTriggerNames.includesDynamicAnimations = true;\n    }\n  } else if (Array.isArray(value)) {\n    for (const resolvedValue of value) {\n      collectAnimationNames(resolvedValue, animationTriggerNames);\n    }\n  } else {\n    animationTriggerNames.includesDynamicAnimations = true;\n  }\n}\n\nexport function isAngularAnimationsReference(reference: Reference, symbolName: string): boolean {\n  return reference.ownedByModuleGuess === '@angular/animations' &&\n      reference.debugName === symbolName;\n}\n\nexport const animationTriggerResolver: ForeignFunctionResolver =\n    (fn, node, resolve, unresolvable) => {\n      const animationTriggerMethodName = 'trigger';\n      if (!isAngularAnimationsReference(fn, animationTriggerMethodName)) {\n        return unresolvable;\n      }\n      const triggerNameExpression = node.arguments[0];\n      if (!triggerNameExpression) {\n        return unresolvable;\n      }\n      const res = new Map<string, ResolvedValue>();\n      res.set('name', resolve(triggerNameExpression));\n      return res;\n    };\n\nexport function validateAndFlattenComponentImports(imports: ResolvedValue, expr: ts.Expression): {\n  imports: Reference<ClassDeclaration>[],\n  diagnostics: ts.Diagnostic[],\n} {\n  const flattened: Reference<ClassDeclaration>[] = [];\n\n  if (!Array.isArray(imports)) {\n    const error = createValueHasWrongTypeError(\n                      expr, imports,\n                      `'imports' must be an array of components, directives, pipes, or NgModules.`)\n                      .toDiagnostic();\n    return {\n      imports: [],\n      diagnostics: [error],\n    };\n  }\n  const diagnostics: ts.Diagnostic[] = [];\n\n  for (const ref of imports) {\n    if (Array.isArray(ref)) {\n      const {imports: childImports, diagnostics: childDiagnostics} =\n          validateAndFlattenComponentImports(ref, expr);\n      flattened.push(...childImports);\n      diagnostics.push(...childDiagnostics);\n    } else if (ref instanceof Reference) {\n      if (isNamedClassDeclaration(ref.node)) {\n        flattened.push(ref as Reference<ClassDeclaration>);\n      } else {\n        diagnostics.push(\n            createValueHasWrongTypeError(\n                ref.getOriginForDiagnostics(expr), ref,\n                `'imports' must be an array of components, directives, pipes, or NgModules.`)\n                .toDiagnostic());\n      }\n    } else if (isLikelyModuleWithProviders(ref)) {\n      let origin = expr;\n      if (ref instanceof SyntheticValue) {\n        // The `ModuleWithProviders` type originated from a foreign function declaration, in which\n        // case the original foreign call is available which is used to get a more accurate origin\n        // node that points at the specific call expression.\n        origin = getOriginNodeForDiagnostics(ref.value.mwpCall, expr);\n      }\n      diagnostics.push(makeDiagnostic(\n          ErrorCode.COMPONENT_UNKNOWN_IMPORT, origin,\n          `'imports' contains a ModuleWithProviders value, likely the result of a 'Module.forRoot()'-style call. ` +\n              `These calls are not used to configure components and are not valid in standalone component imports - ` +\n              `consider importing them in the application bootstrap instead.`));\n    } else {\n      diagnostics.push(\n          createValueHasWrongTypeError(\n              expr, imports,\n              `'imports' must be an array of components, directives, pipes, or NgModules.`)\n              .toDiagnostic());\n    }\n  }\n\n  return {imports: flattened, diagnostics};\n}\n\n/**\n * Inspects `value` to determine if it resembles a `ModuleWithProviders` value. This is an\n * approximation only suitable for error reporting as any resolved object with an `ngModule`\n * key is considered a `ModuleWithProviders`.\n */\nfunction isLikelyModuleWithProviders(value: ResolvedValue):\n    value is SyntheticValue<ResolvedModuleWithProviders>|ResolvedValueMap {\n  if (value instanceof SyntheticValue && isResolvedModuleWithProviders(value)) {\n    // This is a `ModuleWithProviders` as extracted from a foreign function call.\n    return true;\n  }\n\n  if (value instanceof Map && value.has('ngModule')) {\n    // A resolved `Map` with `ngModule` property would have been extracted from locally declared\n    // functions that return a `ModuleWithProviders` object.\n    return true;\n  }\n\n  return false;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileClassMetadata, CompileClassMetadataFn, compileDeclareClassMetadata, compileDeclareInjectableFromMetadata, compileInjectable, createMayBeForwardRefExpression, FactoryTarget, ForwardRefHandling, LiteralExpr, MaybeForwardRefExpression, R3ClassMetadata, R3CompiledExpression, R3DependencyMetadata, R3InjectableMetadata, WrappedNodeExpr,} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {InjectableClassRegistry, isAbstractClassDeclaration} from '../../annotations/common';\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {PartialEvaluator} from '../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult,} from '../../transform';\nimport {checkInheritanceOfInjectable, compileDeclareFactory, CompileFactoryFn, compileNgFactoryDefField, extractClassMetadata, findAngularDecorator, getConstructorDependencies, getValidConstructorDependencies, isAngularCore, toFactoryMetadata, tryUnwrapForwardRef, unwrapConstructorDependencies, validateConstructorDependencies, wrapTypeReference,} from '../common';\n\nexport interface InjectableHandlerData {\n  meta: R3InjectableMetadata;\n  classMetadata: R3ClassMetadata|null;\n  ctorDeps: R3DependencyMetadata[]|'invalid'|null;\n  needsFactory: boolean;\n}\n\n/**\n * Adapts the `compileInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n */\nexport class InjectableDecoratorHandler implements\n    DecoratorHandler<Decorator, InjectableHandlerData, null, unknown> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private isCore: boolean, private strictCtorDeps: boolean,\n      private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder,\n      /**\n       * What to do if the injectable already contains a Éµprov property.\n       *\n       * If true then an error diagnostic is reported.\n       * If false then there is no error and a new Éµprov property is not added.\n       */\n      private errorOnDuplicateProv = true) {}\n\n  readonly precedence = HandlerPrecedence.SHARED;\n  readonly name = InjectableDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'Injectable', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator: decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  analyze(node: ClassDeclaration, decorator: Readonly<Decorator>):\n      AnalysisOutput<InjectableHandlerData> {\n    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n\n    const meta = extractInjectableMetadata(node, decorator, this.reflector);\n    const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n\n    return {\n      analysis: {\n        meta,\n        ctorDeps: extractInjectableCtorDeps(\n            node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore),\n        // Avoid generating multiple factories if a class has\n        // more Angular decorators, apart from Injectable.\n        needsFactory: !decorators ||\n            decorators.every(current => !isAngularCore(current) || current.name === 'Injectable')\n      },\n    };\n  }\n\n  symbol(): null {\n    return null;\n  }\n\n  register(node: ClassDeclaration, analysis: InjectableHandlerData): void {\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.ctorDeps,\n    });\n  }\n\n  resolve(node: ClassDeclaration, analysis: Readonly<InjectableHandlerData>, symbol: null):\n      ResolveResult<unknown> {\n    if (requiresValidCtor(analysis.meta)) {\n      const diagnostic = checkInheritanceOfInjectable(\n          node, this.injectableRegistry, this.reflector, this.evaluator, this.strictCtorDeps,\n          'Injectable');\n      if (diagnostic !== null) {\n        return {\n          diagnostics: [diagnostic],\n        };\n      }\n    }\n\n    return {};\n  }\n\n  compileFull(node: ClassDeclaration, analysis: Readonly<InjectableHandlerData>): CompileResult[] {\n    return this.compile(\n        compileNgFactoryDefField, meta => compileInjectable(meta, false), compileClassMetadata,\n        node, analysis);\n  }\n\n  compilePartial(node: ClassDeclaration, analysis: Readonly<InjectableHandlerData>):\n      CompileResult[] {\n    return this.compile(\n        compileDeclareFactory, compileDeclareInjectableFromMetadata, compileDeclareClassMetadata,\n        node, analysis);\n  }\n\n  private compile(\n      compileFactoryFn: CompileFactoryFn,\n      compileInjectableFn: (meta: R3InjectableMetadata) => R3CompiledExpression,\n      compileClassMetadataFn: CompileClassMetadataFn, node: ClassDeclaration,\n      analysis: Readonly<InjectableHandlerData>): CompileResult[] {\n    const results: CompileResult[] = [];\n\n    if (analysis.needsFactory) {\n      const meta = analysis.meta;\n      const factoryRes = compileFactoryFn(\n          toFactoryMetadata({...meta, deps: analysis.ctorDeps}, FactoryTarget.Injectable));\n      if (analysis.classMetadata !== null) {\n        factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());\n      }\n      results.push(factoryRes);\n    }\n\n    const Éµprov = this.reflector.getMembersOfClass(node).find(member => member.name === 'Éµprov');\n    if (Éµprov !== undefined && this.errorOnDuplicateProv) {\n      throw new FatalDiagnosticError(\n          ErrorCode.INJECTABLE_DUPLICATE_PROV, Éµprov.nameNode || Éµprov.node || node,\n          'Injectables cannot contain a static Éµprov property, because the compiler is going to generate one.');\n    }\n\n    if (Éµprov === undefined) {\n      // Only add a new Éµprov if there is not one already\n      const res = compileInjectableFn(analysis.meta);\n      results.push(\n          {name: 'Éµprov', initializer: res.expression, statements: res.statements, type: res.type});\n    }\n\n    return results;\n  }\n}\n\n/**\n * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the\n * input metadata needed to run `compileInjectable`.\n *\n * A `null` return value indicates this is @Injectable has invalid data.\n */\nfunction extractInjectableMetadata(\n    clazz: ClassDeclaration, decorator: Decorator,\n    reflector: ReflectionHost): R3InjectableMetadata {\n  const name = clazz.name.text;\n  const type = wrapTypeReference(reflector, clazz);\n  const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_NOT_CALLED, decorator.node, '@Injectable must be called');\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      typeArgumentCount,\n      providedIn: createMayBeForwardRefExpression(new LiteralExpr(null), ForwardRefHandling.None),\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to\n    // transport references from one location to another. This is the problem that lowering\n    // used to solve - if this restriction proves too undesirable we can re-implement lowering.\n    if (!ts.isObjectLiteralExpression(metaNode)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode,\n          `@Injectable argument must be an object literal`);\n    }\n\n    // Resolve the fields of the literal into a map of field name to expression.\n    const meta = reflectObjectLiteral(metaNode);\n\n    const providedIn = meta.has('providedIn') ?\n        getProviderExpression(meta.get('providedIn')!, reflector) :\n        createMayBeForwardRefExpression(new LiteralExpr(null), ForwardRefHandling.None);\n\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {\n      const depsExpr = meta.get('deps')!;\n      if (!ts.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(\n            ErrorCode.VALUE_NOT_LITERAL, depsExpr,\n            `@Injectable deps metadata must be an inline array`);\n      }\n      deps = depsExpr.elements.map(dep => getDep(dep, reflector));\n    }\n\n    const result: R3InjectableMetadata = {name, type, typeArgumentCount, providedIn};\n    if (meta.has('useValue')) {\n      result.useValue = getProviderExpression(meta.get('useValue')!, reflector);\n    } else if (meta.has('useExisting')) {\n      result.useExisting = getProviderExpression(meta.get('useExisting')!, reflector);\n    } else if (meta.has('useClass')) {\n      result.useClass = getProviderExpression(meta.get('useClass')!, reflector);\n      result.deps = deps;\n    } else if (meta.has('useFactory')) {\n      result.useFactory = new WrappedNodeExpr(meta.get('useFactory')!);\n      result.deps = deps;\n    }\n    return result;\n  } else {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');\n  }\n}\n\n/**\n * Get the `R3ProviderExpression` for this `expression`.\n *\n * The `useValue`, `useExisting` and `useClass` properties might be wrapped in a `ForwardRef`, which\n * needs to be unwrapped. This function will do that unwrapping and set a flag on the returned\n * object to indicate whether the value needed unwrapping.\n */\nfunction getProviderExpression(\n    expression: ts.Expression, reflector: ReflectionHost): MaybeForwardRefExpression {\n  const forwardRefValue = tryUnwrapForwardRef(expression, reflector);\n  return createMayBeForwardRefExpression(\n      new WrappedNodeExpr(forwardRefValue ?? expression),\n      forwardRefValue !== null ? ForwardRefHandling.Unwrapped : ForwardRefHandling.None);\n}\n\nfunction extractInjectableCtorDeps(\n    clazz: ClassDeclaration, meta: R3InjectableMetadata, decorator: Decorator,\n    reflector: ReflectionHost, isCore: boolean, strictCtorDeps: boolean) {\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_NOT_CALLED, decorator.node, '@Injectable must be called');\n  }\n\n  let ctorDeps: R3DependencyMetadata[]|'invalid'|null = null;\n\n  if (decorator.args.length === 0) {\n    // Ideally, using @Injectable() would have the same effect as using @Injectable({...}), and be\n    // subject to the same validation. However, existing Angular code abuses @Injectable, applying\n    // it to things like abstract classes with constructors that were never meant for use with\n    // Angular's DI.\n    //\n    // To deal with this, @Injectable() without an argument is more lenient, and if the\n    // constructor signature does not work for DI then a factory definition (Éµfac) that throws is\n    // generated.\n    if (strictCtorDeps && !isAbstractClassDeclaration(clazz)) {\n      ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);\n    } else {\n      ctorDeps =\n          unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));\n    }\n\n    return ctorDeps;\n  } else if (decorator.args.length === 1) {\n    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n\n    if (strictCtorDeps && !isAbstractClassDeclaration(clazz) && requiresValidCtor(meta)) {\n      // Since use* was not provided for a concrete class, validate the deps according to\n      // strictCtorDeps.\n      ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n    }\n  }\n\n  return ctorDeps;\n}\n\nfunction requiresValidCtor(meta: R3InjectableMetadata): boolean {\n  return meta.useValue === undefined && meta.useExisting === undefined &&\n      meta.useClass === undefined && meta.useFactory === undefined;\n}\n\nfunction getDep(dep: ts.Expression, reflector: ReflectionHost): R3DependencyMetadata {\n  const meta: R3DependencyMetadata = {\n    token: new WrappedNodeExpr(dep),\n    attributeNameType: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  function maybeUpdateDecorator(\n      dec: ts.Identifier, reflector: ReflectionHost, token?: ts.Expression): boolean {\n    const source = reflector.getImportOfIdentifier(dec);\n    if (source === null || source.from !== '@angular/core') {\n      return false;\n    }\n    switch (source.name) {\n      case 'Inject':\n        if (token !== undefined) {\n          meta.token = new WrappedNodeExpr(token);\n        }\n        break;\n      case 'Optional':\n        meta.optional = true;\n        break;\n      case 'SkipSelf':\n        meta.skipSelf = true;\n        break;\n      case 'Self':\n        meta.self = true;\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n\n  if (ts.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      let isDecorator = false;\n      if (ts.isIdentifier(el)) {\n        isDecorator = maybeUpdateDecorator(el, reflector);\n      } else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;\n        isDecorator = maybeUpdateDecorator(el.expression, reflector, token);\n      }\n      if (!isDecorator) {\n        meta.token = new WrappedNodeExpr(el);\n      }\n    });\n  }\n  return meta;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileClassMetadata, compileDeclareClassMetadata, compileDeclarePipeFromMetadata, compilePipeFromMetadata, FactoryTarget, R3ClassMetadata, R3PipeMetadata, WrappedNodeExpr,} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\nimport {MetadataRegistry, MetaKind} from '../../metadata';\nimport {PartialEvaluator} from '../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\nimport {LocalModuleScopeRegistry} from '../../scope';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult,} from '../../transform';\nimport {compileDeclareFactory, compileNgFactoryDefField, compileResults, createValueHasWrongTypeError, extractClassMetadata, findAngularDecorator, getValidConstructorDependencies, InjectableClassRegistry, makeDuplicateDeclarationError, toFactoryMetadata, unwrapExpression, wrapTypeReference,} from '../common';\n\nexport interface PipeHandlerData {\n  meta: R3PipeMetadata;\n  classMetadata: R3ClassMetadata|null;\n  pipeNameExpr: ts.Expression;\n  decorator: ts.Decorator|null;\n}\n\n/**\n * Represents an Angular pipe.\n */\nexport class PipeSymbol extends SemanticSymbol {\n  constructor(decl: ClassDeclaration, public readonly name: string) {\n    super(decl);\n  }\n\n  override isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof PipeSymbol)) {\n      return true;\n    }\n\n    return this.name !== previousSymbol.name;\n  }\n\n  override isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n    return this.isPublicApiAffected(previousSymbol);\n  }\n}\n\nexport class PipeDecoratorHandler implements\n    DecoratorHandler<Decorator, PipeHandlerData, PipeSymbol, unknown> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n      private injectableRegistry: InjectableClassRegistry, private isCore: boolean,\n      private perf: PerfRecorder) {}\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = PipeDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'Pipe', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator: decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  analyze(clazz: ClassDeclaration, decorator: Readonly<Decorator>):\n      AnalysisOutput<PipeHandlerData> {\n    this.perf.eventCount(PerfEvent.AnalyzePipe);\n\n    const name = clazz.name.text;\n    const type = wrapTypeReference(this.reflector, clazz);\n\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_NOT_CALLED, decorator.node, `@Pipe must be called`);\n    }\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, '@Pipe must have exactly one argument');\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');\n    }\n    const pipe = reflectObjectLiteral(meta);\n\n    if (!pipe.has('name')) {\n      throw new FatalDiagnosticError(\n          ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n    const pipeNameExpr = pipe.get('name')!;\n    const pipeName = this.evaluator.evaluate(pipeNameExpr);\n    if (typeof pipeName !== 'string') {\n      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n    }\n\n    let pure = true;\n    if (pipe.has('pure')) {\n      const expr = pipe.get('pure')!;\n      const pureValue = this.evaluator.evaluate(expr);\n      if (typeof pureValue !== 'boolean') {\n        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n\n    let isStandalone = false;\n    if (pipe.has('standalone')) {\n      const expr = pipe.get('standalone')!;\n      const resolved = this.evaluator.evaluate(expr);\n      if (typeof resolved !== 'boolean') {\n        throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);\n      }\n      isStandalone = resolved;\n    }\n\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n          pipeName,\n          deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n          pure,\n          isStandalone,\n        },\n        classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),\n        pipeNameExpr,\n        decorator: decorator?.node as ts.Decorator | null ?? null,\n      },\n    };\n  }\n\n  symbol(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): PipeSymbol {\n    return new PipeSymbol(node, analysis.meta.pipeName);\n  }\n\n  register(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): void {\n    const ref = new Reference(node);\n    this.metaRegistry.registerPipeMetadata({\n      kind: MetaKind.Pipe,\n      ref,\n      name: analysis.meta.pipeName,\n      nameExpr: analysis.pipeNameExpr,\n      isStandalone: analysis.meta.isStandalone,\n      decorator: analysis.decorator,\n    });\n\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps,\n    });\n  }\n\n  resolve(node: ClassDeclaration): ResolveResult<unknown> {\n    const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n    if (duplicateDeclData !== null) {\n      // This pipe was declared twice (or more).\n      return {\n        diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, 'Pipe')],\n      };\n    }\n\n    return {};\n  }\n\n  compileFull(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): CompileResult[] {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Pipe));\n    const def = compilePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ?\n        compileClassMetadata(analysis.classMetadata).toStmt() :\n        null;\n    return compileResults(fac, def, classMetadata, 'Éµpipe');\n  }\n\n  compilePartial(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): CompileResult[] {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Pipe));\n    const def = compileDeclarePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ?\n        compileDeclareClassMetadata(analysis.classMetadata).toStmt() :\n        null;\n    return compileResults(fac, def, classMetadata, 'Éµpipe');\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ImportGraph} from './imports';\n\n/**\n * Analyzes a `ts.Program` for cycles.\n */\nexport class CycleAnalyzer {\n  /**\n   * Cycle detection is requested with the same `from` source file for all used directives and pipes\n   * within a component, which makes it beneficial to cache the results as long as the `from` source\n   * file has not changed. This avoids visiting the import graph that is reachable from multiple\n   * directives/pipes more than once.\n   */\n  private cachedResults: CycleResults|null = null;\n\n  constructor(private importGraph: ImportGraph) {}\n\n  /**\n   * Check for a cycle to be created in the `ts.Program` by adding an import between `from` and\n   * `to`.\n   *\n   * @returns a `Cycle` object if an import between `from` and `to` would create a cycle; `null`\n   *     otherwise.\n   */\n  wouldCreateCycle(from: ts.SourceFile, to: ts.SourceFile): Cycle|null {\n    // Try to reuse the cached results as long as the `from` source file is the same.\n    if (this.cachedResults === null || this.cachedResults.from !== from) {\n      this.cachedResults = new CycleResults(from, this.importGraph);\n    }\n\n    // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.\n    return this.cachedResults.wouldBeCyclic(to) ? new Cycle(this.importGraph, from, to) : null;\n  }\n\n  /**\n   * Record a synthetic import from `from` to `to`.\n   *\n   * This is an import that doesn't exist in the `ts.Program` but will be considered as part of the\n   * import graph for cycle creation.\n   */\n  recordSyntheticImport(from: ts.SourceFile, to: ts.SourceFile): void {\n    this.cachedResults = null;\n    this.importGraph.addSyntheticImport(from, to);\n  }\n}\n\nconst NgCyclicResult = Symbol('NgCyclicResult');\ntype CyclicResultMarker = {\n  __brand: 'CyclicResultMarker';\n};\ntype CyclicSourceFile = ts.SourceFile&{[NgCyclicResult]?: CyclicResultMarker};\n\n/**\n * Stores the results of cycle detection in a memory efficient manner. A symbol is attached to\n * source files that indicate what the cyclic analysis result is, as indicated by two markers that\n * are unique to this instance. This alleviates memory pressure in large import graphs, as each\n * execution is able to store its results in the same memory location (i.e. in the symbol\n * on the source file) as earlier executions.\n */\nclass CycleResults {\n  private readonly cyclic = {} as CyclicResultMarker;\n  private readonly acyclic = {} as CyclicResultMarker;\n\n  constructor(readonly from: ts.SourceFile, private importGraph: ImportGraph) {}\n\n  wouldBeCyclic(sf: ts.SourceFile): boolean {\n    const cached = this.getCachedResult(sf);\n    if (cached !== null) {\n      // The result for this source file has already been computed, so return its result.\n      return cached;\n    }\n\n    if (sf === this.from) {\n      // We have reached the source file that we want to create an import from, which means that\n      // doing so would create a cycle.\n      return true;\n    }\n\n    // Assume for now that the file will be acyclic; this prevents infinite recursion in the case\n    // that `sf` is visited again as part of an existing cycle in the graph.\n    this.markAcyclic(sf);\n\n    const imports = this.importGraph.importsOf(sf);\n    for (const imported of imports) {\n      if (this.wouldBeCyclic(imported)) {\n        this.markCyclic(sf);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns whether the source file is already known to be cyclic, or `null` if the result is not\n   * yet known.\n   */\n  private getCachedResult(sf: CyclicSourceFile): boolean|null {\n    const result = sf[NgCyclicResult];\n    if (result === this.cyclic) {\n      return true;\n    } else if (result === this.acyclic) {\n      return false;\n    } else {\n      // Either the symbol is missing or its value does not correspond with one of the current\n      // result markers. As such, the result is unknown.\n      return null;\n    }\n  }\n\n  private markCyclic(sf: CyclicSourceFile): void {\n    sf[NgCyclicResult] = this.cyclic;\n  }\n\n  private markAcyclic(sf: CyclicSourceFile): void {\n    sf[NgCyclicResult] = this.acyclic;\n  }\n}\n\n/**\n * Represents an import cycle between `from` and `to` in the program.\n *\n * This class allows us to do the work to compute the cyclic path between `from` and `to` only if\n * needed.\n */\nexport class Cycle {\n  constructor(\n      private importGraph: ImportGraph, readonly from: ts.SourceFile, readonly to: ts.SourceFile) {}\n\n  /**\n   * Compute an array of source-files that illustrates the cyclic path between `from` and `to`.\n   *\n   * Note that a `Cycle` will not be created unless a path is available between `to` and `from`,\n   * so `findPath()` will never return `null`.\n   */\n  getPath(): ts.SourceFile[] {\n    return [this.from, ...this.importGraph.findPath(this.to, this.from)!];\n  }\n}\n\n\n/**\n * What to do if a cycle is detected.\n */\nexport const enum CycleHandlingStrategy {\n  /** Add \"remote scoping\" code to avoid creating a cycle. */\n  UseRemoteScoping,\n  /** Fail the compilation with an error. */\n  Error,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {PerfPhase, PerfRecorder} from '../../perf';\n\n/**\n * A cached graph of imports in the `ts.Program`.\n *\n * The `ImportGraph` keeps track of dependencies (imports) of individual `ts.SourceFile`s. Only\n * dependencies within the same program are tracked; imports into packages on NPM are not.\n */\nexport class ImportGraph {\n  private imports = new Map<ts.SourceFile, Set<ts.SourceFile>>();\n\n  constructor(private checker: ts.TypeChecker, private perf: PerfRecorder) {}\n\n  /**\n   * List the direct (not transitive) imports of a given `ts.SourceFile`.\n   *\n   * This operation is cached.\n   */\n  importsOf(sf: ts.SourceFile): Set<ts.SourceFile> {\n    if (!this.imports.has(sf)) {\n      this.imports.set(sf, this.scanImports(sf));\n    }\n    return this.imports.get(sf)!;\n  }\n\n  /**\n   * Find an import path from the `start` SourceFile to the `end` SourceFile.\n   *\n   * This function implements a breadth first search that results in finding the\n   * shortest path between the `start` and `end` points.\n   *\n   * @param start the starting point of the path.\n   * @param end the ending point of the path.\n   * @returns an array of source files that connect the `start` and `end` source files, or `null` if\n   *     no path could be found.\n   */\n  findPath(start: ts.SourceFile, end: ts.SourceFile): ts.SourceFile[]|null {\n    if (start === end) {\n      // Escape early for the case where `start` and `end` are the same.\n      return [start];\n    }\n\n    const found = new Set<ts.SourceFile>([start]);\n    const queue: Found[] = [new Found(start, null)];\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      const imports = this.importsOf(current.sourceFile);\n      for (const importedFile of imports) {\n        if (!found.has(importedFile)) {\n          const next = new Found(importedFile, current);\n          if (next.sourceFile === end) {\n            // We have hit the target `end` path so we can stop here.\n            return next.toPath();\n          }\n          found.add(importedFile);\n          queue.push(next);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add a record of an import from `sf` to `imported`, that's not present in the original\n   * `ts.Program` but will be remembered by the `ImportGraph`.\n   */\n  addSyntheticImport(sf: ts.SourceFile, imported: ts.SourceFile): void {\n    if (isLocalFile(imported)) {\n      this.importsOf(sf).add(imported);\n    }\n  }\n\n  private scanImports(sf: ts.SourceFile): Set<ts.SourceFile> {\n    return this.perf.inPhase(PerfPhase.CycleDetection, () => {\n      const imports = new Set<ts.SourceFile>();\n      // Look through the source file for import and export statements.\n      for (const stmt of sf.statements) {\n        if ((!ts.isImportDeclaration(stmt) && !ts.isExportDeclaration(stmt)) ||\n            stmt.moduleSpecifier === undefined) {\n          continue;\n        }\n\n        if (ts.isImportDeclaration(stmt) && stmt.importClause !== undefined &&\n            isTypeOnlyImportClause(stmt.importClause)) {\n          // Exclude type-only imports as they are always elided, so they don't contribute to\n          // cycles.\n          continue;\n        }\n\n        const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n          // No symbol could be found to skip over this import/export.\n          continue;\n        }\n        const moduleFile = symbol.valueDeclaration;\n        if (ts.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n          // Record this local import.\n          imports.add(moduleFile);\n        }\n      }\n      return imports;\n    });\n  }\n}\n\nfunction isLocalFile(sf: ts.SourceFile): boolean {\n  return !sf.isDeclarationFile;\n}\n\nfunction isTypeOnlyImportClause(node: ts.ImportClause): boolean {\n  // The clause itself is type-only (e.g. `import type {foo} from '...'`).\n  if (node.isTypeOnly) {\n    return true;\n  }\n\n  // All the specifiers in the cause are type-only (e.g. `import {type a, type b} from '...'`).\n  if (node.namedBindings !== undefined && ts.isNamedImports(node.namedBindings) &&\n      node.namedBindings.elements.every(specifier => specifier.isTypeOnly)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * A helper class to track which SourceFiles are being processed when searching for a path in\n * `getPath()` above.\n */\nclass Found {\n  constructor(readonly sourceFile: ts.SourceFile, readonly parent: Found|null) {}\n\n  /**\n   * Back track through this found SourceFile and its ancestors to generate an array of\n   * SourceFiles that form am import path between two SourceFiles.\n   */\n  toPath(): ts.SourceFile[] {\n    const array: ts.SourceFile[] = [];\n    let current: Found|null = this;\n    while (current !== null) {\n      array.push(current.sourceFile);\n      current = current.parent;\n    }\n    // Pushing and then reversing, O(n), rather than unshifting repeatedly, O(n^2), avoids\n    // manipulating the array on every iteration: https://stackoverflow.com/a/26370620\n    return array.reverse();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"node\" />\n\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath, dirname, join} from '../../file_system';\nimport {TopLevelShimGenerator} from '../../shims/api';\nimport {relativePathBetween} from '../../util/src/path';\n\nexport class FlatIndexGenerator implements TopLevelShimGenerator {\n  readonly flatIndexPath: string;\n  readonly shouldEmit = true;\n\n  constructor(\n      readonly entryPoint: AbsoluteFsPath, relativeFlatIndexPath: string,\n      readonly moduleName: string|null) {\n    this.flatIndexPath =\n        join(dirname(entryPoint), relativeFlatIndexPath).replace(/\\.js$/, '') + '.ts';\n  }\n\n  makeTopLevelShim(): ts.SourceFile {\n    const relativeEntryPoint = relativePathBetween(this.flatIndexPath, this.entryPoint);\n    const contents = `/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from '${relativeEntryPoint}';\n`;\n    const genFile = ts.createSourceFile(\n        this.flatIndexPath, contents, ts.ScriptTarget.ES2015, true, ts.ScriptKind.TS);\n    if (this.moduleName !== null) {\n      genFile.moduleName = this.moduleName;\n    }\n    return genFile;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteFsPath, getFileSystem} from '../../file_system';\nimport {isNonDeclarationTsPath} from '../../util/src/typescript';\n\nexport function findFlatIndexEntryPoint(rootFiles: ReadonlyArray<AbsoluteFsPath>): AbsoluteFsPath|\n    null {\n  // There are two ways for a file to be recognized as the flat module index:\n  // 1) if it's the only file!!!!!!\n  // 2) (deprecated) if it's named 'index.ts' and has the shortest path of all such files.\n  const tsFiles = rootFiles.filter(file => isNonDeclarationTsPath(file));\n  let resolvedEntryPoint: AbsoluteFsPath|null = null;\n\n  if (tsFiles.length === 1) {\n    // There's only one file - this is the flat module index.\n    resolvedEntryPoint = tsFiles[0];\n  } else {\n    // In the event there's more than one TS file, one of them can still be selected as the\n    // flat module index if it's named 'index.ts'. If there's more than one 'index.ts', the one\n    // with the shortest path wins.\n    //\n    // This behavior is DEPRECATED and only exists to support existing usages.\n    for (const tsFile of tsFiles) {\n      if (getFileSystem().basename(tsFile) === 'index.ts' &&\n          (resolvedEntryPoint === null || tsFile.length <= resolvedEntryPoint.length)) {\n        resolvedEntryPoint = tsFile;\n      }\n    }\n  }\n\n  return resolvedEntryPoint;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {DeclarationNode} from '../../reflection';\n\nimport {ReferenceGraph} from './reference_graph';\n\n/**\n * Produce `ts.Diagnostic`s for classes that are visible from exported types (e.g. directives\n * exposed by exported `NgModule`s) that are not themselves exported.\n *\n * This function reconciles two concepts:\n *\n * A class is Exported if it's exported from the main library `entryPoint` file.\n * A class is Visible if, via Angular semantics, a downstream consumer can import an Exported class\n * and be affected by the class in question. For example, an Exported NgModule may expose a\n * directive class to its consumers. Consumers that import the NgModule may have the directive\n * applied to elements in their templates. In this case, the directive is considered Visible.\n *\n * `checkForPrivateExports` attempts to verify that all Visible classes are Exported, and report\n * `ts.Diagnostic`s for those that aren't.\n *\n * @param entryPoint `ts.SourceFile` of the library's entrypoint, which should export the library's\n * public API.\n * @param checker `ts.TypeChecker` for the current program.\n * @param refGraph `ReferenceGraph` tracking the visibility of Angular types.\n * @returns an array of `ts.Diagnostic`s representing errors when visible classes are not exported\n * properly.\n */\nexport function checkForPrivateExports(\n    entryPoint: ts.SourceFile, checker: ts.TypeChecker, refGraph: ReferenceGraph): ts.Diagnostic[] {\n  const diagnostics: ts.Diagnostic[] = [];\n\n  // Firstly, compute the exports of the entry point. These are all the Exported classes.\n  const topLevelExports = new Set<DeclarationNode>();\n\n  // Do this via `ts.TypeChecker.getExportsOfModule`.\n  const moduleSymbol = checker.getSymbolAtLocation(entryPoint);\n  if (moduleSymbol === undefined) {\n    throw new Error(`Internal error: failed to get symbol for entrypoint`);\n  }\n  const exportedSymbols = checker.getExportsOfModule(moduleSymbol);\n\n  // Loop through the exported symbols, de-alias if needed, and add them to `topLevelExports`.\n  // TODO(alxhub): use proper iteration when build.sh is removed. (#27762)\n  exportedSymbols.forEach(symbol => {\n    if (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = checker.getAliasedSymbol(symbol);\n    }\n    const decl = symbol.valueDeclaration;\n    if (decl !== undefined) {\n      topLevelExports.add(decl);\n    }\n  });\n\n  // Next, go through each exported class and expand it to the set of classes it makes Visible,\n  // using the `ReferenceGraph`. For each Visible class, verify that it's also Exported, and queue\n  // an error if it isn't. `checkedSet` ensures only one error is queued per class.\n  const checkedSet = new Set<DeclarationNode>();\n\n  // Loop through each Exported class.\n  // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n  topLevelExports.forEach(mainExport => {\n    // Loop through each class made Visible by the Exported class.\n    refGraph.transitiveReferencesOf(mainExport).forEach(transitiveReference => {\n      // Skip classes which have already been checked.\n      if (checkedSet.has(transitiveReference)) {\n        return;\n      }\n      checkedSet.add(transitiveReference);\n\n      // Verify that the Visible class is also Exported.\n      if (!topLevelExports.has(transitiveReference)) {\n        // This is an error, `mainExport` makes `transitiveReference` Visible, but\n        // `transitiveReference` is not Exported from the entrypoint. Construct a diagnostic to\n        // give to the user explaining the situation.\n\n        const descriptor = getDescriptorOfDeclaration(transitiveReference);\n        const name = getNameOfDeclaration(transitiveReference);\n\n        // Construct the path of visibility, from `mainExport` to `transitiveReference`.\n        let visibleVia = 'NgModule exports';\n        const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);\n        if (transitivePath !== null) {\n          visibleVia = transitivePath.map(seg => getNameOfDeclaration(seg)).join(' -> ');\n        }\n\n        const diagnostic: ts.Diagnostic = {\n          category: ts.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.SYMBOL_NOT_EXPORTED),\n          file: transitiveReference.getSourceFile(),\n          ...getPosOfDeclaration(transitiveReference),\n          messageText: `Unsupported private ${descriptor} ${name}. This ${\n              descriptor} is visible to consumers via ${\n              visibleVia}, but is not exported from the top-level library entrypoint.`,\n        };\n\n        diagnostics.push(diagnostic);\n      }\n    });\n  });\n\n  return diagnostics;\n}\n\nfunction getPosOfDeclaration(decl: DeclarationNode): {start: number, length: number} {\n  const node: ts.Node = getIdentifierOfDeclaration(decl) || decl;\n  return {\n    start: node.getStart(),\n    length: node.getEnd() + 1 - node.getStart(),\n  };\n}\n\nfunction getIdentifierOfDeclaration(decl: DeclarationNode): ts.Identifier|null {\n  if ((ts.isClassDeclaration(decl) || ts.isVariableDeclaration(decl) ||\n       ts.isFunctionDeclaration(decl)) &&\n      decl.name !== undefined && ts.isIdentifier(decl.name)) {\n    return decl.name;\n  } else {\n    return null;\n  }\n}\n\nfunction getNameOfDeclaration(decl: DeclarationNode): string {\n  const id = getIdentifierOfDeclaration(decl);\n  return id !== null ? id.text : '(unnamed)';\n}\n\nfunction getDescriptorOfDeclaration(decl: DeclarationNode): string {\n  switch (decl.kind) {\n    case ts.SyntaxKind.ClassDeclaration:\n      return 'class';\n    case ts.SyntaxKind.FunctionDeclaration:\n      return 'function';\n    case ts.SyntaxKind.VariableDeclaration:\n      return 'variable';\n    case ts.SyntaxKind.EnumDeclaration:\n      return 'enum';\n    default:\n      return 'declaration';\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DeclarationNode} from '../../reflection';\n\nexport class ReferenceGraph<T = DeclarationNode> {\n  private references = new Map<T, Set<T>>();\n\n  add(from: T, to: T): void {\n    if (!this.references.has(from)) {\n      this.references.set(from, new Set());\n    }\n    this.references.get(from)!.add(to);\n  }\n\n  transitiveReferencesOf(target: T): Set<T> {\n    const set = new Set<T>();\n    this.collectTransitiveReferences(set, target);\n    return set;\n  }\n\n  pathFrom(source: T, target: T): T[]|null {\n    return this.collectPathFrom(source, target, new Set());\n  }\n\n  private collectPathFrom(source: T, target: T, seen: Set<T>): T[]|null {\n    if (source === target) {\n      // Looking for a path from the target to itself - that path is just the target. This is the\n      // \"base case\" of the search.\n      return [target];\n    } else if (seen.has(source)) {\n      // The search has already looked through this source before.\n      return null;\n    }\n    // Consider outgoing edges from `source`.\n    seen.add(source);\n\n    if (!this.references.has(source)) {\n      // There are no outgoing edges from `source`.\n      return null;\n    } else {\n      // Look through the outgoing edges of `source`.\n      // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n      let candidatePath: T[]|null = null;\n      this.references.get(source)!.forEach(edge => {\n        // Early exit if a path has already been found.\n        if (candidatePath !== null) {\n          return;\n        }\n        // Look for a path from this outgoing edge to `target`.\n        const partialPath = this.collectPathFrom(edge, target, seen);\n        if (partialPath !== null) {\n          // A path exists from `edge` to `target`. Insert `source` at the beginning.\n          candidatePath = [source, ...partialPath];\n        }\n      });\n\n      return candidatePath;\n    }\n  }\n\n  private collectTransitiveReferences(set: Set<T>, decl: T): void {\n    if (this.references.has(decl)) {\n      // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n      this.references.get(decl)!.forEach(ref => {\n        if (!set.has(ref)) {\n          set.add(ref);\n          this.collectTransitiveReferences(set, ref);\n        }\n      });\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {AbsoluteFsPath} from '../../file_system';\n\nexport interface FileUpdate {\n  /**\n   * The source file text.\n   */\n  newText: string;\n\n  /**\n   * Represents the source file from the original program that is being updated. If the file update\n   * targets a shim file then this is null, as shim files do not have an associated original file.\n   */\n  originalFile: ts.SourceFile|null;\n}\n\nexport const NgOriginalFile = Symbol('NgOriginalFile');\n\n/**\n * If an updated file has an associated original source file, then the original source file\n * is attached to the updated file using the `NgOriginalFile` symbol.\n */\nexport interface MaybeSourceFileWithOriginalFile extends ts.SourceFile {\n  [NgOriginalFile]?: ts.SourceFile;\n}\n\nexport interface ProgramDriver {\n  /**\n   * Whether this strategy supports modifying user files (inline modifications) in addition to\n   * modifying type-checking shims.\n   */\n  readonly supportsInlineOperations: boolean;\n\n  /**\n   * Retrieve the latest version of the program, containing all the updates made thus far.\n   */\n  getProgram(): ts.Program;\n\n  /**\n   * Incorporate a set of changes to either augment or completely replace the type-checking code\n   * included in the type-checking program.\n   */\n  updateFiles(contents: Map<AbsoluteFsPath, FileUpdate>, updateMode: UpdateMode): void;\n\n  /**\n   * Retrieve a string version for a given `ts.SourceFile`, which much change when the contents of\n   * the file have changed.\n   *\n   * If this method is present, the compiler will use these versions in addition to object identity\n   * for `ts.SourceFile`s to determine what's changed between two incremental programs. This is\n   * valuable for some clients (such as the Language Service) that treat `ts.SourceFile`s as mutable\n   * objects.\n   */\n  getSourceFileVersion?(sf: ts.SourceFile): string;\n}\n\nexport enum UpdateMode {\n  /**\n   * A complete update creates a completely new overlay of type-checking code on top of the user's\n   * original program, which doesn't include type-checking code from previous calls to\n   * `updateFiles`.\n   */\n  Complete,\n\n  /**\n   * An incremental update changes the contents of some files in the type-checking program without\n   * reverting any prior changes.\n   */\n  Incremental,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {copyFileShimData, retagAllTsFiles, ShimReferenceTagger, untagAllTsFiles} from '../../shims';\nimport {RequiredDelegations, toUnredirectedSourceFile} from '../../util/src/typescript';\n\nimport {FileUpdate, MaybeSourceFileWithOriginalFile, NgOriginalFile, ProgramDriver, UpdateMode} from './api';\n\n/**\n * Delegates all methods of `ts.CompilerHost` to a delegate, with the exception of\n * `getSourceFile`, `fileExists` and `writeFile` which are implemented in `TypeCheckProgramHost`.\n *\n * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n * generated for this class.\n */\nexport class DelegatingCompilerHost implements\n    Omit<RequiredDelegations<ts.CompilerHost>, 'getSourceFile'|'fileExists'|'writeFile'> {\n  createHash;\n  directoryExists;\n  getCancellationToken;\n  getCanonicalFileName;\n  getCurrentDirectory;\n  getDefaultLibFileName;\n  getDefaultLibLocation;\n  getDirectories;\n  getEnvironmentVariable;\n  getNewLine;\n  getParsedCommandLine;\n  getSourceFileByPath;\n  readDirectory;\n  readFile;\n  realpath;\n  resolveModuleNames;\n  resolveTypeReferenceDirectives;\n  trace;\n  useCaseSensitiveFileNames;\n  getModuleResolutionCache;\n  hasInvalidatedResolutions;\n  resolveModuleNameLiterals;\n  resolveTypeReferenceDirectiveReferences;\n\n  constructor(protected delegate: ts.CompilerHost) {\n    // Excluded are 'getSourceFile', 'fileExists' and 'writeFile', which are actually implemented by\n    // `TypeCheckProgramHost` below.\n\n    this.createHash = this.delegateMethod('createHash');\n    this.directoryExists = this.delegateMethod('directoryExists');\n    this.getCancellationToken = this.delegateMethod('getCancellationToken');\n    this.getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n    this.getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n    this.getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n    this.getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n    this.getDirectories = this.delegateMethod('getDirectories');\n    this.getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n    this.getNewLine = this.delegateMethod('getNewLine');\n    this.getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n    this.getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n    this.readDirectory = this.delegateMethod('readDirectory');\n    this.readFile = this.delegateMethod('readFile');\n    this.realpath = this.delegateMethod('realpath');\n    this.resolveModuleNames = this.delegateMethod('resolveModuleNames');\n    this.resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n    this.trace = this.delegateMethod('trace');\n    this.useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n    this.getModuleResolutionCache = this.delegateMethod('getModuleResolutionCache');\n    this.hasInvalidatedResolutions = this.delegateMethod('hasInvalidatedResolutions');\n    // The following methods are required in TS 5.0+, but they don't exist in earlier versions.\n    // TODO(crisbeto): remove the `ts-ignore` when dropping support for TypeScript 4.9.\n    // @ts-ignore\n    this.resolveModuleNameLiterals = this.delegateMethod('resolveModuleNameLiterals');\n    this.resolveTypeReferenceDirectiveReferences =\n        // @ts-ignore\n        this.delegateMethod('resolveTypeReferenceDirectiveReferences');\n  }\n\n  private delegateMethod<M extends keyof ts.CompilerHost>(name: M): ts.CompilerHost[M] {\n    return this.delegate[name] !== undefined ? (this.delegate[name] as any).bind(this.delegate) :\n                                               undefined;\n  }\n}\n\n/**\n * A `ts.CompilerHost` which augments source files.\n */\nclass UpdatedProgramHost extends DelegatingCompilerHost {\n  /**\n   * Map of source file names to `ts.SourceFile` instances.\n   */\n  private sfMap: Map<string, ts.SourceFile>;\n\n  /**\n   * The `ShimReferenceTagger` responsible for tagging `ts.SourceFile`s loaded via this host.\n   *\n   * The `UpdatedProgramHost` is used in the creation of a new `ts.Program`. Even though this new\n   * program is based on a prior one, TypeScript will still start from the root files and enumerate\n   * all source files to include in the new program.  This means that just like during the original\n   * program's creation, these source files must be tagged with references to per-file shims in\n   * order for those shims to be loaded, and then cleaned up afterwards. Thus the\n   * `UpdatedProgramHost` has its own `ShimReferenceTagger` to perform this function.\n   */\n  private shimTagger: ShimReferenceTagger;\n\n  constructor(\n      sfMap: Map<string, ts.SourceFile>, private originalProgram: ts.Program,\n      delegate: ts.CompilerHost, private shimExtensionPrefixes: string[]) {\n    super(delegate);\n    this.shimTagger = new ShimReferenceTagger(this.shimExtensionPrefixes);\n    this.sfMap = sfMap;\n  }\n\n  getSourceFile(\n      fileName: string, languageVersion: ts.ScriptTarget,\n      onError?: ((message: string) => void)|undefined,\n      shouldCreateNewSourceFile?: boolean|undefined): ts.SourceFile|undefined {\n    // Try to use the same `ts.SourceFile` as the original program, if possible. This guarantees\n    // that program reuse will be as efficient as possible.\n    let delegateSf: ts.SourceFile|undefined = this.originalProgram.getSourceFile(fileName);\n    if (delegateSf === undefined) {\n      // Something went wrong and a source file is being requested that's not in the original\n      // program. Just in case, try to retrieve it from the delegate.\n      delegateSf = this.delegate.getSourceFile(\n          fileName, languageVersion, onError, shouldCreateNewSourceFile)!;\n    }\n    if (delegateSf === undefined) {\n      return undefined;\n    }\n\n    // Look for replacements.\n    let sf: ts.SourceFile;\n    if (this.sfMap.has(fileName)) {\n      sf = this.sfMap.get(fileName)!;\n      copyFileShimData(delegateSf, sf);\n    } else {\n      sf = delegateSf;\n    }\n    // TypeScript doesn't allow returning redirect source files. To avoid unforeseen errors we\n    // return the original source file instead of the redirect target.\n    sf = toUnredirectedSourceFile(sf);\n\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n\n  postProgramCreationCleanup(): void {\n    this.shimTagger.finalize();\n  }\n\n  writeFile(): never {\n    throw new Error(`TypeCheckProgramHost should never write files`);\n  }\n\n  fileExists(fileName: string): boolean {\n    return this.sfMap.has(fileName) || this.delegate.fileExists(fileName);\n  }\n}\n\n\n/**\n * Updates a `ts.Program` instance with a new one that incorporates specific changes, using the\n * TypeScript compiler APIs for incremental program creation.\n */\nexport class TsCreateProgramDriver implements ProgramDriver {\n  /**\n   * A map of source file paths to replacement `ts.SourceFile`s for those paths.\n   *\n   * Effectively, this tracks the delta between the user's program (represented by the\n   * `originalHost`) and the template type-checking program being managed.\n   */\n  private sfMap = new Map<string, ts.SourceFile>();\n\n  private program: ts.Program;\n\n  constructor(\n      private originalProgram: ts.Program, private originalHost: ts.CompilerHost,\n      private options: ts.CompilerOptions, private shimExtensionPrefixes: string[]) {\n    this.program = this.originalProgram;\n  }\n\n  readonly supportsInlineOperations = true;\n\n  getProgram(): ts.Program {\n    return this.program;\n  }\n\n  updateFiles(contents: Map<AbsoluteFsPath, FileUpdate>, updateMode: UpdateMode): void {\n    if (contents.size === 0) {\n      // No changes have been requested. Is it safe to skip updating entirely?\n      // If UpdateMode is Incremental, then yes. If UpdateMode is Complete, then it's safe to skip\n      // only if there are no active changes already (that would be cleared by the update).\n\n      if (updateMode !== UpdateMode.Complete || this.sfMap.size === 0) {\n        // No changes would be made to the `ts.Program` anyway, so it's safe to do nothing here.\n        return;\n      }\n    }\n\n    if (updateMode === UpdateMode.Complete) {\n      this.sfMap.clear();\n    }\n\n    for (const [filePath, {newText, originalFile}] of contents.entries()) {\n      const sf = ts.createSourceFile(filePath, newText, ts.ScriptTarget.Latest, true);\n      if (originalFile !== null) {\n        (sf as MaybeSourceFileWithOriginalFile)[NgOriginalFile] = originalFile;\n      }\n      this.sfMap.set(filePath, sf);\n    }\n\n    const host = new UpdatedProgramHost(\n        this.sfMap, this.originalProgram, this.originalHost, this.shimExtensionPrefixes);\n    const oldProgram = this.program;\n\n    // Retag the old program's `ts.SourceFile`s with shim tags, to allow TypeScript to reuse the\n    // most data.\n    retagAllTsFiles(oldProgram);\n\n    this.program = ts.createProgram({\n      host,\n      rootNames: this.program.getRootFileNames(),\n      options: this.options,\n      oldProgram,\n    });\n    host.postProgramCreationCleanup();\n\n    // And untag them afterwards. We explicitly untag both programs here, because the oldProgram\n    // may still be used for emit and needs to not contain tags.\n    untagAllTsFiles(this.program);\n    untagAllTsFiles(oldProgram);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {isDtsPath} from '../../util/src/typescript';\nimport {PerFileShimGenerator, TopLevelShimGenerator} from '../api';\n\nimport {isFileShimSourceFile, isShim, sfExtensionData} from './expando';\nimport {makeShimFileName} from './util';\n\ninterface ShimGeneratorData {\n  generator: PerFileShimGenerator;\n  test: RegExp;\n  suffix: string;\n}\n\n/**\n * Generates and tracks shim files for each original `ts.SourceFile`.\n *\n * The `ShimAdapter` provides an API that's designed to be used by a `ts.CompilerHost`\n * implementation and allows it to include synthetic \"shim\" files in the program that's being\n * created. It works for both freshly created programs as well as with reuse of an older program\n * (which already may contain shim files and thus have a different creation flow).\n */\nexport class ShimAdapter {\n  /**\n   * A map of shim file names to the `ts.SourceFile` generated for those shims.\n   */\n  private shims = new Map<AbsoluteFsPath, ts.SourceFile>();\n\n  /**\n   * A map of shim file names to existing shims which were part of a previous iteration of this\n   * program.\n   *\n   * Not all of these shims will be inherited into this program.\n   */\n  private priorShims = new Map<AbsoluteFsPath, ts.SourceFile>();\n\n  /**\n   * File names which are already known to not be shims.\n   *\n   * This allows for short-circuit returns without the expense of running regular expressions\n   * against the filename repeatedly.\n   */\n  private notShims = new Set<AbsoluteFsPath>();\n\n  /**\n   * The shim generators supported by this adapter as well as extra precalculated data facilitating\n   * their use.\n   */\n  private generators: ShimGeneratorData[] = [];\n\n  /**\n   * A `Set` of shim `ts.SourceFile`s which should not be emitted.\n   */\n  readonly ignoreForEmit = new Set<ts.SourceFile>();\n\n  /**\n   * A list of extra filenames which should be considered inputs to program creation.\n   *\n   * This includes any top-level shims generated for the program, as well as per-file shim names for\n   * those files which are included in the root files of the program.\n   */\n  readonly extraInputFiles: ReadonlyArray<AbsoluteFsPath>;\n\n  /**\n   * Extension prefixes of all installed per-file shims.\n   */\n  readonly extensionPrefixes: string[] = [];\n\n  constructor(\n      private delegate: Pick<ts.CompilerHost, 'getSourceFile'|'fileExists'>,\n      tsRootFiles: AbsoluteFsPath[], topLevelGenerators: TopLevelShimGenerator[],\n      perFileGenerators: PerFileShimGenerator[], oldProgram: ts.Program|null) {\n    // Initialize `this.generators` with a regex that matches each generator's paths.\n    for (const gen of perFileGenerators) {\n      // This regex matches paths for shims from this generator. The first (and only) capture group\n      // extracts the filename prefix, which can be used to find the original file that was used to\n      // generate this shim.\n      const pattern = `^(.*)\\\\.${gen.extensionPrefix}\\\\.ts$`;\n      const regexp = new RegExp(pattern, 'i');\n      this.generators.push({\n        generator: gen,\n        test: regexp,\n        suffix: `.${gen.extensionPrefix}.ts`,\n      });\n      this.extensionPrefixes.push(gen.extensionPrefix);\n    }\n    // Process top-level generators and pre-generate their shims. Accumulate the list of filenames\n    // as extra input files.\n    const extraInputFiles: AbsoluteFsPath[] = [];\n\n    for (const gen of topLevelGenerators) {\n      const sf = gen.makeTopLevelShim();\n      sfExtensionData(sf).isTopLevelShim = true;\n\n      if (!gen.shouldEmit) {\n        this.ignoreForEmit.add(sf);\n      }\n\n      const fileName = absoluteFromSourceFile(sf);\n      this.shims.set(fileName, sf);\n      extraInputFiles.push(fileName);\n    }\n\n    // Add to that list the per-file shims associated with each root file. This is needed because\n    // reference tagging alone may not work in TS compilations that have `noResolve` set. Such\n    // compilations rely on the list of input files completely describing the program.\n    for (const rootFile of tsRootFiles) {\n      for (const gen of this.generators) {\n        extraInputFiles.push(makeShimFileName(rootFile, gen.suffix));\n      }\n    }\n\n    this.extraInputFiles = extraInputFiles;\n\n    // If an old program is present, extract all per-file shims into a map, which will be used to\n    // generate new versions of those shims.\n    if (oldProgram !== null) {\n      for (const oldSf of oldProgram.getSourceFiles()) {\n        if (oldSf.isDeclarationFile || !isFileShimSourceFile(oldSf)) {\n          continue;\n        }\n\n        this.priorShims.set(absoluteFromSourceFile(oldSf), oldSf);\n      }\n    }\n  }\n\n  /**\n   * Produce a shim `ts.SourceFile` if `fileName` refers to a shim file which should exist in the\n   * program.\n   *\n   * If `fileName` does not refer to a potential shim file, `null` is returned. If a corresponding\n   * base file could not be determined, `undefined` is returned instead.\n   */\n  maybeGenerate(fileName: AbsoluteFsPath): ts.SourceFile|null|undefined {\n    // Fast path: either this filename has been proven not to be a shim before, or it is a known\n    // shim and no generation is required.\n    if (this.notShims.has(fileName)) {\n      return null;\n    } else if (this.shims.has(fileName)) {\n      return this.shims.get(fileName)!;\n    }\n\n    // .d.ts files can't be shims.\n    if (isDtsPath(fileName)) {\n      this.notShims.add(fileName);\n      return null;\n    }\n\n    // This is the first time seeing this path. Try to match it against a shim generator.\n    for (const record of this.generators) {\n      const match = record.test.exec(fileName);\n      if (match === null) {\n        continue;\n      }\n\n      // The path matched. Extract the filename prefix without the extension.\n      const prefix = match[1];\n      // This _might_ be a shim, if an underlying base file exists. The base file might be .ts or\n      // .tsx.\n      let baseFileName = absoluteFrom(prefix + '.ts');\n      // Retrieve the original file for which the shim will be generated.\n      let inputFile = this.delegate.getSourceFile(baseFileName, ts.ScriptTarget.Latest);\n      if (inputFile === undefined) {\n        // No .ts file by that name - try .tsx.\n        baseFileName = absoluteFrom(prefix + '.tsx');\n        inputFile = this.delegate.getSourceFile(baseFileName, ts.ScriptTarget.Latest);\n      }\n      if (inputFile === undefined || isShim(inputFile)) {\n        // This isn't a shim after all since there is no original file which would have triggered\n        // its generation, even though the path is right. There are a few reasons why this could\n        // occur:\n        //\n        // * when resolving an import to an .ngfactory.d.ts file, the module resolution algorithm\n        //   will first look for an .ngfactory.ts file in its place, which will be requested here.\n        // * when the user writes a bad import.\n        // * when a file is present in one compilation and removed in the next incremental step.\n        //\n        // Note that this does not add the filename to `notShims`, so this path is not cached.\n        // That's okay as these cases above are edge cases and do not occur regularly in normal\n        // operations.\n        return undefined;\n      }\n\n      // Actually generate and cache the shim.\n      return this.generateSpecific(fileName, record.generator, inputFile);\n    }\n\n    // No generator matched.\n    this.notShims.add(fileName);\n    return null;\n  }\n\n  private generateSpecific(\n      fileName: AbsoluteFsPath, generator: PerFileShimGenerator,\n      inputFile: ts.SourceFile): ts.SourceFile {\n    let priorShimSf: ts.SourceFile|null = null;\n    if (this.priorShims.has(fileName)) {\n      // In the previous program a shim with this name already existed. It's passed to the shim\n      // generator which may reuse it instead of generating a fresh shim.\n\n      priorShimSf = this.priorShims.get(fileName)!;\n      this.priorShims.delete(fileName);\n    }\n\n    const shimSf = generator.generateShimForFile(inputFile, fileName, priorShimSf);\n\n    // Mark the new generated source file as a shim that originated from this generator.\n    sfExtensionData(shimSf).fileShim = {\n      extension: generator.extensionPrefix,\n      generatedFrom: absoluteFromSourceFile(inputFile),\n    };\n\n    if (!generator.shouldEmit) {\n      this.ignoreForEmit.add(shimSf);\n    }\n\n    this.shims.set(fileName, shimSf);\n    return shimSf;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\n\n/**\n * A `Symbol` which is used to patch extension data onto `ts.SourceFile`s.\n */\nexport const NgExtension = Symbol('NgExtension');\n\n/**\n * Contents of the `NgExtension` property of a `ts.SourceFile`.\n */\nexport interface NgExtensionData {\n  isTopLevelShim: boolean;\n  fileShim: NgFileShimData|null;\n\n  /**\n   * The contents of the `referencedFiles` array, before modification by a `ShimReferenceTagger`.\n   */\n  originalReferencedFiles: ReadonlyArray<ts.FileReference>|null;\n\n  /**\n   * The contents of the `referencedFiles` array, after modification by a `ShimReferenceTagger`.\n   */\n  taggedReferenceFiles: ReadonlyArray<ts.FileReference>|null;\n}\n\n/**\n * A `ts.SourceFile` which may or may not have `NgExtension` data.\n */\ninterface MaybeNgExtendedSourceFile extends ts.SourceFile {\n  [NgExtension]?: NgExtensionData;\n}\n\n/**\n * A `ts.SourceFile` which has `NgExtension` data.\n */\nexport interface NgExtendedSourceFile extends ts.SourceFile {\n  /**\n   * Overrides the type of `referencedFiles` to be writeable.\n   */\n  referencedFiles: ts.FileReference[];\n\n  [NgExtension]: NgExtensionData;\n}\n\n/**\n * Narrows a `ts.SourceFile` if it has an `NgExtension` property.\n */\nexport function isExtended(sf: ts.SourceFile): sf is NgExtendedSourceFile {\n  return (sf as MaybeNgExtendedSourceFile)[NgExtension] !== undefined;\n}\n\n/**\n * Returns the `NgExtensionData` for a given `ts.SourceFile`, adding it if none exists.\n */\nexport function sfExtensionData(sf: ts.SourceFile): NgExtensionData {\n  const extSf = sf as MaybeNgExtendedSourceFile;\n  if (extSf[NgExtension] !== undefined) {\n    // The file already has extension data, so return it directly.\n    return extSf[NgExtension]!;\n  }\n\n  // The file has no existing extension data, so add it and return it.\n  const extension: NgExtensionData = {\n    isTopLevelShim: false,\n    fileShim: null,\n    originalReferencedFiles: null,\n    taggedReferenceFiles: null,\n  };\n  extSf[NgExtension] = extension;\n  return extension;\n}\n\n/**\n * Data associated with a per-shim instance `ts.SourceFile`.\n */\nexport interface NgFileShimData {\n  generatedFrom: AbsoluteFsPath;\n  extension: string;\n}\n\n/**\n * An `NgExtendedSourceFile` that is a per-file shim and has `NgFileShimData`.\n */\nexport interface NgFileShimSourceFile extends NgExtendedSourceFile {\n  [NgExtension]: NgExtensionData&{\n    fileShim: NgFileShimData,\n  };\n}\n\n/**\n * Check whether `sf` is a per-file shim `ts.SourceFile`.\n */\nexport function isFileShimSourceFile(sf: ts.SourceFile): sf is NgFileShimSourceFile {\n  return isExtended(sf) && sf[NgExtension].fileShim !== null;\n}\n\n/**\n * Check whether `sf` is a shim `ts.SourceFile` (either a per-file shim or a top-level shim).\n */\nexport function isShim(sf: ts.SourceFile): boolean {\n  return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);\n}\n\n/**\n * Copy any shim data from one `ts.SourceFile` to another.\n */\nexport function copyFileShimData(from: ts.SourceFile, to: ts.SourceFile): void {\n  if (!isFileShimSourceFile(from)) {\n    return;\n  }\n  sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;\n}\n\n/**\n * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n * `ShimReferenceTagger`, restore the original `referencedFiles` array that does not have shim tags.\n */\nexport function untagAllTsFiles(program: ts.Program): void {\n  for (const sf of program.getSourceFiles()) {\n    untagTsFile(sf);\n  }\n}\n\n/**\n * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n * `ShimReferenceTagger`, re-apply the effects of tagging by updating the `referencedFiles` array to\n * the tagged version produced previously.\n */\nexport function retagAllTsFiles(program: ts.Program): void {\n  for (const sf of program.getSourceFiles()) {\n    retagTsFile(sf);\n  }\n}\n\n/**\n * Restore the original `referencedFiles` for the given `ts.SourceFile`.\n */\nexport function untagTsFile(sf: ts.SourceFile): void {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n\n  const ext = sfExtensionData(sf);\n  if (ext.originalReferencedFiles !== null) {\n    sf.referencedFiles = ext.originalReferencedFiles as Array<ts.FileReference>;\n  }\n}\n\n/**\n * Apply the previously tagged `referencedFiles` to the given `ts.SourceFile`, if it was previously\n * tagged.\n */\nexport function retagTsFile(sf: ts.SourceFile): void {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n\n  const ext = sfExtensionData(sf);\n  if (ext.taggedReferenceFiles !== null) {\n    sf.referencedFiles = ext.taggedReferenceFiles as Array<ts.FileReference>;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {absoluteFrom, AbsoluteFsPath} from '../../file_system';\n\nconst TS_EXTENSIONS = /\\.tsx?$/i;\n\n/**\n * Replace the .ts or .tsx extension of a file with the shim filename suffix.\n */\nexport function makeShimFileName(fileName: AbsoluteFsPath, suffix: string): AbsoluteFsPath {\n  return absoluteFrom(fileName.replace(TS_EXTENSIONS, suffix));\n}\n\nexport function generatedModuleName(\n    originalModuleName: string, originalFileName: string, genSuffix: string): string {\n  let moduleName: string;\n  if (originalFileName.endsWith('/index.ts')) {\n    moduleName = originalModuleName + '/index' + genSuffix;\n  } else {\n    moduleName = originalModuleName + genSuffix;\n  }\n\n  return moduleName;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {absoluteFromSourceFile} from '../../file_system';\nimport {isNonDeclarationTsPath} from '../../util/src/typescript';\n\nimport {isShim, sfExtensionData} from './expando';\nimport {makeShimFileName} from './util';\n\n/**\n * Manipulates the `referencedFiles` property of `ts.SourceFile`s to add references to shim files\n * for each original source file, causing the shims to be loaded into the program as well.\n *\n * `ShimReferenceTagger`s are intended to operate during program creation only.\n */\nexport class ShimReferenceTagger {\n  private suffixes: string[];\n\n  /**\n   * Tracks which original files have been processed and had shims generated if necessary.\n   *\n   * This is used to avoid generating shims twice for the same file.\n   */\n  private tagged = new Set<ts.SourceFile>();\n\n  /**\n   * Whether shim tagging is currently being performed.\n   */\n  private enabled: boolean = true;\n\n  constructor(shimExtensions: string[]) {\n    this.suffixes = shimExtensions.map(extension => `.${extension}.ts`);\n  }\n\n  /**\n   * Tag `sf` with any needed references if it's not a shim itself.\n   */\n  tag(sf: ts.SourceFile): void {\n    if (!this.enabled || sf.isDeclarationFile || isShim(sf) || this.tagged.has(sf) ||\n        !isNonDeclarationTsPath(sf.fileName)) {\n      return;\n    }\n\n    const ext = sfExtensionData(sf);\n\n    // If this file has never been tagged before, capture its `referencedFiles` in the extension\n    // data.\n    if (ext.originalReferencedFiles === null) {\n      ext.originalReferencedFiles = sf.referencedFiles;\n    }\n\n    const referencedFiles = [...ext.originalReferencedFiles];\n\n\n    const sfPath = absoluteFromSourceFile(sf);\n    for (const suffix of this.suffixes) {\n      referencedFiles.push({\n        fileName: makeShimFileName(sfPath, suffix),\n        pos: 0,\n        end: 0,\n      });\n    }\n\n    ext.taggedReferenceFiles = referencedFiles;\n    sf.referencedFiles = referencedFiles;\n    this.tagged.add(sf);\n  }\n\n  /**\n   * Disable the `ShimReferenceTagger` and free memory associated with tracking tagged files.\n   */\n  finalize(): void {\n    this.enabled = false;\n    this.tagged.clear();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {DependencyTracker} from '../api';\n\n/**\n * An implementation of the `DependencyTracker` dependency graph API.\n *\n * The `FileDependencyGraph`'s primary job is to determine whether a given file has \"logically\"\n * changed, given the set of physical changes (direct changes to files on disk).\n *\n * A file is logically changed if at least one of three conditions is met:\n *\n * 1. The file itself has physically changed.\n * 2. One of its dependencies has physically changed.\n * 3. One of its resource dependencies has physically changed.\n */\nexport class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> implements\n    DependencyTracker<T> {\n  private nodes = new Map<T, FileNode>();\n\n  addDependency(from: T, on: T): void {\n    this.nodeFor(from).dependsOn.add(absoluteFromSourceFile(on));\n  }\n\n  addResourceDependency(from: T, resource: AbsoluteFsPath): void {\n    this.nodeFor(from).usesResources.add(resource);\n  }\n\n  recordDependencyAnalysisFailure(file: T): void {\n    this.nodeFor(file).failedAnalysis = true;\n  }\n\n  getResourceDependencies(from: T): AbsoluteFsPath[] {\n    const node = this.nodes.get(from);\n\n    return node ? [...node.usesResources] : [];\n  }\n\n  /**\n   * Update the current dependency graph from a previous one, incorporating a set of physical\n   * changes.\n   *\n   * This method performs two tasks:\n   *\n   * 1. For files which have not logically changed, their dependencies from `previous` are added to\n   *    `this` graph.\n   * 2. For files which have logically changed, they're added to a set of logically changed files\n   *    which is eventually returned.\n   *\n   * In essence, for build `n`, this method performs:\n   *\n   * G(n) + L(n) = G(n - 1) + P(n)\n   *\n   * where:\n   *\n   * G(n) = the dependency graph of build `n`\n   * L(n) = the logically changed files from build n - 1 to build n.\n   * P(n) = the physically changed files from build n - 1 to build n.\n   */\n  updateWithPhysicalChanges(\n      previous: FileDependencyGraph<T>, changedTsPaths: Set<AbsoluteFsPath>,\n      deletedTsPaths: Set<AbsoluteFsPath>,\n      changedResources: Set<AbsoluteFsPath>): Set<AbsoluteFsPath> {\n    const logicallyChanged = new Set<AbsoluteFsPath>();\n\n    for (const sf of previous.nodes.keys()) {\n      const sfPath = absoluteFromSourceFile(sf);\n      const node = previous.nodeFor(sf);\n      if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {\n        logicallyChanged.add(sfPath);\n      } else if (!deletedTsPaths.has(sfPath)) {\n        this.nodes.set(sf, {\n          dependsOn: new Set(node.dependsOn),\n          usesResources: new Set(node.usesResources),\n          failedAnalysis: false,\n        });\n      }\n    }\n\n    return logicallyChanged;\n  }\n\n  private nodeFor(sf: T): FileNode {\n    if (!this.nodes.has(sf)) {\n      this.nodes.set(sf, {\n        dependsOn: new Set<AbsoluteFsPath>(),\n        usesResources: new Set<AbsoluteFsPath>(),\n        failedAnalysis: false,\n      });\n    }\n    return this.nodes.get(sf)!;\n  }\n}\n\n/**\n * Determine whether `sf` has logically changed, given its dependencies and the set of physically\n * changed files and resources.\n */\nfunction isLogicallyChanged<T extends {fileName: string}>(\n    sf: T, node: FileNode, changedTsPaths: ReadonlySet<AbsoluteFsPath>,\n    deletedTsPaths: ReadonlySet<AbsoluteFsPath>,\n    changedResources: ReadonlySet<AbsoluteFsPath>): boolean {\n  // A file is assumed to have logically changed if its dependencies could not be determined\n  // accurately.\n  if (node.failedAnalysis) {\n    return true;\n  }\n\n  const sfPath = absoluteFromSourceFile(sf);\n\n  // A file is logically changed if it has physically changed itself (including being deleted).\n  if (changedTsPaths.has(sfPath) || deletedTsPaths.has(sfPath)) {\n    return true;\n  }\n\n  // A file is logically changed if one of its dependencies has physically changed.\n  for (const dep of node.dependsOn) {\n    if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {\n      return true;\n    }\n  }\n\n  // A file is logically changed if one of its resources has physically changed.\n  for (const dep of node.usesResources) {\n    if (changedResources.has(dep)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface FileNode {\n  dependsOn: Set<AbsoluteFsPath>;\n  usesResources: Set<AbsoluteFsPath>;\n  failedAnalysis: boolean;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {ClassRecord} from '../../transform';\nimport {FileTypeCheckingData} from '../../typecheck/src/checker';\nimport {SemanticDepGraph} from '../semantic_graph';\n\nimport {FileDependencyGraph} from './dependency_tracking';\n\n/**\n * Discriminant of the `IncrementalState` union.\n */\nexport enum IncrementalStateKind {\n  Fresh,\n  Delta,\n  Analyzed,\n}\n\n/**\n * Placeholder state for a fresh compilation that has never been successfully analyzed.\n */\nexport interface FreshIncrementalState {\n  kind: IncrementalStateKind.Fresh;\n}\n\n/**\n * State captured from a compilation that completed analysis successfully, that can serve as a\n * starting point for a future incremental build.\n */\nexport interface AnalyzedIncrementalState {\n  kind: IncrementalStateKind.Analyzed;\n\n  /**\n   * Dependency graph extracted from the build, to be used to determine the logical impact of\n   * physical file changes.\n   */\n  depGraph: FileDependencyGraph;\n\n  /**\n   * The semantic dependency graph from the build.\n   *\n   * This is used to perform in-depth comparison of Angular decorated classes, to determine\n   * which files have to be re-emitted and/or re-type-checked.\n   */\n  semanticDepGraph: SemanticDepGraph;\n\n  /**\n   * The analysis data from a prior compilation. This stores the trait information for all source\n   * files that was present in a prior compilation.\n   */\n  priorAnalysis: Map<ts.SourceFile, ClassRecord[]>;\n\n  /**\n   * All generated template type-checking files produced as part of this compilation, or `null` if\n   * type-checking was not (yet) performed.\n   */\n  typeCheckResults: Map<AbsoluteFsPath, FileTypeCheckingData>|null;\n\n  /**\n   * Cumulative set of source file paths which were definitively emitted by this compilation or\n   * carried forward from a prior one.\n   */\n  emitted: Set<AbsoluteFsPath>;\n\n  /**\n   * Map of source file paths to the version of this file as seen in the compilation.\n   */\n  versions: Map<AbsoluteFsPath, string>|null;\n}\n\n/**\n * Incremental state for a compilation that has not been successfully analyzed, but that can be\n * based on a previous compilation which was.\n *\n * This is the state produced by an incremental compilation until its own analysis succeeds. If\n * analysis fails, this state carries forward information about which files have changed since the\n * last successful build (the `lastAnalyzedState`), so that the next incremental build can consider\n * the total delta between the `lastAnalyzedState` and the current program in its incremental\n * analysis.\n */\nexport interface DeltaIncrementalState {\n  kind: IncrementalStateKind.Delta;\n\n  /**\n   * If available, the `AnalyzedIncrementalState` for the most recent ancestor of the current\n   * program which was successfully analyzed.\n   */\n  lastAnalyzedState: AnalyzedIncrementalState;\n\n  /**\n   * Set of file paths which have changed since the `lastAnalyzedState` compilation.\n   */\n  physicallyChangedTsFiles: Set<AbsoluteFsPath>;\n\n  /**\n   * Set of resource file paths which have changed since the `lastAnalyzedState` compilation.\n   */\n  changedResourceFiles: Set<AbsoluteFsPath>;\n}\n\n/**\n * State produced by a compilation that's usable as the starting point for a subsequent compilation.\n *\n * Discriminated by the `IncrementalStateKind` enum.\n */\nexport type IncrementalState = AnalyzedIncrementalState|DeltaIncrementalState|FreshIncrementalState;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath, resolve} from '../../file_system';\nimport {PerfPhase, PerfRecorder} from '../../perf';\nimport {MaybeSourceFileWithOriginalFile, NgOriginalFile} from '../../program_driver';\nimport {ClassRecord, TraitCompiler} from '../../transform';\nimport {FileTypeCheckingData} from '../../typecheck';\nimport {toUnredirectedSourceFile} from '../../util/src/typescript';\nimport {IncrementalBuild} from '../api';\nimport {SemanticDepGraphUpdater} from '../semantic_graph';\n\nimport {FileDependencyGraph} from './dependency_tracking';\nimport {AnalyzedIncrementalState, DeltaIncrementalState, IncrementalState, IncrementalStateKind} from './state';\n\n/**\n * Information about the previous compilation being used as a starting point for the current one,\n * including the delta of files which have logically changed and need to be reanalyzed.\n */\ninterface IncrementalStep {\n  priorState: AnalyzedIncrementalState;\n  logicallyChangedTsFiles: Set<AbsoluteFsPath>;\n}\n\n/**\n * Discriminant of the `Phase` type union.\n */\nenum PhaseKind {\n  Analysis,\n  TypeCheckAndEmit,\n}\n\n/**\n * An incremental compilation undergoing analysis, and building a semantic dependency graph.\n */\ninterface AnalysisPhase {\n  kind: PhaseKind.Analysis;\n  semanticDepGraphUpdater: SemanticDepGraphUpdater;\n}\n\n/**\n * An incremental compilation that completed analysis and is undergoing template type-checking and\n * emit.\n */\ninterface TypeCheckAndEmitPhase {\n  kind: PhaseKind.TypeCheckAndEmit;\n  needsEmit: Set<AbsoluteFsPath>;\n  needsTypeCheckEmit: Set<AbsoluteFsPath>;\n}\n\n/**\n * Represents the current phase of a compilation.\n */\ntype Phase = AnalysisPhase|TypeCheckAndEmitPhase;\n\n/**\n * Manages the incremental portion of an Angular compilation, allowing for reuse of a prior\n * compilation if available, and producing an output state for reuse of the current compilation in a\n * future one.\n */\nexport class IncrementalCompilation implements IncrementalBuild<ClassRecord, FileTypeCheckingData> {\n  private phase: Phase;\n\n  /**\n   * `IncrementalState` of this compilation if it were to be reused in a subsequent incremental\n   * compilation at the current moment.\n   *\n   * Exposed via the `state` read-only getter.\n   */\n  private _state: IncrementalState;\n\n  private constructor(\n      state: IncrementalState, readonly depGraph: FileDependencyGraph,\n      private versions: Map<AbsoluteFsPath, string>|null, private step: IncrementalStep|null) {\n    this._state = state;\n\n    // The compilation begins in analysis phase.\n    this.phase = {\n      kind: PhaseKind.Analysis,\n      semanticDepGraphUpdater:\n          new SemanticDepGraphUpdater(step !== null ? step.priorState.semanticDepGraph : null),\n    };\n  }\n\n  /**\n   * Begin a fresh `IncrementalCompilation`.\n   */\n  static fresh(program: ts.Program, versions: Map<AbsoluteFsPath, string>|null):\n      IncrementalCompilation {\n    const state: IncrementalState = {\n      kind: IncrementalStateKind.Fresh,\n    };\n    return new IncrementalCompilation(state, new FileDependencyGraph(), versions, /* reuse */ null);\n  }\n\n  static incremental(\n      program: ts.Program, newVersions: Map<AbsoluteFsPath, string>|null, oldProgram: ts.Program,\n      oldState: IncrementalState, modifiedResourceFiles: Set<AbsoluteFsPath>|null,\n      perf: PerfRecorder): IncrementalCompilation {\n    return perf.inPhase(PerfPhase.Reconciliation, () => {\n      const physicallyChangedTsFiles = new Set<AbsoluteFsPath>();\n      const changedResourceFiles = new Set<AbsoluteFsPath>(modifiedResourceFiles ?? []);\n\n\n      let priorAnalysis: AnalyzedIncrementalState;\n      switch (oldState.kind) {\n        case IncrementalStateKind.Fresh:\n          // Since this line of program has never been successfully analyzed to begin with, treat\n          // this as a fresh compilation.\n          return IncrementalCompilation.fresh(program, newVersions);\n        case IncrementalStateKind.Analyzed:\n          // The most recent program was analyzed successfully, so we can use that as our prior\n          // state and don't need to consider any other deltas except changes in the most recent\n          // program.\n          priorAnalysis = oldState;\n          break;\n        case IncrementalStateKind.Delta:\n          // There is an ancestor program which was analyzed successfully and can be used as a\n          // starting point, but we need to determine what's changed since that program.\n          priorAnalysis = oldState.lastAnalyzedState;\n          for (const sfPath of oldState.physicallyChangedTsFiles) {\n            physicallyChangedTsFiles.add(sfPath);\n          }\n          for (const resourcePath of oldState.changedResourceFiles) {\n            changedResourceFiles.add(resourcePath);\n          }\n          break;\n      }\n\n      const oldVersions = priorAnalysis.versions;\n\n      const oldFilesArray = oldProgram.getSourceFiles().map(toOriginalSourceFile);\n      const oldFiles = new Set(oldFilesArray);\n      const deletedTsFiles = new Set(oldFilesArray.map(sf => absoluteFromSourceFile(sf)));\n\n      for (const possiblyRedirectedNewFile of program.getSourceFiles()) {\n        const sf = toOriginalSourceFile(possiblyRedirectedNewFile);\n        const sfPath = absoluteFromSourceFile(sf);\n        // Since we're seeing a file in the incoming program with this name, it can't have been\n        // deleted.\n        deletedTsFiles.delete(sfPath);\n\n        if (oldFiles.has(sf)) {\n          // This source file has the same object identity as in the previous program. We need to\n          // determine if it's really the same file, or if it might have changed versions since the\n          // last program without changing its identity.\n\n          // If there's no version information available, then this is the same file, and we can\n          // skip it.\n          if (oldVersions === null || newVersions === null) {\n            continue;\n          }\n\n          // If a version is available for the file from both the prior and the current program, and\n          // that version is the same, then this is the same file, and we can skip it.\n          if (oldVersions.has(sfPath) && newVersions.has(sfPath) &&\n              oldVersions.get(sfPath)! === newVersions.get(sfPath)!) {\n            continue;\n          }\n\n          // Otherwise, assume that the file has changed. Either its versions didn't match, or we\n          // were missing version information about it on one side for some reason.\n        }\n\n        // Bail out if a .d.ts file changes - the semantic dep graph is not able to process such\n        // changes correctly yet.\n        if (sf.isDeclarationFile) {\n          return IncrementalCompilation.fresh(program, newVersions);\n        }\n\n        // The file has changed physically, so record it.\n        physicallyChangedTsFiles.add(sfPath);\n      }\n\n      // Remove any files that have been deleted from the list of physical changes.\n      for (const deletedFileName of deletedTsFiles) {\n        physicallyChangedTsFiles.delete(resolve(deletedFileName));\n      }\n\n      // Use the prior dependency graph to project physical changes into a set of logically changed\n      // files.\n      const depGraph = new FileDependencyGraph();\n      const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(\n          priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles);\n\n      // Physically changed files aren't necessarily counted as logically changed by the dependency\n      // graph (files do not have edges to themselves), so add them to the logical changes\n      // explicitly.\n      for (const sfPath of physicallyChangedTsFiles) {\n        logicallyChangedTsFiles.add(sfPath);\n      }\n\n      // Start off in a `DeltaIncrementalState` as a delta against the previous successful analysis,\n      // until this compilation completes its own analysis.\n      const state: DeltaIncrementalState = {\n        kind: IncrementalStateKind.Delta,\n        physicallyChangedTsFiles,\n        changedResourceFiles,\n        lastAnalyzedState: priorAnalysis,\n      };\n\n      return new IncrementalCompilation(state, depGraph, newVersions, {\n        priorState: priorAnalysis,\n        logicallyChangedTsFiles,\n      });\n    });\n  }\n\n  get state(): IncrementalState {\n    return this._state;\n  }\n\n  get semanticDepGraphUpdater(): SemanticDepGraphUpdater {\n    if (this.phase.kind !== PhaseKind.Analysis) {\n      throw new Error(\n          `AssertionError: Cannot update the SemanticDepGraph after analysis completes`);\n    }\n    return this.phase.semanticDepGraphUpdater;\n  }\n\n  recordSuccessfulAnalysis(traitCompiler: TraitCompiler): void {\n    if (this.phase.kind !== PhaseKind.Analysis) {\n      throw new Error(`AssertionError: Incremental compilation in phase ${\n          PhaseKind[this.phase.kind]}, expected Analysis`);\n    }\n\n    const {needsEmit, needsTypeCheckEmit, newGraph} = this.phase.semanticDepGraphUpdater.finalize();\n\n    // Determine the set of files which have already been emitted.\n    let emitted: Set<AbsoluteFsPath>;\n    if (this.step === null) {\n      // Since there is no prior compilation, no files have yet been emitted.\n      emitted = new Set();\n    } else {\n      // Begin with the files emitted by the prior successful compilation, but remove those which we\n      // know need to bee re-emitted.\n      emitted = new Set(this.step.priorState.emitted);\n\n      // Files need re-emitted if they've logically changed.\n      for (const sfPath of this.step.logicallyChangedTsFiles) {\n        emitted.delete(sfPath);\n      }\n\n      // Files need re-emitted if they've semantically changed.\n      for (const sfPath of needsEmit) {\n        emitted.delete(sfPath);\n      }\n    }\n\n    // Transition to a successfully analyzed compilation. At this point, a subsequent compilation\n    // could use this state as a starting point.\n    this._state = {\n      kind: IncrementalStateKind.Analyzed,\n      versions: this.versions,\n      depGraph: this.depGraph,\n      semanticDepGraph: newGraph,\n      priorAnalysis: traitCompiler.getAnalyzedRecords(),\n      typeCheckResults: null,\n      emitted,\n    };\n\n    // We now enter the type-check and emit phase of compilation.\n    this.phase = {\n      kind: PhaseKind.TypeCheckAndEmit,\n      needsEmit,\n      needsTypeCheckEmit,\n    };\n  }\n\n  recordSuccessfulTypeCheck(results: Map<AbsoluteFsPath, FileTypeCheckingData>): void {\n    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    } else if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Incremental compilation in phase ${\n          PhaseKind[this.phase.kind]}, expected TypeCheck`);\n    }\n\n    this._state.typeCheckResults = results;\n  }\n\n\n  recordSuccessfulEmit(sf: ts.SourceFile): void {\n    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    }\n    this._state.emitted.add(absoluteFromSourceFile(sf));\n  }\n\n  priorAnalysisFor(sf: ts.SourceFile): ClassRecord[]|null {\n    if (this.step === null) {\n      return null;\n    }\n\n    const sfPath = absoluteFromSourceFile(sf);\n\n    // If the file has logically changed, its previous analysis cannot be reused.\n    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n      return null;\n    }\n\n    const priorAnalysis = this.step.priorState.priorAnalysis;\n    if (!priorAnalysis.has(sf)) {\n      return null;\n    }\n    return priorAnalysis.get(sf)!;\n  }\n\n  priorTypeCheckingResultsFor(sf: ts.SourceFile): FileTypeCheckingData|null {\n    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    }\n\n    if (this.step === null) {\n      return null;\n    }\n\n    const sfPath = absoluteFromSourceFile(sf);\n\n    // If the file has logically changed, or its template type-checking results have semantically\n    // changed, then past type-checking results cannot be reused.\n    if (this.step.logicallyChangedTsFiles.has(sfPath) ||\n        this.phase.needsTypeCheckEmit.has(sfPath)) {\n      return null;\n    }\n\n    // Past results also cannot be reused if they're not available.\n    if (this.step.priorState.typeCheckResults === null ||\n        !this.step.priorState.typeCheckResults.has(sfPath)) {\n      return null;\n    }\n\n    const priorResults = this.step.priorState.typeCheckResults.get(sfPath)!;\n    // If the past results relied on inlining, they're not safe for reuse.\n    if (priorResults.hasInlines) {\n      return null;\n    }\n\n    return priorResults;\n  }\n\n  safeToSkipEmit(sf: ts.SourceFile): boolean {\n    // If this is a fresh compilation, it's never safe to skip an emit.\n    if (this.step === null) {\n      return false;\n    }\n\n    const sfPath = absoluteFromSourceFile(sf);\n\n    // If the file has itself logically changed, it must be emitted.\n    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n      return false;\n    }\n\n    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(\n          `AssertionError: Expected successful analysis before attempting to emit files`);\n    }\n\n    // If during analysis it was determined that this file has semantically changed, it must be\n    // emitted.\n    if (this.phase.needsEmit.has(sfPath)) {\n      return false;\n    }\n\n    // Generally it should be safe to assume here that the file was previously emitted by the last\n    // successful compilation. However, as a defense-in-depth against incorrectness, we explicitly\n    // check that the last emit included this file, and re-emit it otherwise.\n    return this.step.priorState.emitted.has(sfPath);\n  }\n}\n\n/**\n * To accurately detect whether a source file was affected during an incremental rebuild, the\n * \"original\" source file needs to be consistently used.\n *\n * First, TypeScript may have created source file redirects when declaration files of the same\n * version of a library are included multiple times. The non-redirected source file should be used\n * to detect changes, as otherwise the redirected source files cause a mismatch when compared to\n * a prior program.\n *\n * Second, the program that is used for template type checking may contain mutated source files, if\n * inline type constructors or inline template type-check blocks had to be used. Such source files\n * store their original, non-mutated source file from the original program in a symbol. For\n * computing the affected files in an incremental build this original source file should be used, as\n * the mutated source file would always be considered affected.\n */\nfunction toOriginalSourceFile(sf: ts.SourceFile): ts.SourceFile {\n  const unredirectedSf = toUnredirectedSourceFile(sf);\n  const originalFile = (unredirectedSf as MaybeSourceFileWithOriginalFile)[NgOriginalFile];\n  if (originalFile !== undefined) {\n    return originalFile;\n  } else {\n    return unredirectedSf;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {IncrementalState} from './state';\n\n/**\n * Strategy used to manage the association between a `ts.Program` and the `IncrementalState` which\n * represents the reusable Angular part of its compilation.\n */\nexport interface IncrementalBuildStrategy {\n  /**\n   * Determine the Angular `IncrementalState` for the given `ts.Program`, if one is available.\n   */\n  getIncrementalState(program: ts.Program): IncrementalState|null;\n\n  /**\n   * Associate the given `IncrementalState` with the given `ts.Program` and make it available to\n   * future compilations.\n   */\n  setIncrementalState(driver: IncrementalState, program: ts.Program): void;\n\n  /**\n   * Convert this `IncrementalBuildStrategy` into a possibly new instance to be used in the next\n   * incremental compilation (may be a no-op if the strategy is not stateful).\n   */\n  toNextBuildStrategy(): IncrementalBuildStrategy;\n}\n\n/**\n * A noop implementation of `IncrementalBuildStrategy` which neither returns nor tracks any\n * incremental data.\n */\nexport class NoopIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  getIncrementalState(): null {\n    return null;\n  }\n\n  setIncrementalState(): void {}\n\n  toNextBuildStrategy(): IncrementalBuildStrategy {\n    return this;\n  }\n}\n\n/**\n * Tracks an `IncrementalState` within the strategy itself.\n */\nexport class TrackedIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  private state: IncrementalState|null = null;\n  private isSet: boolean = false;\n\n  getIncrementalState(): IncrementalState|null {\n    return this.state;\n  }\n\n  setIncrementalState(state: IncrementalState): void {\n    this.state = state;\n    this.isSet = true;\n  }\n\n  toNextBuildStrategy(): TrackedIncrementalBuildStrategy {\n    const strategy = new TrackedIncrementalBuildStrategy();\n    // Only reuse state that was explicitly set via `setIncrementalState`.\n    strategy.state = this.isSet ? this.state : null;\n    return strategy;\n  }\n}\n\n/**\n * Manages the `IncrementalState` associated with a `ts.Program` by monkey-patching it onto the\n * program under `SYM_INCREMENTAL_STATE`.\n */\nexport class PatchedProgramIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  getIncrementalState(program: ts.Program): IncrementalState|null {\n    const state = (program as MayHaveIncrementalState)[SYM_INCREMENTAL_STATE];\n    if (state === undefined) {\n      return null;\n    }\n    return state;\n  }\n\n  setIncrementalState(state: IncrementalState, program: ts.Program): void {\n    (program as MayHaveIncrementalState)[SYM_INCREMENTAL_STATE] = state;\n  }\n\n  toNextBuildStrategy(): IncrementalBuildStrategy {\n    return this;\n  }\n}\n\n\n/**\n * Symbol under which the `IncrementalState` is stored on a `ts.Program`.\n *\n * The TS model of incremental compilation is based around reuse of a previous `ts.Program` in the\n * construction of a new one. The `NgCompiler` follows this abstraction - passing in a previous\n * `ts.Program` is sufficient to trigger incremental compilation. This previous `ts.Program` need\n * not be from an Angular compilation (that is, it need not have been created from `NgCompiler`).\n *\n * If it is, though, Angular can benefit from reusing previous analysis work. This reuse is managed\n * by the `IncrementalState`, which is inherited from the old program to the new program. To\n * support this behind the API of passing an old `ts.Program`, the `IncrementalState` is stored on\n * the `ts.Program` under this symbol.\n */\nconst SYM_INCREMENTAL_STATE = Symbol('NgIncrementalState');\n\ninterface MayHaveIncrementalState {\n  [SYM_INCREMENTAL_STATE]?: IncrementalState;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceFile} from '@angular/compiler';\n\nimport {ClassDeclaration, DeclarationNode} from '../../reflection';\n\n/**\n * Describes the kind of identifier found in a template.\n */\nexport enum IdentifierKind {\n  Property,\n  Method,  // TODO: No longer being used. To be removed together with `MethodIdentifier`.\n  Element,\n  Template,\n  Attribute,\n  Reference,\n  Variable,\n}\n\n/**\n * Describes a semantically-interesting identifier in a template, such as an interpolated variable\n * or selector.\n */\nexport interface TemplateIdentifier {\n  name: string;\n  span: AbsoluteSourceSpan;\n  kind: IdentifierKind;\n}\n\n/** Describes a template expression, which may have a template reference or variable target. */\ninterface ExpressionIdentifier extends TemplateIdentifier {\n  /**\n   * ReferenceIdentifier or VariableIdentifier in the template that this identifier targets, if\n   * any. If the target is `null`, it points to a declaration on the component class.\n   * */\n  target: ReferenceIdentifier|VariableIdentifier|null;\n}\n\n/** Describes a property accessed in a template. */\nexport interface PropertyIdentifier extends ExpressionIdentifier {\n  kind: IdentifierKind.Property;\n}\n\n/**\n * Describes a method accessed in a template.\n * @deprecated No longer being used. To be removed.\n */\nexport interface MethodIdentifier extends ExpressionIdentifier {\n  kind: IdentifierKind.Method;\n}\n\n/** Describes an element attribute in a template. */\nexport interface AttributeIdentifier extends TemplateIdentifier {\n  kind: IdentifierKind.Attribute;\n}\n\n/** A reference to a directive node and its selector. */\ninterface DirectiveReference {\n  node: ClassDeclaration;\n  selector: string;\n}\n/** A base interface for element and template identifiers. */\ninterface BaseElementOrTemplateIdentifier extends TemplateIdentifier {\n  /** Attributes on an element or template. */\n  attributes: Set<AttributeIdentifier>;\n\n  /** Directives applied to an element or template. */\n  usedDirectives: Set<DirectiveReference>;\n}\n/**\n * Describes an indexed element in a template. The name of an `ElementIdentifier` is the entire\n * element tag, which can be parsed by an indexer to determine where used directives should be\n * referenced.\n */\nexport interface ElementIdentifier extends BaseElementOrTemplateIdentifier {\n  kind: IdentifierKind.Element;\n}\n\n/** Describes an indexed template node in a component template file. */\nexport interface TemplateNodeIdentifier extends BaseElementOrTemplateIdentifier {\n  kind: IdentifierKind.Template;\n}\n\n/** Describes a reference in a template like \"foo\" in `<div #foo></div>`. */\nexport interface ReferenceIdentifier extends TemplateIdentifier {\n  kind: IdentifierKind.Reference;\n\n  /** The target of this reference. If the target is not known, this is `null`. */\n  target: {\n    /** The template AST node that the reference targets. */\n    node: ElementIdentifier|TemplateIdentifier;\n\n    /**\n     * The directive on `node` that the reference targets. If no directive is targeted, this is\n     * `null`.\n     */\n    directive: ClassDeclaration | null;\n  }|null;\n}\n\n/** Describes a template variable like \"foo\" in `<div *ngFor=\"let foo of foos\"></div>`. */\nexport interface VariableIdentifier extends TemplateIdentifier {\n  kind: IdentifierKind.Variable;\n}\n\n/**\n * Identifiers recorded at the top level of the template, without any context about the HTML nodes\n * they were discovered in.\n */\nexport type TopLevelIdentifier = PropertyIdentifier|ElementIdentifier|TemplateNodeIdentifier|\n    ReferenceIdentifier|VariableIdentifier|MethodIdentifier;\n\n/**\n * Describes the absolute byte offsets of a text anchor in a source code.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public start: number, public end: number) {}\n}\n\n/**\n * Describes an analyzed, indexed component and its template.\n */\nexport interface IndexedComponent {\n  name: string;\n  selector: string|null;\n  file: ParseSourceFile;\n  template: {\n    identifiers: Set<TopLevelIdentifier>,\n    usedComponents: Set<DeclarationNode>,\n    isInline: boolean,\n    file: ParseSourceFile;\n  };\n  errors: Error[];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BoundTarget, DirectiveMeta, ParseSourceFile} from '@angular/compiler';\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nexport interface ComponentMeta extends DirectiveMeta {\n  ref: Reference<ClassDeclaration>;\n  /**\n   * Unparsed selector of the directive, or null if the directive does not have a selector.\n   */\n  selector: string|null;\n}\n\n/**\n * An intermediate representation of a component.\n */\nexport interface ComponentInfo {\n  /** Component TypeScript class declaration */\n  declaration: ClassDeclaration;\n\n  /** Component template selector if it exists, otherwise null. */\n  selector: string|null;\n\n  /**\n   * BoundTarget containing the parsed template. Can also be used to query for directives used in\n   * the template.\n   */\n  boundTemplate: BoundTarget<ComponentMeta>;\n\n  /** Metadata about the template */\n  templateMeta: {\n    /** Whether the component template is inline */\n    isInline: boolean;\n\n    /** Template file recorded by template parser */\n    file: ParseSourceFile;\n  };\n}\n\n/**\n * A context for storing indexing information about components of a program.\n *\n * An `IndexingContext` collects component and template analysis information from\n * `DecoratorHandler`s and exposes them to be indexed.\n */\nexport class IndexingContext {\n  readonly components = new Set<ComponentInfo>();\n\n  /**\n   * Adds a component to the context.\n   */\n  addComponent(info: ComponentInfo) {\n    this.components.add(info);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AST, ASTWithSource, BoundTarget, ImplicitReceiver, ParseSourceSpan, PropertyRead, PropertyWrite, RecursiveAstVisitor, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n\nimport {ClassDeclaration, DeclarationNode} from '../../reflection';\n\nimport {AbsoluteSourceSpan, AttributeIdentifier, ElementIdentifier, IdentifierKind, MethodIdentifier, PropertyIdentifier, ReferenceIdentifier, TemplateNodeIdentifier, TopLevelIdentifier, VariableIdentifier} from './api';\nimport {ComponentMeta} from './context';\n\n/**\n * A parsed node in a template, which may have a name (if it is a selector) or\n * be anonymous (like a text span).\n */\ninterface HTMLNode extends TmplAstNode {\n  tagName?: string;\n  name?: string;\n}\n\ntype ExpressionIdentifier = PropertyIdentifier|MethodIdentifier;\ntype TmplTarget = TmplAstReference|TmplAstVariable;\ntype TargetIdentifier = ReferenceIdentifier|VariableIdentifier;\ntype TargetIdentifierMap = Map<TmplTarget, TargetIdentifier>;\n\n/**\n * Visits the AST of an Angular template syntax expression, finding interesting\n * entities (variable references, etc.). Creates an array of Entities found in\n * the expression, with the location of the Entities being relative to the\n * expression.\n *\n * Visiting `text {{prop}}` will return\n * `[TopLevelIdentifier {name: 'prop', span: {start: 7, end: 11}}]`.\n */\nclass ExpressionVisitor extends RecursiveAstVisitor {\n  readonly identifiers: ExpressionIdentifier[] = [];\n  readonly errors: Error[] = [];\n\n  private constructor(\n      private readonly expressionStr: string, private readonly absoluteOffset: number,\n      private readonly boundTemplate: BoundTarget<ComponentMeta>,\n      private readonly targetToIdentifier: (target: TmplTarget) => TargetIdentifier | null) {\n    super();\n  }\n\n  /**\n   * Returns identifiers discovered in an expression.\n   *\n   * @param ast expression AST to visit\n   * @param source expression AST source code\n   * @param absoluteOffset absolute byte offset from start of the file to the start of the AST\n   * source code.\n   * @param boundTemplate bound target of the entire template, which can be used to query for the\n   * entities expressions target.\n   * @param targetToIdentifier closure converting a template target node to its identifier.\n   */\n  static getIdentifiers(\n      ast: AST, source: string, absoluteOffset: number, boundTemplate: BoundTarget<ComponentMeta>,\n      targetToIdentifier: (target: TmplTarget) => TargetIdentifier |\n          null): {identifiers: TopLevelIdentifier[], errors: Error[]} {\n    const visitor =\n        new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);\n    visitor.visit(ast);\n    return {identifiers: visitor.identifiers, errors: visitor.errors};\n  }\n\n  override visit(ast: AST) {\n    ast.visit(this);\n  }\n\n  override visitPropertyRead(ast: PropertyRead, context: {}) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyRead(ast, context);\n  }\n\n  override visitPropertyWrite(ast: PropertyWrite, context: {}) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyWrite(ast, context);\n  }\n\n  /**\n   * Visits an identifier, adding it to the identifier store if it is useful for indexing.\n   *\n   * @param ast expression AST the identifier is in\n   * @param kind identifier kind\n   */\n  private visitIdentifier(\n      ast: AST&{name: string, receiver: AST}, kind: ExpressionIdentifier['kind']) {\n    // The definition of a non-top-level property such as `bar` in `{{foo.bar}}` is currently\n    // impossible to determine by an indexer and unsupported by the indexing module.\n    // The indexing module also does not currently support references to identifiers declared in the\n    // template itself, which have a non-null expression target.\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    // The source span of the requested AST starts at a location that is offset from the expression.\n    let identifierStart = ast.sourceSpan.start - this.absoluteOffset;\n\n    if (ast instanceof PropertyRead || ast instanceof PropertyWrite) {\n      // For `PropertyRead` and `PropertyWrite`, the identifier starts at the `nameSpan`, not\n      // necessarily the `sourceSpan`.\n      identifierStart = ast.nameSpan.start - this.absoluteOffset;\n    }\n\n    if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {\n      this.errors.push(new Error(`Impossible state: \"${ast.name}\" not found in \"${\n          this.expressionStr}\" at location ${identifierStart}`));\n      return;\n    }\n\n    // Join the relative position of the expression within a node with the absolute position\n    // of the node to get the absolute position of the expression in the source code.\n    const absoluteStart = this.absoluteOffset + identifierStart;\n    const span = new AbsoluteSourceSpan(absoluteStart, absoluteStart + ast.name.length);\n\n    const targetAst = this.boundTemplate.getExpressionTarget(ast);\n    const target = targetAst ? this.targetToIdentifier(targetAst) : null;\n    const identifier = {\n      name: ast.name,\n      span,\n      kind,\n      target,\n    } as ExpressionIdentifier;\n\n    this.identifiers.push(identifier);\n  }\n}\n\n/**\n * Visits the AST of a parsed Angular template. Discovers and stores\n * identifiers of interest, deferring to an `ExpressionVisitor` as needed.\n */\nclass TemplateVisitor extends TmplAstRecursiveVisitor {\n  // Identifiers of interest found in the template.\n  readonly identifiers = new Set<TopLevelIdentifier>();\n  readonly errors: Error[] = [];\n\n  // Map of targets in a template to their identifiers.\n  private readonly targetIdentifierCache: TargetIdentifierMap = new Map();\n\n  // Map of elements and templates to their identifiers.\n  private readonly elementAndTemplateIdentifierCache =\n      new Map<TmplAstElement|TmplAstTemplate, ElementIdentifier|TemplateNodeIdentifier>();\n\n  /**\n   * Creates a template visitor for a bound template target. The bound target can be used when\n   * deferred to the expression visitor to get information about the target of an expression.\n   *\n   * @param boundTemplate bound template target\n   */\n  constructor(private boundTemplate: BoundTarget<ComponentMeta>) {\n    super();\n  }\n\n  /**\n   * Visits a node in the template.\n   *\n   * @param node node to visit\n   */\n  visit(node: HTMLNode) {\n    node.visit(this);\n  }\n\n  visitAll(nodes: TmplAstNode[]) {\n    nodes.forEach(node => this.visit(node));\n  }\n\n  /**\n   * Add an identifier for an HTML element and visit its children recursively.\n   *\n   * @param element\n   */\n  override visitElement(element: TmplAstElement) {\n    const elementIdentifier = this.elementOrTemplateToIdentifier(element);\n    if (elementIdentifier !== null) {\n      this.identifiers.add(elementIdentifier);\n    }\n\n\n    this.visitAll(element.references);\n    this.visitAll(element.inputs);\n    this.visitAll(element.attributes);\n    this.visitAll(element.children);\n    this.visitAll(element.outputs);\n  }\n  override visitTemplate(template: TmplAstTemplate) {\n    const templateIdentifier = this.elementOrTemplateToIdentifier(template);\n\n    if (templateIdentifier !== null) {\n      this.identifiers.add(templateIdentifier);\n    }\n\n    this.visitAll(template.variables);\n    this.visitAll(template.attributes);\n    this.visitAll(template.templateAttrs);\n    this.visitAll(template.children);\n    this.visitAll(template.references);\n  }\n  override visitBoundAttribute(attribute: TmplAstBoundAttribute) {\n    // If the bound attribute has no value, it cannot have any identifiers in the value expression.\n    if (attribute.valueSpan === undefined) {\n      return;\n    }\n\n    const {identifiers, errors} = ExpressionVisitor.getIdentifiers(\n        attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset,\n        this.boundTemplate, this.targetToIdentifier.bind(this));\n    identifiers.forEach(id => this.identifiers.add(id));\n    this.errors.push(...errors);\n  }\n  override visitBoundEvent(attribute: TmplAstBoundEvent) {\n    this.visitExpression(attribute.handler);\n  }\n  override visitBoundText(text: TmplAstBoundText) {\n    this.visitExpression(text.value);\n  }\n  override visitReference(reference: TmplAstReference) {\n    const referenceIdentifier = this.targetToIdentifier(reference);\n    if (referenceIdentifier === null) {\n      return;\n    }\n\n    this.identifiers.add(referenceIdentifier);\n  }\n  override visitVariable(variable: TmplAstVariable) {\n    const variableIdentifier = this.targetToIdentifier(variable);\n    if (variableIdentifier === null) {\n      return;\n    }\n\n    this.identifiers.add(variableIdentifier);\n  }\n\n  /** Creates an identifier for a template element or template node. */\n  private elementOrTemplateToIdentifier(node: TmplAstElement|TmplAstTemplate): ElementIdentifier\n      |TemplateNodeIdentifier|null {\n    // If this node has already been seen, return the cached result.\n    if (this.elementAndTemplateIdentifierCache.has(node)) {\n      return this.elementAndTemplateIdentifierCache.get(node)!;\n    }\n\n    let name: string;\n    let kind: IdentifierKind.Element|IdentifierKind.Template;\n    if (node instanceof TmplAstTemplate) {\n      name = node.tagName ?? 'ng-template';\n      kind = IdentifierKind.Template;\n    } else {\n      name = node.name;\n      kind = IdentifierKind.Element;\n    }\n    // Namespaced elements have a particular format for `node.name` that needs to be handled.\n    // For example, an `<svg>` element has a `node.name` of `':svg:svg'`.\n    // TODO(alxhub): properly handle namespaced elements\n    if (name.startsWith(':')) {\n      name = name.split(':').pop()!;\n    }\n\n    const sourceSpan = node.startSourceSpan;\n    // An element's or template's source span can be of the form `<element>`, `<element />`, or\n    // `<element></element>`. Only the selector is interesting to the indexer, so the source is\n    // searched for the first occurrence of the element (selector) name.\n    const start = this.getStartLocation(name, sourceSpan);\n    if (start === null) {\n      return null;\n    }\n    const absoluteSpan = new AbsoluteSourceSpan(start, start + name.length);\n\n    // Record the nodes's attributes, which an indexer can later traverse to see if any of them\n    // specify a used directive on the node.\n    const attributes = node.attributes.map(({name, sourceSpan}): AttributeIdentifier => {\n      return {\n        name,\n        span: new AbsoluteSourceSpan(sourceSpan.start.offset, sourceSpan.end.offset),\n        kind: IdentifierKind.Attribute,\n      };\n    });\n    const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];\n\n    const identifier = {\n      name,\n      span: absoluteSpan,\n      kind,\n      attributes: new Set(attributes),\n      usedDirectives: new Set(usedDirectives.map(dir => {\n        return {\n          node: dir.ref.node,\n          selector: dir.selector,\n        };\n      })),\n      // cast b/c pre-TypeScript 3.5 unions aren't well discriminated\n    } as ElementIdentifier |\n        TemplateNodeIdentifier;\n\n    this.elementAndTemplateIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n\n  /** Creates an identifier for a template reference or template variable target. */\n  private targetToIdentifier(node: TmplAstReference|TmplAstVariable): TargetIdentifier|null {\n    // If this node has already been seen, return the cached result.\n    if (this.targetIdentifierCache.has(node)) {\n      return this.targetIdentifierCache.get(node)!;\n    }\n\n    const {name, sourceSpan} = node;\n    const start = this.getStartLocation(name, sourceSpan);\n    if (start === null) {\n      return null;\n    }\n\n    const span = new AbsoluteSourceSpan(start, start + name.length);\n    let identifier: ReferenceIdentifier|VariableIdentifier;\n    if (node instanceof TmplAstReference) {\n      // If the node is a reference, we care about its target. The target can be an element, a\n      // template, a directive applied on a template or element (in which case the directive field\n      // is non-null), or nothing at all.\n      const refTarget = this.boundTemplate.getReferenceTarget(node);\n      let target = null;\n      if (refTarget) {\n        let node: ElementIdentifier|TemplateNodeIdentifier|null = null;\n        let directive: ClassDeclaration<DeclarationNode>|null = null;\n        if (refTarget instanceof TmplAstElement || refTarget instanceof TmplAstTemplate) {\n          node = this.elementOrTemplateToIdentifier(refTarget);\n        } else {\n          node = this.elementOrTemplateToIdentifier(refTarget.node);\n          directive = refTarget.directive.ref.node;\n        }\n\n        if (node === null) {\n          return null;\n        }\n        target = {\n          node,\n          directive,\n        };\n      }\n\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Reference,\n        target,\n      };\n    } else {\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Variable,\n      };\n    }\n\n    this.targetIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n\n  /** Gets the start location of a string in a SourceSpan */\n  private getStartLocation(name: string, context: ParseSourceSpan): number|null {\n    const localStr = context.toString();\n    if (!localStr.includes(name)) {\n      this.errors.push(new Error(`Impossible state: \"${name}\" not found in \"${localStr}\"`));\n      return null;\n    }\n    return context.start.offset + localStr.indexOf(name);\n  }\n\n  /**\n   * Visits a node's expression and adds its identifiers, if any, to the visitor's state.\n   * Only ASTs with information about the expression source and its location are visited.\n   *\n   * @param node node whose expression to visit\n   */\n  private visitExpression(ast: AST) {\n    // Only include ASTs that have information about their source and absolute source spans.\n    if (ast instanceof ASTWithSource && ast.source !== null) {\n      // Make target to identifier mapping closure stateful to this visitor instance.\n      const targetToIdentifier = this.targetToIdentifier.bind(this);\n      const absoluteOffset = ast.sourceSpan.start;\n      const {identifiers, errors} = ExpressionVisitor.getIdentifiers(\n          ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);\n      identifiers.forEach(id => this.identifiers.add(id));\n      this.errors.push(...errors);\n    }\n  }\n}\n\n/**\n * Traverses a template AST and builds identifiers discovered in it.\n *\n * @param boundTemplate bound template target, which can be used for querying expression targets.\n * @return identifiers in template\n */\nexport function getTemplateIdentifiers(boundTemplate: BoundTarget<ComponentMeta>):\n    {identifiers: Set<TopLevelIdentifier>, errors: Error[]} {\n  const visitor = new TemplateVisitor(boundTemplate);\n  if (boundTemplate.target.template !== undefined) {\n    visitor.visitAll(boundTemplate.target.template);\n  }\n  return {identifiers: visitor.identifiers, errors: visitor.errors};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceFile} from '@angular/compiler';\n\nimport {DeclarationNode} from '../../reflection';\n\nimport {IndexedComponent} from './api';\nimport {IndexingContext} from './context';\nimport {getTemplateIdentifiers} from './template';\n\n/**\n * Generates `IndexedComponent` entries from a `IndexingContext`, which has information\n * about components discovered in the program registered in it.\n *\n * The context must be populated before `generateAnalysis` is called.\n */\nexport function generateAnalysis(context: IndexingContext): Map<DeclarationNode, IndexedComponent> {\n  const analysis = new Map<DeclarationNode, IndexedComponent>();\n\n  context.components.forEach(({declaration, selector, boundTemplate, templateMeta}) => {\n    const name = declaration.name.getText();\n\n    const usedComponents = new Set<DeclarationNode>();\n    const usedDirs = boundTemplate.getUsedDirectives();\n    usedDirs.forEach(dir => {\n      if (dir.isComponent) {\n        usedComponents.add(dir.ref.node);\n      }\n    });\n\n    // Get source files for the component and the template. If the template is inline, its source\n    // file is the component's.\n    const componentFile = new ParseSourceFile(\n        declaration.getSourceFile().getFullText(), declaration.getSourceFile().fileName);\n    let templateFile: ParseSourceFile;\n    if (templateMeta.isInline) {\n      templateFile = componentFile;\n    } else {\n      templateFile = templateMeta.file;\n    }\n\n    const {identifiers, errors} = getTemplateIdentifiers(boundTemplate);\n    analysis.set(declaration, {\n      name,\n      selector,\n      file: componentFile,\n      template: {\n        identifiers,\n        usedComponents,\n        isInline: templateMeta.isInline,\n        file: templateFile,\n      },\n      errors,\n    });\n  });\n\n  return analysis;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {MetadataReader, MetadataReaderWithIndex, MetaKind, NgModuleIndex} from './api';\n\n/**\n * An index of all NgModules that export or re-export a given trait.\n */\nexport class NgModuleIndexImpl implements NgModuleIndex {\n  constructor(private metaReader: MetadataReader, private localReader: MetadataReaderWithIndex) {}\n\n  // A map from an NgModule's Class Declaration to the \"main\" reference to that module, aka the one\n  // present in the reader metadata object\n  private ngModuleAuthoritativeReference = new Map<ClassDeclaration, Reference<ClassDeclaration>>();\n  // A map from a Directive/Pipe's class declaration to the class declarations of all re-exporting\n  // NgModules\n  private typeToExportingModules = new Map<ClassDeclaration, Set<ClassDeclaration>>();\n\n  private indexed = false;\n\n  private updateWith<K, V>(cache: Map<K, Set<V>>, key: K, elem: V) {\n    if (cache.has(key)) {\n      cache.get(key)!.add(elem);\n    } else {\n      const set = new Set<V>();\n      set.add(elem);\n      cache.set(key, set);\n    }\n  }\n\n  private index(): void {\n    const seenTypesWithReexports = new Map<ClassDeclaration, Set<ClassDeclaration>>();\n    const locallyDeclaredDirsAndNgModules = [\n      ...this.localReader.getKnown(MetaKind.NgModule),\n      ...this.localReader.getKnown(MetaKind.Directive),\n    ];\n    for (const decl of locallyDeclaredDirsAndNgModules) {\n      // Here it's safe to create a new Reference because these are known local types.\n      this.indexTrait(new Reference(decl), seenTypesWithReexports);\n    }\n    this.indexed = true;\n  }\n\n  private indexTrait(\n      ref: Reference<ClassDeclaration>,\n      seenTypesWithReexports: Map<ClassDeclaration, Set<ClassDeclaration>>): void {\n    if (seenTypesWithReexports.has(ref.node)) {\n      // We've processed this type before.\n      return;\n    }\n    seenTypesWithReexports.set(ref.node, new Set());\n\n    const meta =\n        this.metaReader.getDirectiveMetadata(ref) ?? this.metaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      return;\n    }\n\n    // Component + NgModule: recurse into imports\n    if (meta.imports !== null) {\n      for (const childRef of meta.imports) {\n        this.indexTrait(childRef, seenTypesWithReexports);\n      }\n    }\n\n    if (meta.kind === MetaKind.NgModule) {\n      if (!this.ngModuleAuthoritativeReference.has(ref.node)) {\n        this.ngModuleAuthoritativeReference.set(ref.node, ref);\n      }\n\n      for (const childRef of meta.exports) {\n        this.indexTrait(childRef, seenTypesWithReexports);\n\n        const childMeta = this.metaReader.getDirectiveMetadata(childRef) ??\n            this.metaReader.getPipeMetadata(childRef) ??\n            this.metaReader.getNgModuleMetadata(childRef);\n        if (childMeta === null) {\n          continue;\n        }\n\n        switch (childMeta.kind) {\n          case MetaKind.Directive:\n          case MetaKind.Pipe:\n            this.updateWith(this.typeToExportingModules, childRef.node, ref.node);\n            this.updateWith(seenTypesWithReexports, ref.node, childRef.node);\n            break;\n          case MetaKind.NgModule:\n            if (seenTypesWithReexports.has(childRef.node)) {\n              for (const reexported of seenTypesWithReexports.get(childRef.node)!) {\n                this.updateWith(this.typeToExportingModules, reexported, ref.node);\n                this.updateWith(seenTypesWithReexports, ref.node, reexported);\n              }\n            }\n            break;\n        }\n      }\n    }\n  }\n\n  getNgModulesExporting(directiveOrPipe: ClassDeclaration): Array<Reference<ClassDeclaration>> {\n    if (!this.indexed) {\n      this.index();\n    }\n\n    if (!this.typeToExportingModules.has(directiveOrPipe)) {\n      return [];\n    }\n\n    const refs: Array<Reference<ClassDeclaration>> = [];\n    for (const ngModule of this.typeToExportingModules.get(directiveOrPipe)!) {\n      if (this.ngModuleAuthoritativeReference.has(ngModule)) {\n        refs.push(this.ngModuleAuthoritativeReference.get(ngModule)!);\n      }\n    }\n    return refs;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ResourceLoader, ResourceLoaderContext} from '../../annotations';\nimport {NgCompilerAdapter, ResourceHostContext} from '../../core/api';\nimport {AbsoluteFsPath, join, PathSegment} from '../../file_system';\nimport {RequiredDelegations} from '../../util/src/typescript';\n\nconst CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\n\nconst RESOURCE_MARKER = '.$ngresource$';\nconst RESOURCE_MARKER_TS = RESOURCE_MARKER + '.ts';\n\n/**\n * `ResourceLoader` which delegates to an `NgCompilerAdapter`'s resource loading methods.\n */\nexport class AdapterResourceLoader implements ResourceLoader {\n  private cache = new Map<string, string>();\n  private fetching = new Map<string, Promise<void>>();\n  private lookupResolutionHost: RequiredDelegations<ts.ModuleResolutionHost>;\n\n  canPreload: boolean;\n  canPreprocess: boolean;\n\n  constructor(private adapter: NgCompilerAdapter, private options: ts.CompilerOptions) {\n    this.lookupResolutionHost = createLookupResolutionHost(this.adapter);\n    this.canPreload = !!this.adapter.readResource;\n    this.canPreprocess = !!this.adapter.transformResource;\n  }\n\n  /**\n   * Resolve the url of a resource relative to the file that contains the reference to it.\n   * The return value of this method can be used in the `load()` and `preload()` methods.\n   *\n   * Uses the provided CompilerHost if it supports mapping resources to filenames.\n   * Otherwise, uses a fallback mechanism that searches the module resolution candidates.\n   *\n   * @param url The, possibly relative, url of the resource.\n   * @param fromFile The path to the file that contains the URL of the resource.\n   * @returns A resolved url of resource.\n   * @throws An error if the resource cannot be resolved.\n   */\n  resolve(url: string, fromFile: string): string {\n    let resolvedUrl: string|null = null;\n    if (this.adapter.resourceNameToFileName) {\n      resolvedUrl = this.adapter.resourceNameToFileName(\n          url, fromFile, (url: string, fromFile: string) => this.fallbackResolve(url, fromFile));\n    } else {\n      resolvedUrl = this.fallbackResolve(url, fromFile);\n    }\n    if (resolvedUrl === null) {\n      throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);\n    }\n    return resolvedUrl;\n  }\n\n  /**\n   * Preload the specified resource, asynchronously.\n   *\n   * Once the resource is loaded, its value is cached so it can be accessed synchronously via the\n   * `load()` method.\n   *\n   * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.\n   * @param context Information about the resource such as the type and containing file.\n   * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the\n   * file has already been loaded.\n   * @throws An Error if pre-loading is not available.\n   */\n  preload(resolvedUrl: string, context: ResourceLoaderContext): Promise<void>|undefined {\n    if (!this.adapter.readResource) {\n      throw new Error(\n          'HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');\n    }\n    if (this.cache.has(resolvedUrl)) {\n      return undefined;\n    } else if (this.fetching.has(resolvedUrl)) {\n      return this.fetching.get(resolvedUrl);\n    }\n\n    let result = this.adapter.readResource(resolvedUrl);\n\n    if (this.adapter.transformResource && context.type === 'style') {\n      const resourceContext: ResourceHostContext = {\n        type: 'style',\n        containingFile: context.containingFile,\n        resourceFile: resolvedUrl,\n      };\n      result = Promise.resolve(result).then(async (str) => {\n        const transformResult = await this.adapter.transformResource!(str, resourceContext);\n        return transformResult === null ? str : transformResult.content;\n      });\n    }\n\n    if (typeof result === 'string') {\n      this.cache.set(resolvedUrl, result);\n      return undefined;\n    } else {\n      const fetchCompletion = result.then(str => {\n        this.fetching.delete(resolvedUrl);\n        this.cache.set(resolvedUrl, str);\n      });\n      this.fetching.set(resolvedUrl, fetchCompletion);\n      return fetchCompletion;\n    }\n  }\n\n  /**\n   * Preprocess the content data of an inline resource, asynchronously.\n   *\n   * @param data The existing content data from the inline resource.\n   * @param context Information regarding the resource such as the type and containing file.\n   * @returns A Promise that resolves to the processed data. If no processing occurs, the\n   * same data string that was passed to the function will be resolved.\n   */\n  async preprocessInline(data: string, context: ResourceLoaderContext): Promise<string> {\n    if (!this.adapter.transformResource || context.type !== 'style') {\n      return data;\n    }\n\n    const transformResult = await this.adapter.transformResource(\n        data, {type: 'style', containingFile: context.containingFile, resourceFile: null});\n    if (transformResult === null) {\n      return data;\n    }\n\n    return transformResult.content;\n  }\n\n  /**\n   * Load the resource at the given url, synchronously.\n   *\n   * The contents of the resource may have been cached by a previous call to `preload()`.\n   *\n   * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to load.\n   * @returns The contents of the resource.\n   */\n  load(resolvedUrl: string): string {\n    if (this.cache.has(resolvedUrl)) {\n      return this.cache.get(resolvedUrl)!;\n    }\n\n    const result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) :\n                                               this.adapter.readFile(resolvedUrl);\n    if (typeof result !== 'string') {\n      throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);\n    }\n    this.cache.set(resolvedUrl, result);\n    return result;\n  }\n\n  /**\n   * Invalidate the entire resource cache.\n   */\n  invalidate(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Attempt to resolve `url` in the context of `fromFile`, while respecting the rootDirs\n   * option from the tsconfig. First, normalize the file name.\n   */\n  private fallbackResolve(url: string, fromFile: string): string|null {\n    let candidateLocations: string[];\n    if (url.startsWith('/')) {\n      // This path is not really an absolute path, but instead the leading '/' means that it's\n      // rooted in the project rootDirs. So look for it according to the rootDirs.\n      candidateLocations = this.getRootedCandidateLocations(url);\n    } else {\n      // This path is a \"relative\" path and can be resolved as such. To make this easier on the\n      // downstream resolver, the './' prefix is added if missing to distinguish these paths from\n      // absolute node_modules paths.\n      if (!url.startsWith('.')) {\n        url = `./${url}`;\n      }\n      candidateLocations = this.getResolvedCandidateLocations(url, fromFile);\n    }\n\n    for (const candidate of candidateLocations) {\n      if (this.adapter.fileExists(candidate)) {\n        return candidate;\n      } else if (CSS_PREPROCESSOR_EXT.test(candidate)) {\n        /**\n         * If the user specified styleUrl points to *.scss, but the Sass compiler was run before\n         * Angular, then the resource may have been generated as *.css. Simply try the resolution\n         * again.\n         */\n        const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, '.css');\n        if (this.adapter.fileExists(cssFallbackUrl)) {\n          return cssFallbackUrl;\n        }\n      }\n    }\n    return null;\n  }\n\n  private getRootedCandidateLocations(url: string): AbsoluteFsPath[] {\n    // The path already starts with '/', so add a '.' to make it relative.\n    const segment: PathSegment = ('.' + url) as PathSegment;\n    return this.adapter.rootDirs.map(rootDir => join(rootDir, segment));\n  }\n\n  /**\n   * TypeScript provides utilities to resolve module names, but not resource files (which aren't\n   * a part of the ts.Program). However, TypeScript's module resolution can be used creatively\n   * to locate where resource files should be expected to exist. Since module resolution returns\n   * a list of file names that were considered, the loader can enumerate the possible locations\n   * for the file by setting up a module resolution for it that will fail.\n   */\n  private getResolvedCandidateLocations(url: string, fromFile: string): string[] {\n    // `failedLookupLocations` is in the name of the type ts.ResolvedModuleWithFailedLookupLocations\n    // but is marked @internal in TypeScript. See\n    // https://github.com/Microsoft/TypeScript/issues/28770.\n    type ResolvedModuleWithFailedLookupLocations =\n        ts.ResolvedModuleWithFailedLookupLocations&{failedLookupLocations: ReadonlyArray<string>};\n\n    // clang-format off\n    const failedLookup = ts.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost) as ResolvedModuleWithFailedLookupLocations;\n    // clang-format on\n    if (failedLookup.failedLookupLocations === undefined) {\n      throw new Error(\n          `Internal error: expected to find failedLookupLocations during resolution of resource '${\n              url}' in context of ${fromFile}`);\n    }\n\n    return failedLookup.failedLookupLocations\n        .filter(candidate => candidate.endsWith(RESOURCE_MARKER_TS))\n        .map(candidate => candidate.slice(0, -RESOURCE_MARKER_TS.length));\n  }\n}\n\n/**\n * Derives a `ts.ModuleResolutionHost` from a compiler adapter that recognizes the special resource\n * marker and does not go to the filesystem for these requests, as they are known not to exist.\n */\nfunction createLookupResolutionHost(adapter: NgCompilerAdapter):\n    RequiredDelegations<ts.ModuleResolutionHost> {\n  return {\n    directoryExists(directoryName: string): boolean {\n      if (directoryName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else if (adapter.directoryExists !== undefined) {\n        return adapter.directoryExists(directoryName);\n      } else {\n        // TypeScript's module resolution logic assumes that the directory exists when no host\n        // implementation is available.\n        return true;\n      }\n    },\n    fileExists(fileName: string): boolean {\n      if (fileName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else {\n        return adapter.fileExists(fileName);\n      }\n    },\n    readFile: adapter.readFile.bind(adapter),\n    getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),\n    getDirectories: adapter.getDirectories?.bind(adapter),\n    realpath: adapter.realpath?.bind(adapter),\n    trace: adapter.trace?.bind(adapter),\n    useCaseSensitiveFileNames: typeof adapter.useCaseSensitiveFileNames === 'function' ?\n        adapter.useCaseSensitiveFileNames.bind(adapter) :\n        adapter.useCaseSensitiveFileNames\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {DirectiveMeta, MetadataReader, NgModuleMeta, PipeMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ComponentScopeKind, ComponentScopeReader, ExportScope, RemoteScope, StandaloneScope} from './api';\nimport {DtsModuleScopeResolver} from './dependency';\nimport {LocalModuleScopeRegistry} from './local';\n\n/**\n * Computes scopes for standalone components based on their `imports`, expanding imported NgModule\n * scopes where necessary.\n */\nexport class StandaloneComponentScopeReader implements ComponentScopeReader {\n  private cache = new Map<ClassDeclaration, StandaloneScope|null>();\n\n  constructor(\n      private metaReader: MetadataReader, private localModuleReader: LocalModuleScopeRegistry,\n      private dtsModuleReader: DtsModuleScopeResolver) {}\n\n  getScopeForComponent(clazz: ClassDeclaration): StandaloneScope|null {\n    if (!this.cache.has(clazz)) {\n      const clazzRef = new Reference(clazz);\n      const clazzMeta = this.metaReader.getDirectiveMetadata(clazzRef);\n\n      if (clazzMeta === null || !clazzMeta.isComponent || !clazzMeta.isStandalone) {\n        this.cache.set(clazz, null);\n        return null;\n      }\n\n      // A standalone component always has itself in scope, so add `clazzMeta` during\n      // initialization.\n      const dependencies = new Set<DirectiveMeta|PipeMeta|NgModuleMeta>([clazzMeta]);\n      const seen = new Set<ClassDeclaration>([clazz]);\n      let isPoisoned = clazzMeta.isPoisoned;\n\n      if (clazzMeta.imports !== null) {\n        for (const ref of clazzMeta.imports) {\n          if (seen.has(ref.node)) {\n            continue;\n          }\n          seen.add(ref.node);\n\n          const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n          if (dirMeta !== null) {\n            dependencies.add({...dirMeta, ref});\n            isPoisoned = isPoisoned || dirMeta.isPoisoned || !dirMeta.isStandalone;\n            continue;\n          }\n\n          const pipeMeta = this.metaReader.getPipeMetadata(ref);\n          if (pipeMeta !== null) {\n            dependencies.add({...pipeMeta, ref});\n            isPoisoned = isPoisoned || !pipeMeta.isStandalone;\n            continue;\n          }\n\n          const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n          if (ngModuleMeta !== null) {\n            dependencies.add({...ngModuleMeta, ref});\n\n            let ngModuleScope: ExportScope|null;\n            if (ref.node.getSourceFile().isDeclarationFile) {\n              ngModuleScope = this.dtsModuleReader.resolve(ref);\n            } else {\n              ngModuleScope = this.localModuleReader.getScopeOfModule(ref.node);\n            }\n            if (ngModuleScope === null) {\n              // This technically shouldn't happen, but mark the scope as poisoned just in case.\n              isPoisoned = true;\n              continue;\n            }\n\n            isPoisoned = isPoisoned || ngModuleScope.exported.isPoisoned;\n            for (const dep of ngModuleScope.exported.dependencies) {\n              if (!seen.has(dep.ref.node)) {\n                seen.add(dep.ref.node);\n                dependencies.add(dep);\n              }\n            }\n\n            continue;\n          }\n\n          // Import was not a component/directive/pipe/NgModule, which is an error and poisons the\n          // scope.\n          isPoisoned = true;\n        }\n      }\n\n      this.cache.set(clazz, {\n        kind: ComponentScopeKind.Standalone,\n        component: clazz,\n        dependencies: Array.from(dependencies),\n        isPoisoned,\n        schemas: clazzMeta.schemas ?? [],\n      });\n    }\n\n    return this.cache.get(clazz)!;\n  }\n\n  getRemoteScope(): null {\n    return null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, LiteralPrimitive, ParseSourceSpan, PropertyRead, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate, TmplAstTextAttribute} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../../../src/ngtsc/file_system';\nimport {ErrorCode} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {NgModuleMeta, PipeMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {FullTemplateMapping, NgTemplateDiagnostic, TypeCheckableDirectiveMeta} from './api';\nimport {GlobalCompletion} from './completion';\nimport {PotentialDirective, PotentialImport, PotentialImportMode, PotentialPipe} from './scope';\nimport {ElementSymbol, Symbol, TcbLocation, TemplateSymbol} from './symbols';\n\n/**\n * Interface to the Angular Template Type Checker to extract diagnostics and intelligence from the\n * compiler's understanding of component templates.\n *\n * This interface is analogous to TypeScript's own `ts.TypeChecker` API.\n *\n * In general, this interface supports two kinds of operations:\n *  - updating Type Check Blocks (TCB)s that capture the template in the form of TypeScript code\n *  - querying information about available TCBs, including diagnostics\n *\n * Once a TCB is available, information about it can be queried. If no TCB is available to answer a\n * query, depending on the method either `null` will be returned or an error will be thrown.\n */\nexport interface TemplateTypeChecker {\n  /**\n   * Retrieve the template in use for the given component.\n   */\n  getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null;\n\n  /**\n   * Get all `ts.Diagnostic`s currently available for the given `ts.SourceFile`.\n   *\n   * This method will fail (throw) if there are components within the `ts.SourceFile` that do not\n   * have TCBs available.\n   *\n   * Generating a template type-checking program is expensive, and in some workflows (e.g. checking\n   * an entire program before emit), it should ideally only be done once. The `optimizeFor` flag\n   * allows the caller to hint to `getDiagnosticsForFile` (which internally will create a template\n   * type-checking program if needed) whether the caller is interested in just the results of the\n   * single file, or whether they plan to query about other files in the program. Based on this\n   * flag, `getDiagnosticsForFile` will determine how much of the user's program to prepare for\n   * checking as part of the template type-checking program it creates.\n   */\n  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[];\n\n  /**\n   * Given a `shim` and position within the file, returns information for mapping back to a template\n   * location.\n   */\n  getTemplateMappingAtTcbLocation(tcbLocation: TcbLocation): FullTemplateMapping|null;\n\n  /**\n   * Get all `ts.Diagnostic`s currently available that pertain to the given component.\n   *\n   * This method always runs in `OptimizeFor.SingleFile` mode.\n   */\n  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[];\n\n  /**\n   * Ensures shims for the whole program are generated. This type of operation would be required by\n   * operations like \"find references\" and \"refactor/rename\" because references may appear in type\n   * check blocks generated from templates anywhere in the program.\n   */\n  generateAllTypeCheckBlocks(): void;\n\n  /**\n   * Returns `true` if the given file is in the record of known shims generated by the compiler,\n   * `false` if we cannot find the file in the shim records.\n   */\n  isTrackedTypeCheckFile(filePath: AbsoluteFsPath): boolean;\n\n  /**\n   * Retrieve the top-level node representing the TCB for the given component.\n   *\n   * This can return `null` if there is no TCB available for the component.\n   *\n   * This method always runs in `OptimizeFor.SingleFile` mode.\n   */\n  getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null;\n\n  /**\n   * Retrieves a `Symbol` for the node in a component's template.\n   *\n   * This method can return `null` if a valid `Symbol` cannot be determined for the node.\n   *\n   * @see Symbol\n   */\n  getSymbolOfNode(node: TmplAstElement, component: ts.ClassDeclaration): ElementSymbol|null;\n  getSymbolOfNode(node: TmplAstTemplate, component: ts.ClassDeclaration): TemplateSymbol|null;\n  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null;\n\n  /**\n   * Get \"global\" `Completion`s in the given context.\n   *\n   * Global completions are completions in the global context, as opposed to completions within an\n   * existing expression. For example, completing inside a new interpolation expression (`{{|}}`) or\n   * inside a new property binding `[input]=\"|\" should retrieve global completions, which will\n   * include completions from the template's context component, as well as any local references or\n   * template variables which are in scope for that expression.\n   */\n  getGlobalCompletions(\n      context: TmplAstTemplate|null, component: ts.ClassDeclaration,\n      node: AST|TmplAstNode): GlobalCompletion|null;\n\n\n  /**\n   * For the given expression node, retrieve a `TcbLocation` that can be used to perform\n   * autocompletion at that point in the expression, if such a location exists.\n   */\n  getExpressionCompletionLocation(\n      expr: PropertyRead|SafePropertyRead, component: ts.ClassDeclaration): TcbLocation|null;\n\n  /**\n   * For the given node represents a `LiteralPrimitive`(the `TextAttribute` represents a string\n   * literal), retrieve a `TcbLocation` that can be used to perform autocompletion at that point in\n   * the node, if such a location exists.\n   */\n  getLiteralCompletionLocation(\n      strNode: LiteralPrimitive|TmplAstTextAttribute, component: ts.ClassDeclaration): TcbLocation\n      |null;\n\n  /**\n   * Get basic metadata on the directives which are in scope or can be imported for the given\n   * component.\n   */\n  getPotentialTemplateDirectives(component: ts.ClassDeclaration): PotentialDirective[];\n\n  /**\n   * Get basic metadata on the pipes which are in scope or can be imported for the given component.\n   */\n  getPotentialPipes(component: ts.ClassDeclaration): PotentialPipe[];\n\n  /**\n   * Retrieve a `Map` of potential template element tags, to either the `PotentialDirective` that\n   * declares them (if the tag is from a directive/component), or `null` if the tag originates from\n   * the DOM schema.\n   */\n  getPotentialElementTags(component: ts.ClassDeclaration): Map<string, PotentialDirective|null>;\n\n  /**\n   * In the context of an Angular trait, generate potential imports for a directive.\n   */\n  getPotentialImportsFor(\n      toImport: Reference<ClassDeclaration>, inComponent: ts.ClassDeclaration,\n      importMode: PotentialImportMode): ReadonlyArray<PotentialImport>;\n\n  /**\n   * Get the primary decorator for an Angular class (such as @Component). This does not work for\n   * `@Injectable`.\n   */\n  getPrimaryAngularDecorator(target: ts.ClassDeclaration): ts.Decorator|null;\n\n  /**\n   * Get the class of the NgModule that owns this Angular trait. If the result is `null`, that\n   * probably means the provided component is standalone.\n   */\n  getOwningNgModule(component: ts.ClassDeclaration): ts.ClassDeclaration|null;\n\n  /**\n   * Retrieve any potential DOM bindings for the given element.\n   *\n   * This returns an array of objects which list both the attribute and property names of each\n   * binding, which are usually identical but can vary if the HTML attribute name is for example a\n   * reserved keyword in JS, like the `for` attribute which corresponds to the `htmlFor` property.\n   */\n  getPotentialDomBindings(tagName: string): {attribute: string, property: string}[];\n\n  /**\n   * Retrieve any potential DOM events.\n   */\n  getPotentialDomEvents(tagName: string): string[];\n\n  /**\n   * Retrieve the type checking engine's metadata for the given directive class, if available.\n   */\n  getDirectiveMetadata(dir: ts.ClassDeclaration): TypeCheckableDirectiveMeta|null;\n\n  /**\n   * Retrieve the type checking engine's metadata for the given NgModule class, if available.\n   */\n  getNgModuleMetadata(module: ts.ClassDeclaration): NgModuleMeta|null;\n\n  /**\n   * Retrieve the type checking engine's metadata for the given pipe class, if available.\n   */\n  getPipeMetadata(pipe: ts.ClassDeclaration): PipeMeta|null;\n\n  /**\n   * Gets the directives that have been used in a component's template.\n   */\n  getUsedDirectives(component: ts.ClassDeclaration): TypeCheckableDirectiveMeta[]|null;\n\n  /**\n   * Gets the pipes that have been used in a component's template.\n   */\n  getUsedPipes(component: ts.ClassDeclaration): string[]|null;\n\n  /**\n   * Reset the `TemplateTypeChecker`'s state for the given class, so that it will be recomputed on\n   * the next request.\n   */\n  invalidateClass(clazz: ts.ClassDeclaration): void;\n\n  /**\n   * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.\n   */\n  makeTemplateDiagnostic<T extends ErrorCode>(\n      clazz: ts.ClassDeclaration, sourceSpan: ParseSourceSpan, category: ts.DiagnosticCategory,\n      errorCode: T, message: string, relatedInformation?: {\n        text: string,\n        start: number,\n        end: number,\n        sourceFile: ts.SourceFile,\n      }[]): NgTemplateDiagnostic<T>;\n}\n\n/**\n * Describes the scope of the caller's interest in template type-checking results.\n */\nexport enum OptimizeFor {\n  /**\n   * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a\n   * given file, and wants them as fast as possible.\n   *\n   * Calling `TemplateTypeChecker` methods successively for multiple files while specifying\n   * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.\n   */\n  SingleFile,\n\n  /**\n   * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining\n   * to the entire user program, and so the type-checker should internally optimize for this case.\n   *\n   * Initial calls to retrieve type-checking information may take longer, but repeated calls to\n   * gather information for the whole user program will be significantly faster with this mode of\n   * optimization.\n   */\n  WholeProgram,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TmplAstReference, TmplAstVariable} from '@angular/compiler';\n\nimport {TcbLocation} from './symbols';\n\n/**\n * An autocompletion source of any kind.\n */\nexport type Completion = ReferenceCompletion|VariableCompletion;\n\n/**\n * Discriminant of an autocompletion source (a `Completion`).\n */\n\nexport enum CompletionKind {\n  Reference,\n  Variable,\n}\n\n/**\n * An autocompletion result representing a local reference declared in the template.\n */\nexport interface ReferenceCompletion {\n  kind: CompletionKind.Reference;\n\n  /**\n   * The `TmplAstReference` from the template which should be available as a completion.\n   */\n  node: TmplAstReference;\n}\n\n/**\n * An autocompletion result representing a variable declared in the template.\n */\nexport interface VariableCompletion {\n  kind: CompletionKind.Variable;\n\n  /**\n   * The `TmplAstVariable` from the template which should be available as a completion.\n   */\n  node: TmplAstVariable;\n}\n\n/**\n * Autocompletion data for an expression in the global scope.\n *\n * Global completion is accomplished by merging data from two sources:\n *  * TypeScript completion of the component's class members.\n *  * Local references and variables that are in scope at a given template level.\n */\nexport interface GlobalCompletion {\n  /**\n   * A location within the type-checking shim where TypeScript's completion APIs can be used to\n   * access completions for the template's component context (component class members).\n   */\n  componentContext: TcbLocation;\n\n  /**\n   * `Map` of local references and variables that are visible at the requested level of the\n   * template.\n   *\n   * Shadowing of references/variables from multiple levels of the template has already been\n   * accounted for in the preparation of `templateContext`. Entries here shadow component members of\n   * the same name (from the `componentContext` completions).\n   */\n  templateContext: Map<string, ReferenceCompletion|VariableCompletion>;\n\n  /**\n   * A location within the type-checking shim where TypeScript's completion APIs can be used to\n   * access completions for the AST node of the cursor position (primitive constants).\n   */\n  nodeContext: TcbLocation|null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {EmittedReference, Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\nimport {SymbolWithValueDeclaration} from '../../util/src/typescript';\n\n/**\n * A PotentialImport for some Angular trait has a TypeScript module specifier, which can be\n * relative, as well as an identifier name.\n */\nexport interface PotentialImport {\n  kind: PotentialImportKind;\n  // If no moduleSpecifier is present, the given symbol name is already in scope.\n  moduleSpecifier?: string;\n  symbolName: string;\n  isForwardReference: boolean;\n}\n\n/**\n * Which kind of Angular Trait the import targets.\n */\nexport enum PotentialImportKind {\n  NgModule,\n  Standalone,\n}\n\n/**\n * Metadata on a directive which is available in a template.\n */\nexport interface PotentialDirective {\n  ref: Reference<ClassDeclaration>;\n\n  /**\n   * The `ts.Symbol` for the directive class.\n   */\n  tsSymbol: SymbolWithValueDeclaration;\n\n  /**\n   * The module which declares the directive.\n   */\n  ngModule: ClassDeclaration|null;\n\n  /**\n   * The selector for the directive or component.\n   */\n  selector: string|null;\n\n  /**\n   * `true` if this directive is a component.\n   */\n  isComponent: boolean;\n\n  /**\n   * `true` if this directive is a structural directive.\n   */\n  isStructural: boolean;\n\n  /**\n   * Whether or not this directive is in scope.\n   */\n  isInScope: boolean;\n}\n\n/**\n * Metadata for a pipe which is available in a template.\n */\nexport interface PotentialPipe {\n  ref: Reference<ClassDeclaration>;\n\n  /**\n   * The `ts.Symbol` for the pipe class.\n   */\n  tsSymbol: ts.Symbol;\n\n  /**\n   * Name of the pipe.\n   */\n  name: string;\n\n  /**\n   * Whether or not this pipe is in scope.\n   */\n  isInScope: boolean;\n}\n\n/**\n * Possible modes in which to look up a potential import.\n */\nexport enum PotentialImportMode {\n  /** Whether an import is standalone is inferred based on its metadata. */\n  Normal,\n\n  /**\n   * An import is assumed to be standalone and is imported directly. This is useful for migrations\n   * where a declaration wasn't standalone when the program was created, but will become standalone\n   * as a part of the migration.\n   */\n  ForceDirect,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TmplAstElement, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {SymbolWithValueDeclaration} from '../../util/src/typescript';\n\nimport {PotentialDirective} from './scope';\n\nexport enum SymbolKind {\n  Input,\n  Output,\n  Binding,\n  Reference,\n  Variable,\n  Directive,\n  Element,\n  Template,\n  Expression,\n  DomBinding,\n  Pipe,\n}\n\n/**\n * A representation of an entity in the `TemplateAst`.\n */\nexport type Symbol = InputBindingSymbol|OutputBindingSymbol|ElementSymbol|ReferenceSymbol|\n    VariableSymbol|ExpressionSymbol|DirectiveSymbol|TemplateSymbol|DomBindingSymbol|PipeSymbol;\n\n/**\n * A `Symbol` which declares a new named entity in the template scope.\n */\nexport type TemplateDeclarationSymbol = ReferenceSymbol|VariableSymbol;\n\n/**\n * Information about where a `ts.Node` can be found in the type check file. This can either be\n * a type-checking shim file, or an original source file for inline type check blocks.\n */\nexport interface TcbLocation {\n  /**\n   * The fully qualified path of the file which contains the generated TypeScript type check\n   * code for the component's template.\n   */\n  tcbPath: AbsoluteFsPath;\n\n  /**\n   * Whether the type check block exists in a type-checking shim file or is inline.\n   */\n  isShimFile: boolean;\n\n  /** The location in the file where node appears. */\n  positionInFile: number;\n}\n\n/**\n * A generic representation of some node in a template.\n */\nexport interface TsNodeSymbolInfo {\n  /** The `ts.Type` of the template node. */\n  tsType: ts.Type;\n\n  /** The `ts.Symbol` for the template node */\n  tsSymbol: ts.Symbol|null;\n\n  /** The position of the most relevant part of the template node. */\n  tcbLocation: TcbLocation;\n}\n\n/**\n * A representation of an expression in a component template.\n */\nexport interface ExpressionSymbol {\n  kind: SymbolKind.Expression;\n\n  /** The `ts.Type` of the expression AST. */\n  tsType: ts.Type;\n\n  /**\n   * The `ts.Symbol` of the entity. This could be `null`, for example `AST` expression\n   * `{{foo.bar + foo.baz}}` does not have a `ts.Symbol` but `foo.bar` and `foo.baz` both do.\n   */\n  tsSymbol: ts.Symbol|null;\n\n  /** The position of the most relevant part of the expression. */\n  tcbLocation: TcbLocation;\n}\n\n/** Represents either an input or output binding in a template. */\nexport interface BindingSymbol {\n  kind: SymbolKind.Binding;\n\n  /** The `ts.Type` of the class member on the directive that is the target of the binding. */\n  tsType: ts.Type;\n\n  /** The `ts.Symbol` of the class member on the directive that is the target of the binding. */\n  tsSymbol: ts.Symbol;\n\n  /**\n   * The `DirectiveSymbol` or `ElementSymbol` for the Directive, Component, or `HTMLElement` with\n   * the binding.\n   */\n  target: DirectiveSymbol|ElementSymbol|TemplateSymbol;\n\n  /** The location in the shim file where the field access for the binding appears. */\n  tcbLocation: TcbLocation;\n}\n\n/**\n * A representation of an input binding in a component template.\n */\nexport interface InputBindingSymbol {\n  kind: SymbolKind.Input;\n\n  /** A single input may be bound to multiple components or directives. */\n  bindings: BindingSymbol[];\n}\n\n/**\n * A representation of an output binding in a component template.\n */\nexport interface OutputBindingSymbol {\n  kind: SymbolKind.Output;\n\n  /** A single output may be bound to multiple components or directives. */\n  bindings: BindingSymbol[];\n}\n\n/**\n * A representation of a local reference in a component template.\n */\nexport interface ReferenceSymbol {\n  kind: SymbolKind.Reference;\n\n  /**\n   * The `ts.Type` of the Reference value.\n   *\n   * `TmplAstTemplate` - The type of the `TemplateRef`\n   * `TmplAstElement` - The `ts.Type` for the `HTMLElement`.\n   * Directive - The `ts.Type` for the class declaration.\n   */\n  tsType: ts.Type;\n\n  /**\n   * The `ts.Symbol` for the Reference value.\n   *\n   * `TmplAstTemplate` - A `TemplateRef` symbol.\n   * `TmplAstElement` - The symbol for the `HTMLElement`.\n   * Directive - The symbol for the class declaration of the directive.\n   */\n  tsSymbol: ts.Symbol;\n\n  /**\n   * Depending on the type of the reference, this is one of the following:\n   *  - `TmplAstElement` when the local ref refers to the HTML element\n   *  - `TmplAstTemplate` when the ref refers to an `ng-template`\n   *  - `ts.ClassDeclaration` when the local ref refers to a Directive instance (#ref=\"myExportAs\")\n   */\n  target: TmplAstElement|TmplAstTemplate|ts.ClassDeclaration;\n\n  /**\n   * The node in the `TemplateAst` where the symbol is declared. That is, node for the `#ref` or\n   * `#ref=\"exportAs\"`.\n   */\n  declaration: TmplAstReference;\n\n  /**\n   * The location in the shim file of a variable that holds the type of the local ref.\n   * For example, a reference declaration like the following:\n   * ```\n   * var _t1 = document.createElement('div');\n   * var _t2 = _t1; // This is the reference declaration\n   * ```\n   * This `targetLocation` is `[_t1 variable declaration].getStart()`.\n   */\n  targetLocation: TcbLocation;\n\n  /**\n   * The location in the TCB for the identifier node in the reference variable declaration.\n   * For example, given a variable declaration statement for a template reference:\n   * `var _t2 = _t1`, this location is `[_t2 node].getStart()`. This location can\n   * be used to find references to the variable within the template.\n   */\n  referenceVarLocation: TcbLocation;\n}\n\n/**\n * A representation of a context variable in a component template.\n */\nexport interface VariableSymbol {\n  kind: SymbolKind.Variable;\n\n  /**\n   * The `ts.Type` of the entity.\n   *\n   * This will be `any` if there is no `ngTemplateContextGuard`.\n   */\n  tsType: ts.Type;\n\n  /**\n   * The `ts.Symbol` for the context variable.\n   *\n   * This will be `null` if there is no `ngTemplateContextGuard`.\n   */\n  tsSymbol: ts.Symbol|null;\n\n  /**\n   * The node in the `TemplateAst` where the variable is declared. That is, the node for the `let-`\n   * node in the template.\n   */\n  declaration: TmplAstVariable;\n\n  /**\n   * The location in the shim file for the identifier that was declared for the template variable.\n   */\n  localVarLocation: TcbLocation;\n\n  /**\n   * The location in the shim file for the initializer node of the variable that represents the\n   * template variable.\n   */\n  initializerLocation: TcbLocation;\n}\n\n/**\n * A representation of an element in a component template.\n */\nexport interface ElementSymbol {\n  kind: SymbolKind.Element;\n\n  /** The `ts.Type` for the `HTMLElement`. */\n  tsType: ts.Type;\n\n  /** The `ts.Symbol` for the `HTMLElement`. */\n  tsSymbol: ts.Symbol|null;\n\n  /** A list of directives applied to the element. */\n  directives: DirectiveSymbol[];\n\n  /** The location in the shim file for the variable that holds the type of the element. */\n  tcbLocation: TcbLocation;\n\n  templateNode: TmplAstElement;\n}\n\nexport interface TemplateSymbol {\n  kind: SymbolKind.Template;\n\n  /** A list of directives applied to the element. */\n  directives: DirectiveSymbol[];\n\n  templateNode: TmplAstTemplate;\n}\n\n/** Interface shared between host and non-host directives. */\ninterface DirectiveSymbolBase extends PotentialDirective {\n  kind: SymbolKind.Directive;\n\n  /** The `ts.Type` for the class declaration. */\n  tsType: ts.Type;\n\n  /** The location in the shim file for the variable that holds the type of the directive. */\n  tcbLocation: TcbLocation;\n}\n\n/**\n * A representation of a directive/component whose selector matches a node in a component\n * template.\n */\nexport type DirectiveSymbol = (DirectiveSymbolBase&{isHostDirective: false})|(DirectiveSymbolBase&{\n  isHostDirective: true;\n  exposedInputs: Record<string, string>|null;\n  exposedOutputs: Record<string, string>|null;\n});\n\n/**\n * A representation of an attribute on an element or template. These bindings aren't currently\n * type-checked (see `checkTypeOfDomBindings`) so they won't have a `ts.Type`, `ts.Symbol`, or shim\n * location.\n */\nexport interface DomBindingSymbol {\n  kind: SymbolKind.DomBinding;\n\n  /** The symbol for the element or template of the text attribute. */\n  host: ElementSymbol|TemplateSymbol;\n}\n\n/**\n * A representation for a call to a pipe's transform method in the TCB.\n */\nexport interface PipeSymbol {\n  kind: SymbolKind.Pipe;\n\n  /** The `ts.Type` of the transform node. */\n  tsType: ts.Type;\n\n  /**\n   * The `ts.Symbol` for the transform call. This could be `null` when `checkTypeOfPipes` is set to\n   * `false` because the transform call would be of the form `(_pipe1 as any).transform()`\n   */\n  tsSymbol: ts.Symbol|null;\n\n  /** The position of the transform call in the template. */\n  tcbLocation: TcbLocation;\n\n  /** The symbol for the pipe class as an instance that appears in the TCB. */\n  classSymbol: ClassSymbol;\n}\n\n/** Represents an instance of a class found in the TCB, i.e. `var _pipe1: MyPipe = null!; */\nexport interface ClassSymbol {\n  /** The `ts.Type` of class. */\n  tsType: ts.Type;\n\n  /** The `ts.Symbol` for class. */\n  tsSymbol: SymbolWithValueDeclaration;\n\n  /** The position for the variable declaration for the class instance. */\n  tcbLocation: TcbLocation;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {addDiagnosticChain, makeDiagnosticChain} from '../../../diagnostics';\nimport {ExternalTemplateSourceMapping, IndirectTemplateSourceMapping, TemplateDiagnostic, TemplateId, TemplateSourceMapping} from '../../api';\n\n/**\n * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.\n */\nexport function makeTemplateDiagnostic(\n    templateId: TemplateId, mapping: TemplateSourceMapping, span: ParseSourceSpan,\n    category: ts.DiagnosticCategory, code: number, messageText: string|ts.DiagnosticMessageChain,\n    relatedMessages?: {\n      text: string,\n      start: number,\n      end: number,\n      sourceFile: ts.SourceFile,\n    }[]): TemplateDiagnostic {\n  if (mapping.type === 'direct') {\n    let relatedInformation: ts.DiagnosticRelatedInformation[]|undefined = undefined;\n    if (relatedMessages !== undefined) {\n      relatedInformation = [];\n      for (const relatedMessage of relatedMessages) {\n        relatedInformation.push({\n          category: ts.DiagnosticCategory.Message,\n          code: 0,\n          file: relatedMessage.sourceFile,\n          start: relatedMessage.start,\n          length: relatedMessage.end - relatedMessage.start,\n          messageText: relatedMessage.text,\n        });\n      }\n    }\n    // For direct mappings, the error is shown inline as ngtsc was able to pinpoint a string\n    // constant within the `@Component` decorator for the template. This allows us to map the error\n    // directly into the bytes of the source file.\n    return {\n      source: 'ngtsc',\n      code,\n      category,\n      messageText,\n      file: mapping.node.getSourceFile(),\n      componentFile: mapping.node.getSourceFile(),\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      relatedInformation,\n    };\n  } else if (mapping.type === 'indirect' || mapping.type === 'external') {\n    // For indirect mappings (template was declared inline, but ngtsc couldn't map it directly\n    // to a string constant in the decorator), the component's file name is given with a suffix\n    // indicating it's not the TS file being displayed, but a template.\n    // For external temoplates, the HTML filename is used.\n    const componentSf = mapping.componentClass.getSourceFile();\n    const componentName = mapping.componentClass.name.text;\n    const fileName = mapping.type === 'indirect' ?\n        `${componentSf.fileName} (${componentName} template)` :\n        mapping.templateUrl;\n\n    let relatedInformation: ts.DiagnosticRelatedInformation[] = [];\n    if (relatedMessages !== undefined) {\n      for (const relatedMessage of relatedMessages) {\n        relatedInformation.push({\n          category: ts.DiagnosticCategory.Message,\n          code: 0,\n          file: relatedMessage.sourceFile,\n          start: relatedMessage.start,\n          length: relatedMessage.end - relatedMessage.start,\n          messageText: relatedMessage.text,\n        });\n      }\n    }\n\n    let sf: ts.SourceFile;\n    try {\n      sf = getParsedTemplateSourceFile(fileName, mapping);\n    } catch (e) {\n      const failureChain = makeDiagnosticChain(\n          `Failed to report an error in '${fileName}' at ${span.start.line + 1}:${\n              span.start.col + 1}`,\n          [\n            makeDiagnosticChain((e as Error)?.stack ?? `${e}`),\n          ]);\n      return {\n        source: 'ngtsc',\n        category,\n        code,\n        messageText: addDiagnosticChain(messageText, [failureChain]),\n        file: componentSf,\n        componentFile: componentSf,\n        templateId,\n        // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()\n        // and getEnd() are used because they don't include surrounding whitespace.\n        start: mapping.node.getStart(),\n        length: mapping.node.getEnd() - mapping.node.getStart(),\n        relatedInformation,\n      };\n    }\n\n    relatedInformation.push({\n      category: ts.DiagnosticCategory.Message,\n      code: 0,\n      file: componentSf,\n      // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()\n      // and getEnd() are used because they don't include surrounding whitespace.\n      start: mapping.node.getStart(),\n      length: mapping.node.getEnd() - mapping.node.getStart(),\n      messageText: `Error occurs in the template of component ${componentName}.`,\n    });\n\n    return {\n      source: 'ngtsc',\n      category,\n      code,\n      messageText,\n      file: sf,\n      componentFile: componentSf,\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      // Show a secondary message indicating the component whose template contains the error.\n      relatedInformation,\n    };\n  } else {\n    throw new Error(`Unexpected source mapping type: ${(mapping as {type: string}).type}`);\n  }\n}\n\nconst TemplateSourceFile = Symbol('TemplateSourceFile');\n\ntype TemplateSourceMappingWithSourceFile =\n    (ExternalTemplateSourceMapping|IndirectTemplateSourceMapping)&{\n  [TemplateSourceFile]?: ts.SourceFile;\n};\n\nfunction getParsedTemplateSourceFile(\n    fileName: string, mapping: TemplateSourceMappingWithSourceFile): ts.SourceFile {\n  if (mapping[TemplateSourceFile] === undefined) {\n    mapping[TemplateSourceFile] = parseTemplateAsSourceFile(fileName, mapping.template);\n  }\n\n  return mapping[TemplateSourceFile];\n}\n\nlet parseTemplateAsSourceFileForTest: typeof parseTemplateAsSourceFile|null = null;\n\nexport function setParseTemplateAsSourceFileForTest(fn: typeof parseTemplateAsSourceFile): void {\n  parseTemplateAsSourceFileForTest = fn;\n}\n\nexport function resetParseTemplateAsSourceFileForTest(): void {\n  parseTemplateAsSourceFileForTest = null;\n}\n\nfunction parseTemplateAsSourceFile(fileName: string, template: string): ts.SourceFile {\n  if (parseTemplateAsSourceFileForTest !== null) {\n    return parseTemplateAsSourceFileForTest(fileName, template);\n  }\n\n  // TODO(alxhub): investigate creating a fake `ts.SourceFile` here instead of invoking the TS\n  // parser against the template (HTML is just really syntactically invalid TypeScript code ;).\n  return ts.createSourceFile(\n      fileName, template, ts.ScriptTarget.Latest, /* setParentNodes */ false, ts.ScriptKind.JSX);\n}\n\nexport function isTemplateDiagnostic(diagnostic: ts.Diagnostic): diagnostic is TemplateDiagnostic {\n  return diagnostic.hasOwnProperty('componentFile') &&\n      ts.isSourceFile((diagnostic as any).componentFile);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {DeclarationNode} from '../../../reflection';\n\nimport {TemplateId} from '../../api';\n\n\nconst TEMPLATE_ID = Symbol('ngTemplateId');\nconst NEXT_TEMPLATE_ID = Symbol('ngNextTemplateId');\n\ninterface HasTemplateId {\n  [TEMPLATE_ID]: TemplateId;\n}\n\ninterface HasNextTemplateId {\n  [NEXT_TEMPLATE_ID]: number;\n}\n\nexport function getTemplateId(clazz: DeclarationNode): TemplateId {\n  const node = clazz as ts.Declaration & Partial<HasTemplateId>;\n  if (node[TEMPLATE_ID] === undefined) {\n    node[TEMPLATE_ID] = allocateTemplateId(node.getSourceFile());\n  }\n  return node[TEMPLATE_ID]!;\n}\n\nfunction allocateTemplateId(sf: ts.SourceFile&Partial<HasNextTemplateId>): TemplateId {\n  if (sf[NEXT_TEMPLATE_ID] === undefined) {\n    sf[NEXT_TEMPLATE_ID] = 1;\n  }\n  return (`tcb${sf[NEXT_TEMPLATE_ID]!++}`) as TemplateId;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {CompletionKind, GlobalCompletion, ReferenceCompletion, TcbLocation, VariableCompletion} from '../api';\n\nimport {ExpressionIdentifier, findFirstMatchingNode} from './comments';\nimport {TemplateData} from './context';\n\n/**\n * Powers autocompletion for a specific component.\n *\n * Internally caches autocompletion results, and must be discarded if the component template or\n * surrounding TS program have changed.\n */\nexport class CompletionEngine {\n  private componentContext: TcbLocation|null;\n\n  /**\n   * Cache of completions for various levels of the template, including the root template (`null`).\n   * Memoizes `getTemplateContextCompletions`.\n   */\n  private templateContextCache =\n      new Map<TmplAstTemplate|null, Map<string, ReferenceCompletion|VariableCompletion>>();\n\n  private expressionCompletionCache =\n      new Map<PropertyRead|SafePropertyRead|LiteralPrimitive|TmplAstTextAttribute, TcbLocation>();\n\n\n  constructor(\n      private tcb: ts.Node, private data: TemplateData, private tcbPath: AbsoluteFsPath,\n      private tcbIsShim: boolean) {\n    // Find the component completion expression within the TCB. This looks like: `ctx. /* ... */;`\n    const globalRead = findFirstMatchingNode(this.tcb, {\n      filter: ts.isPropertyAccessExpression,\n      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n    });\n\n    if (globalRead !== null) {\n      this.componentContext = {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        // `globalRead.name` is an empty `ts.Identifier`, so its start position immediately follows\n        // the `.` in `ctx.`. TS autocompletion APIs can then be used to access completion results\n        // for the component context.\n        positionInFile: globalRead.name.getStart(),\n      };\n    } else {\n      this.componentContext = null;\n    }\n  }\n\n  /**\n   * Get global completions within the given template context and AST node.\n   *\n   * @param context the given template context - either a `TmplAstTemplate` embedded view, or `null`\n   *     for the root\n   * template context.\n   * @param node the given AST node\n   */\n  getGlobalCompletions(context: TmplAstTemplate|null, node: AST|TmplAstNode): GlobalCompletion\n      |null {\n    if (this.componentContext === null) {\n      return null;\n    }\n\n    const templateContext = this.getTemplateContextCompletions(context);\n    if (templateContext === null) {\n      return null;\n    }\n\n    let nodeContext: TcbLocation|null = null;\n    if (node instanceof EmptyExpr) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts.isIdentifier,\n        withSpan: node.sourceSpan,\n      });\n      if (nodeLocation !== null) {\n        nodeContext = {\n          tcbPath: this.tcbPath,\n          isShimFile: this.tcbIsShim,\n          positionInFile: nodeLocation.getStart(),\n        };\n      }\n    }\n\n    if (node instanceof PropertyRead && node.receiver instanceof ImplicitReceiver) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts.isPropertyAccessExpression,\n        withSpan: node.sourceSpan,\n      });\n      if (nodeLocation) {\n        nodeContext = {\n          tcbPath: this.tcbPath,\n          isShimFile: this.tcbIsShim,\n          positionInFile: nodeLocation.getStart(),\n        };\n      }\n    }\n\n    return {\n      componentContext: this.componentContext,\n      templateContext,\n      nodeContext,\n    };\n  }\n\n  getExpressionCompletionLocation(expr: PropertyRead|PropertyWrite|SafePropertyRead): TcbLocation\n      |null {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr)!;\n    }\n\n    // Completion works inside property reads and method calls.\n    let tsExpr: ts.PropertyAccessExpression|null = null;\n    if (expr instanceof PropertyRead || expr instanceof PropertyWrite) {\n      // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts.isPropertyAccessExpression,\n        withSpan: expr.nameSpan,\n      });\n    } else if (expr instanceof SafePropertyRead) {\n      // Safe navigation operations are a little more complex, and involve a ternary. Completion\n      // happens in the \"true\" case of the ternary.\n      const ternaryExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts.isParenthesizedExpression,\n        withSpan: expr.sourceSpan,\n      });\n      if (ternaryExpr === null || !ts.isConditionalExpression(ternaryExpr.expression)) {\n        return null;\n      }\n      const whenTrue = ternaryExpr.expression.whenTrue;\n\n      if (ts.isPropertyAccessExpression(whenTrue)) {\n        tsExpr = whenTrue;\n      } else if (\n          ts.isCallExpression(whenTrue) && ts.isPropertyAccessExpression(whenTrue.expression)) {\n        tsExpr = whenTrue.expression;\n      }\n    }\n\n    if (tsExpr === null) {\n      return null;\n    }\n\n    const res: TcbLocation = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: tsExpr.name.getEnd(),\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n\n  getLiteralCompletionLocation(expr: LiteralPrimitive|TmplAstTextAttribute): TcbLocation|null {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr)!;\n    }\n\n    let tsExpr: ts.StringLiteral|ts.NumericLiteral|null = null;\n\n    if (expr instanceof TmplAstTextAttribute) {\n      const strNode = findFirstMatchingNode(this.tcb, {\n        filter: ts.isParenthesizedExpression,\n        withSpan: expr.sourceSpan,\n      });\n      if (strNode !== null && ts.isStringLiteral(strNode.expression)) {\n        tsExpr = strNode.expression;\n      }\n    } else {\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: (n: ts.Node): n is ts.NumericLiteral | ts.StringLiteral =>\n            ts.isStringLiteral(n) || ts.isNumericLiteral(n),\n        withSpan: expr.sourceSpan,\n      });\n    }\n\n    if (tsExpr === null) {\n      return null;\n    }\n\n    let positionInShimFile = tsExpr.getEnd();\n    if (ts.isStringLiteral(tsExpr)) {\n      // In the shimFile, if `tsExpr` is a string, the position should be in the quotes.\n      positionInShimFile -= 1;\n    }\n    const res: TcbLocation = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: positionInShimFile,\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n\n  /**\n   * Get global completions within the given template context - either a `TmplAstTemplate` embedded\n   * view, or `null` for the root context.\n   */\n  private getTemplateContextCompletions(context: TmplAstTemplate|null):\n      Map<string, ReferenceCompletion|VariableCompletion>|null {\n    if (this.templateContextCache.has(context)) {\n      return this.templateContextCache.get(context)!;\n    }\n\n    const templateContext = new Map<string, ReferenceCompletion|VariableCompletion>();\n\n    // The bound template already has details about the references and variables in scope in the\n    // `context` template - they just need to be converted to `Completion`s.\n    for (const node of this.data.boundTarget.getEntitiesInTemplateScope(context)) {\n      if (node instanceof TmplAstReference) {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Reference,\n          node,\n        });\n      } else {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Variable,\n          node,\n        });\n      }\n    }\n\n    this.templateContextCache.set(context, templateContext);\n    return templateContext;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\nimport ts from 'typescript';\n\nconst parseSpanComment = /^(\\d+),(\\d+)$/;\n\n/**\n * Reads the trailing comments and finds the first match which is a span comment (i.e. 4,10) on a\n * node and returns it as an `AbsoluteSourceSpan`.\n *\n * Will return `null` if no trailing comments on the node match the expected form of a source span.\n */\nexport function readSpanComment(\n    node: ts.Node, sourceFile: ts.SourceFile = node.getSourceFile()): AbsoluteSourceSpan|null {\n  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    const match = commentText.match(parseSpanComment);\n    if (match === null) {\n      return null;\n    }\n\n    return new AbsoluteSourceSpan(+match[1], +match[2]);\n  }) || null;\n}\n\n/** Used to identify what type the comment is. */\nexport enum CommentTriviaType {\n  DIAGNOSTIC = 'D',\n  EXPRESSION_TYPE_IDENTIFIER = 'T',\n}\n\n/** Identifies what the TCB expression is for (for example, a directive declaration). */\nexport enum ExpressionIdentifier {\n  DIRECTIVE = 'DIR',\n  COMPONENT_COMPLETION = 'COMPCOMP',\n  EVENT_PARAMETER = 'EP',\n}\n\n/** Tags the node with the given expression identifier. */\nexport function addExpressionIdentifier(node: ts.Node, identifier: ExpressionIdentifier) {\n  ts.addSyntheticTrailingComment(\n      node, ts.SyntaxKind.MultiLineCommentTrivia,\n      `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`,\n      /* hasTrailingNewLine */ false);\n}\n\nconst IGNORE_FOR_DIAGNOSTICS_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\n\n/**\n * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node\n * should be ignored.\n */\nexport function markIgnoreDiagnostics(node: ts.Node): void {\n  ts.addSyntheticTrailingComment(\n      node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_FOR_DIAGNOSTICS_MARKER,\n      /* hasTrailingNewLine */ false);\n}\n\n/** Returns true if the node has a marker that indicates diagnostics errors should be ignored.  */\nexport function hasIgnoreForDiagnosticsMarker(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;\n  }) === true;\n}\n\nfunction makeRecursiveVisitor<T extends ts.Node>(visitor: (node: ts.Node) => T | null):\n    (node: ts.Node) => T | undefined {\n  function recursiveVisitor(node: ts.Node): T|undefined {\n    const res = visitor(node);\n    return res !== null ? res : node.forEachChild(recursiveVisitor);\n  }\n  return recursiveVisitor;\n}\n\nexport interface FindOptions<T extends ts.Node> {\n  filter: (node: ts.Node) => node is T;\n  withExpressionIdentifier?: ExpressionIdentifier;\n  withSpan?: AbsoluteSourceSpan|ParseSourceSpan;\n}\n\nfunction getSpanFromOptions(opts: FindOptions<ts.Node>) {\n  let withSpan: {start: number, end: number}|null = null;\n  if (opts.withSpan !== undefined) {\n    if (opts.withSpan instanceof AbsoluteSourceSpan) {\n      withSpan = opts.withSpan;\n    } else {\n      withSpan = {start: opts.withSpan.start.offset, end: opts.withSpan.end.offset};\n    }\n  }\n  return withSpan;\n}\n\n/**\n * Given a `ts.Node` with finds the first node whose matching the criteria specified\n * by the `FindOptions`.\n *\n * Returns `null` when no `ts.Node` matches the given conditions.\n */\nexport function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T|\n    null {\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const sf = tcb.getSourceFile();\n  const visitor = makeRecursiveVisitor<T>(node => {\n    if (!opts.filter(node)) {\n      return null;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        return null;\n      }\n    }\n    if (withExpressionIdentifier !== undefined &&\n        !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      return null;\n    }\n    return node;\n  });\n  return tcb.forEachChild(visitor) ?? null;\n}\n\n/**\n * Given a `ts.Node` with source span comments, finds the first node whose source span comment\n * matches the given `sourceSpan`. Additionally, the `filter` function allows matching only\n * `ts.Nodes` of a given type, which provides the ability to select only matches of a given type\n * when there may be more than one.\n *\n * Returns `null` when no `ts.Node` matches the given conditions.\n */\nexport function findAllMatchingNodes<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T[] {\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const results: T[] = [];\n  const stack: ts.Node[] = [tcb];\n  const sf = tcb.getSourceFile();\n\n  while (stack.length > 0) {\n    const node = stack.pop()!;\n\n    if (!opts.filter(node)) {\n      stack.push(...node.getChildren());\n      continue;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        stack.push(...node.getChildren());\n        continue;\n      }\n    }\n    if (withExpressionIdentifier !== undefined &&\n        !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      continue;\n    }\n\n    results.push(node);\n  }\n\n  return results;\n}\n\nexport function hasExpressionIdentifier(\n    sourceFile: ts.SourceFile, node: ts.Node, identifier: ExpressionIdentifier): boolean {\n  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return false;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;\n  }) || false;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BoundTarget, ParseError, ParseSourceFile, R3TargetBinder, SchemaMetadata, TmplAstNode} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../../../src/ngtsc/diagnostics';\nimport {absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {NoopImportRewriter, Reference, ReferenceEmitter} from '../../imports';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {FileUpdate} from '../../program_driver';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ImportManager} from '../../translator';\nimport {TemplateDiagnostic, TemplateId, TemplateSourceMapping, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata, TypeCheckContext, TypeCheckingConfig, TypeCtorMetadata} from '../api';\nimport {makeTemplateDiagnostic} from '../diagnostics';\n\nimport {DomSchemaChecker, RegistryDomSchemaChecker} from './dom';\nimport {Environment} from './environment';\nimport {OutOfBandDiagnosticRecorder, OutOfBandDiagnosticRecorderImpl} from './oob';\nimport {TypeCheckShimGenerator} from './shim';\nimport {TemplateSourceManager} from './source';\nimport {requiresInlineTypeCheckBlock, TcbInliningRequirement} from './tcb_util';\nimport {generateTypeCheckBlock, TcbGenericContextBehavior} from './type_check_block';\nimport {TypeCheckFile} from './type_check_file';\nimport {generateInlineTypeCtor, requiresInlineTypeCtor} from './type_constructor';\n\nexport interface ShimTypeCheckingData {\n  /**\n   * Path to the shim file.\n   */\n  path: AbsoluteFsPath;\n\n  /**\n   * Any `ts.Diagnostic`s which were produced during the generation of this shim.\n   *\n   * Some diagnostics are produced during creation time and are tracked here.\n   */\n  genesisDiagnostics: TemplateDiagnostic[];\n\n  /**\n   * Whether any inline operations for the input file were required to generate this shim.\n   */\n  hasInlines: boolean;\n\n  /**\n   * Map of `TemplateId` to information collected about the template during the template\n   * type-checking process.\n   */\n  templates: Map<TemplateId, TemplateData>;\n}\n\n/**\n * Data tracked for each template processed by the template type-checking system.\n */\nexport interface TemplateData {\n  /**\n   * Template nodes for which the TCB was generated.\n   */\n  template: TmplAstNode[];\n\n  /**\n   * `BoundTarget` which was used to generate the TCB, and contains bindings for the associated\n   * template nodes.\n   */\n  boundTarget: BoundTarget<TypeCheckableDirectiveMeta>;\n\n  /**\n   * Errors found while parsing them template, which have been converted to diagnostics.\n   */\n  templateDiagnostics: TemplateDiagnostic[];\n}\n\n/**\n * Data for an input file which is still in the process of template type-checking code generation.\n */\nexport interface PendingFileTypeCheckingData {\n  /**\n   * Whether any inline code has been required by the shim yet.\n   */\n  hasInlines: boolean;\n\n  /**\n   * Source mapping information for mapping diagnostics from inlined type check blocks back to the\n   * original template.\n   */\n  sourceManager: TemplateSourceManager;\n\n  /**\n   * Map of in-progress shim data for shims generated from this input file.\n   */\n  shimData: Map<AbsoluteFsPath, PendingShimData>;\n}\n\nexport interface PendingShimData {\n  /**\n   * Recorder for out-of-band diagnostics which are raised during generation.\n   */\n  oobRecorder: OutOfBandDiagnosticRecorder;\n\n  /**\n   * The `DomSchemaChecker` in use for this template, which records any schema-related diagnostics.\n   */\n  domSchemaChecker: DomSchemaChecker;\n\n  /**\n   * Shim file in the process of being generated.\n   */\n  file: TypeCheckFile;\n\n\n  /**\n   * Map of `TemplateId` to information collected about the template as it's ingested.\n   */\n  templates: Map<TemplateId, TemplateData>;\n}\n\n/**\n * Adapts the `TypeCheckContextImpl` to the larger template type-checking system.\n *\n * Through this interface, a single `TypeCheckContextImpl` (which represents one \"pass\" of template\n * type-checking) requests information about the larger state of type-checking, as well as reports\n * back its results once finalized.\n */\nexport interface TypeCheckingHost {\n  /**\n   * Retrieve the `TemplateSourceManager` responsible for components in the given input file path.\n   */\n  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager;\n\n  /**\n   * Whether a particular component class should be included in the current type-checking pass.\n   *\n   * Not all components offered to the `TypeCheckContext` for checking may require processing. For\n   * example, the component may have results already available from a prior pass or from a previous\n   * program.\n   */\n  shouldCheckComponent(node: ts.ClassDeclaration): boolean;\n\n  /**\n   * Report data from a shim generated from the given input file path.\n   */\n  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void;\n\n  /**\n   * Record that all of the components within the given input file path had code generated - that\n   * is, coverage for the file can be considered complete.\n   */\n  recordComplete(sfPath: AbsoluteFsPath): void;\n}\n\n/**\n * How a type-checking context should handle operations which would require inlining.\n */\nexport enum InliningMode {\n  /**\n   * Use inlining operations when required.\n   */\n  InlineOps,\n\n  /**\n   * Produce diagnostics if an operation would require inlining.\n   */\n  Error,\n}\n\n/**\n * A template type checking context for a program.\n *\n * The `TypeCheckContext` allows registration of components and their templates which need to be\n * type checked.\n */\nexport class TypeCheckContextImpl implements TypeCheckContext {\n  private fileMap = new Map<AbsoluteFsPath, PendingFileTypeCheckingData>();\n\n  constructor(\n      private config: TypeCheckingConfig,\n      private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n      private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n      private host: TypeCheckingHost, private inlining: InliningMode, private perf: PerfRecorder) {\n    if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n      // We cannot use inlining for type checking since this environment does not support it.\n      throw new Error(`AssertionError: invalid inlining configuration.`);\n    }\n  }\n\n  /**\n   * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods\n   * or type-check blocks) that need to be eventually performed on that file.\n   */\n  private opMap = new Map<ts.SourceFile, Op[]>();\n\n  /**\n   * Tracks when an a particular class has a pending type constructor patching operation already\n   * queued.\n   */\n  private typeCtorPending = new Set<ts.ClassDeclaration>();\n\n  /**\n   * Register a template to potentially be type-checked.\n   *\n   * Implements `TypeCheckContext.addTemplate`.\n   */\n  addTemplate(\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      binder: R3TargetBinder<TypeCheckableDirectiveMeta>, template: TmplAstNode[],\n      pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n      schemas: SchemaMetadata[], sourceMapping: TemplateSourceMapping, file: ParseSourceFile,\n      parseErrors: ParseError[]|null, isStandalone: boolean): void {\n    if (!this.host.shouldCheckComponent(ref.node)) {\n      return;\n    }\n\n    const fileData = this.dataForFile(ref.node.getSourceFile());\n    const shimData = this.pendingShimForComponent(ref.node);\n    const templateId = fileData.sourceManager.getTemplateId(ref.node);\n\n    const templateDiagnostics: TemplateDiagnostic[] = [];\n\n    if (parseErrors !== null) {\n      templateDiagnostics.push(\n          ...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));\n    }\n\n    const boundTarget = binder.bind({template});\n\n    if (this.inlining === InliningMode.InlineOps) {\n      // Get all of the directives used in the template and record inline type constructors when\n      // required.\n      for (const dir of boundTarget.getUsedDirectives()) {\n        const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n        const dirNode = dirRef.node;\n\n        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector, shimData.file)) {\n          // inlining not required\n          continue;\n        }\n\n        // Add an inline type constructor operation for the directive.\n        this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n          fnName: 'ngTypeCtor',\n          // The constructor should have a body if the directive comes from a .ts file, but not if\n          // it comes from a .d.ts file. .d.ts declarations don't have bodies.\n          body: !dirNode.getSourceFile().isDeclarationFile,\n          fields: {\n            inputs: dir.inputs.classPropertyNames,\n            outputs: dir.outputs.classPropertyNames,\n            // TODO(alxhub): support queries\n            queries: dir.queries,\n          },\n          coercedInputFields: dir.coercedInputFields,\n        });\n      }\n    }\n\n    shimData.templates.set(templateId, {\n      template,\n      boundTarget,\n      templateDiagnostics,\n    });\n\n    const usedPipes: Reference<ClassDeclaration<ts.ClassDeclaration>>[] = [];\n    for (const name of boundTarget.getUsedPipes()) {\n      if (!pipes.has(name)) {\n        continue;\n      }\n      usedPipes.push(pipes.get(name)!);\n    }\n\n    const inliningRequirement =\n        requiresInlineTypeCheckBlock(ref, shimData.file, usedPipes, this.reflector);\n\n    // If inlining is not supported, but is required for either the TCB or one of its directive\n    // dependencies, then exit here with an error.\n    if (this.inlining === InliningMode.Error &&\n        inliningRequirement === TcbInliningRequirement.MustInline) {\n      // This template cannot be supported because the underlying strategy does not support inlining\n      // and inlining would be required.\n\n      // Record diagnostics to indicate the issues with this template.\n      shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n\n      // Checking this template would be unsupported, so don't try.\n      this.perf.eventCount(PerfEvent.SkipGenerateTcbNoInline);\n      return;\n    }\n\n    const meta = {\n      id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),\n      boundTarget,\n      pipes,\n      schemas,\n      isStandalone\n    };\n    this.perf.eventCount(PerfEvent.GenerateTcb);\n    if (inliningRequirement !== TcbInliningRequirement.None &&\n        this.inlining === InliningMode.InlineOps) {\n      // This class didn't meet the requirements for external type checking, so generate an inline\n      // TCB for the class.\n      this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);\n    } else if (\n        inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds &&\n        this.inlining === InliningMode.Error) {\n      // It's suggested that this TCB should be generated inline due to the component's generic\n      // bounds, but inlining is not supported by the current environment. Use a non-inline type\n      // check block, but fall back to `any` generic parameters since the generic bounds can't be\n      // referenced in that context. This will infer a less useful type for the component, but allow\n      // for type-checking it in an environment where that would not be possible otherwise.\n      shimData.file.addTypeCheckBlock(\n          ref, meta, shimData.domSchemaChecker, shimData.oobRecorder,\n          TcbGenericContextBehavior.FallbackToAny);\n    } else {\n      shimData.file.addTypeCheckBlock(\n          ref, meta, shimData.domSchemaChecker, shimData.oobRecorder,\n          TcbGenericContextBehavior.UseEmitter);\n    }\n  }\n\n  /**\n   * Record a type constructor for the given `node` with the given `ctorMetadata`.\n   */\n  addInlineTypeCtor(\n      fileData: PendingFileTypeCheckingData, sf: ts.SourceFile,\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, ctorMeta: TypeCtorMetadata): void {\n    if (this.typeCtorPending.has(ref.node)) {\n      return;\n    }\n    this.typeCtorPending.add(ref.node);\n\n    // Lazily construct the operation map.\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf)!;\n\n    // Push a `TypeCtorOp` into the operation queue for the source file.\n    ops.push(new TypeCtorOp(ref, ctorMeta));\n    fileData.hasInlines = true;\n  }\n\n  /**\n   * Transform a `ts.SourceFile` into a version that includes type checking code.\n   *\n   * If this particular `ts.SourceFile` requires changes, the text representing its new contents\n   * will be returned. Otherwise, a `null` return indicates no changes were necessary.\n   */\n  transform(sf: ts.SourceFile): string|null {\n    // If there are no operations pending for this particular file, return `null` to indicate no\n    // changes.\n    if (!this.opMap.has(sf)) {\n      return null;\n    }\n\n    // Imports may need to be added to the file to support type-checking of directives used in the\n    // template within it.\n    const importManager = new ImportManager(new NoopImportRewriter(), '_i');\n\n    // Each Op has a splitPoint index into the text where it needs to be inserted. Split the\n    // original source text into chunks at these split points, where code will be inserted between\n    // the chunks.\n    const ops = this.opMap.get(sf)!.sort(orderOps);\n    const textParts = splitStringAtPoints(sf.text, ops.map(op => op.splitPoint));\n\n    // Use a `ts.Printer` to generate source code.\n    const printer = ts.createPrinter({omitTrailingSemicolon: true});\n\n    // Begin with the initial section of the code text.\n    let code = textParts[0];\n\n    // Process each operation and use the printer to generate source code for it, inserting it into\n    // the source code in between the original chunks.\n    ops.forEach((op, idx) => {\n      const text = op.execute(importManager, sf, this.refEmitter, printer);\n      code += '\\n\\n' + text + textParts[idx + 1];\n    });\n\n    // Write out the imports that need to be added to the beginning of the file.\n    let imports = importManager.getAllImports(sf.fileName)\n                      .map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`)\n                      .join('\\n');\n    code = imports + '\\n' + code;\n\n    return code;\n  }\n\n  finalize(): Map<AbsoluteFsPath, FileUpdate> {\n    // First, build the map of updates to source files.\n    const updates = new Map<AbsoluteFsPath, FileUpdate>();\n    for (const originalSf of this.opMap.keys()) {\n      const newText = this.transform(originalSf);\n      if (newText !== null) {\n        updates.set(absoluteFromSourceFile(originalSf), {\n          newText,\n          originalFile: originalSf,\n        });\n      }\n    }\n\n    // Then go through each input file that has pending code generation operations.\n    for (const [sfPath, pendingFileData] of this.fileMap) {\n      // For each input file, consider generation operations for each of its shims.\n      for (const pendingShimData of pendingFileData.shimData.values()) {\n        this.host.recordShimData(sfPath, {\n          genesisDiagnostics: [\n            ...pendingShimData.domSchemaChecker.diagnostics,\n            ...pendingShimData.oobRecorder.diagnostics,\n          ],\n          hasInlines: pendingFileData.hasInlines,\n          path: pendingShimData.file.fileName,\n          templates: pendingShimData.templates,\n        });\n        const sfText = pendingShimData.file.render(false /* removeComments */);\n        updates.set(pendingShimData.file.fileName, {\n          newText: sfText,\n\n          // Shim files do not have an associated original file.\n          originalFile: null,\n        });\n      }\n    }\n\n    return updates;\n  }\n\n  private addInlineTypeCheckBlock(\n      fileData: PendingFileTypeCheckingData, shimData: PendingShimData,\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      tcbMeta: TypeCheckBlockMetadata): void {\n    const sf = ref.node.getSourceFile();\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf)!;\n    ops.push(new InlineTcbOp(\n        ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker,\n        shimData.oobRecorder));\n    fileData.hasInlines = true;\n  }\n\n  private pendingShimForComponent(node: ts.ClassDeclaration): PendingShimData {\n    const fileData = this.dataForFile(node.getSourceFile());\n    const shimPath = TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(node.getSourceFile()));\n    if (!fileData.shimData.has(shimPath)) {\n      fileData.shimData.set(shimPath, {\n        domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),\n        oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),\n        file: new TypeCheckFile(\n            shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),\n        templates: new Map<TemplateId, TemplateData>(),\n      });\n    }\n    return fileData.shimData.get(shimPath)!;\n  }\n\n  private dataForFile(sf: ts.SourceFile): PendingFileTypeCheckingData {\n    const sfPath = absoluteFromSourceFile(sf);\n\n    if (!this.fileMap.has(sfPath)) {\n      const data: PendingFileTypeCheckingData = {\n        hasInlines: false,\n        sourceManager: this.host.getSourceManager(sfPath),\n        shimData: new Map(),\n      };\n      this.fileMap.set(sfPath, data);\n    }\n\n    return this.fileMap.get(sfPath)!;\n  }\n\n  private getTemplateDiagnostics(\n      parseErrors: ParseError[], templateId: TemplateId,\n      sourceMapping: TemplateSourceMapping): TemplateDiagnostic[] {\n    return parseErrors.map(error => {\n      const span = error.span;\n\n      if (span.start.offset === span.end.offset) {\n        // Template errors can contain zero-length spans, if the error occurs at a single point.\n        // However, TypeScript does not handle displaying a zero-length diagnostic very well, so\n        // increase the ending offset by 1 for such errors, to ensure the position is shown in the\n        // diagnostic.\n        span.end.offset++;\n      }\n\n      return makeTemplateDiagnostic(\n          templateId, sourceMapping, span, ts.DiagnosticCategory.Error,\n          ngErrorCode(ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);\n    });\n  }\n}\n\n/**\n * A code generation operation that needs to happen within a given source file.\n */\ninterface Op {\n  /**\n   * The node in the file which will have code generated for it.\n   */\n  readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>;\n\n  /**\n   * Index into the source text where the code generated by the operation should be inserted.\n   */\n  readonly splitPoint: number;\n\n  /**\n   * Execute the operation and return the generated code as text.\n   */\n  execute(im: ImportManager, sf: ts.SourceFile, refEmitter: ReferenceEmitter, printer: ts.Printer):\n      string;\n}\n\n/**\n * A type check block operation which produces inline type check code for a particular component.\n */\nclass InlineTcbOp implements Op {\n  constructor(\n      readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      readonly meta: TypeCheckBlockMetadata, readonly config: TypeCheckingConfig,\n      readonly reflector: ReflectionHost, readonly domSchemaChecker: DomSchemaChecker,\n      readonly oobRecorder: OutOfBandDiagnosticRecorder) {}\n\n  /**\n   * Type check blocks are inserted immediately after the end of the component class.\n   */\n  get splitPoint(): number {\n    return this.ref.node.end + 1;\n  }\n\n  execute(im: ImportManager, sf: ts.SourceFile, refEmitter: ReferenceEmitter, printer: ts.Printer):\n      string {\n    const env = new Environment(this.config, im, refEmitter, this.reflector, sf);\n    const fnName = ts.factory.createIdentifier(`_tcb_${this.ref.node.pos}`);\n\n    // Inline TCBs should copy any generic type parameter nodes directly, as the TCB code is inlined\n    // into the class in a context where that will always be legal.\n    const fn = generateTypeCheckBlock(\n        env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder,\n        TcbGenericContextBehavior.CopyClassNodes);\n    return printer.printNode(ts.EmitHint.Unspecified, fn, sf);\n  }\n}\n\n/**\n * A type constructor operation which produces type constructor code for a particular directive.\n */\nclass TypeCtorOp implements Op {\n  constructor(\n      readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      readonly meta: TypeCtorMetadata) {}\n\n  /**\n   * Type constructor operations are inserted immediately before the end of the directive class.\n   */\n  get splitPoint(): number {\n    return this.ref.node.end - 1;\n  }\n\n  execute(im: ImportManager, sf: ts.SourceFile, refEmitter: ReferenceEmitter, printer: ts.Printer):\n      string {\n    const tcb = generateInlineTypeCtor(this.ref.node, this.meta);\n    return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);\n  }\n}\n\n/**\n * Compare two operations and return their split point ordering.\n */\nfunction orderOps(op1: Op, op2: Op): number {\n  return op1.splitPoint - op2.splitPoint;\n}\n\n/**\n * Split a string into chunks at any number of split points.\n */\nfunction splitStringAtPoints(str: string, points: number[]): string[] {\n  const splits: string[] = [];\n  let start = 0;\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    splits.push(str.substring(start, point));\n    start = point;\n  }\n  splits.push(str.substring(start));\n  return splits;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DomElementSchemaRegistry, ParseSourceSpan, SchemaMetadata, TmplAstElement} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {TemplateDiagnostic, TemplateId} from '../api';\nimport {makeTemplateDiagnostic} from '../diagnostics';\n\nimport {TemplateSourceResolver} from './tcb_util';\n\nconst REGISTRY = new DomElementSchemaRegistry();\nconst REMOVE_XHTML_REGEX = /^:xhtml:/;\n\n/**\n * Checks every non-Angular element/property processed in a template and potentially produces\n * `ts.Diagnostic`s related to improper usage.\n *\n * A `DomSchemaChecker`'s job is to check DOM nodes and their attributes written used in templates\n * and produce `ts.Diagnostic`s if the nodes don't conform to the DOM specification. It acts as a\n * collector for these diagnostics, and can be queried later to retrieve the list of any that have\n * been generated.\n */\nexport interface DomSchemaChecker {\n  /**\n   * Get the `ts.Diagnostic`s that have been generated via `checkElement` and `checkProperty` calls\n   * thus far.\n   */\n  readonly diagnostics: ReadonlyArray<TemplateDiagnostic>;\n\n  /**\n   * Check a non-Angular element and record any diagnostics about it.\n   *\n   * @param id the template ID, suitable for resolution with a `TcbSourceResolver`.\n   * @param element the element node in question.\n   * @param schemas any active schemas for the template, which might affect the validity of the\n   * element.\n   * @param hostIsStandalone boolean indicating whether the element's host is a standalone\n   *     component.\n   */\n  checkElement(\n      id: string, element: TmplAstElement, schemas: SchemaMetadata[],\n      hostIsStandalone: boolean): void;\n\n  /**\n   * Check a property binding on an element and record any diagnostics about it.\n   *\n   * @param id the template ID, suitable for resolution with a `TcbSourceResolver`.\n   * @param element the element node in question.\n   * @param name the name of the property being checked.\n   * @param span the source span of the binding. This is redundant with `element.attributes` but is\n   * passed separately to avoid having to look up the particular property name.\n   * @param schemas any active schemas for the template, which might affect the validity of the\n   * property.\n   */\n  checkProperty(\n      id: string, element: TmplAstElement, name: string, span: ParseSourceSpan,\n      schemas: SchemaMetadata[], hostIsStandalone: boolean): void;\n}\n\n/**\n * Checks non-Angular elements and properties against the `DomElementSchemaRegistry`, a schema\n * maintained by the Angular team via extraction from a browser IDL.\n */\nexport class RegistryDomSchemaChecker implements DomSchemaChecker {\n  private _diagnostics: TemplateDiagnostic[] = [];\n\n  get diagnostics(): ReadonlyArray<TemplateDiagnostic> {\n    return this._diagnostics;\n  }\n\n  constructor(private resolver: TemplateSourceResolver) {}\n\n  checkElement(\n      id: TemplateId, element: TmplAstElement, schemas: SchemaMetadata[],\n      hostIsStandalone: boolean): void {\n    // HTML elements inside an SVG `foreignObject` are declared in the `xhtml` namespace.\n    // We need to strip it before handing it over to the registry because all HTML tag names\n    // in the registry are without a namespace.\n    const name = element.name.replace(REMOVE_XHTML_REGEX, '');\n\n    if (!REGISTRY.hasElement(name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n\n      const schemas = `'${hostIsStandalone ? '@Component' : '@NgModule'}.schemas'`;\n      let errorMsg = `'${name}' is not a known element:\\n`;\n      errorMsg += `1. If '${name}' is an Angular component, then verify that it is ${\n          hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                             'part of this module'}.\\n`;\n      if (name.indexOf('-') > -1) {\n        errorMsg += `2. If '${name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${\n            schemas} of this component to suppress this message.`;\n      } else {\n        errorMsg +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n      }\n\n      const diag = makeTemplateDiagnostic(\n          id, mapping, element.startSourceSpan, ts.DiagnosticCategory.Error,\n          ngErrorCode(ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n\n  checkProperty(\n      id: TemplateId, element: TmplAstElement, name: string, span: ParseSourceSpan,\n      schemas: SchemaMetadata[], hostIsStandalone: boolean): void {\n    if (!REGISTRY.hasProperty(element.name, name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n\n      const decorator = hostIsStandalone ? '@Component' : '@NgModule';\n      const schemas = `'${decorator}.schemas'`;\n      let errorMsg =\n          `Can't bind to '${name}' since it isn't a known property of '${element.name}'.`;\n      if (element.name.startsWith('ng-')) {\n        errorMsg += `\\n1. If '${name}' is an Angular directive, then add 'CommonModule' to the '${\n                        decorator}.imports' of this component.` +\n            `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${\n                        schemas} of this component.`;\n      } else if (element.name.indexOf('-') > -1) {\n        errorMsg +=\n            `\\n1. If '${element.name}' is an Angular component and it has '${\n                name}' input, then verify that it is ${\n                hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                                   'part of this module'}.` +\n            `\\n2. If '${\n                element.name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${\n                schemas} of this component to suppress this message.` +\n            `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${\n                schemas} of this component.`;\n      }\n\n      const diag = makeTemplateDiagnostic(\n          id, mapping, span, ts.DiagnosticCategory.Error,\n          ngErrorCode(ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ExpressionType, ExternalExpr, Type, TypeModifier} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {assertSuccessfulReferenceEmit, ImportFlags, Reference, ReferenceEmitKind, ReferenceEmitter} from '../../imports';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ImportManager, translateExpression, translateType} from '../../translator';\nimport {TypeCheckableDirectiveMeta, TypeCheckingConfig, TypeCtorMetadata} from '../api';\n\nimport {ReferenceEmitEnvironment} from './tcb_util';\nimport {tsDeclareVariable} from './ts_util';\nimport {generateTypeCtorDeclarationFn, requiresInlineTypeCtor} from './type_constructor';\nimport {TypeParameterEmitter} from './type_parameter_emitter';\n\n/**\n * A context which hosts one or more Type Check Blocks (TCBs).\n *\n * An `Environment` supports the generation of TCBs by tracking necessary imports, declarations of\n * type constructors, and other statements beyond the type-checking code within the TCB itself.\n * Through method calls on `Environment`, the TCB generator can request `ts.Expression`s which\n * reference declarations in the `Environment` for these artifacts`.\n *\n * `Environment` can be used in a standalone fashion, or can be extended to support more specialized\n * usage.\n */\nexport class Environment implements ReferenceEmitEnvironment {\n  private nextIds = {\n    pipeInst: 1,\n    typeCtor: 1,\n  };\n\n  private typeCtors = new Map<ClassDeclaration, ts.Expression>();\n  protected typeCtorStatements: ts.Statement[] = [];\n\n  private pipeInsts = new Map<ClassDeclaration, ts.Expression>();\n  protected pipeInstStatements: ts.Statement[] = [];\n\n  constructor(\n      readonly config: TypeCheckingConfig, protected importManager: ImportManager,\n      private refEmitter: ReferenceEmitter, readonly reflector: ReflectionHost,\n      protected contextFile: ts.SourceFile) {}\n\n  /**\n   * Get an expression referring to a type constructor for the given directive.\n   *\n   * Depending on the shape of the directive itself, this could be either a reference to a declared\n   * type constructor, or to an inline type constructor.\n   */\n  typeCtorFor(dir: TypeCheckableDirectiveMeta): ts.Expression {\n    const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n    const node = dirRef.node;\n    if (this.typeCtors.has(node)) {\n      return this.typeCtors.get(node)!;\n    }\n\n    if (requiresInlineTypeCtor(node, this.reflector, this)) {\n      // The constructor has already been created inline, we just need to construct a reference to\n      // it.\n      const ref = this.reference(dirRef);\n      const typeCtorExpr = ts.factory.createPropertyAccessExpression(ref, 'ngTypeCtor');\n      this.typeCtors.set(node, typeCtorExpr);\n      return typeCtorExpr;\n    } else {\n      const fnName = `_ctor${this.nextIds.typeCtor++}`;\n      const nodeTypeRef = this.referenceType(dirRef);\n      if (!ts.isTypeReferenceNode(nodeTypeRef)) {\n        throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);\n      }\n      const meta: TypeCtorMetadata = {\n        fnName,\n        body: true,\n        fields: {\n          inputs: dir.inputs.classPropertyNames,\n          outputs: dir.outputs.classPropertyNames,\n          // TODO: support queries\n          queries: dir.queries,\n        },\n        coercedInputFields: dir.coercedInputFields,\n      };\n      const typeParams = this.emitTypeParameters(node);\n      const typeCtor = generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams);\n      this.typeCtorStatements.push(typeCtor);\n      const fnId = ts.factory.createIdentifier(fnName);\n      this.typeCtors.set(node, fnId);\n      return fnId;\n    }\n  }\n\n  /*\n   * Get an expression referring to an instance of the given pipe.\n   */\n  pipeInst(ref: Reference<ClassDeclaration<ts.ClassDeclaration>>): ts.Expression {\n    if (this.pipeInsts.has(ref.node)) {\n      return this.pipeInsts.get(ref.node)!;\n    }\n\n    const pipeType = this.referenceType(ref);\n    const pipeInstId = ts.factory.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);\n\n    this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));\n    this.pipeInsts.set(ref.node, pipeInstId);\n\n    return pipeInstId;\n  }\n\n  /**\n   * Generate a `ts.Expression` that references the given node.\n   *\n   * This may involve importing the node into the file if it's not declared there already.\n   */\n  reference(ref: Reference<ClassDeclaration<ts.ClassDeclaration>>): ts.Expression {\n    // Disable aliasing for imports generated in a template type-checking context, as there is no\n    // guarantee that any alias re-exports exist in the .d.ts files. It's safe to use direct imports\n    // in these cases as there is no strict dependency checking during the template type-checking\n    // pass.\n    const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, 'class');\n\n    // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n    return translateExpression(ngExpr.expression, this.importManager);\n  }\n\n  canReferenceType(ref: Reference): boolean {\n    const result = this.refEmitter.emit(\n        ref, this.contextFile,\n        ImportFlags.NoAliasing | ImportFlags.AllowTypeImports |\n            ImportFlags.AllowRelativeDtsImports);\n    return result.kind === ReferenceEmitKind.Success;\n  }\n\n  /**\n   * Generate a `ts.TypeNode` that references the given node as a type.\n   *\n   * This may involve importing the node into the file if it's not declared there already.\n   */\n  referenceType(ref: Reference): ts.TypeNode {\n    const ngExpr = this.refEmitter.emit(\n        ref, this.contextFile,\n        ImportFlags.NoAliasing | ImportFlags.AllowTypeImports |\n            ImportFlags.AllowRelativeDtsImports);\n    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, 'symbol');\n\n    // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.\n    // TODO(alxhub): support references to types with generic arguments in a clean way.\n    return translateType(new ExpressionType(ngExpr.expression), this.importManager);\n  }\n\n  private emitTypeParameters(declaration: ClassDeclaration<ts.ClassDeclaration>):\n      ts.TypeParameterDeclaration[]|undefined {\n    const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);\n    return emitter.emit(ref => this.referenceType(ref));\n  }\n\n  /**\n   * Generate a `ts.TypeNode` that references a given type from the provided module.\n   *\n   * This will involve importing the type into the file, and will also add type parameters if\n   * provided.\n   */\n  referenceExternalType(moduleName: string, name: string, typeParams?: Type[]): ts.TypeNode {\n    const external = new ExternalExpr({moduleName, name});\n    return translateType(\n        new ExpressionType(external, /* modifiers */ TypeModifier.None, typeParams),\n        this.importManager);\n  }\n\n  getPreludeStatements(): ts.Statement[] {\n    return [\n      ...this.pipeInstStatements,\n      ...this.typeCtorStatements,\n    ];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n\n/**\n * A `Set` of `ts.SyntaxKind`s of `ts.Expression` which are safe to wrap in a `ts.AsExpression`\n * without needing to be wrapped in parentheses.\n *\n * For example, `foo.bar()` is a `ts.CallExpression`, and can be safely cast to `any` with\n * `foo.bar() as any`. however, `foo !== bar` is a `ts.BinaryExpression`, and attempting to cast\n * without the parentheses yields the expression `foo !== bar as any`. This is semantically\n * equivalent to `foo !== (bar as any)`, which is not what was intended. Thus,\n * `ts.BinaryExpression`s need to be wrapped in parentheses before casting.\n */\n//\nconst SAFE_TO_CAST_WITHOUT_PARENS: Set<ts.SyntaxKind> = new Set([\n  // Expressions which are already parenthesized can be cast without further wrapping.\n  ts.SyntaxKind.ParenthesizedExpression,\n\n  // Expressions which form a single lexical unit leave no room for precedence issues with the cast.\n  ts.SyntaxKind.Identifier,\n  ts.SyntaxKind.CallExpression,\n  ts.SyntaxKind.NonNullExpression,\n  ts.SyntaxKind.ElementAccessExpression,\n  ts.SyntaxKind.PropertyAccessExpression,\n  ts.SyntaxKind.ArrayLiteralExpression,\n  ts.SyntaxKind.ObjectLiteralExpression,\n\n  // The same goes for various literals.\n  ts.SyntaxKind.StringLiteral,\n  ts.SyntaxKind.NumericLiteral,\n  ts.SyntaxKind.TrueKeyword,\n  ts.SyntaxKind.FalseKeyword,\n  ts.SyntaxKind.NullKeyword,\n  ts.SyntaxKind.UndefinedKeyword,\n]);\n\nexport function tsCastToAny(expr: ts.Expression): ts.Expression {\n  // Wrap `expr` in parentheses if needed (see `SAFE_TO_CAST_WITHOUT_PARENS` above).\n  if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {\n    expr = ts.factory.createParenthesizedExpression(expr);\n  }\n\n  // The outer expression is always wrapped in parentheses.\n  return ts.factory.createParenthesizedExpression(ts.factory.createAsExpression(\n      expr, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));\n}\n\n\n/**\n * Create an expression which instantiates an element by its HTML tagName.\n *\n * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred\n * based on the tag name, including for custom elements that have appropriate .d.ts definitions.\n */\nexport function tsCreateElement(tagName: string): ts.Expression {\n  const createElement = ts.factory.createPropertyAccessExpression(\n      /* expression */ ts.factory.createIdentifier('document'), 'createElement');\n  return ts.factory.createCallExpression(\n      /* expression */ createElement,\n      /* typeArguments */ undefined,\n      /* argumentsArray */[ts.factory.createStringLiteral(tagName)]);\n}\n\n/**\n * Create a `ts.VariableStatement` which declares a variable without explicit initialization.\n *\n * The initializer `null!` is used to bypass strict variable initialization checks.\n *\n * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.\n */\nexport function tsDeclareVariable(id: ts.Identifier, type: ts.TypeNode): ts.VariableStatement {\n  const decl = ts.factory.createVariableDeclaration(\n      /* name */ id,\n      /* exclamationToken */ undefined,\n      /* type */ type,\n      /* initializer */ ts.factory.createNonNullExpression(ts.factory.createNull()));\n  return ts.factory.createVariableStatement(\n      /* modifiers */ undefined,\n      /* declarationList */[decl]);\n}\n\n/**\n * Creates a `ts.TypeQueryNode` for a coerced input.\n *\n * For example: `typeof MatInput.ngAcceptInputType_value`, where MatInput is `typeName` and `value`\n * is the `coercedInputName`.\n *\n * @param typeName The `EntityName` of the Directive where the static coerced input is defined.\n * @param coercedInputName The field name of the coerced input.\n */\nexport function tsCreateTypeQueryForCoercedInput(\n    typeName: ts.EntityName, coercedInputName: string): ts.TypeQueryNode {\n  return ts.factory.createTypeQueryNode(\n      ts.factory.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));\n}\n\n/**\n * Create a `ts.VariableStatement` that initializes a variable with a given expression.\n *\n * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer\n * expression.\n */\nexport function tsCreateVariable(\n    id: ts.Identifier, initializer: ts.Expression): ts.VariableStatement {\n  const decl = ts.factory.createVariableDeclaration(\n      /* name */ id,\n      /* exclamationToken */ undefined,\n      /* type */ undefined,\n      /* initializer */ initializer);\n  return ts.factory.createVariableStatement(\n      /* modifiers */ undefined,\n      /* declarationList */[decl]);\n}\n\n/**\n * Construct a `ts.CallExpression` that calls a method on a receiver.\n */\nexport function tsCallMethod(\n    receiver: ts.Expression, methodName: string, args: ts.Expression[] = []): ts.CallExpression {\n  const methodAccess = ts.factory.createPropertyAccessExpression(receiver, methodName);\n  return ts.factory.createCallExpression(\n      /* expression */ methodAccess,\n      /* typeArguments */ undefined,\n      /* argumentsArray */ args);\n}\n\nexport function isAccessExpression(node: ts.Node): node is ts.ElementAccessExpression|\n    ts.PropertyAccessExpression {\n  return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {TypeCtorMetadata} from '../api';\n\nimport {checkIfGenericTypeBoundsCanBeEmitted, ReferenceEmitEnvironment} from './tcb_util';\nimport {tsCreateTypeQueryForCoercedInput} from './ts_util';\n\nexport function generateTypeCtorDeclarationFn(\n    node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata, nodeTypeRef: ts.EntityName,\n    typeParams: ts.TypeParameterDeclaration[]|undefined): ts.Statement {\n  const rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;\n  const rawType = ts.factory.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);\n\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n\n  const typeParameters = typeParametersWithDefaultTypes(typeParams);\n\n  if (meta.body) {\n    const fnType = ts.factory.createFunctionTypeNode(\n        /* typeParameters */ typeParameters,\n        /* parameters */[initParam],\n        /* type */ rawType,\n    );\n\n    const decl = ts.factory.createVariableDeclaration(\n        /* name */ meta.fnName,\n        /* exclamationToken */ undefined,\n        /* type */ fnType,\n        /* body */ ts.factory.createNonNullExpression(ts.factory.createNull()));\n    const declList = ts.factory.createVariableDeclarationList([decl], ts.NodeFlags.Const);\n    return ts.factory.createVariableStatement(\n        /* modifiers */ undefined,\n        /* declarationList */ declList);\n  } else {\n    return ts.factory.createFunctionDeclaration(\n        /* modifiers */[ts.factory.createModifier(ts.SyntaxKind.DeclareKeyword)],\n        /* asteriskToken */ undefined,\n        /* name */ meta.fnName,\n        /* typeParameters */ typeParameters,\n        /* parameters */[initParam],\n        /* type */ rawType,\n        /* body */ undefined);\n  }\n}\n\n/**\n * Generate an inline type constructor for the given class and metadata.\n *\n * An inline type constructor is a specially shaped TypeScript static method, intended to be placed\n * within a directive class itself, that permits type inference of any generic type parameters of\n * the class from the types of expressions bound to inputs or outputs, and the types of elements\n * that match queries performed by the directive. It also catches any errors in the types of these\n * expressions. This method is never called at runtime, but is used in type-check blocks to\n * construct directive types.\n *\n * An inline type constructor for NgFor looks like:\n *\n * static ngTypeCtor<T>(init: Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):\n *   NgForOf<T>;\n *\n * A typical constructor would be:\n *\n * NgForOf.ngTypeCtor(init: {\n *   ngForOf: ['foo', 'bar'],\n *   ngForTrackBy: null as any,\n *   ngForTemplate: null as any,\n * }); // Infers a type of NgForOf<string>.\n *\n * Any inputs declared on the type for which no property binding is present are assigned a value of\n * type `any`, to avoid producing any type errors for unset inputs.\n *\n * Inline type constructors are used when the type being created has bounded generic types which\n * make writing a declared type constructor (via `generateTypeCtorDeclarationFn`) difficult or\n * impossible.\n *\n * @param node the `ClassDeclaration<ts.ClassDeclaration>` for which a type constructor will be\n * generated.\n * @param meta additional metadata required to generate the type constructor.\n * @returns a `ts.MethodDeclaration` for the type constructor.\n */\nexport function generateInlineTypeCtor(\n    node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata): ts.MethodDeclaration {\n  // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from\n  // the definition without any type bounds. For example, if the class is\n  // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.\n  const rawTypeArgs =\n      node.typeParameters !== undefined ? generateGenericArgs(node.typeParameters) : undefined;\n  const rawType = ts.factory.createTypeReferenceNode(node.name, rawTypeArgs);\n\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n\n  // If this constructor is being generated into a .ts file, then it needs a fake body. The body\n  // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,\n  // it needs no body.\n  let body: ts.Block|undefined = undefined;\n  if (meta.body) {\n    body = ts.factory.createBlock([\n      ts.factory.createReturnStatement(ts.factory.createNonNullExpression(ts.factory.createNull())),\n    ]);\n  }\n\n  // Create the type constructor method declaration.\n  return ts.factory.createMethodDeclaration(\n      /* modifiers */[ts.factory.createModifier(ts.SyntaxKind.StaticKeyword)],\n      /* asteriskToken */ undefined,\n      /* name */ meta.fnName,\n      /* questionToken */ undefined,\n      /* typeParameters */ typeParametersWithDefaultTypes(node.typeParameters),\n      /* parameters */[initParam],\n      /* type */ rawType,\n      /* body */ body,\n  );\n}\n\nfunction constructTypeCtorParameter(\n    node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata,\n    rawType: ts.TypeReferenceNode): ts.ParameterDeclaration {\n  // initType is the type of 'init', the single argument to the type constructor method.\n  // If the Directive has any inputs, its initType will be:\n  //\n  // Pick<rawType, 'inputA'|'inputB'>\n  //\n  // Pick here is used to select only those fields from which the generic type parameters of the\n  // directive will be inferred.\n  //\n  // In the special case there are no inputs, initType is set to {}.\n  let initType: ts.TypeNode|null = null;\n\n  const keys: string[] = meta.fields.inputs;\n  const plainKeys: ts.LiteralTypeNode[] = [];\n  const coercedKeys: ts.PropertySignature[] = [];\n  for (const key of keys) {\n    if (!meta.coercedInputFields.has(key)) {\n      plainKeys.push(ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(key)));\n    } else {\n      coercedKeys.push(ts.factory.createPropertySignature(\n          /* modifiers */ undefined,\n          /* name */ key,\n          /* questionToken */ undefined,\n          /* type */ tsCreateTypeQueryForCoercedInput(rawType.typeName, key)));\n    }\n  }\n  if (plainKeys.length > 0) {\n    // Construct a union of all the field names.\n    const keyTypeUnion = ts.factory.createUnionTypeNode(plainKeys);\n\n    // Construct the Pick<rawType, keyTypeUnion>.\n    initType = ts.factory.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);\n  }\n  if (coercedKeys.length > 0) {\n    const coercedLiteral = ts.factory.createTypeLiteralNode(coercedKeys);\n\n    initType = initType !== null ?\n        ts.factory.createIntersectionTypeNode([initType, coercedLiteral]) :\n        coercedLiteral;\n  }\n\n  if (initType === null) {\n    // Special case - no inputs, outputs, or other fields which could influence the result type.\n    initType = ts.factory.createTypeLiteralNode([]);\n  }\n\n  // Create the 'init' parameter itself.\n  return ts.factory.createParameterDeclaration(\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ 'init',\n      /* questionToken */ undefined,\n      /* type */ initType,\n      /* initializer */ undefined);\n}\n\nfunction generateGenericArgs(params: ReadonlyArray<ts.TypeParameterDeclaration>): ts.TypeNode[] {\n  return params.map(param => ts.factory.createTypeReferenceNode(param.name, undefined));\n}\n\nexport function requiresInlineTypeCtor(\n    node: ClassDeclaration<ts.ClassDeclaration>, host: ReflectionHost,\n    env: ReferenceEmitEnvironment): boolean {\n  // The class requires an inline type constructor if it has generic type bounds that can not be\n  // emitted into the provided type-check environment.\n  return !checkIfGenericTypeBoundsCanBeEmitted(node, host, env);\n}\n\n/**\n * Add a default `= any` to type parameters that don't have a default value already.\n *\n * TypeScript uses the default type of a type parameter whenever inference of that parameter fails.\n * This can happen when inferring a complex type from 'any'. For example, if `NgFor`'s inference is\n * done with the TCB code:\n *\n * ```\n * class NgFor<T> {\n *   ngForOf: T[];\n * }\n *\n * declare function ctor<T>(o: Pick<NgFor<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>): NgFor<T>;\n * ```\n *\n * An invocation looks like:\n *\n * ```\n * var _t1 = ctor({ngForOf: [1, 2], ngForTrackBy: null as any, ngForTemplate: null as any});\n * ```\n *\n * This correctly infers the type `NgFor<number>` for `_t1`, since `T` is inferred from the\n * assignment of type `number[]` to `ngForOf`'s type `T[]`. However, if `any` is passed instead:\n *\n * ```\n * var _t2 = ctor({ngForOf: [1, 2] as any, ngForTrackBy: null as any, ngForTemplate: null as any});\n * ```\n *\n * then inference for `T` fails (it cannot be inferred from `T[] = any`). In this case, `T` takes\n * the type `{}`, and so `_t2` is inferred as `NgFor<{}>`. This is obviously wrong.\n *\n * Adding a default type to the generic declaration in the constructor solves this problem, as the\n * default type will be used in the event that inference fails.\n *\n * ```\n * declare function ctor<T = any>(o: Pick<NgFor<T>, 'ngForOf'>): NgFor<T>;\n *\n * var _t3 = ctor({ngForOf: [1, 2] as any});\n * ```\n *\n * This correctly infers `T` as `any`, and therefore `_t3` as `NgFor<any>`.\n */\nfunction typeParametersWithDefaultTypes(params: ReadonlyArray<ts.TypeParameterDeclaration>|\n                                        undefined): ts.TypeParameterDeclaration[]|undefined {\n  if (params === undefined) {\n    return undefined;\n  }\n\n  return params.map(param => {\n    if (param.default === undefined) {\n      return ts.factory.updateTypeParameterDeclaration(\n          param, param.modifiers, param.name, param.constraint,\n          ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n    } else {\n      return param;\n    }\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ClassDeclaration, ReflectionHost} from '../../../../src/ngtsc/reflection';\nimport {Reference} from '../../imports';\nimport {getTokenAtPosition} from '../../util/src/typescript';\nimport {FullTemplateMapping, SourceLocation, TemplateId, TemplateSourceMapping} from '../api';\n\nimport {hasIgnoreForDiagnosticsMarker, readSpanComment} from './comments';\nimport {TypeParameterEmitter} from './type_parameter_emitter';\n\n/**\n * Represents the origin environment from where reference will be emitted. This interface exists\n * as an indirection for the `Environment` type, which would otherwise introduce a (type-only)\n * import cycle.\n */\nexport interface ReferenceEmitEnvironment {\n  canReferenceType(ref: Reference): boolean;\n}\n\n/**\n * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n * in a TCB and map them back to original locations in the template.\n */\nexport interface TemplateSourceResolver {\n  getTemplateId(node: ts.ClassDeclaration): TemplateId;\n\n  /**\n   * For the given template id, retrieve the original source mapping which describes how the offsets\n   * in the template should be interpreted.\n   */\n  getSourceMapping(id: TemplateId): TemplateSourceMapping;\n\n  /**\n   * Convert an absolute source span associated with the given template id into a full\n   * `ParseSourceSpan`. The returned parse span has line and column numbers in addition to only\n   * absolute offsets and gives access to the original template source.\n   */\n  toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null;\n}\n\n/**\n * Indicates whether a particular component requires an inline type check block.\n *\n * This is not a boolean state as inlining might only be required to get the best possible\n * type-checking, but the component could theoretically still be checked without it.\n */\nexport enum TcbInliningRequirement {\n  /**\n   * There is no way to type check this component without inlining.\n   */\n  MustInline,\n\n  /**\n   * Inlining should be used due to the component's generic bounds, but a non-inlining fallback\n   * method can be used if that's not possible.\n   */\n  ShouldInlineForGenericBounds,\n\n  /**\n   * There is no requirement for this component's TCB to be inlined.\n   */\n  None,\n}\n\nexport function requiresInlineTypeCheckBlock(\n    ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, env: ReferenceEmitEnvironment,\n    usedPipes: Reference<ClassDeclaration<ts.ClassDeclaration>>[],\n    reflector: ReflectionHost): TcbInliningRequirement {\n  // In order to qualify for a declared TCB (not inline) two conditions must be met:\n  // 1) the class must be suitable to be referenced from `env` (e.g. it must be exported)\n  // 2) it must not have contextual generic type bounds\n  if (!env.canReferenceType(ref)) {\n    // Condition 1 is false, the class is not exported.\n    return TcbInliningRequirement.MustInline;\n  } else if (!checkIfGenericTypeBoundsCanBeEmitted(ref.node, reflector, env)) {\n    // Condition 2 is false, the class has constrained generic types. It should be checked with an\n    // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.\n    return TcbInliningRequirement.ShouldInlineForGenericBounds;\n  } else if (usedPipes.some(pipeRef => !env.canReferenceType(pipeRef))) {\n    // If one of the pipes used by the component is not exported, a non-inline TCB will not be able\n    // to import it, so this requires an inline TCB.\n    return TcbInliningRequirement.MustInline;\n  } else {\n    return TcbInliningRequirement.None;\n  }\n}\n\n/** Maps a shim position back to a template location. */\nexport function getTemplateMapping(\n    shimSf: ts.SourceFile, position: number, resolver: TemplateSourceResolver,\n    isDiagnosticRequest: boolean): FullTemplateMapping|null {\n  const node = getTokenAtPosition(shimSf, position);\n  const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);\n  if (sourceLocation === null) {\n    return null;\n  }\n\n  const mapping = resolver.getSourceMapping(sourceLocation.id);\n  const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n  if (span === null) {\n    return null;\n  }\n  // TODO(atscott): Consider adding a context span by walking up from `node` until we get a\n  // different span.\n  return {sourceLocation, templateSourceMapping: mapping, span};\n}\n\nexport function findTypeCheckBlock(\n    file: ts.SourceFile, id: TemplateId, isDiagnosticRequest: boolean): ts.Node|null {\n  for (const stmt of file.statements) {\n    if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file, isDiagnosticRequest) === id) {\n      return stmt;\n    }\n  }\n  return null;\n}\n\n/**\n * Traverses up the AST starting from the given node to extract the source location from comments\n * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore\n * marker comment is found up the tree (and this is part of a diagnostic request), this function\n * returns null.\n */\nexport function findSourceLocation(\n    node: ts.Node, sourceFile: ts.SourceFile, isDiagnosticsRequest: boolean): SourceLocation|null {\n  // Search for comments until the TCB's function declaration is encountered.\n  while (node !== undefined && !ts.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {\n      // There's an ignore marker on this node, so the diagnostic should not be reported.\n      return null;\n    }\n\n    const span = readSpanComment(node, sourceFile);\n    if (span !== null) {\n      // Once the positional information has been extracted, search further up the TCB to extract\n      // the unique id that is attached with the TCB's function declaration.\n      const id = getTemplateId(node, sourceFile, isDiagnosticsRequest);\n      if (id === null) {\n        return null;\n      }\n      return {id, span};\n    }\n\n    node = node.parent;\n  }\n\n  return null;\n}\n\nfunction getTemplateId(\n    node: ts.Node, sourceFile: ts.SourceFile, isDiagnosticRequest: boolean): TemplateId|null {\n  // Walk up to the function declaration of the TCB, the file information is attached there.\n  while (!ts.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {\n      // There's an ignore marker on this node, so the diagnostic should not be reported.\n      return null;\n    }\n    node = node.parent;\n\n    // Bail once we have reached the root.\n    if (node === undefined) {\n      return null;\n    }\n  }\n\n  const start = node.getFullStart();\n  return ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText;\n  }) as TemplateId || null;\n}\n\nexport function checkIfGenericTypeBoundsCanBeEmitted(\n    node: ClassDeclaration<ts.ClassDeclaration>, reflector: ReflectionHost,\n    env: ReferenceEmitEnvironment): boolean {\n  // Generic type parameters are considered context free if they can be emitted into any context.\n  const emitter = new TypeParameterEmitter(node.typeParameters, reflector);\n  return emitter.canEmit(ref => env.canReferenceType(ref));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {OwningModule, Reference} from '../../imports';\nimport {DeclarationNode, ReflectionHost} from '../../reflection';\n\nimport {canEmitType, TypeEmitter} from './type_emitter';\n\n\n/**\n * See `TypeEmitter` for more information on the emitting process.\n */\nexport class TypeParameterEmitter {\n  constructor(\n      private typeParameters: ts.NodeArray<ts.TypeParameterDeclaration>|undefined,\n      private reflector: ReflectionHost) {}\n\n  /**\n   * Determines whether the type parameters can be emitted. If this returns true, then a call to\n   * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be\n   * called, as it would fail.\n   */\n  canEmit(canEmitReference: (ref: Reference) => boolean): boolean {\n    if (this.typeParameters === undefined) {\n      return true;\n    }\n\n    return this.typeParameters.every(typeParam => {\n      return this.canEmitType(typeParam.constraint, canEmitReference) &&\n          this.canEmitType(typeParam.default, canEmitReference);\n    });\n  }\n\n  private canEmitType(type: ts.TypeNode|undefined, canEmitReference: (ref: Reference) => boolean):\n      boolean {\n    if (type === undefined) {\n      return true;\n    }\n\n    return canEmitType(type, typeReference => {\n      const reference = this.resolveTypeReference(typeReference);\n      if (reference === null) {\n        return false;\n      }\n\n      if (reference instanceof Reference) {\n        return canEmitReference(reference);\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Emits the type parameters using the provided emitter function for `Reference`s.\n   */\n  emit(emitReference: (ref: Reference) => ts.TypeNode): ts.TypeParameterDeclaration[]|undefined {\n    if (this.typeParameters === undefined) {\n      return undefined;\n    }\n\n    const emitter = new TypeEmitter(type => this.translateTypeReference(type, emitReference));\n\n    return this.typeParameters.map(typeParam => {\n      const constraint =\n          typeParam.constraint !== undefined ? emitter.emitType(typeParam.constraint) : undefined;\n      const defaultType =\n          typeParam.default !== undefined ? emitter.emitType(typeParam.default) : undefined;\n\n      return ts.factory.updateTypeParameterDeclaration(\n          typeParam, typeParam.modifiers, typeParam.name, constraint, defaultType);\n    });\n  }\n\n  private resolveTypeReference(type: ts.TypeReferenceNode): Reference|ts.TypeReferenceNode|null {\n    const target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;\n    const declaration = this.reflector.getDeclarationOfIdentifier(target);\n\n    // If no declaration could be resolved or does not have a `ts.Declaration`, the type cannot be\n    // resolved.\n    if (declaration === null || declaration.node === null) {\n      return null;\n    }\n\n    // If the declaration corresponds with a local type parameter, the type reference can be used\n    // as is.\n    if (this.isLocalTypeParameter(declaration.node)) {\n      return type;\n    }\n\n    let owningModule: OwningModule|null = null;\n    if (declaration.viaModule !== null) {\n      owningModule = {\n        specifier: declaration.viaModule,\n        resolutionContext: type.getSourceFile().fileName,\n      };\n    }\n\n    return new Reference(declaration.node, owningModule);\n  }\n\n  private translateTypeReference(\n      type: ts.TypeReferenceNode,\n      emitReference: (ref: Reference) => ts.TypeNode | null): ts.TypeReferenceNode|null {\n    const reference = this.resolveTypeReference(type);\n    if (!(reference instanceof Reference)) {\n      return reference;\n    }\n\n    const typeNode = emitReference(reference);\n    if (typeNode === null) {\n      return null;\n    }\n\n    if (!ts.isTypeReferenceNode(typeNode)) {\n      throw new Error(\n          `Expected TypeReferenceNode for emitted reference, got ${ts.SyntaxKind[typeNode.kind]}.`);\n    }\n    return typeNode;\n  }\n\n  private isLocalTypeParameter(decl: DeclarationNode): boolean {\n    // Checking for local type parameters only occurs during resolution of type parameters, so it is\n    // guaranteed that type parameters are present.\n    return this.typeParameters!.some(param => param === decl);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\n/**\n * A type reference resolver function is responsible for translating a type reference from the\n * origin source file into a type reference that is valid in the desired source file. If the type\n * cannot be translated to the desired source file, then null can be returned.\n */\nexport type TypeReferenceTranslator = (type: ts.TypeReferenceNode) => ts.TypeReferenceNode|null;\n\n/**\n * A marker to indicate that a type reference is ineligible for emitting. This needs to be truthy\n * as it's returned from `ts.forEachChild`, which only returns truthy values.\n */\ntype INELIGIBLE = {\n  __brand: 'ineligible';\n};\nconst INELIGIBLE: INELIGIBLE = {} as INELIGIBLE;\n\n/**\n * Determines whether the provided type can be emitted, which means that it can be safely emitted\n * into a different location.\n *\n * If this function returns true, a `TypeEmitter` should be able to succeed. Vice versa, if this\n * function returns false, then using the `TypeEmitter` should not be attempted as it is known to\n * fail.\n */\nexport function canEmitType(\n    type: ts.TypeNode, canEmit: (type: ts.TypeReferenceNode) => boolean): boolean {\n  return canEmitTypeWorker(type);\n\n  function canEmitTypeWorker(type: ts.TypeNode): boolean {\n    return visitNode(type) !== INELIGIBLE;\n  }\n\n  // To determine whether a type can be emitted, we have to recursively look through all type nodes.\n  // If an unsupported type node is found at any position within the type, then the `INELIGIBLE`\n  // constant is returned to stop the recursive walk as the type as a whole cannot be emitted in\n  // that case. Otherwise, the result of visiting all child nodes determines the result. If no\n  // ineligible type reference node is found then the walk returns `undefined`, indicating that\n  // no type node was visited that could not be emitted.\n  function visitNode(node: ts.Node): INELIGIBLE|undefined {\n    // `import('module')` type nodes are not supported, as it may require rewriting the module\n    // specifier which is currently not done.\n    if (ts.isImportTypeNode(node)) {\n      return INELIGIBLE;\n    }\n\n    // Emitting a type reference node in a different context requires that an import for the type\n    // can be created. If a type reference node cannot be emitted, `INELIGIBLE` is returned to stop\n    // the walk.\n    if (ts.isTypeReferenceNode(node) && !canEmitTypeReference(node)) {\n      return INELIGIBLE;\n    } else {\n      return ts.forEachChild(node, visitNode);\n    }\n  }\n\n  function canEmitTypeReference(type: ts.TypeReferenceNode): boolean {\n    if (!canEmit(type)) {\n      return false;\n    }\n\n    // The type can be emitted if either it does not have any type arguments, or all of them can be\n    // emitted.\n    return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);\n  }\n}\n\n/**\n * Given a `ts.TypeNode`, this class derives an equivalent `ts.TypeNode` that has been emitted into\n * a different context.\n *\n * For example, consider the following code:\n *\n * ```\n * import {NgIterable} from '@angular/core';\n *\n * class NgForOf<T, U extends NgIterable<T>> {}\n * ```\n *\n * Here, the generic type parameters `T` and `U` can be emitted into a different context, as the\n * type reference to `NgIterable` originates from an absolute module import so that it can be\n * emitted anywhere, using that same module import. The process of emitting translates the\n * `NgIterable` type reference to a type reference that is valid in the context in which it is\n * emitted, for example:\n *\n * ```\n * import * as i0 from '@angular/core';\n * import * as i1 from '@angular/common';\n *\n * const _ctor1: <T, U extends i0.NgIterable<T>>(o: Pick<i1.NgForOf<T, U>, 'ngForOf'>):\n * i1.NgForOf<T, U>;\n * ```\n *\n * Notice how the type reference for `NgIterable` has been translated into a qualified name,\n * referring to the namespace import that was created.\n */\nexport class TypeEmitter {\n  constructor(private translator: TypeReferenceTranslator) {}\n\n  emitType(type: ts.TypeNode): ts.TypeNode {\n    const typeReferenceTransformer: ts.TransformerFactory<ts.TypeNode> = context => {\n      const visitNode = (node: ts.Node): ts.Node => {\n        if (ts.isImportTypeNode(node)) {\n          throw new Error('Unable to emit import type');\n        }\n\n        if (ts.isTypeReferenceNode(node)) {\n          return this.emitTypeReference(node);\n        } else if (ts.isLiteralExpression(node)) {\n          // TypeScript would typically take the emit text for a literal expression from the source\n          // file itself. As the type node is being emitted into a different file, however,\n          // TypeScript would extract the literal text from the wrong source file. To mitigate this\n          // issue the literal is cloned and explicitly marked as synthesized by setting its text\n          // range to a negative range, forcing TypeScript to determine the node's literal text from\n          // the synthesized node's text instead of the incorrect source file.\n          let clone: ts.LiteralExpression;\n\n          if (ts.isStringLiteral(node)) {\n            clone = ts.factory.createStringLiteral(node.text);\n          } else if (ts.isNumericLiteral(node)) {\n            clone = ts.factory.createNumericLiteral(node.text);\n          } else if (ts.isBigIntLiteral(node)) {\n            clone = ts.factory.createBigIntLiteral(node.text);\n          } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n            clone = ts.factory.createNoSubstitutionTemplateLiteral(node.text, node.rawText);\n          } else if (ts.isRegularExpressionLiteral(node)) {\n            clone = ts.factory.createRegularExpressionLiteral(node.text);\n          } else {\n            throw new Error(`Unsupported literal kind ${ts.SyntaxKind[node.kind]}`);\n          }\n\n          ts.setTextRange(clone, {pos: -1, end: -1});\n          return clone;\n        } else {\n          return ts.visitEachChild(node, visitNode, context);\n        }\n      };\n      return node => ts.visitNode(node, visitNode, ts.isTypeNode);\n    };\n    return ts.transform(type, [typeReferenceTransformer]).transformed[0];\n  }\n\n  private emitTypeReference(type: ts.TypeReferenceNode): ts.TypeNode {\n    // Determine the reference that the type corresponds with.\n    const translatedType = this.translator(type);\n    if (translatedType === null) {\n      throw new Error('Unable to emit an unresolved reference');\n    }\n\n    // Emit the type arguments, if any.\n    let typeArguments: ts.NodeArray<ts.TypeNode>|undefined = undefined;\n    if (type.typeArguments !== undefined) {\n      typeArguments =\n          ts.factory.createNodeArray(type.typeArguments.map(typeArg => this.emitType(typeArg)));\n    }\n\n    return ts.factory.updateTypeReferenceNode(type, translatedType.typeName, typeArguments);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BindingPipe, PropertyWrite, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, makeDiagnostic, makeRelatedInformation, ngErrorCode} from '../../diagnostics';\nimport {ClassDeclaration} from '../../reflection';\nimport {TemplateDiagnostic, TemplateId} from '../api';\nimport {makeTemplateDiagnostic} from '../diagnostics';\n\nimport {TemplateSourceResolver} from './tcb_util';\n\n\n\n/**\n * Collects `ts.Diagnostic`s on problems which occur in the template which aren't directly sourced\n * from Type Check Blocks.\n *\n * During the creation of a Type Check Block, the template is traversed and the\n * `OutOfBandDiagnosticRecorder` is called to record cases when a correct interpretation for the\n * template cannot be found. These operations create `ts.Diagnostic`s which are stored by the\n * recorder for later display.\n */\nexport interface OutOfBandDiagnosticRecorder {\n  readonly diagnostics: ReadonlyArray<TemplateDiagnostic>;\n\n  /**\n   * Reports a `#ref=\"target\"` expression in the template for which a target directive could not be\n   * found.\n   *\n   * @param templateId the template type-checking ID of the template which contains the broken\n   * reference.\n   * @param ref the `TmplAstReference` which could not be matched to a directive.\n   */\n  missingReferenceTarget(templateId: TemplateId, ref: TmplAstReference): void;\n\n  /**\n   * Reports usage of a `| pipe` expression in the template for which the named pipe could not be\n   * found.\n   *\n   * @param templateId the template type-checking ID of the template which contains the unknown\n   * pipe.\n   * @param ast the `BindingPipe` invocation of the pipe which could not be found.\n   */\n  missingPipe(templateId: TemplateId, ast: BindingPipe): void;\n\n  illegalAssignmentToTemplateVar(\n      templateId: TemplateId, assignment: PropertyWrite, target: TmplAstVariable): void;\n\n  /**\n   * Reports a duplicate declaration of a template variable.\n   *\n   * @param templateId the template type-checking ID of the template which contains the duplicate\n   * declaration.\n   * @param variable the `TmplAstVariable` which duplicates a previously declared variable.\n   * @param firstDecl the first variable declaration which uses the same name as `variable`.\n   */\n  duplicateTemplateVar(\n      templateId: TemplateId, variable: TmplAstVariable, firstDecl: TmplAstVariable): void;\n\n  requiresInlineTcb(templateId: TemplateId, node: ClassDeclaration): void;\n\n  requiresInlineTypeConstructors(\n      templateId: TemplateId, node: ClassDeclaration, directives: ClassDeclaration[]): void;\n\n  /**\n   * Report a warning when structural directives support context guards, but the current\n   * type-checking configuration prohibits their usage.\n   */\n  suboptimalTypeInference(templateId: TemplateId, variables: TmplAstVariable[]): void;\n\n  /**\n   * Reports a split two way binding error message.\n   */\n  splitTwoWayBinding(\n      templateId: TemplateId, input: TmplAstBoundAttribute, output: TmplAstBoundEvent,\n      inputConsumer: ClassDeclaration, outputConsumer: ClassDeclaration|TmplAstElement): void;\n\n  /** Reports required inputs that haven't been bound. */\n  missingRequiredInputs(\n      templateId: TemplateId, element: TmplAstElement|TmplAstTemplate, directiveName: string,\n      isComponent: boolean, inputAliases: string[]): void;\n}\n\nexport class OutOfBandDiagnosticRecorderImpl implements OutOfBandDiagnosticRecorder {\n  private _diagnostics: TemplateDiagnostic[] = [];\n\n  /**\n   * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic\n   * is ever produced per node.\n   */\n  private recordedPipes = new Set<BindingPipe>();\n\n  constructor(private resolver: TemplateSourceResolver) {}\n\n  get diagnostics(): ReadonlyArray<TemplateDiagnostic> {\n    return this._diagnostics;\n  }\n\n  missingReferenceTarget(templateId: TemplateId, ref: TmplAstReference): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const value = ref.value.trim();\n\n    const errorMsg = `No directive found with exportAs '${value}'.`;\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));\n  }\n\n  missingPipe(templateId: TemplateId, ast: BindingPipe): void {\n    if (this.recordedPipes.has(ast)) {\n      return;\n    }\n\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `No pipe found with name '${ast.name}'.`;\n\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);\n    if (sourceSpan === null) {\n      throw new Error(\n          `Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));\n    this.recordedPipes.add(ast);\n  }\n\n  illegalAssignmentToTemplateVar(\n      templateId: TemplateId, assignment: PropertyWrite, target: TmplAstVariable): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot use variable '${\n        assignment\n            .name}' as the left-hand side of an assignment expression. Template variables are read-only.`;\n\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);\n    if (sourceSpan === null) {\n      throw new Error(`Assertion failure: no SourceLocation found for property binding.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, [{\n          text: `The variable ${assignment.name} is declared here.`,\n          start: target.valueSpan?.start.offset || target.sourceSpan.start.offset,\n          end: target.valueSpan?.end.offset || target.sourceSpan.end.offset,\n          sourceFile: mapping.node.getSourceFile(),\n        }]));\n  }\n\n  duplicateTemplateVar(\n      templateId: TemplateId, variable: TmplAstVariable, firstDecl: TmplAstVariable): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot redeclare variable '${\n        variable.name}' as it was previously declared elsewhere for the same template.`;\n\n    // The allocation of the error here is pretty useless for variables declared in microsyntax,\n    // since the sourceSpan refers to the entire microsyntax property, not a span for the specific\n    // variable in question.\n    //\n    // TODO(alxhub): allocate to a tighter span once one is available.\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, [{\n          text: `The variable '${firstDecl.name}' was first declared here.`,\n          start: firstDecl.sourceSpan.start.offset,\n          end: firstDecl.sourceSpan.end.offset,\n          sourceFile: mapping.node.getSourceFile(),\n        }]));\n  }\n\n  requiresInlineTcb(templateId: TemplateId, node: ClassDeclaration): void {\n    this._diagnostics.push(makeInlineDiagnostic(\n        templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name,\n        `This component requires inline template type-checking, which is not supported by the current environment.`));\n  }\n\n  requiresInlineTypeConstructors(\n      templateId: TemplateId, node: ClassDeclaration, directives: ClassDeclaration[]): void {\n    let message: string;\n    if (directives.length > 1) {\n      message =\n          `This component uses directives which require inline type constructors, which are not supported by the current environment.`;\n    } else {\n      message =\n          `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;\n    }\n\n    this._diagnostics.push(makeInlineDiagnostic(\n        templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message,\n        directives.map(\n            dir => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));\n  }\n\n  suboptimalTypeInference(templateId: TemplateId, variables: TmplAstVariable[]): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n\n    // Select one of the template variables that's most suitable for reporting the diagnostic. Any\n    // variable will do, but prefer one bound to the context's $implicit if present.\n    let diagnosticVar: TmplAstVariable|null = null;\n    for (const variable of variables) {\n      if (diagnosticVar === null || (variable.value === '' || variable.value === '$implicit')) {\n        diagnosticVar = variable;\n      }\n    }\n    if (diagnosticVar === null) {\n      // There is no variable on which to report the diagnostic.\n      return;\n    }\n\n    let varIdentification = `'${diagnosticVar.name}'`;\n    if (variables.length === 2) {\n      varIdentification += ` (and 1 other)`;\n    } else if (variables.length > 2) {\n      varIdentification += ` (and ${variables.length - 1} others)`;\n    }\n    const message =\n        `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${\n            varIdentification} will have type 'any' as a result.\\n\\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;\n\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, diagnosticVar.keySpan, ts.DiagnosticCategory.Suggestion,\n        ngErrorCode(ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));\n  }\n\n  splitTwoWayBinding(\n      templateId: TemplateId, input: TmplAstBoundAttribute, output: TmplAstBoundEvent,\n      inputConsumer: ClassDeclaration, outputConsumer: ClassDeclaration|TmplAstElement): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `The property and event halves of the two-way binding '${\n        input.name}' are not bound to the same target.\n            Find more at https://angular.io/guide/two-way-binding#how-two-way-binding-works`;\n\n    const relatedMessages: {text: string; start: number; end: number;\n                            sourceFile: ts.SourceFile;}[] = [];\n\n    relatedMessages.push({\n      text: `The property half of the binding is to the '${inputConsumer.name.text}' component.`,\n      start: inputConsumer.name.getStart(),\n      end: inputConsumer.name.getEnd(),\n      sourceFile: inputConsumer.name.getSourceFile(),\n    });\n\n    if (outputConsumer instanceof TmplAstElement) {\n      let message = `The event half of the binding is to a native event called '${\n          input.name}' on the <${outputConsumer.name}> DOM element.`;\n      if (!mapping.node.getSourceFile().isDeclarationFile) {\n        message += `\\n \\n Are you missing an output declaration called '${output.name}'?`;\n      }\n      relatedMessages.push({\n        text: message,\n        start: outputConsumer.sourceSpan.start.offset + 1,\n        end: outputConsumer.sourceSpan.start.offset + outputConsumer.name.length + 1,\n        sourceFile: mapping.node.getSourceFile(),\n      });\n    } else {\n      relatedMessages.push({\n        text: `The event half of the binding is to the '${outputConsumer.name.text}' component.`,\n        start: outputConsumer.name.getStart(),\n        end: outputConsumer.name.getEnd(),\n        sourceFile: outputConsumer.name.getSourceFile(),\n      });\n    }\n\n\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, input.keySpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.SPLIT_TWO_WAY_BINDING), errorMsg, relatedMessages));\n  }\n\n  missingRequiredInputs(\n      templateId: TemplateId, element: TmplAstElement|TmplAstTemplate, directiveName: string,\n      isComponent: boolean, inputAliases: string[]): void {\n    const message = `Required input${inputAliases.length === 1 ? '' : 's'} ${\n        inputAliases.map(n => `'${n}'`).join(', ')} from ${\n        isComponent ? 'component' : 'directive'} ${directiveName} must be specified.`;\n\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, this.resolver.getSourceMapping(templateId), element.startSourceSpan,\n        ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REQUIRED_INPUTS), message));\n  }\n}\n\nfunction makeInlineDiagnostic(\n    templateId: TemplateId, code: ErrorCode.INLINE_TCB_REQUIRED|ErrorCode.INLINE_TYPE_CTOR_REQUIRED,\n    node: ts.Node, messageText: string|ts.DiagnosticMessageChain,\n    relatedInformation?: ts.DiagnosticRelatedInformation[]): TemplateDiagnostic {\n  return {\n    ...makeDiagnostic(code, node, messageText, relatedInformation),\n    componentFile: node.getSourceFile(),\n    templateId,\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {absoluteFrom, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\nimport {PerFileShimGenerator, TopLevelShimGenerator} from '../../shims/api';\n\n/**\n * A `ShimGenerator` which adds type-checking files to the `ts.Program`.\n *\n * This is a requirement for performant template type-checking, as TypeScript will only reuse\n * information in the main program when creating the type-checking program if the set of files in\n * each are exactly the same. Thus, the main program also needs the synthetic type-checking files.\n */\nexport class TypeCheckShimGenerator implements PerFileShimGenerator {\n  readonly extensionPrefix = 'ngtypecheck';\n  readonly shouldEmit = false;\n\n  generateShimForFile(\n      sf: ts.SourceFile, genFilePath: AbsoluteFsPath,\n      priorShimSf: ts.SourceFile|null): ts.SourceFile {\n    if (priorShimSf !== null) {\n      // If this shim existed in the previous program, reuse it now. It might not be correct, but\n      // reusing it in the main program allows the shape of its imports to potentially remain the\n      // same and TS can then use the fastest path for incremental program creation. Later during\n      // the type-checking phase it's going to either be reused, or replaced anyways. Thus there's\n      // no harm in reuse here even if it's out of date.\n      return priorShimSf;\n    }\n    return ts.createSourceFile(\n        genFilePath, 'export const USED_FOR_NG_TYPE_CHECKING = true;', ts.ScriptTarget.Latest, true,\n        ts.ScriptKind.TS);\n  }\n\n  static shimFor(fileName: AbsoluteFsPath): AbsoluteFsPath {\n    return absoluteFrom(fileName.replace(/\\.tsx?$/, '.ngtypecheck.ts'));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BindingPipe, BindingType, BoundTarget, Call, DYNAMIC_TYPE, ImplicitReceiver, ParsedEventType, ParseSourceSpan, PropertyRead, PropertyWrite, SafeCall, SafePropertyRead, SchemaMetadata, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {BindingPropertyName, ClassPropertyName} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\nimport {TemplateId, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata} from '../api';\n\nimport {addExpressionIdentifier, ExpressionIdentifier, markIgnoreDiagnostics} from './comments';\nimport {addParseSpanInfo, addTemplateId, wrapForDiagnostics, wrapForTypeChecker} from './diagnostics';\nimport {DomSchemaChecker} from './dom';\nimport {Environment} from './environment';\nimport {astToTypescript, NULL_AS_ANY} from './expression';\nimport {OutOfBandDiagnosticRecorder} from './oob';\nimport {ExpressionSemanticVisitor} from './template_semantics';\nimport {tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\nimport {requiresInlineTypeCtor} from './type_constructor';\nimport {TypeParameterEmitter} from './type_parameter_emitter';\n\n/**\n * Controls how generics for the component context class will be handled during TCB generation.\n */\nexport enum TcbGenericContextBehavior {\n  /**\n   * References to generic parameter bounds will be emitted via the `TypeParameterEmitter`.\n   *\n   * The caller must verify that all parameter bounds are emittable in order to use this mode.\n   */\n  UseEmitter,\n\n  /**\n   * Generic parameter declarations will be copied directly from the `ts.ClassDeclaration` of the\n   * component class.\n   *\n   * The caller must only use the generated TCB code in a context where such copies will still be\n   * valid, such as an inline type check block.\n   */\n  CopyClassNodes,\n\n  /**\n   * Any generic parameters for the component context class will be set to `any`.\n   *\n   * Produces a less useful type, but is always safe to use.\n   */\n  FallbackToAny,\n}\n\n/**\n * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n * \"type check block\" function.\n *\n * When passed through TypeScript's TypeChecker, type errors that arise within the type check block\n * function indicate issues in the template itself.\n *\n * As a side effect of generating a TCB for the component, `ts.Diagnostic`s may also be produced\n * directly for issues within the template which are identified during generation. These issues are\n * recorded in either the `domSchemaChecker` (which checks usage of DOM elements and bindings) as\n * well as the `oobRecorder` (which records errors when the type-checking code generator is unable\n * to sufficiently understand a template).\n *\n * @param env an `Environment` into which type-checking code will be generated.\n * @param ref a `Reference` to the component class which should be type-checked.\n * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.\n * @param meta metadata about the component's template and the function being generated.\n * @param domSchemaChecker used to check and record errors regarding improper usage of DOM elements\n * and bindings.\n * @param oobRecorder used to record errors regarding template elements which could not be correctly\n * translated into types during TCB generation.\n * @param genericContextBehavior controls how generic parameters (especially parameters with generic\n * bounds) will be referenced from the generated TCB code.\n */\nexport function generateTypeCheckBlock(\n    env: Environment, ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, name: ts.Identifier,\n    meta: TypeCheckBlockMetadata, domSchemaChecker: DomSchemaChecker,\n    oobRecorder: OutOfBandDiagnosticRecorder,\n    genericContextBehavior: TcbGenericContextBehavior): ts.FunctionDeclaration {\n  const tcb = new Context(\n      env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas,\n      meta.isStandalone);\n  const scope = Scope.forNodes(tcb, null, tcb.boundTarget.target.template!, /* guard */ null);\n  const ctxRawType = env.referenceType(ref);\n  if (!ts.isTypeReferenceNode(ctxRawType)) {\n    throw new Error(\n        `Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);\n  }\n\n  let typeParameters: ts.TypeParameterDeclaration[]|undefined = undefined;\n  let typeArguments: ts.TypeNode[]|undefined = undefined;\n\n  if (ref.node.typeParameters !== undefined) {\n    if (!env.config.useContextGenericType) {\n      genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;\n    }\n\n    switch (genericContextBehavior) {\n      case TcbGenericContextBehavior.UseEmitter:\n        // Guaranteed to emit type parameters since we checked that the class has them above.\n        typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector)\n                             .emit(typeRef => env.referenceType(typeRef))!;\n        typeArguments = typeParameters.map(param => ts.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.CopyClassNodes:\n        typeParameters = [...ref.node.typeParameters];\n        typeArguments = typeParameters.map(param => ts.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.FallbackToAny:\n        typeArguments = ref.node.typeParameters.map(\n            () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n        break;\n    }\n  }\n\n  const paramList = [tcbThisParam(ctxRawType.typeName, typeArguments)];\n\n  const scopeStatements = scope.render();\n  const innerBody = ts.factory.createBlock([\n    ...env.getPreludeStatements(),\n    ...scopeStatements,\n  ]);\n\n  // Wrap the body in an \"if (true)\" expression. This is unnecessary but has the effect of causing\n  // the `ts.Printer` to format the type-check block nicely.\n  const body = ts.factory.createBlock(\n      [ts.factory.createIfStatement(ts.factory.createTrue(), innerBody, undefined)]);\n  const fnDecl = ts.factory.createFunctionDeclaration(\n      /* modifiers */ undefined,\n      /* asteriskToken */ undefined,\n      /* name */ name,\n      /* typeParameters */ env.config.useContextGenericType ? typeParameters : undefined,\n      /* parameters */ paramList,\n      /* type */ undefined,\n      /* body */ body);\n  addTemplateId(fnDecl, meta.id);\n  return fnDecl;\n}\n\n/**\n * A code generation operation that's involved in the construction of a Type Check Block.\n *\n * The generation of a TCB is non-linear. Bindings within a template may result in the need to\n * construct certain types earlier than they otherwise would be constructed. That is, if the\n * generation of a TCB for a template is broken down into specific operations (constructing a\n * directive, extracting a variable from a let- operation, etc), then it's possible for operations\n * earlier in the sequence to depend on operations which occur later in the sequence.\n *\n * `TcbOp` abstracts the different types of operations which are required to convert a template into\n * a TCB. This allows for two phases of processing for the template, where 1) a linear sequence of\n * `TcbOp`s is generated, and then 2) these operations are executed, not necessarily in linear\n * order.\n *\n * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a\n * `ts.Expression` which can be used to reference the operation's result.\n */\nabstract class TcbOp {\n  /**\n   * Set to true if this operation can be considered optional. Optional operations are only executed\n   * when depended upon by other operations, otherwise they are disregarded. This allows for less\n   * code to generate, parse and type-check, overall positively contributing to performance.\n   */\n  abstract readonly optional: boolean;\n\n  abstract execute(): ts.Expression|null;\n\n  /**\n   * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular\n   * references during its execution).\n   *\n   * This is usually a `null!` expression (which asks TS to infer an appropriate type), but another\n   * `TcbOp` can be returned in cases where additional code generation is necessary to deal with\n   * circular references.\n   */\n  circularFallback(): TcbOp|ts.Expression {\n    return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;\n  }\n}\n\n/**\n * A `TcbOp` which creates an expression for a native DOM element (or web component) from a\n * `TmplAstElement`.\n *\n * Executing this operation returns a reference to the element variable.\n */\nclass TcbElementOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope, private element: TmplAstElement) {\n    super();\n  }\n\n  override get optional() {\n    // The statement generated by this operation is only used for type-inference of the DOM\n    // element's type and won't report diagnostics by itself, so the operation is marked as optional\n    // to avoid generating statements for DOM elements that are never referenced.\n    return true;\n  }\n\n  override execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    // Add the declaration of the element using document.createElement.\n    const initializer = tsCreateElement(this.element.name);\n    addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which creates an expression for particular let- `TmplAstVariable` on a\n * `TmplAstTemplate`'s context.\n *\n * Executing this operation returns a reference to the variable variable (lol).\n */\nclass TcbVariableOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private template: TmplAstTemplate,\n      private variable: TmplAstVariable) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): ts.Identifier {\n    // Look for a context variable for the template.\n    const ctx = this.scope.resolve(this.template);\n\n    // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable\n    // on the template context.\n    const id = this.tcb.allocateId();\n    const initializer = ts.factory.createPropertyAccessExpression(\n        /* expression */ ctx,\n        /* name */ this.variable.value || '$implicit');\n    addParseSpanInfo(id, this.variable.keySpan);\n\n    // Declare the variable, and return its identifier.\n    let variable: ts.VariableStatement;\n    if (this.variable.valueSpan !== undefined) {\n      addParseSpanInfo(initializer, this.variable.valueSpan);\n      variable = tsCreateVariable(id, wrapForTypeChecker(initializer));\n    } else {\n      variable = tsCreateVariable(id, initializer);\n    }\n    addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);\n    this.scope.addStatement(variable);\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which generates a variable for a `TmplAstTemplate`'s context.\n *\n * Executing this operation returns a reference to the template's context variable.\n */\nclass TcbTemplateContextOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope) {\n    super();\n  }\n\n  // The declaration of the context variable is only needed when the context is actually referenced.\n  override readonly optional = true;\n\n  override execute(): ts.Identifier {\n    // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable\n    // may be narrowed as a result of template guard conditions.\n    const ctx = this.tcb.allocateId();\n    const type = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    this.scope.addStatement(tsDeclareVariable(ctx, type));\n    return ctx;\n  }\n}\n\n/**\n * A `TcbOp` which descends into a `TmplAstTemplate`'s children and generates type-checking code for\n * them.\n *\n * This operation wraps the children's type-checking code in an `if` block, which may include one\n * or more type guard conditions that narrow types within the template body.\n */\nclass TcbTemplateBodyOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope, private template: TmplAstTemplate) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): null {\n    // An `if` will be constructed, within which the template's children will be type checked. The\n    // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared\n    // in the template's TCB from the outer context, and it allows any directives on the templates\n    // to perform type narrowing of either expressions or the template's context.\n    //\n    // The guard is the `if` block's condition. It's usually set to `true` but directives that exist\n    // on the template can trigger extra guard expressions that serve to narrow types within the\n    // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.\n    // Collect these into `guards` by processing the directives.\n    const directiveGuards: ts.Expression[] = [];\n\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);\n    if (directives !== null) {\n      for (const dir of directives) {\n        const dirInstId = this.scope.resolve(this.template, dir);\n        const dirId =\n            this.tcb.env.reference(dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>);\n\n        // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of\n        // the expression passed to an @Input of the directive. Scan the directive to see if it has\n        // any template guards, and generate them if needed.\n        dir.ngTemplateGuards.forEach(guard => {\n          // For each template guard function on the directive, look for a binding to that input.\n          const boundInput = this.template.inputs.find(i => i.name === guard.inputName) ||\n              this.template.templateAttrs.find(\n                  (i: TmplAstTextAttribute|TmplAstBoundAttribute): i is TmplAstBoundAttribute =>\n                      i instanceof TmplAstBoundAttribute && i.name === guard.inputName);\n          if (boundInput !== undefined) {\n            // If there is such a binding, generate an expression for it.\n            const expr = tcbExpression(boundInput.value, this.tcb, this.scope);\n\n            // The expression has already been checked in the type constructor invocation, so\n            // it should be ignored when used within a template guard.\n            markIgnoreDiagnostics(expr);\n\n            if (guard.type === 'binding') {\n              // Use the binding expression itself as guard.\n              directiveGuards.push(expr);\n            } else {\n              // Call the guard function on the directive with the directive instance and that\n              // expression.\n              const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard.inputName}`, [\n                dirInstId,\n                expr,\n              ]);\n              addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);\n              directiveGuards.push(guardInvoke);\n            }\n          }\n        });\n\n        // The second kind of guard is a template context guard. This guard narrows the template\n        // rendering context variable `ctx`.\n        if (dir.hasNgTemplateContextGuard) {\n          if (this.tcb.env.config.applyTemplateContextGuards) {\n            const ctx = this.scope.resolve(this.template);\n            const guardInvoke = tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);\n            addParseSpanInfo(guardInvoke, this.template.sourceSpan);\n            directiveGuards.push(guardInvoke);\n          } else if (\n              this.template.variables.length > 0 &&\n              this.tcb.env.config.suggestionsForSuboptimalTypeInference) {\n            // The compiler could have inferred a better type for the variables in this template,\n            // but was prevented from doing so by the type-checking configuration. Issue a warning\n            // diagnostic.\n            this.tcb.oobRecorder.suboptimalTypeInference(this.tcb.id, this.template.variables);\n          }\n        }\n      }\n    }\n\n    // By default the guard is simply `true`.\n    let guard: ts.Expression|null = null;\n\n    // If there are any guards from directives, use them instead.\n    if (directiveGuards.length > 0) {\n      // Pop the first value and use it as the initializer to reduce(). This way, a single guard\n      // will be used on its own, but two or more will be combined into binary AND expressions.\n      guard = directiveGuards.reduce(\n          (expr, dirGuard) => ts.factory.createBinaryExpression(\n              expr, ts.SyntaxKind.AmpersandAmpersandToken, dirGuard),\n          directiveGuards.pop()!);\n    }\n\n    // Create a new Scope for the template. This constructs the list of operations for the template\n    // children, as well as tracks bindings within the template.\n    const tmplScope = Scope.forNodes(this.tcb, this.scope, this.template, guard);\n\n    // Render the template's `Scope` into its statements.\n    const statements = tmplScope.render();\n    if (statements.length === 0) {\n      // As an optimization, don't generate the scope's block if it has no statements. This is\n      // beneficial for templates that contain for example `<span *ngIf=\"first\"></span>`, in which\n      // case there's no need to render the `NgIf` guard expression. This seems like a minor\n      // improvement, however it reduces the number of flow-node antecedents that TypeScript needs\n      // to keep into account for such cases, resulting in an overall reduction of\n      // type-checking time.\n      return null;\n    }\n\n    let tmplBlock: ts.Statement = ts.factory.createBlock(statements);\n    if (guard !== null) {\n      // The scope has a guard that needs to be applied, so wrap the template block into an `if`\n      // statement containing the guard expression.\n      tmplBlock =\n          ts.factory.createIfStatement(/* expression */ guard, /* thenStatement */ tmplBlock);\n    }\n    this.scope.addStatement(tmplBlock);\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which renders a text binding (interpolation) into the TCB.\n *\n * Executing this operation returns nothing.\n */\nclass TcbTextInterpolationOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope, private binding: TmplAstBoundText) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): null {\n    const expr = tcbExpression(this.binding.value, this.tcb, this.scope);\n    this.scope.addStatement(ts.factory.createExpressionStatement(expr));\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a directive. For generic directives, generic\n * parameters are set to `any` type.\n */\nabstract class TcbDirectiveTypeOpBase extends TcbOp {\n  constructor(\n      protected tcb: Context, protected scope: Scope,\n      protected node: TmplAstTemplate|TmplAstElement, protected dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  override get optional() {\n    // The statement generated by this operation is only used to declare the directive's type and\n    // won't report diagnostics by itself, so the operation is marked as optional to avoid\n    // generating declarations for directives that don't have any inputs/outputs.\n    return true;\n  }\n\n  override execute(): ts.Identifier {\n    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n\n    const rawType = this.tcb.env.referenceType(this.dir.ref);\n\n    let type: ts.TypeNode;\n    if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {\n      type = rawType;\n    } else {\n      if (!ts.isTypeReferenceNode(rawType)) {\n        throw new Error(\n            `Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);\n      }\n      const typeArguments = dirRef.node.typeParameters.map(\n          () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      type = ts.factory.createTypeReferenceNode(rawType.typeName, typeArguments);\n    }\n\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n    this.scope.addStatement(tsDeclareVariable(id, type));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its\n * inputs. Inputs are later set in the `TcbDirectiveInputsOp`. Type checking was found to be\n * faster when done in this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the\n * directive is generic.\n *\n * Executing this operation returns a reference to the directive instance variable with its inferred\n * type.\n */\nclass TcbNonGenericDirectiveTypeOp extends TcbDirectiveTypeOpBase {\n  /**\n   * Creates a variable declaration for this op's directive of the argument type. Returns the id of\n   * the newly created variable.\n   */\n  override execute(): ts.Identifier {\n    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n    if (this.dir.isGeneric) {\n      throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);\n    }\n    return super.execute();\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a generic directive with its generic parameters set\n * to `any` type. This op is like `TcbDirectiveTypeOp`, except that generic parameters are set to\n * `any` type. This is used for situations where we want to avoid inlining.\n *\n * Executing this operation returns a reference to the directive instance variable with its generic\n * type parameters set to `any`.\n */\nclass TcbGenericDirectiveTypeWithAnyParamsOp extends TcbDirectiveTypeOpBase {\n  override execute(): ts.Identifier {\n    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n    if (dirRef.node.typeParameters === undefined) {\n      throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${\n          dirRef.debugName}`);\n    }\n\n    return super.execute();\n  }\n}\n\n/**\n * A `TcbOp` which creates a variable for a local ref in a template.\n * The initializer for the variable is the variable expression for the directive, template, or\n * element the ref refers to. When the reference is used in the template, those TCB statements will\n * access this variable as well. For example:\n * ```\n * var _t1 = document.createElement('div');\n * var _t2 = _t1;\n * _t2.value\n * ```\n * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol\n * for a reference. In most cases, this isn't essential; that is, the information for the symbol\n * could be gathered without this operation using the `BoundTarget`. However, for the case of\n * ng-template references, we will need this reference variable to not only provide a location in\n * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than\n * `TemplateRef<any>` (this work is still TODO).\n *\n * Executing this operation returns a reference to the directive instance variable with its inferred\n * type.\n */\nclass TcbReferenceOp extends TcbOp {\n  constructor(\n      private readonly tcb: Context, private readonly scope: Scope,\n      private readonly node: TmplAstReference,\n      private readonly host: TmplAstElement|TmplAstTemplate,\n      private readonly target: TypeCheckableDirectiveMeta|TmplAstTemplate|TmplAstElement) {\n    super();\n  }\n\n  // The statement generated by this operation is only used to for the Type Checker\n  // so it can map a reference variable in the template directly to a node in the TCB.\n  override readonly optional = true;\n\n  override execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    let initializer: ts.Expression =\n        this.target instanceof TmplAstTemplate || this.target instanceof TmplAstElement ?\n        this.scope.resolve(this.target) :\n        this.scope.resolve(this.host, this.target);\n\n    // The reference is either to an element, an <ng-template> node, or to a directive on an\n    // element or template.\n    if ((this.target instanceof TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences) ||\n        !this.tcb.env.config.checkTypeOfNonDomReferences) {\n      // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.\n      // References to `TemplateRef`s and directives are pinned to 'any' when\n      // `checkTypeOfNonDomReferences` is `false`.\n      initializer = ts.factory.createAsExpression(\n          initializer, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n    } else if (this.target instanceof TmplAstTemplate) {\n      // Direct references to an <ng-template> node simply require a value of type\n      // `TemplateRef<any>`. To get this, an expression of the form\n      // `(_t1 as any as TemplateRef<any>)` is constructed.\n      initializer = ts.factory.createAsExpression(\n          initializer, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      initializer = ts.factory.createAsExpression(\n          initializer,\n          this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));\n      initializer = ts.factory.createParenthesizedExpression(initializer);\n    }\n    addParseSpanInfo(initializer, this.node.sourceSpan);\n    addParseSpanInfo(id, this.node.keySpan);\n\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which is used when the target of a reference is missing. This operation generates a\n * variable of type any for usages of the invalid reference to resolve to. The invalid reference\n * itself is recorded out-of-band.\n */\nclass TcbInvalidReferenceOp extends TcbOp {\n  constructor(private readonly tcb: Context, private readonly scope: Scope) {\n    super();\n  }\n\n  // The declaration of a missing reference is only needed when the reference is resolved.\n  override readonly optional = true;\n\n  override execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    this.scope.addStatement(tsCreateVariable(id, NULL_AS_ANY));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The\n * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.\n * Any errors reported in this statement are ignored, as the type constructor call is only present\n * for type-inference.\n *\n * When a Directive is generic, it is required that the TCB generates the instance using this method\n * in order to infer the type information correctly.\n *\n * Executing this operation returns a reference to the directive instance variable with its inferred\n * type.\n */\nclass TcbDirectiveCtorOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  override get optional() {\n    // The statement generated by this operation is only used to infer the directive's type and\n    // won't report diagnostics by itself, so the operation is marked as optional.\n    return true;\n  }\n\n  override execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);\n\n    const genericInputs = new Map<string, TcbDirectiveInput>();\n    const boundAttrs = getBoundAttributes(this.dir, this.node);\n\n    for (const attr of boundAttrs) {\n      // Skip text attributes if configured to do so.\n      if (!this.tcb.env.config.checkTypeOfAttributes &&\n          attr.attribute instanceof TmplAstTextAttribute) {\n        continue;\n      }\n      for (const {fieldName} of attr.inputs) {\n        // Skip the field if an attribute has already been bound to it; we can't have a duplicate\n        // key in the type constructor call.\n        if (genericInputs.has(fieldName)) {\n          continue;\n        }\n\n        const expression = translateInput(attr.attribute, this.tcb, this.scope);\n        genericInputs.set(\n            fieldName,\n            {type: 'binding', field: fieldName, expression, sourceSpan: attr.attribute.sourceSpan});\n      }\n    }\n\n    // Add unset directive inputs for each of the remaining unset fields.\n    for (const {classPropertyName} of this.dir.inputs) {\n      if (!genericInputs.has(classPropertyName)) {\n        genericInputs.set(classPropertyName, {type: 'unset', field: classPropertyName});\n      }\n    }\n\n    // Call the type constructor of the directive to infer a type, and assign the directive\n    // instance.\n    const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n    markIgnoreDiagnostics(typeCtor);\n    this.scope.addStatement(tsCreateVariable(id, typeCtor));\n    return id;\n  }\n\n  override circularFallback(): TcbOp {\n    return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n  }\n}\n\n/**\n * A `TcbOp` which generates code to check input bindings on an element that correspond with the\n * members of a directive.\n *\n * Executing this operation returns nothing.\n */\nclass TcbDirectiveInputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): null {\n    let dirId: ts.Expression|null = null;\n\n    // TODO(joost): report duplicate properties\n\n    const boundAttrs = getBoundAttributes(this.dir, this.node);\n    const seenRequiredInputs = new Set<ClassPropertyName>();\n\n    for (const attr of boundAttrs) {\n      // For bound inputs, the property is assigned the binding expression.\n      const expr = widenBinding(translateInput(attr.attribute, this.tcb, this.scope), this.tcb);\n\n      let assignment: ts.Expression = wrapForDiagnostics(expr);\n\n      for (const {fieldName, required} of attr.inputs) {\n        let target: ts.LeftHandSideExpression;\n\n        if (required) {\n          seenRequiredInputs.add(fieldName);\n        }\n\n        if (this.dir.coercedInputFields.has(fieldName)) {\n          // The input has a coercion declaration which should be used instead of assigning the\n          // expression into the input field directly. To achieve this, a variable is declared\n          // with a type of `typeof Directive.ngAcceptInputType_fieldName` which is then used as\n          // target of the assignment.\n          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n          if (!ts.isTypeReferenceNode(dirTypeRef)) {\n            throw new Error(\n                `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n          }\n\n          const id = this.tcb.allocateId();\n          const type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);\n          this.scope.addStatement(tsDeclareVariable(id, type));\n\n          target = id;\n        } else if (this.dir.undeclaredInputFields.has(fieldName)) {\n          // If no coercion declaration is present nor is the field declared (i.e. the input is\n          // declared in a `@Directive` or `@Component` decorator's `inputs` property) there is no\n          // assignment target available, so this field is skipped.\n          continue;\n        } else if (\n            !this.tcb.env.config.honorAccessModifiersForInputBindings &&\n            this.dir.restrictedInputFields.has(fieldName)) {\n          // If strict checking of access modifiers is disabled and the field is restricted\n          // (i.e. private/protected/readonly), generate an assignment into a temporary variable\n          // that has the type of the field. This achieves type-checking but circumvents the access\n          // modifiers.\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n\n          const id = this.tcb.allocateId();\n          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n          if (!ts.isTypeReferenceNode(dirTypeRef)) {\n            throw new Error(\n                `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n          }\n          const type = ts.factory.createIndexedAccessTypeNode(\n              ts.factory.createTypeQueryNode(dirId as ts.Identifier),\n              ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(fieldName)));\n          const temp = tsDeclareVariable(id, type);\n          this.scope.addStatement(temp);\n          target = id;\n        } else {\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n\n          // To get errors assign directly to the fields on the instance, using property access\n          // when possible. String literal fields may not be valid JS identifiers so we use\n          // literal element access instead for those cases.\n          target = this.dir.stringLiteralInputFields.has(fieldName) ?\n              ts.factory.createElementAccessExpression(\n                  dirId, ts.factory.createStringLiteral(fieldName)) :\n              ts.factory.createPropertyAccessExpression(\n                  dirId, ts.factory.createIdentifier(fieldName));\n        }\n\n        if (attr.attribute.keySpan !== undefined) {\n          addParseSpanInfo(target, attr.attribute.keySpan);\n        }\n        // Finally the assignment is extended by assigning it into the target expression.\n        assignment =\n            ts.factory.createBinaryExpression(target, ts.SyntaxKind.EqualsToken, assignment);\n      }\n\n      addParseSpanInfo(assignment, attr.attribute.sourceSpan);\n      // Ignore diagnostics for text attributes if configured to do so.\n      if (!this.tcb.env.config.checkTypeOfAttributes &&\n          attr.attribute instanceof TmplAstTextAttribute) {\n        markIgnoreDiagnostics(assignment);\n      }\n\n      this.scope.addStatement(ts.factory.createExpressionStatement(assignment));\n    }\n\n    this.checkRequiredInputs(seenRequiredInputs);\n\n    return null;\n  }\n\n  private checkRequiredInputs(seenRequiredInputs: Set<ClassPropertyName>): void {\n    const missing: BindingPropertyName[] = [];\n\n    for (const input of this.dir.inputs) {\n      if (input.required && !seenRequiredInputs.has(input.classPropertyName)) {\n        missing.push(input.bindingPropertyName);\n      }\n    }\n\n    if (missing.length > 0) {\n      this.tcb.oobRecorder.missingRequiredInputs(\n          this.tcb.id, this.node, this.dir.name, this.dir.isComponent, missing);\n    }\n  }\n}\n\n/**\n * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type\n * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template\n * reference:\n *\n * ```html\n * <some-cmp #ref [prop]=\"ref.foo\"></some-cmp>\n * ```\n *\n * In this case, `TcbDirectiveCtorCircularFallbackOp` will add a second inference of the directive\n * type to the type-check block, this time calling the directive's type constructor without any\n * input expressions. This infers the widest possible supertype for the directive, which is used to\n * resolve any recursive references required to infer the real type.\n */\nclass TcbDirectiveCtorCircularFallbackOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    const typeCtor = this.tcb.env.typeCtorFor(this.dir);\n    const circularPlaceholder = ts.factory.createCallExpression(\n        typeCtor, /* typeArguments */ undefined,\n        [ts.factory.createNonNullExpression(ts.factory.createNull())]);\n    this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which feeds elements and unclaimed properties to the `DomSchemaChecker`.\n *\n * The DOM schema is not checked via TCB code generation. Instead, the `DomSchemaChecker` ingests\n * elements and property bindings and accumulates synthetic `ts.Diagnostic`s out-of-band. These are\n * later merged with the diagnostics generated from the TCB.\n *\n * For convenience, the TCB iteration of the template is used to drive the `DomSchemaChecker` via\n * the `TcbDomSchemaCheckerOp`.\n */\nclass TcbDomSchemaCheckerOp extends TcbOp {\n  constructor(\n      private tcb: Context, private element: TmplAstElement, private checkElement: boolean,\n      private claimedInputs: Set<string>) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): ts.Expression|null {\n    if (this.checkElement) {\n      this.tcb.domSchemaChecker.checkElement(\n          this.tcb.id, this.element, this.tcb.schemas, this.tcb.hostIsStandalone);\n    }\n\n    // TODO(alxhub): this could be more efficient.\n    for (const binding of this.element.inputs) {\n      if (binding.type === BindingType.Property && this.claimedInputs.has(binding.name)) {\n        // Skip this binding as it was claimed by a directive.\n        continue;\n      }\n\n      if (binding.type === BindingType.Property) {\n        if (binding.name !== 'style' && binding.name !== 'class') {\n          // A direct binding to a property.\n          const propertyName = ATTR_TO_PROP.get(binding.name) ?? binding.name;\n          this.tcb.domSchemaChecker.checkProperty(\n              this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas,\n              this.tcb.hostIsStandalone);\n        }\n      }\n    }\n    return null;\n  }\n}\n\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n * Note: this mapping has to be kept in sync with the equally named mapping in the runtime.\n */\nconst ATTR_TO_PROP = new Map(Object.entries({\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n}));\n\n/**\n * A `TcbOp` which generates code to check \"unclaimed inputs\" - bindings on an element which were\n * not attributed to any directive or component, and are instead processed against the HTML element\n * itself.\n *\n * Currently, only the expressions of these bindings are checked. The targets of the bindings are\n * checked against the DOM schema via a `TcbDomSchemaCheckerOp`.\n *\n * Executing this operation returns nothing.\n */\nclass TcbUnclaimedInputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private element: TmplAstElement,\n      private claimedInputs: Set<string>) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): null {\n    // `this.inputs` contains only those bindings not matched by any directive. These bindings go to\n    // the element itself.\n    let elId: ts.Expression|null = null;\n\n    // TODO(alxhub): this could be more efficient.\n    for (const binding of this.element.inputs) {\n      if (binding.type === BindingType.Property && this.claimedInputs.has(binding.name)) {\n        // Skip this binding as it was claimed by a directive.\n        continue;\n      }\n\n      const expr = widenBinding(tcbExpression(binding.value, this.tcb, this.scope), this.tcb);\n\n      if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === BindingType.Property) {\n        if (binding.name !== 'style' && binding.name !== 'class') {\n          if (elId === null) {\n            elId = this.scope.resolve(this.element);\n          }\n          // A direct binding to a property.\n          const propertyName = ATTR_TO_PROP.get(binding.name) ?? binding.name;\n          const prop = ts.factory.createElementAccessExpression(\n              elId, ts.factory.createStringLiteral(propertyName));\n          const stmt = ts.factory.createBinaryExpression(\n              prop, ts.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));\n          addParseSpanInfo(stmt, binding.sourceSpan);\n          this.scope.addStatement(ts.factory.createExpressionStatement(stmt));\n        } else {\n          this.scope.addStatement(ts.factory.createExpressionStatement(expr));\n        }\n      } else {\n        // A binding to an animation, attribute, class or style. For now, only validate the right-\n        // hand side of the expression.\n        // TODO: properly check class and style bindings.\n        this.scope.addStatement(ts.factory.createExpressionStatement(expr));\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which generates code to check event bindings on an element that correspond with the\n * outputs of a directive.\n *\n * Executing this operation returns nothing.\n */\nexport class TcbDirectiveOutputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): null {\n    let dirId: ts.Expression|null = null;\n    const outputs = this.dir.outputs;\n\n    for (const output of this.node.outputs) {\n      if (output.type !== ParsedEventType.Regular || !outputs.hasBindingPropertyName(output.name)) {\n        continue;\n      }\n\n      if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith('Change')) {\n        const inputName = output.name.slice(0, -6);\n        isSplitTwoWayBinding(inputName, output, this.node.inputs, this.tcb);\n      }\n      // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.\n      const field = outputs.getByBindingPropertyName(output.name)![0].classPropertyName;\n\n      if (dirId === null) {\n        dirId = this.scope.resolve(this.node, this.dir);\n      }\n      const outputField =\n          ts.factory.createElementAccessExpression(dirId, ts.factory.createStringLiteral(field));\n      addParseSpanInfo(outputField, output.keySpan);\n      if (this.tcb.env.config.checkTypeOfOutputEvents) {\n        // For strict checking of directive events, generate a call to the `subscribe` method\n        // on the directive's output field to let type information flow into the handler function's\n        // `$event` parameter.\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);\n        const subscribeFn = ts.factory.createPropertyAccessExpression(outputField, 'subscribe');\n        const call =\n            ts.factory.createCallExpression(subscribeFn, /* typeArguments */ undefined, [handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts.factory.createExpressionStatement(call));\n      } else {\n        // If strict checking of directive events is disabled:\n        //\n        // * We still generate the access to the output field as a statement in the TCB so consumers\n        //   of the `TemplateTypeChecker` can still find the node for the class member for the\n        //   output.\n        // * Emit a handler function where the `$event` parameter has an explicit `any` type.\n        this.scope.addStatement(ts.factory.createExpressionStatement(outputField));\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Any);\n        this.scope.addStatement(ts.factory.createExpressionStatement(handler));\n      }\n\n      ExpressionSemanticVisitor.visit(\n          output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which generates code to check \"unclaimed outputs\" - event bindings on an element which\n * were not attributed to any directive or component, and are instead processed against the HTML\n * element itself.\n *\n * Executing this operation returns nothing.\n */\nclass TcbUnclaimedOutputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private element: TmplAstElement,\n      private claimedOutputs: Set<string>) {\n    super();\n  }\n\n  override get optional() {\n    return false;\n  }\n\n  override execute(): null {\n    let elId: ts.Expression|null = null;\n\n    // TODO(alxhub): this could be more efficient.\n    for (const output of this.element.outputs) {\n      if (this.claimedOutputs.has(output.name)) {\n        // Skip this event handler as it was claimed by a directive.\n        continue;\n      }\n\n      if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith('Change')) {\n        const inputName = output.name.slice(0, -6);\n        if (isSplitTwoWayBinding(inputName, output, this.element.inputs, this.tcb)) {\n          // Skip this event handler as the error was already handled.\n          continue;\n        }\n      }\n\n      if (output.type === ParsedEventType.Animation) {\n        // Animation output bindings always have an `$event` parameter of type `AnimationEvent`.\n        const eventType = this.tcb.env.config.checkTypeOfAnimationEvents ?\n            this.tcb.env.referenceExternalType('@angular/animations', 'AnimationEvent') :\n            EventParamType.Any;\n\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);\n        this.scope.addStatement(ts.factory.createExpressionStatement(handler));\n      } else if (this.tcb.env.config.checkTypeOfDomEvents) {\n        // If strict checking of DOM events is enabled, generate a call to `addEventListener` on\n        // the element instance so that TypeScript's type inference for\n        // `HTMLElement.addEventListener` using `HTMLElementEventMap` to infer an accurate type for\n        // `$event` depending on the event name. For unknown event names, TypeScript resorts to the\n        // base `Event` type.\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);\n\n        if (elId === null) {\n          elId = this.scope.resolve(this.element);\n        }\n        const propertyAccess = ts.factory.createPropertyAccessExpression(elId, 'addEventListener');\n        addParseSpanInfo(propertyAccess, output.keySpan);\n        const call = ts.factory.createCallExpression(\n            /* expression */ propertyAccess,\n            /* typeArguments */ undefined,\n            /* arguments */[ts.factory.createStringLiteral(output.name), handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts.factory.createExpressionStatement(call));\n      } else {\n        // If strict checking of DOM inputs is disabled, emit a handler function where the `$event`\n        // parameter has an explicit `any` type.\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Any);\n        this.scope.addStatement(ts.factory.createExpressionStatement(handler));\n      }\n\n      ExpressionSemanticVisitor.visit(\n          output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which generates a completion point for the component context.\n *\n * This completion point looks like `this. ;` in the TCB output, and does not produce diagnostics.\n * TypeScript autocompletion APIs can be used at this completion point (after the '.') to produce\n * autocompletion results of properties and methods from the template's component context.\n */\nclass TcbComponentContextCompletionOp extends TcbOp {\n  constructor(private scope: Scope) {\n    super();\n  }\n\n  override readonly optional = false;\n\n  override execute(): null {\n    const ctx = ts.factory.createThis();\n    const ctxDot = ts.factory.createPropertyAccessExpression(ctx, '');\n    markIgnoreDiagnostics(ctxDot);\n    addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);\n    this.scope.addStatement(ts.factory.createExpressionStatement(ctxDot));\n    return null;\n  }\n}\n\n/**\n * Value used to break a circular reference between `TcbOp`s.\n *\n * This value is returned whenever `TcbOp`s have a circular dependency. The expression is a non-null\n * assertion of the null value (in TypeScript, the expression `null!`). This construction will infer\n * the least narrow type for whatever it's assigned to.\n */\nconst INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts.factory.createNonNullExpression(ts.factory.createNull());\n\n/**\n * Overall generation context for the type check block.\n *\n * `Context` handles operations during code generation which are global with respect to the whole\n * block. It's responsible for variable name allocation and management of any imports needed. It\n * also contains the template metadata itself.\n */\nexport class Context {\n  private nextId = 1;\n\n  constructor(\n      readonly env: Environment, readonly domSchemaChecker: DomSchemaChecker,\n      readonly oobRecorder: OutOfBandDiagnosticRecorder, readonly id: TemplateId,\n      readonly boundTarget: BoundTarget<TypeCheckableDirectiveMeta>,\n      private pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n      readonly schemas: SchemaMetadata[], readonly hostIsStandalone: boolean) {}\n\n  /**\n   * Allocate a new variable name for use within the `Context`.\n   *\n   * Currently this uses a monotonically increasing counter, but in the future the variable name\n   * might change depending on the type of data being stored.\n   */\n  allocateId(): ts.Identifier {\n    return ts.factory.createIdentifier(`_t${this.nextId++}`);\n  }\n\n  getPipeByName(name: string): Reference<ClassDeclaration<ts.ClassDeclaration>>|null {\n    if (!this.pipes.has(name)) {\n      return null;\n    }\n    return this.pipes.get(name)!;\n  }\n}\n\n/**\n * Local scope within the type check block for a particular template.\n *\n * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a\n * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type\n * check block, where each nested template is encased in an `if` structure.\n *\n * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via\n * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`\n * via `renderToBlock()`.\n *\n * If a `TcbOp` requires the output of another, it can call `resolve()`.\n */\nclass Scope {\n  /**\n   * A queue of operations which need to be performed to generate the TCB code for this scope.\n   *\n   * This array can contain either a `TcbOp` which has yet to be executed, or a `ts.Expression|null`\n   * representing the memoized result of executing the operation. As operations are executed, their\n   * results are written into the `opQueue`, overwriting the original operation.\n   *\n   * If an operation is in the process of being executed, it is temporarily overwritten here with\n   * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cycle is encountered where an operation\n   * depends transitively on its own result, the inner operation will infer the least narrow type\n   * that fits instead. This has the same semantics as TypeScript itself when types are referenced\n   * circularly.\n   */\n  private opQueue: (TcbOp|ts.Expression|null)[] = [];\n\n  /**\n   * A map of `TmplAstElement`s to the index of their `TcbElementOp` in the `opQueue`\n   */\n  private elementOpMap = new Map<TmplAstElement, number>();\n  /**\n   * A map of maps which tracks the index of `TcbDirectiveCtorOp`s in the `opQueue` for each\n   * directive on a `TmplAstElement` or `TmplAstTemplate` node.\n   */\n  private directiveOpMap =\n      new Map<TmplAstElement|TmplAstTemplate, Map<TypeCheckableDirectiveMeta, number>>();\n\n  /**\n   * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`\n   */\n  private referenceOpMap = new Map<TmplAstReference, number>();\n\n  /**\n   * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`\n   * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.\n   */\n  private templateCtxOpMap = new Map<TmplAstTemplate, number>();\n\n  /**\n   * Map of variables declared on the template that created this `Scope` (represented by\n   * `TmplAstVariable` nodes) to the index of their `TcbVariableOp`s in the `opQueue`.\n   */\n  private varMap = new Map<TmplAstVariable, number>();\n\n  /**\n   * Statements for this template.\n   *\n   * Executing the `TcbOp`s in the `opQueue` populates this array.\n   */\n  private statements: ts.Statement[] = [];\n\n  private constructor(\n      private tcb: Context, private parent: Scope|null = null,\n      private guard: ts.Expression|null = null) {}\n\n  /**\n   * Constructs a `Scope` given either a `TmplAstTemplate` or a list of `TmplAstNode`s.\n   *\n   * @param tcb the overall context of TCB generation.\n   * @param parent the `Scope` of the parent template (if any) or `null` if this is the root\n   * `Scope`.\n   * @param templateOrNodes either a `TmplAstTemplate` representing the template for which to\n   * calculate the `Scope`, or a list of nodes if no outer template object is available.\n   * @param guard an expression that is applied to this scope for type narrowing purposes.\n   */\n  static forNodes(\n      tcb: Context, parent: Scope|null, templateOrNodes: TmplAstTemplate|(TmplAstNode[]),\n      guard: ts.Expression|null): Scope {\n    const scope = new Scope(tcb, parent, guard);\n\n    if (parent === null && tcb.env.config.enableTemplateTypeChecker) {\n      // Add an autocompletion point for the component context.\n      scope.opQueue.push(new TcbComponentContextCompletionOp(scope));\n    }\n\n    let children: TmplAstNode[];\n\n    // If given an actual `TmplAstTemplate` instance, then process any additional information it\n    // has.\n    if (templateOrNodes instanceof TmplAstTemplate) {\n      // The template's variable declarations need to be added as `TcbVariableOp`s.\n      const varMap = new Map<string, TmplAstVariable>();\n\n      for (const v of templateOrNodes.variables) {\n        // Validate that variables on the `TmplAstTemplate` are only declared once.\n        if (!varMap.has(v.name)) {\n          varMap.set(v.name, v);\n        } else {\n          const firstDecl = varMap.get(v.name)!;\n          tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);\n        }\n\n        const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;\n        scope.varMap.set(v, opIndex);\n      }\n      children = templateOrNodes.children;\n    } else {\n      children = templateOrNodes;\n    }\n    for (const node of children) {\n      scope.appendNode(node);\n    }\n    return scope;\n  }\n\n  /**\n   * Look up a `ts.Expression` representing the value of some operation in the current `Scope`,\n   * including any parent scope(s). This method always returns a mutable clone of the\n   * `ts.Expression` with the comments cleared.\n   *\n   * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on\n   * the type of this node:\n   *\n   * Assuming `directive` is not present, then `resolve` will return:\n   *\n   * * `TmplAstElement` - retrieve the expression for the element DOM node\n   * * `TmplAstTemplate` - retrieve the template context variable\n   * * `TmplAstVariable` - retrieve a template let- variable\n   * * `TmplAstReference` - retrieve variable created for the local ref\n   *\n   * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to\n   * look up instead of the default for an element or template node.\n   */\n  resolve(\n      node: TmplAstElement|TmplAstTemplate|TmplAstVariable|TmplAstReference,\n      directive?: TypeCheckableDirectiveMeta): ts.Identifier|ts.NonNullExpression {\n    // Attempt to resolve the operation locally.\n    const res = this.resolveLocal(node, directive);\n    if (res !== null) {\n      // We want to get a clone of the resolved expression and clear the trailing comments\n      // so they don't continue to appear in every place the expression is used.\n      // As an example, this would otherwise produce:\n      // var _t1 /**T:DIR*/ /*1,2*/ = _ctor1();\n      // _t1 /**T:DIR*/ /*1,2*/.input = 'value';\n      //\n      // In addition, returning a clone prevents the consumer of `Scope#resolve` from\n      // attaching comments at the declaration site.\n      let clone: ts.Identifier|ts.NonNullExpression;\n\n      if (ts.isIdentifier(res)) {\n        clone = ts.factory.createIdentifier(res.text);\n      } else if (ts.isNonNullExpression(res)) {\n        clone = ts.factory.createNonNullExpression(res.expression);\n      } else {\n        throw new Error(`Could not resolve ${node} to an Identifier or a NonNullExpression`);\n      }\n\n      ts.setOriginalNode(clone, res);\n      (clone as any).parent = clone.parent;\n      return ts.setSyntheticTrailingComments(clone, []);\n    } else if (this.parent !== null) {\n      // Check with the parent.\n      return this.parent.resolve(node, directive);\n    } else {\n      throw new Error(`Could not resolve ${node} / ${directive}`);\n    }\n  }\n\n  /**\n   * Add a statement to this scope.\n   */\n  addStatement(stmt: ts.Statement): void {\n    this.statements.push(stmt);\n  }\n\n  /**\n   * Get the statements.\n   */\n  render(): ts.Statement[] {\n    for (let i = 0; i < this.opQueue.length; i++) {\n      // Optional statements cannot be skipped when we are generating the TCB for use\n      // by the TemplateTypeChecker.\n      const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;\n      this.executeOp(i, skipOptional);\n    }\n    return this.statements;\n  }\n\n  /**\n   * Returns an expression of all template guards that apply to this scope, including those of\n   * parent scopes. If no guards have been applied, null is returned.\n   */\n  guards(): ts.Expression|null {\n    let parentGuards: ts.Expression|null = null;\n    if (this.parent !== null) {\n      // Start with the guards from the parent scope, if present.\n      parentGuards = this.parent.guards();\n    }\n\n    if (this.guard === null) {\n      // This scope does not have a guard, so return the parent's guards as is.\n      return parentGuards;\n    } else if (parentGuards === null) {\n      // There's no guards from the parent scope, so this scope's guard represents all available\n      // guards.\n      return this.guard;\n    } else {\n      // Both the parent scope and this scope provide a guard, so create a combination of the two.\n      // It is important that the parent guard is used as left operand, given that it may provide\n      // narrowing that is required for this scope's guard to be valid.\n      return ts.factory.createBinaryExpression(\n          parentGuards, ts.SyntaxKind.AmpersandAmpersandToken, this.guard);\n    }\n  }\n\n  private resolveLocal(\n      ref: TmplAstElement|TmplAstTemplate|TmplAstVariable|TmplAstReference,\n      directive?: TypeCheckableDirectiveMeta): ts.Expression|null {\n    if (ref instanceof TmplAstReference && this.referenceOpMap.has(ref)) {\n      return this.resolveOp(this.referenceOpMap.get(ref)!);\n    } else if (ref instanceof TmplAstVariable && this.varMap.has(ref)) {\n      // Resolving a context variable for this template.\n      // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.\n      return this.resolveOp(this.varMap.get(ref)!);\n    } else if (\n        ref instanceof TmplAstTemplate && directive === undefined &&\n        this.templateCtxOpMap.has(ref)) {\n      // Resolving the context of the given sub-template.\n      // Execute the `TcbTemplateContextOp` for the template.\n      return this.resolveOp(this.templateCtxOpMap.get(ref)!);\n    } else if (\n        (ref instanceof TmplAstElement || ref instanceof TmplAstTemplate) &&\n        directive !== undefined && this.directiveOpMap.has(ref)) {\n      // Resolving a directive on an element or sub-template.\n      const dirMap = this.directiveOpMap.get(ref)!;\n      if (dirMap.has(directive)) {\n        return this.resolveOp(dirMap.get(directive)!);\n      } else {\n        return null;\n      }\n    } else if (ref instanceof TmplAstElement && this.elementOpMap.has(ref)) {\n      // Resolving the DOM node of an element in this template.\n      return this.resolveOp(this.elementOpMap.get(ref)!);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.\n   */\n  private resolveOp(opIndex: number): ts.Expression {\n    const res = this.executeOp(opIndex, /* skipOptional */ false);\n    if (res === null) {\n      throw new Error(`Error resolving operation, got null`);\n    }\n    return res;\n  }\n\n  /**\n   * Execute a particular `TcbOp` in the `opQueue`.\n   *\n   * This method replaces the operation in the `opQueue` with the result of execution (once done)\n   * and also protects against a circular dependency from the operation to itself by temporarily\n   * setting the operation's result to a special expression.\n   */\n  private executeOp(opIndex: number, skipOptional: boolean): ts.Expression|null {\n    const op = this.opQueue[opIndex];\n    if (!(op instanceof TcbOp)) {\n      return op;\n    }\n\n    if (skipOptional && op.optional) {\n      return null;\n    }\n\n    // Set the result of the operation in the queue to its circular fallback. If executing this\n    // operation results in a circular dependency, this will prevent an infinite loop and allow for\n    // the resolution of such cycles.\n    this.opQueue[opIndex] = op.circularFallback();\n    const res = op.execute();\n    // Once the operation has finished executing, it's safe to cache the real result.\n    this.opQueue[opIndex] = res;\n    return res;\n  }\n\n  private appendNode(node: TmplAstNode): void {\n    if (node instanceof TmplAstElement) {\n      const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;\n      this.elementOpMap.set(node, opIndex);\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      for (const child of node.children) {\n        this.appendNode(child);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstTemplate) {\n      // Template children are rendered in a child scope.\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n      this.templateCtxOpMap.set(node, ctxIndex);\n      if (this.tcb.env.config.checkTemplateBodies) {\n        this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));\n      } else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {\n        this.appendDeepSchemaChecks(node.children);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstBoundText) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));\n    } else if (node instanceof TmplAstIcu) {\n      this.appendIcuExpressions(node);\n    }\n  }\n\n  private checkAndAppendReferencesOfNode(node: TmplAstElement|TmplAstTemplate): void {\n    for (const ref of node.references) {\n      const target = this.tcb.boundTarget.getReferenceTarget(ref);\n\n      let ctxIndex: number;\n      if (target === null) {\n        // The reference is invalid if it doesn't have a target, so report it as an error.\n        this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);\n\n        // Any usages of the invalid reference will be resolved to a variable of type any.\n        ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;\n      } else if (target instanceof TmplAstTemplate || target instanceof TmplAstElement) {\n        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;\n      } else {\n        ctxIndex =\n            this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;\n      }\n      this.referenceOpMap.set(ref, ctxIndex);\n    }\n  }\n\n  private appendDirectivesAndInputsOfNode(node: TmplAstElement|TmplAstTemplate): void {\n    // Collect all the inputs on the element.\n    const claimedInputs = new Set<string>();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      // If there are no directives, then all inputs are unclaimed inputs, so queue an operation\n      // to add them if needed.\n      if (node instanceof TmplAstElement) {\n        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n        this.opQueue.push(\n            new TcbDomSchemaCheckerOp(this.tcb, node, /* checkElement */ true, claimedInputs));\n      }\n      return;\n    }\n\n    const dirMap = new Map<TypeCheckableDirectiveMeta, number>();\n    for (const dir of directives) {\n      let directiveOp: TcbOp;\n      const host = this.tcb.env.reflector;\n      const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n\n      if (!dir.isGeneric) {\n        // The most common case is that when a directive is not generic, we use the normal\n        // `TcbNonDirectiveTypeOp`.\n        directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n      } else if (\n          !requiresInlineTypeCtor(dirRef.node, host, this.tcb.env) ||\n          this.tcb.env.config.useInlineTypeConstructors) {\n        // For generic directives, we use a type constructor to infer types. If a directive requires\n        // an inline type constructor, then inlining must be available to use the\n        // `TcbDirectiveCtorOp`. If not we, we fallback to using `any` â€“ see below.\n        directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);\n      } else {\n        // If inlining is not available, then we give up on inferring the generic params, and use\n        // `any` type for the directive's generic parameters.\n        directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);\n      }\n\n      const dirIndex = this.opQueue.push(directiveOp) - 1;\n      dirMap.set(dir, dirIndex);\n\n      this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));\n    }\n    this.directiveOpMap.set(node, dirMap);\n\n    // After expanding the directives, we might need to queue an operation to check any unclaimed\n    // inputs.\n    if (node instanceof TmplAstElement) {\n      // Go through the directives and remove any inputs that it claims from `elementInputs`.\n      for (const dir of directives) {\n        for (const propertyName of dir.inputs.propertyNames) {\n          claimedInputs.add(propertyName);\n        }\n      }\n\n      this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n      // If there are no directives which match this element, then it's a \"plain\" DOM element (or a\n      // web component), and should be checked against the DOM schema. If any directives match,\n      // we must assume that the element could be custom (either a component, or a directive like\n      // <router-outlet>) and shouldn't validate the element name itself.\n      const checkElement = directives.length === 0;\n      this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));\n    }\n  }\n\n  private appendOutputsOfNode(node: TmplAstElement|TmplAstTemplate): void {\n    // Collect all the outputs on the element.\n    const claimedOutputs = new Set<string>();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      // If there are no directives, then all outputs are unclaimed outputs, so queue an operation\n      // to add them if needed.\n      if (node instanceof TmplAstElement) {\n        this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n      }\n      return;\n    }\n\n    // Queue operations for all directives to check the relevant outputs for a directive.\n    for (const dir of directives) {\n      this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));\n    }\n\n    // After expanding the directives, we might need to queue an operation to check any unclaimed\n    // outputs.\n    if (node instanceof TmplAstElement) {\n      // Go through the directives and register any outputs that it claims in `claimedOutputs`.\n      for (const dir of directives) {\n        for (const outputProperty of dir.outputs.propertyNames) {\n          claimedOutputs.add(outputProperty);\n        }\n      }\n\n      this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n    }\n  }\n\n  private appendDeepSchemaChecks(nodes: TmplAstNode[]): void {\n    for (const node of nodes) {\n      if (!(node instanceof TmplAstElement || node instanceof TmplAstTemplate)) {\n        continue;\n      }\n\n      if (node instanceof TmplAstElement) {\n        const claimedInputs = new Set<string>();\n        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n        let hasDirectives: boolean;\n        if (directives === null || directives.length === 0) {\n          hasDirectives = false;\n        } else {\n          hasDirectives = true;\n          for (const dir of directives) {\n            for (const propertyName of dir.inputs.propertyNames) {\n              claimedInputs.add(propertyName);\n            }\n          }\n        }\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));\n      }\n\n      this.appendDeepSchemaChecks(node.children);\n    }\n  }\n\n  private appendIcuExpressions(node: TmplAstIcu): void {\n    for (const variable of Object.values(node.vars)) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, variable));\n    }\n    for (const placeholder of Object.values(node.placeholders)) {\n      if (placeholder instanceof TmplAstBoundText) {\n        this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, placeholder));\n      }\n    }\n  }\n}\n\ninterface TcbBoundAttribute {\n  attribute: TmplAstBoundAttribute|TmplAstTextAttribute;\n  inputs: {fieldName: ClassPropertyName, required: boolean}[];\n}\n\n/**\n * Create the `this` parameter to the top-level TCB function, with the given generic type\n * arguments.\n */\nfunction tcbThisParam(\n    name: ts.EntityName, typeArguments: ts.TypeNode[]|undefined): ts.ParameterDeclaration {\n  return ts.factory.createParameterDeclaration(\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ 'this',\n      /* questionToken */ undefined,\n      /* type */ ts.factory.createTypeReferenceNode(name, typeArguments),\n      /* initializer */ undefined);\n}\n\n/**\n * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the\n * correct identifiers in the current scope.\n */\nfunction tcbExpression(ast: AST, tcb: Context, scope: Scope): ts.Expression {\n  const translator = new TcbExpressionTranslator(tcb, scope);\n  return translator.translate(ast);\n}\n\nclass TcbExpressionTranslator {\n  constructor(protected tcb: Context, protected scope: Scope) {}\n\n  translate(ast: AST): ts.Expression {\n    // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed\n    // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These\n    // nodes actually refer to identifiers within the current scope.\n    return astToTypescript(ast, ast => this.resolve(ast), this.tcb.env.config);\n  }\n\n  /**\n   * Resolve an `AST` expression within the given scope.\n   *\n   * Some `AST` expressions refer to top-level concepts (references, variables, the component\n   * context). This method assists in resolving those.\n   */\n  protected resolve(ast: AST): ts.Expression|null {\n    if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver) {\n      // Try to resolve a bound target for this expression. If no such target is available, then\n      // the expression is referencing the top-level component context. In that case, `null` is\n      // returned here to let it fall through resolution so it will be caught when the\n      // `ImplicitReceiver` is resolved in the branch below.\n      return this.resolveTarget(ast);\n    } else if (ast instanceof PropertyWrite && ast.receiver instanceof ImplicitReceiver) {\n      const target = this.resolveTarget(ast);\n      if (target === null) {\n        return null;\n      }\n\n      const expr = this.translate(ast.value);\n      const result = ts.factory.createParenthesizedExpression(\n          ts.factory.createBinaryExpression(target, ts.SyntaxKind.EqualsToken, expr));\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if (ast instanceof ImplicitReceiver) {\n      // AST instances representing variables and references look very similar to property reads\n      // or method calls from the component context: both have the shape\n      // PropertyRead(ImplicitReceiver, 'propName') or Call(ImplicitReceiver, 'methodName').\n      //\n      // `translate` will first try to `resolve` the outer PropertyRead/Call. If this works,\n      // it's because the `BoundTarget` found an expression target for the whole expression, and\n      // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that\n      // PropertyRead/Call.\n      //\n      // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer\n      // PropertyRead/Call resolved to a variable or reference, and therefore this is a\n      // property read or method call on the component context itself.\n      return ts.factory.createThis();\n    } else if (ast instanceof BindingPipe) {\n      const expr = this.translate(ast.exp);\n      const pipeRef = this.tcb.getPipeByName(ast.name);\n      let pipe: ts.Expression|null;\n      if (pipeRef === null) {\n        // No pipe by that name exists in scope. Record this as an error.\n        this.tcb.oobRecorder.missingPipe(this.tcb.id, ast);\n\n        // Use an 'any' value to at least allow the rest of the expression to be checked.\n        pipe = NULL_AS_ANY;\n      } else {\n        // Use a variable declared as the pipe's type.\n        pipe = this.tcb.env.pipeInst(pipeRef);\n      }\n      const args = ast.args.map(arg => this.translate(arg));\n      let methodAccess: ts.Expression =\n          ts.factory.createPropertyAccessExpression(pipe, 'transform');\n      addParseSpanInfo(methodAccess, ast.nameSpan);\n      if (!this.tcb.env.config.checkTypeOfPipes) {\n        methodAccess = ts.factory.createAsExpression(\n            methodAccess, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      }\n\n      const result = ts.factory.createCallExpression(\n          /* expression */ methodAccess,\n          /* typeArguments */ undefined,\n          /* argumentsArray */[expr, ...args]);\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if (\n        (ast instanceof Call || ast instanceof SafeCall) &&\n        (ast.receiver instanceof PropertyRead || ast.receiver instanceof SafePropertyRead)) {\n      // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.\n      // `$any(expr)` -> `expr as any`\n      if (ast.receiver.receiver instanceof ImplicitReceiver &&\n          !(ast.receiver.receiver instanceof ThisReceiver) && ast.receiver.name === '$any' &&\n          ast.args.length === 1) {\n        const expr = this.translate(ast.args[0]);\n        const exprAsAny = ts.factory.createAsExpression(\n            expr, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n        const result = ts.factory.createParenthesizedExpression(exprAsAny);\n        addParseSpanInfo(result, ast.sourceSpan);\n        return result;\n      }\n\n      // Attempt to resolve a bound target for the method, and generate the method call if a target\n      // could be resolved. If no target is available, then the method is referencing the top-level\n      // component context, in which case `null` is returned to let the `ImplicitReceiver` being\n      // resolved to the component context.\n      const receiver = this.resolveTarget(ast);\n      if (receiver === null) {\n        return null;\n      }\n\n      const method = wrapForDiagnostics(receiver);\n      addParseSpanInfo(method, ast.receiver.nameSpan);\n      const args = ast.args.map(arg => this.translate(arg));\n      const node = ts.factory.createCallExpression(method, undefined, args);\n      addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    } else {\n      // This AST isn't special after all.\n      return null;\n    }\n  }\n\n  /**\n   * Attempts to resolve a bound target for a given expression, and translates it into the\n   * appropriate `ts.Expression` that represents the bound target. If no target is available,\n   * `null` is returned.\n   */\n  protected resolveTarget(ast: AST): ts.Expression|null {\n    const binding = this.tcb.boundTarget.getExpressionTarget(ast);\n    if (binding === null) {\n      return null;\n    }\n\n    const expr = this.scope.resolve(binding);\n    addParseSpanInfo(expr, ast.sourceSpan);\n    return expr;\n  }\n}\n\n/**\n * Call the type constructor of a directive instance on a given template node, inferring a type for\n * the directive instance from any bound inputs.\n */\nfunction tcbCallTypeCtor(\n    dir: TypeCheckableDirectiveMeta, tcb: Context, inputs: TcbDirectiveInput[]): ts.Expression {\n  const typeCtor = tcb.env.typeCtorFor(dir);\n\n  // Construct an array of `ts.PropertyAssignment`s for each of the directive's inputs.\n  const members = inputs.map(input => {\n    const propertyName = ts.factory.createStringLiteral(input.field);\n\n    if (input.type === 'binding') {\n      // For bound inputs, the property is assigned the binding expression.\n      const expr = widenBinding(input.expression, tcb);\n\n      const assignment =\n          ts.factory.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));\n      addParseSpanInfo(assignment, input.sourceSpan);\n      return assignment;\n    } else {\n      // A type constructor is required to be called with all input properties, so any unset\n      // inputs are simply assigned a value of type `any` to ignore them.\n      return ts.factory.createPropertyAssignment(propertyName, NULL_AS_ANY);\n    }\n  });\n\n  // Call the `ngTypeCtor` method on the directive class, with an object literal argument created\n  // from the matched inputs.\n  return ts.factory.createCallExpression(\n      /* expression */ typeCtor,\n      /* typeArguments */ undefined,\n      /* argumentsArray */[ts.factory.createObjectLiteralExpression(members)]);\n}\n\nfunction getBoundAttributes(\n    directive: TypeCheckableDirectiveMeta,\n    node: TmplAstTemplate|TmplAstElement): TcbBoundAttribute[] {\n  const boundInputs: TcbBoundAttribute[] = [];\n\n  const processAttribute = (attr: TmplAstBoundAttribute|TmplAstTextAttribute) => {\n    // Skip non-property bindings.\n    if (attr instanceof TmplAstBoundAttribute && attr.type !== BindingType.Property) {\n      return;\n    }\n\n    // Skip the attribute if the directive does not have an input for it.\n    const inputs = directive.inputs.getByBindingPropertyName(attr.name);\n\n    if (inputs !== null) {\n      boundInputs.push({\n        attribute: attr,\n        inputs:\n            inputs.map(input => ({fieldName: input.classPropertyName, required: input.required}))\n      });\n    }\n  };\n\n  node.inputs.forEach(processAttribute);\n  node.attributes.forEach(processAttribute);\n  if (node instanceof TmplAstTemplate) {\n    node.templateAttrs.forEach(processAttribute);\n  }\n\n  return boundInputs;\n}\n\n/**\n * Translates the given attribute binding to a `ts.Expression`.\n */\nfunction translateInput(\n    attr: TmplAstBoundAttribute|TmplAstTextAttribute, tcb: Context, scope: Scope): ts.Expression {\n  if (attr instanceof TmplAstBoundAttribute) {\n    // Produce an expression representing the value of the binding.\n    return tcbExpression(attr.value, tcb, scope);\n  } else {\n    // For regular attributes with a static string value, use the represented string literal.\n    return ts.factory.createStringLiteral(attr.value);\n  }\n}\n\n/**\n * Potentially widens the type of `expr` according to the type-checking configuration.\n */\nfunction widenBinding(expr: ts.Expression, tcb: Context): ts.Expression {\n  if (!tcb.env.config.checkTypeOfInputBindings) {\n    // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n    // before the assignment.\n    return tsCastToAny(expr);\n  } else if (!tcb.env.config.strictNullInputBindings) {\n    if (ts.isObjectLiteralExpression(expr) || ts.isArrayLiteralExpression(expr)) {\n      // Object literals and array literals should not be wrapped in non-null assertions as that\n      // would cause literals to be prematurely widened, resulting in type errors when assigning\n      // into a literal type.\n      return expr;\n    } else {\n      // If strict null checks are disabled, erase `null` and `undefined` from the type by\n      // wrapping the expression in a non-null assertion.\n      return ts.factory.createNonNullExpression(expr);\n    }\n  } else {\n    // No widening is requested, use the expression as is.\n    return expr;\n  }\n}\n\n/**\n * An input binding that corresponds with a field of a directive.\n */\ninterface TcbDirectiveBoundInput {\n  type: 'binding';\n\n  /**\n   * The name of a field on the directive that is set.\n   */\n  field: string;\n\n  /**\n   * The `ts.Expression` corresponding with the input binding expression.\n   */\n  expression: ts.Expression;\n\n  /**\n   * The source span of the full attribute binding.\n   */\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Indicates that a certain field of a directive does not have a corresponding input binding.\n */\ninterface TcbDirectiveUnsetInput {\n  type: 'unset';\n\n  /**\n   * The name of a field on the directive for which no input binding is present.\n   */\n  field: string;\n}\n\ntype TcbDirectiveInput = TcbDirectiveBoundInput|TcbDirectiveUnsetInput;\n\nconst EVENT_PARAMETER = '$event';\n\nconst enum EventParamType {\n  /* Generates code to infer the type of `$event` based on how the listener is registered. */\n  Infer,\n\n  /* Declares the type of the `$event` parameter as `any`. */\n  Any,\n}\n\n/**\n * Creates an arrow function to be used as handler function for event bindings. The handler\n * function has a single parameter `$event` and the bound event's handler `AST` represented as a\n * TypeScript expression as its body.\n *\n * When `eventType` is set to `Infer`, the `$event` parameter will not have an explicit type. This\n * allows for the created handler function to have its `$event` parameter's type inferred based on\n * how it's used, to enable strict type checking of event bindings. When set to `Any`, the `$event`\n * parameter will have an explicit `any` type, effectively disabling strict type checking of event\n * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.\n */\nfunction tcbCreateEventHandler(\n    event: TmplAstBoundEvent, tcb: Context, scope: Scope,\n    eventType: EventParamType|ts.TypeNode): ts.Expression {\n  const handler = tcbEventHandlerExpression(event.handler, tcb, scope);\n\n  let eventParamType: ts.TypeNode|undefined;\n  if (eventType === EventParamType.Infer) {\n    eventParamType = undefined;\n  } else if (eventType === EventParamType.Any) {\n    eventParamType = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n  } else {\n    eventParamType = eventType;\n  }\n\n  // Obtain all guards that have been applied to the scope and its parents, as they have to be\n  // repeated within the handler function for their narrowing to be in effect within the handler.\n  const guards = scope.guards();\n\n  let body: ts.Statement = ts.factory.createExpressionStatement(handler);\n  if (guards !== null) {\n    // Wrap the body in an `if` statement containing all guards that have to be applied.\n    body = ts.factory.createIfStatement(guards, body);\n  }\n\n  const eventParam = ts.factory.createParameterDeclaration(\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ EVENT_PARAMETER,\n      /* questionToken */ undefined,\n      /* type */ eventParamType);\n  addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);\n\n  // Return an arrow function instead of a function expression to preserve the `this` context.\n  return ts.factory.createArrowFunction(\n      /* modifiers */ undefined,\n      /* typeParameters */ undefined,\n      /* parameters */[eventParam],\n      /* type */ ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n      /* equalsGreaterThanToken */ undefined,\n      /* body */ ts.factory.createBlock([body]));\n}\n\n/**\n * Similar to `tcbExpression`, this function converts the provided `AST` expression into a\n * `ts.Expression`, with special handling of the `$event` variable that can be used within event\n * bindings.\n */\nfunction tcbEventHandlerExpression(ast: AST, tcb: Context, scope: Scope): ts.Expression {\n  const translator = new TcbEventHandlerTranslator(tcb, scope);\n  return translator.translate(ast);\n}\n\nfunction isSplitTwoWayBinding(\n    inputName: string, output: TmplAstBoundEvent, inputs: TmplAstBoundAttribute[], tcb: Context) {\n  const input = inputs.find(input => input.name === inputName);\n  if (input === undefined || input.sourceSpan !== output.sourceSpan) {\n    return false;\n  }\n  // Input consumer should be a directive because it's claimed\n  const inputConsumer = tcb.boundTarget.getConsumerOfBinding(input) as TypeCheckableDirectiveMeta;\n  const outputConsumer = tcb.boundTarget.getConsumerOfBinding(output);\n  if (outputConsumer === null || inputConsumer.ref === undefined ||\n      outputConsumer instanceof TmplAstTemplate) {\n    return false;\n  }\n  if (outputConsumer instanceof TmplAstElement) {\n    tcb.oobRecorder.splitTwoWayBinding(\n        tcb.id, input, output, inputConsumer.ref.node, outputConsumer);\n    return true;\n  } else if (outputConsumer.ref !== inputConsumer.ref) {\n    tcb.oobRecorder.splitTwoWayBinding(\n        tcb.id, input, output, inputConsumer.ref.node, outputConsumer.ref.node);\n    return true;\n  }\n  return false;\n}\n\nclass TcbEventHandlerTranslator extends TcbExpressionTranslator {\n  protected override resolve(ast: AST): ts.Expression|null {\n    // Recognize a property read on the implicit receiver corresponding with the event parameter\n    // that is available in event bindings. Since this variable is a parameter of the handler\n    // function that the converted expression becomes a child of, just create a reference to the\n    // parameter by its name.\n    if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver &&\n        !(ast.receiver instanceof ThisReceiver) && ast.name === EVENT_PARAMETER) {\n      const event = ts.factory.createIdentifier(EVENT_PARAMETER);\n      addParseSpanInfo(event, ast.nameSpan);\n      return event;\n    }\n\n    return super.resolve(ast);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {TemplateDiagnostic, TemplateId} from '../api';\nimport {makeTemplateDiagnostic} from '../diagnostics';\n\nimport {getTemplateMapping, TemplateSourceResolver} from './tcb_util';\n\n\n/**\n * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n * node. This is an alias for `ts.factory.createParenthesizedExpression` with the benefit that it\n * signifies that the inserted parenthesis are for diagnostic purposes, not for correctness of the\n * rendered TCB code.\n *\n * Note that it is important that nodes and its attached comment are not wrapped into parenthesis\n * by default, as it prevents correct translation of e.g. diagnostics produced for incorrect method\n * arguments. Such diagnostics would then be produced for the parenthesised node whereas the\n * positional comment would be located within that node, resulting in a mismatch.\n */\nexport function wrapForDiagnostics(expr: ts.Expression): ts.Expression {\n  return ts.factory.createParenthesizedExpression(expr);\n}\n\n/**\n * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n * node. This is an alias for `ts.factory.createParenthesizedExpression` with the benefit that it\n * signifies that the inserted parenthesis are for use by the type checker, not for correctness of\n * the rendered TCB code.\n */\nexport function wrapForTypeChecker(expr: ts.Expression): ts.Expression {\n  return ts.factory.createParenthesizedExpression(expr);\n}\n\n/**\n * Adds a synthetic comment to the expression that represents the parse span of the provided node.\n * This comment can later be retrieved as trivia of a node to recover original source locations.\n */\nexport function addParseSpanInfo(node: ts.Node, span: AbsoluteSourceSpan|ParseSourceSpan): void {\n  let commentText: string;\n  if (span instanceof AbsoluteSourceSpan) {\n    commentText = `${span.start},${span.end}`;\n  } else {\n    commentText = `${span.start.offset},${span.end.offset}`;\n  }\n  ts.addSyntheticTrailingComment(\n      node, ts.SyntaxKind.MultiLineCommentTrivia, commentText, /* hasTrailingNewLine */ false);\n}\n\n/**\n * Adds a synthetic comment to the function declaration that contains the template id\n * of the class declaration.\n */\nexport function addTemplateId(tcb: ts.FunctionDeclaration, id: TemplateId): void {\n  ts.addSyntheticLeadingComment(tcb, ts.SyntaxKind.MultiLineCommentTrivia, id, true);\n}\n\n/**\n * Determines if the diagnostic should be reported. Some diagnostics are produced because of the\n * way TCBs are generated; those diagnostics should not be reported as type check errors of the\n * template.\n */\nexport function shouldReportDiagnostic(diagnostic: ts.Diagnostic): boolean {\n  const {code} = diagnostic;\n  if (code === 6133 /* $var is declared but its value is never read. */) {\n    return false;\n  } else if (code === 6199 /* All variables are unused. */) {\n    return false;\n  } else if (code === 2695 /* Left side of comma operator is unused and has no side effects. */) {\n    return false;\n  } else if (code === 7006 /* Parameter '$event' implicitly has an 'any' type. */) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Attempts to translate a TypeScript diagnostic produced during template type-checking to their\n * location of origin, based on the comments that are emitted in the TCB code.\n *\n * If the diagnostic could not be translated, `null` is returned to indicate that the diagnostic\n * should not be reported at all. This prevents diagnostics from non-TCB code in a user's source\n * file from being reported as type-check errors.\n */\nexport function translateDiagnostic(\n    diagnostic: ts.Diagnostic, resolver: TemplateSourceResolver): TemplateDiagnostic|null {\n  if (diagnostic.file === undefined || diagnostic.start === undefined) {\n    return null;\n  }\n  const fullMapping = getTemplateMapping(\n      diagnostic.file, diagnostic.start, resolver, /*isDiagnosticsRequest*/ true);\n  if (fullMapping === null) {\n    return null;\n  }\n\n  const {sourceLocation, templateSourceMapping, span} = fullMapping;\n  return makeTemplateDiagnostic(\n      sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code,\n      diagnostic.messageText);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, SafeCall, SafeKeyedRead, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {TypeCheckingConfig} from '../api';\n\nimport {addParseSpanInfo, wrapForDiagnostics, wrapForTypeChecker} from './diagnostics';\nimport {tsCastToAny} from './ts_util';\n\nexport const NULL_AS_ANY = ts.factory.createAsExpression(\n    ts.factory.createNull(), ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\nconst UNDEFINED = ts.factory.createIdentifier('undefined');\n\nconst UNARY_OPS = new Map<string, ts.PrefixUnaryOperator>([\n  ['+', ts.SyntaxKind.PlusToken],\n  ['-', ts.SyntaxKind.MinusToken],\n]);\n\nconst BINARY_OPS = new Map<string, ts.BinaryOperator>([\n  ['+', ts.SyntaxKind.PlusToken],\n  ['-', ts.SyntaxKind.MinusToken],\n  ['<', ts.SyntaxKind.LessThanToken],\n  ['>', ts.SyntaxKind.GreaterThanToken],\n  ['<=', ts.SyntaxKind.LessThanEqualsToken],\n  ['>=', ts.SyntaxKind.GreaterThanEqualsToken],\n  ['==', ts.SyntaxKind.EqualsEqualsToken],\n  ['===', ts.SyntaxKind.EqualsEqualsEqualsToken],\n  ['*', ts.SyntaxKind.AsteriskToken],\n  ['/', ts.SyntaxKind.SlashToken],\n  ['%', ts.SyntaxKind.PercentToken],\n  ['!=', ts.SyntaxKind.ExclamationEqualsToken],\n  ['!==', ts.SyntaxKind.ExclamationEqualsEqualsToken],\n  ['||', ts.SyntaxKind.BarBarToken],\n  ['&&', ts.SyntaxKind.AmpersandAmpersandToken],\n  ['&', ts.SyntaxKind.AmpersandToken],\n  ['|', ts.SyntaxKind.BarToken],\n  ['??', ts.SyntaxKind.QuestionQuestionToken],\n]);\n\n/**\n * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`\n * AST.\n */\nexport function astToTypescript(\n    ast: AST, maybeResolve: (ast: AST) => (ts.Expression | null),\n    config: TypeCheckingConfig): ts.Expression {\n  const translator = new AstTranslator(maybeResolve, config);\n  return translator.translate(ast);\n}\n\nclass AstTranslator implements AstVisitor {\n  constructor(\n      private maybeResolve: (ast: AST) => (ts.Expression | null),\n      private config: TypeCheckingConfig) {}\n\n  translate(ast: AST): ts.Expression {\n    // Skip over an `ASTWithSource` as its `visit` method calls directly into its ast's `visit`,\n    // which would prevent any custom resolution through `maybeResolve` for that node.\n    if (ast instanceof ASTWithSource) {\n      ast = ast.ast;\n    }\n\n    // The `EmptyExpr` doesn't have a dedicated method on `AstVisitor`, so it's special cased here.\n    if (ast instanceof EmptyExpr) {\n      const res = ts.factory.createIdentifier('undefined');\n      addParseSpanInfo(res, ast.sourceSpan);\n      return res;\n    }\n\n    // First attempt to let any custom resolution logic provide a translation for the given node.\n    const resolved = this.maybeResolve(ast);\n    if (resolved !== null) {\n      return resolved;\n    }\n\n    return ast.visit(this);\n  }\n\n  visitUnary(ast: Unary): ts.Expression {\n    const expr = this.translate(ast.expr);\n    const op = UNARY_OPS.get(ast.operator);\n    if (op === undefined) {\n      throw new Error(`Unsupported Unary.operator: ${ast.operator}`);\n    }\n    const node = wrapForDiagnostics(ts.factory.createPrefixUnaryExpression(op, expr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitBinary(ast: Binary): ts.Expression {\n    const lhs = wrapForDiagnostics(this.translate(ast.left));\n    const rhs = wrapForDiagnostics(this.translate(ast.right));\n    const op = BINARY_OPS.get(ast.operation);\n    if (op === undefined) {\n      throw new Error(`Unsupported Binary.operation: ${ast.operation}`);\n    }\n    const node = ts.factory.createBinaryExpression(lhs, op, rhs);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitChain(ast: Chain): ts.Expression {\n    const elements = ast.expressions.map(expr => this.translate(expr));\n    const node = wrapForDiagnostics(ts.factory.createCommaListExpression(elements));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitConditional(ast: Conditional): ts.Expression {\n    const condExpr = this.translate(ast.condition);\n    const trueExpr = this.translate(ast.trueExp);\n    // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the\n    // whole conditional.\n    // In the following example, the last source span comment (5,6) could be seen as the\n    // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that\n    // is immediately before it:\n    // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`\n    // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`\n    const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));\n    const node = ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(\n        condExpr, undefined, trueExpr, undefined, falseExpr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitImplicitReceiver(ast: ImplicitReceiver): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitThisReceiver(ast: ThisReceiver): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInterpolation(ast: Interpolation): ts.Expression {\n    // Build up a chain of binary + operations to simulate the string concatenation of the\n    // interpolation's expressions. The chain is started using an actual string literal to ensure\n    // the type is inferred as 'string'.\n    return ast.expressions.reduce(\n        (lhs, ast) => ts.factory.createBinaryExpression(\n            lhs, ts.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast))),\n        ts.factory.createStringLiteral(''));\n  }\n\n  visitKeyedRead(ast: KeyedRead): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const key = this.translate(ast.key);\n    const node = ts.factory.createElementAccessExpression(receiver, key);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts.factory.createElementAccessExpression(receiver, this.translate(ast.key));\n    // TODO(joost): annotate `left` with the span of the element access, which is not currently\n    //  available on `ast`.\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(\n        ts.factory.createBinaryExpression(left, ts.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitLiteralArray(ast: LiteralArray): ts.Expression {\n    const elements = ast.expressions.map(expr => this.translate(expr));\n    const literal = ts.factory.createArrayLiteralExpression(elements);\n    // If strictLiteralTypes is disabled, array literals are cast to `any`.\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitLiteralMap(ast: LiteralMap): ts.Expression {\n    const properties = ast.keys.map(({key}, idx) => {\n      const value = this.translate(ast.values[idx]);\n      return ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(key), value);\n    });\n    const literal = ts.factory.createObjectLiteralExpression(properties, true);\n    // If strictLiteralTypes is disabled, object literals are cast to `any`.\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive): ts.Expression {\n    let node: ts.Expression;\n    if (ast.value === undefined) {\n      node = ts.factory.createIdentifier('undefined');\n    } else if (ast.value === null) {\n      node = ts.factory.createNull();\n    } else if (typeof ast.value === 'string') {\n      node = ts.factory.createStringLiteral(ast.value);\n    } else if (typeof ast.value === 'number') {\n      node = ts.factory.createNumericLiteral(ast.value);\n    } else if (typeof ast.value === 'boolean') {\n      node = ast.value ? ts.factory.createTrue() : ts.factory.createFalse();\n    } else {\n      throw Error(`Unsupported AST value of type ${typeof ast.value}`);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert): ts.Expression {\n    const expr = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts.factory.createNonNullExpression(expr);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitPipe(ast: BindingPipe): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitPrefixNot(ast: PrefixNot): ts.Expression {\n    const expression = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts.factory.createLogicalNot(expression);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitPropertyRead(ast: PropertyRead): ts.Expression {\n    // This is a normal property read - convert the receiver to an expression and emit the correct\n    // TypeScript expression to read the property.\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const name = ts.factory.createPropertyAccessExpression(receiver, ast.name);\n    addParseSpanInfo(name, ast.nameSpan);\n    const node = wrapForDiagnostics(name);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts.factory.createPropertyAccessExpression(receiver, ast.name);\n    addParseSpanInfo(left, ast.nameSpan);\n    // TypeScript reports assignment errors on the entire lvalue expression. Annotate the lvalue of\n    // the assignment with the sourceSpan, which includes receivers, rather than nameSpan for\n    // consistency of the diagnostic location.\n    // a.b.c = 1\n    // ^^^^^^^^^ sourceSpan\n    //     ^     nameSpan\n    const leftWithPath = wrapForDiagnostics(left);\n    addParseSpanInfo(leftWithPath, ast.sourceSpan);\n    // The right needs to be wrapped in parens as well or we cannot accurately match its\n    // span to just the RHS. For example, the span in `e = $event /*0,10*/` is ambiguous.\n    // It could refer to either the whole binary expression or just the RHS.\n    // We should instead generate `e = ($event /*0,10*/)` so we know the span 0,10 matches RHS.\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(\n        ts.factory.createBinaryExpression(leftWithPath, ts.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead): ts.Expression {\n    let node: ts.Expression;\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    // The form of safe property reads depends on whether strictness is in use.\n    if (this.config.strictSafeNavigationTypes) {\n      // Basically, the return here is either the type of the complete expression with a null-safe\n      // property read, or `undefined`. So a ternary is used to create an \"or\" type:\n      // \"a?.b\" becomes (null as any ? a!.b : undefined)\n      // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.\n      const expr = ts.factory.createPropertyAccessExpression(\n          ts.factory.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(\n          NULL_AS_ANY, undefined, expr, undefined, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe\n      // navigation operation. With this bug, the type of the left-hand side is regarded as any.\n      // Therefore, the left-hand side only needs repeating in the output (to validate it), and then\n      // 'any' is used for the rest of the expression. This is done using a comma operator:\n      // \"a?.b\" becomes (a as any).b, which will of course have type 'any'.\n      node = ts.factory.createPropertyAccessExpression(tsCastToAny(receiver), ast.name);\n    } else {\n      // The View Engine bug isn't active, so check the entire type of the expression, but the final\n      // result is still inferred as `any`.\n      // \"a?.b\" becomes (a!.b as any)\n      const expr = ts.factory.createPropertyAccessExpression(\n          ts.factory.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const key = this.translate(ast.key);\n    let node: ts.Expression;\n\n    // The form of safe property reads depends on whether strictness is in use.\n    if (this.config.strictSafeNavigationTypes) {\n      // \"a?.[...]\" becomes (null as any ? a![...] : undefined)\n      const expr = ts.factory.createElementAccessExpression(\n          ts.factory.createNonNullExpression(receiver), key);\n      addParseSpanInfo(expr, ast.sourceSpan);\n      node = ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(\n          NULL_AS_ANY, undefined, expr, undefined, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      // \"a?.[...]\" becomes (a as any)[...]\n      node = ts.factory.createElementAccessExpression(tsCastToAny(receiver), key);\n    } else {\n      // \"a?.[...]\" becomes (a!.[...] as any)\n      const expr = ts.factory.createElementAccessExpression(\n          ts.factory.createNonNullExpression(receiver), key);\n      addParseSpanInfo(expr, ast.sourceSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitCall(ast: Call): ts.Expression {\n    const args = ast.args.map(expr => this.translate(expr));\n\n    let expr: ts.Expression;\n    const receiver = ast.receiver;\n\n    // For calls that have a property read as receiver, we have to special-case their emit to avoid\n    // inserting superfluous parenthesis as they prevent TypeScript from applying a narrowing effect\n    // if the method acts as a type guard.\n    if (receiver instanceof PropertyRead) {\n      const resolved = this.maybeResolve(receiver);\n      if (resolved !== null) {\n        expr = resolved;\n      } else {\n        const propertyReceiver = wrapForDiagnostics(this.translate(receiver.receiver));\n        expr = ts.factory.createPropertyAccessExpression(propertyReceiver, receiver.name);\n        addParseSpanInfo(expr, receiver.nameSpan);\n      }\n    } else {\n      expr = this.translate(receiver);\n    }\n\n    let node: ts.Expression;\n\n    // Safe property/keyed reads will produce a ternary whose value is nullable.\n    // We have to generate a similar ternary around the call.\n    if (ast.receiver instanceof SafePropertyRead || ast.receiver instanceof SafeKeyedRead) {\n      node = this.convertToSafeCall(ast, expr, args);\n    } else {\n      node = ts.factory.createCallExpression(expr, undefined, args);\n    }\n\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitSafeCall(ast: SafeCall): ts.Expression {\n    const args = ast.args.map(expr => this.translate(expr));\n    const expr = wrapForDiagnostics(this.translate(ast.receiver));\n    const node = this.convertToSafeCall(ast, expr, args);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  private convertToSafeCall(ast: Call|SafeCall, expr: ts.Expression, args: ts.Expression[]):\n      ts.Expression {\n    if (this.config.strictSafeNavigationTypes) {\n      // \"a?.method(...)\" becomes (null as any ? a!.method(...) : undefined)\n      const call = ts.factory.createCallExpression(\n          ts.factory.createNonNullExpression(expr), undefined, args);\n      return ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(\n          NULL_AS_ANY, undefined, call, undefined, UNDEFINED));\n    }\n\n    if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      // \"a?.method(...)\" becomes (a as any).method(...)\n      return ts.factory.createCallExpression(tsCastToAny(expr), undefined, args);\n    }\n\n    // \"a?.method(...)\" becomes (a!.method(...) as any)\n    return tsCastToAny(\n        ts.factory.createCallExpression(ts.factory.createNonNullExpression(expr), undefined, args));\n  }\n}\n\n/**\n * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation\n * operation.\n *\n * In View Engine's template type-checker, certain receivers of safe navigation operations will\n * cause a temporary variable to be allocated as part of the checking expression, to save the value\n * of the receiver and use it more than once in the expression. This temporary variable has type\n * 'any'. In practice, this means certain receivers cause View Engine to not check the full\n * expression, and other receivers will receive more complete checking.\n *\n * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the\n * Ivy checker can emulate this bug when needed.\n */\nclass VeSafeLhsInferenceBugDetector implements AstVisitor {\n  private static SINGLETON = new VeSafeLhsInferenceBugDetector();\n\n  static veWillInferAnyFor(ast: Call|SafeCall|SafePropertyRead|SafeKeyedRead) {\n    const visitor = VeSafeLhsInferenceBugDetector.SINGLETON;\n    return ast instanceof Call ? ast.visit(visitor) : ast.receiver.visit(visitor);\n  }\n\n  visitUnary(ast: Unary): boolean {\n    return ast.expr.visit(this);\n  }\n  visitBinary(ast: Binary): boolean {\n    return ast.left.visit(this) || ast.right.visit(this);\n  }\n  visitChain(ast: Chain): boolean {\n    return false;\n  }\n  visitConditional(ast: Conditional): boolean {\n    return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);\n  }\n  visitCall(ast: Call): boolean {\n    return true;\n  }\n  visitSafeCall(ast: SafeCall): boolean {\n    return false;\n  }\n  visitImplicitReceiver(ast: ImplicitReceiver): boolean {\n    return false;\n  }\n  visitThisReceiver(ast: ThisReceiver): boolean {\n    return false;\n  }\n  visitInterpolation(ast: Interpolation): boolean {\n    return ast.expressions.some(exp => exp.visit(this));\n  }\n  visitKeyedRead(ast: KeyedRead): boolean {\n    return false;\n  }\n  visitKeyedWrite(ast: KeyedWrite): boolean {\n    return false;\n  }\n  visitLiteralArray(ast: LiteralArray): boolean {\n    return true;\n  }\n  visitLiteralMap(ast: LiteralMap): boolean {\n    return true;\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive): boolean {\n    return false;\n  }\n  visitPipe(ast: BindingPipe): boolean {\n    return true;\n  }\n  visitPrefixNot(ast: PrefixNot): boolean {\n    return ast.expression.visit(this);\n  }\n  visitNonNullAssert(ast: PrefixNot): boolean {\n    return ast.expression.visit(this);\n  }\n  visitPropertyRead(ast: PropertyRead): boolean {\n    return false;\n  }\n  visitPropertyWrite(ast: PropertyWrite): boolean {\n    return false;\n  }\n  visitSafePropertyRead(ast: SafePropertyRead): boolean {\n    return false;\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead): boolean {\n    return false;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BoundTarget, ImplicitReceiver, PropertyWrite, RecursiveAstVisitor, TmplAstVariable} from '@angular/compiler';\n\nimport {TemplateId} from '../api';\n\nimport {OutOfBandDiagnosticRecorder} from './oob';\n\n/**\n * Visits a template and records any semantic errors within its expressions.\n */\nexport class ExpressionSemanticVisitor extends RecursiveAstVisitor {\n  constructor(\n      private templateId: TemplateId, private boundTarget: BoundTarget<any>,\n      private oob: OutOfBandDiagnosticRecorder) {\n    super();\n  }\n\n  override visitPropertyWrite(ast: PropertyWrite, context: any): void {\n    super.visitPropertyWrite(ast, context);\n\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    const target = this.boundTarget.getExpressionTarget(ast);\n    if (target instanceof TmplAstVariable) {\n      // Template variables are read-only.\n      this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);\n    }\n  }\n\n  static visit(\n      ast: AST, id: TemplateId, boundTarget: BoundTarget<any>,\n      oob: OutOfBandDiagnosticRecorder): void {\n    ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath, join} from '../../file_system';\nimport {NoopImportRewriter, Reference, ReferenceEmitter} from '../../imports';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ImportManager} from '../../translator';\nimport {TypeCheckBlockMetadata, TypeCheckingConfig} from '../api';\n\nimport {DomSchemaChecker} from './dom';\nimport {Environment} from './environment';\nimport {OutOfBandDiagnosticRecorder} from './oob';\nimport {generateTypeCheckBlock, TcbGenericContextBehavior} from './type_check_block';\n\n\n\n/**\n * An `Environment` representing the single type-checking file into which most (if not all) Type\n * Check Blocks (TCBs) will be generated.\n *\n * The `TypeCheckFile` hosts multiple TCBs and allows the sharing of declarations (e.g. type\n * constructors) between them. Rather than return such declarations via `getPreludeStatements()`, it\n * hoists them to the top of the generated `ts.SourceFile`.\n */\nexport class TypeCheckFile extends Environment {\n  private nextTcbId = 1;\n  private tcbStatements: ts.Statement[] = [];\n\n  constructor(\n      readonly fileName: AbsoluteFsPath, config: TypeCheckingConfig, refEmitter: ReferenceEmitter,\n      reflector: ReflectionHost, compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>) {\n    super(\n        config, new ImportManager(new NoopImportRewriter(), 'i'), refEmitter, reflector,\n        ts.createSourceFile(\n            compilerHost.getCanonicalFileName(fileName), '', ts.ScriptTarget.Latest, true));\n  }\n\n  addTypeCheckBlock(\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, meta: TypeCheckBlockMetadata,\n      domSchemaChecker: DomSchemaChecker, oobRecorder: OutOfBandDiagnosticRecorder,\n      genericContextBehavior: TcbGenericContextBehavior): void {\n    const fnId = ts.factory.createIdentifier(`_tcb${this.nextTcbId++}`);\n    const fn = generateTypeCheckBlock(\n        this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);\n    this.tcbStatements.push(fn);\n  }\n\n  render(removeComments: boolean): string {\n    let source: string = this.importManager.getAllImports(this.contextFile.fileName)\n                             .map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`)\n                             .join('\\n') +\n        '\\n\\n';\n    const printer = ts.createPrinter({removeComments});\n    source += '\\n';\n    for (const stmt of this.pipeInstStatements) {\n      source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n    }\n    for (const stmt of this.typeCtorStatements) {\n      source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n    }\n    source += '\\n';\n    for (const stmt of this.tcbStatements) {\n      source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n    }\n\n    // Ensure the template type-checking file is an ES module. Otherwise, it's interpreted as some\n    // kind of global namespace in TS, which forces a full re-typecheck of the user's program that\n    // is somehow more expensive than the initial parse.\n    source += '\\nexport const IS_A_MODULE = true;\\n';\n\n    return source;\n  }\n\n  override getPreludeStatements(): ts.Statement[] {\n    return [];\n  }\n}\n\nexport function typeCheckFilePath(rootDirs: AbsoluteFsPath[]): AbsoluteFsPath {\n  const shortest = rootDirs.concat([]).sort((a, b) => a.length - b.length)[0];\n  return join(shortest, '__ng_typecheck__.ts');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst LF_CHAR = 10;\nconst CR_CHAR = 13;\nconst LINE_SEP_CHAR = 8232;\nconst PARAGRAPH_CHAR = 8233;\n\n/** Gets the line and character for the given position from the line starts map. */\nexport function getLineAndCharacterFromPosition(lineStartsMap: number[], position: number) {\n  const lineIndex = findClosestLineStartPosition(lineStartsMap, position);\n  return {character: position - lineStartsMap[lineIndex], line: lineIndex};\n}\n\n/**\n * Computes the line start map of the given text. This can be used in order to\n * retrieve the line and character of a given text position index.\n */\nexport function computeLineStartsMap(text: string): number[] {\n  const result: number[] = [0];\n  let pos = 0;\n  while (pos < text.length) {\n    const char = text.charCodeAt(pos++);\n    // Handles the \"CRLF\" line break. In that case we peek the character\n    // after the \"CR\" and check if it is a line feed.\n    if (char === CR_CHAR) {\n      if (text.charCodeAt(pos) === LF_CHAR) {\n        pos++;\n      }\n      result.push(pos);\n    } else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {\n      result.push(pos);\n    }\n  }\n  result.push(pos);\n  return result;\n}\n\n/** Finds the closest line start for the given position. */\nfunction findClosestLineStartPosition<T>(\n    linesMap: T[], position: T, low = 0, high = linesMap.length - 1) {\n  while (low <= high) {\n    const pivotIdx = Math.floor((low + high) / 2);\n    const pivotEl = linesMap[pivotIdx];\n\n    if (pivotEl === position) {\n      return pivotIdx;\n    } else if (position > pivotEl) {\n      low = pivotIdx + 1;\n    } else {\n      high = pivotIdx - 1;\n    }\n  }\n\n  // In case there was no exact match, return the closest \"lower\" line index. We also\n  // subtract the index by one because want the index of the previous line start.\n  return low - 1;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {TemplateId, TemplateSourceMapping} from '../api';\nimport {getTemplateId} from '../diagnostics';\n\nimport {computeLineStartsMap, getLineAndCharacterFromPosition} from './line_mappings';\nimport {TemplateSourceResolver} from './tcb_util';\n\n/**\n * Represents the source of a template that was processed during type-checking. This information is\n * used when translating parse offsets in diagnostics back to their original line/column location.\n */\nexport class TemplateSource {\n  private lineStarts: number[]|null = null;\n\n  constructor(readonly mapping: TemplateSourceMapping, private file: ParseSourceFile) {}\n\n  toParseSourceSpan(start: number, end: number): ParseSourceSpan {\n    const startLoc = this.toParseLocation(start);\n    const endLoc = this.toParseLocation(end);\n    return new ParseSourceSpan(startLoc, endLoc);\n  }\n\n  private toParseLocation(position: number) {\n    const lineStarts = this.acquireLineStarts();\n    const {line, character} = getLineAndCharacterFromPosition(lineStarts, position);\n    return new ParseLocation(this.file, position, line, character);\n  }\n\n  private acquireLineStarts(): number[] {\n    if (this.lineStarts === null) {\n      this.lineStarts = computeLineStartsMap(this.file.content);\n    }\n    return this.lineStarts;\n  }\n}\n\n/**\n * Assigns IDs to templates and keeps track of their origins.\n *\n * Implements `TemplateSourceResolver` to resolve the source of a template based on these IDs.\n */\nexport class TemplateSourceManager implements TemplateSourceResolver {\n  /**\n   * This map keeps track of all template sources that have been type-checked by the id that is\n   * attached to a TCB's function declaration as leading trivia. This enables translation of\n   * diagnostics produced for TCB code to their source location in the template.\n   */\n  private templateSources = new Map<TemplateId, TemplateSource>();\n\n  getTemplateId(node: ts.ClassDeclaration): TemplateId {\n    return getTemplateId(node);\n  }\n\n  captureSource(node: ts.ClassDeclaration, mapping: TemplateSourceMapping, file: ParseSourceFile):\n      TemplateId {\n    const id = getTemplateId(node);\n    this.templateSources.set(id, new TemplateSource(mapping, file));\n    return id;\n  }\n\n  getSourceMapping(id: TemplateId): TemplateSourceMapping {\n    if (!this.templateSources.has(id)) {\n      throw new Error(`Unexpected unknown template ID: ${id}`);\n    }\n    return this.templateSources.get(id)!.mapping;\n  }\n\n  toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null {\n    if (!this.templateSources.has(id)) {\n      return null;\n    }\n    const templateSource = this.templateSources.get(id)!;\n    return templateSource.toParseSourceSpan(span.start, span.end);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ASTWithSource, BindingPipe, Call, ParseSourceSpan, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {Reference} from '../../imports';\nimport {HostDirectiveMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\nimport {ComponentScopeKind, ComponentScopeReader} from '../../scope';\nimport {isAssignment, isSymbolWithValueDeclaration} from '../../util/src/typescript';\nimport {BindingSymbol, DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, PipeSymbol, ReferenceSymbol, Symbol, SymbolKind, TcbLocation, TemplateSymbol, TsNodeSymbolInfo, TypeCheckableDirectiveMeta, VariableSymbol} from '../api';\n\nimport {ExpressionIdentifier, findAllMatchingNodes, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\nimport {TemplateData} from './context';\nimport {isAccessExpression} from './ts_util';\n\n/**\n * Generates and caches `Symbol`s for various template structures for a given component.\n *\n * The `SymbolBuilder` internally caches the `Symbol`s it creates, and must be destroyed and\n * replaced if the component's template changes.\n */\nexport class SymbolBuilder {\n  private symbolCache = new Map<AST|TmplAstNode, Symbol|null>();\n\n  constructor(\n      private readonly tcbPath: AbsoluteFsPath,\n      private readonly tcbIsShim: boolean,\n      private readonly typeCheckBlock: ts.Node,\n      private readonly templateData: TemplateData,\n      private readonly componentScopeReader: ComponentScopeReader,\n      // The `ts.TypeChecker` depends on the current type-checking program, and so must be requested\n      // on-demand instead of cached.\n      private readonly getTypeChecker: () => ts.TypeChecker,\n  ) {}\n\n  getSymbol(node: TmplAstTemplate|TmplAstElement): TemplateSymbol|ElementSymbol|null;\n  getSymbol(node: TmplAstReference|TmplAstVariable): ReferenceSymbol|VariableSymbol|null;\n  getSymbol(node: AST|TmplAstNode): Symbol|null;\n  getSymbol(node: AST|TmplAstNode): Symbol|null {\n    if (this.symbolCache.has(node)) {\n      return this.symbolCache.get(node)!;\n    }\n\n    let symbol: Symbol|null = null;\n    if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute) {\n      // TODO(atscott): input and output bindings only return the first directive match but should\n      // return a list of bindings for all of them.\n      symbol = this.getSymbolOfInputBinding(node);\n    } else if (node instanceof TmplAstBoundEvent) {\n      symbol = this.getSymbolOfBoundEvent(node);\n    } else if (node instanceof TmplAstElement) {\n      symbol = this.getSymbolOfElement(node);\n    } else if (node instanceof TmplAstTemplate) {\n      symbol = this.getSymbolOfAstTemplate(node);\n    } else if (node instanceof TmplAstVariable) {\n      symbol = this.getSymbolOfVariable(node);\n    } else if (node instanceof TmplAstReference) {\n      symbol = this.getSymbolOfReference(node);\n    } else if (node instanceof BindingPipe) {\n      symbol = this.getSymbolOfPipe(node);\n    } else if (node instanceof AST) {\n      symbol = this.getSymbolOfTemplateExpression(node);\n    } else {\n      // TODO(atscott): TmplAstContent, TmplAstIcu\n    }\n\n    this.symbolCache.set(node, symbol);\n    return symbol;\n  }\n\n  private getSymbolOfAstTemplate(template: TmplAstTemplate): TemplateSymbol|null {\n    const directives = this.getDirectivesOfNode(template);\n    return {kind: SymbolKind.Template, directives, templateNode: template};\n  }\n\n  private getSymbolOfElement(element: TmplAstElement): ElementSymbol|null {\n    const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n\n    const node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: elementSourceSpan, filter: ts.isVariableDeclaration});\n    if (node === null) {\n      return null;\n    }\n\n    const symbolFromDeclaration = this.getSymbolOfTsNode(node);\n    if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n      return null;\n    }\n\n    const directives = this.getDirectivesOfNode(element);\n    // All statements in the TCB are `Expression`s that optionally include more information.\n    // An `ElementSymbol` uses the information returned for the variable declaration expression,\n    // adds the directives for the element, and updates the `kind` to be `SymbolKind.Element`.\n    return {\n      ...symbolFromDeclaration,\n      kind: SymbolKind.Element,\n      directives,\n      templateNode: element,\n    };\n  }\n\n  private getDirectivesOfNode(element: TmplAstElement|TmplAstTemplate): DirectiveSymbol[] {\n    const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n    const tcbSourceFile = this.typeCheckBlock.getSourceFile();\n    // directives could be either:\n    // - var _t1: TestDir /*T:D*/ = (null!);\n    // - var _t1 /*T:D*/ = _ctor1({});\n    const isDirectiveDeclaration = (node: ts.Node): node is ts.TypeNode|ts.Identifier =>\n        (ts.isTypeNode(node) || ts.isIdentifier(node)) && ts.isVariableDeclaration(node.parent) &&\n        hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n\n    const nodes = findAllMatchingNodes(\n        this.typeCheckBlock, {withSpan: elementSourceSpan, filter: isDirectiveDeclaration});\n    const symbols: DirectiveSymbol[] = [];\n\n    for (const node of nodes) {\n      const symbol = this.getSymbolOfTsNode(node.parent);\n      if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) ||\n          !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n        continue;\n      }\n\n      const meta = this.getDirectiveMeta(element, symbol.tsSymbol.valueDeclaration);\n\n      if (meta !== null && meta.selector !== null) {\n        const ref = new Reference<ClassDeclaration>(symbol.tsSymbol.valueDeclaration as any);\n\n        if (meta.hostDirectives !== null) {\n          this.addHostDirectiveSymbols(element, meta.hostDirectives, symbols);\n        }\n\n        const directiveSymbol: DirectiveSymbol = {\n          ...symbol,\n          ref,\n          tsSymbol: symbol.tsSymbol,\n          selector: meta.selector,\n          isComponent: meta.isComponent,\n          ngModule: this.getDirectiveModule(symbol.tsSymbol.valueDeclaration),\n          kind: SymbolKind.Directive,\n          isStructural: meta.isStructural,\n          isInScope: true,\n          isHostDirective: false,\n        };\n\n        symbols.push(directiveSymbol);\n      }\n    }\n\n    return symbols;\n  }\n\n  private addHostDirectiveSymbols(\n      host: TmplAstTemplate|TmplAstElement, hostDirectives: HostDirectiveMeta[],\n      symbols: DirectiveSymbol[]): void {\n    for (const current of hostDirectives) {\n      if (!ts.isClassDeclaration(current.directive.node)) {\n        continue;\n      }\n\n      const symbol = this.getSymbolOfTsNode(current.directive.node);\n      const meta = this.getDirectiveMeta(host, current.directive.node);\n\n      if (meta !== null && symbol !== null && isSymbolWithValueDeclaration(symbol.tsSymbol)) {\n        if (meta.hostDirectives !== null) {\n          this.addHostDirectiveSymbols(host, meta.hostDirectives, symbols);\n        }\n\n        const directiveSymbol: DirectiveSymbol = {\n          ...symbol,\n          isHostDirective: true,\n          ref: current.directive,\n          tsSymbol: symbol.tsSymbol,\n          exposedInputs: current.inputs,\n          exposedOutputs: current.outputs,\n          selector: meta.selector,\n          isComponent: meta.isComponent,\n          ngModule: this.getDirectiveModule(current.directive.node),\n          kind: SymbolKind.Directive,\n          isStructural: meta.isStructural,\n          isInScope: true,\n        };\n\n        symbols.push(directiveSymbol);\n      }\n    }\n  }\n\n  private getDirectiveMeta(\n      host: TmplAstTemplate|TmplAstElement,\n      directiveDeclaration: ts.Declaration): TypeCheckableDirectiveMeta|null {\n    let directives = this.templateData.boundTarget.getDirectivesOfNode(host);\n\n    // `getDirectivesOfNode` will not return the directives intended for an element\n    // on a microsyntax template, for example `<div *ngFor=\"let user of users;\" dir>`,\n    // the `dir` will be skipped, but it's needed in language service.\n    const firstChild = host.children[0];\n    if (firstChild instanceof TmplAstElement) {\n      const isMicrosyntaxTemplate = host instanceof TmplAstTemplate &&\n          sourceSpanEqual(firstChild.sourceSpan, host.sourceSpan);\n      if (isMicrosyntaxTemplate) {\n        const firstChildDirectives = this.templateData.boundTarget.getDirectivesOfNode(firstChild);\n        if (firstChildDirectives !== null && directives !== null) {\n          directives = directives.concat(firstChildDirectives);\n        } else {\n          directives = directives ?? firstChildDirectives;\n        }\n      }\n    }\n    if (directives === null) {\n      return null;\n    }\n\n    return directives.find(m => m.ref.node === directiveDeclaration) ?? null;\n  }\n\n  private getDirectiveModule(declaration: ts.ClassDeclaration): ClassDeclaration|null {\n    const scope = this.componentScopeReader.getScopeForComponent(declaration as ClassDeclaration);\n    if (scope === null || scope.kind !== ComponentScopeKind.NgModule) {\n      return null;\n    }\n    return scope.ngModule;\n  }\n\n  private getSymbolOfBoundEvent(eventBinding: TmplAstBoundEvent): OutputBindingSymbol|null {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n    if (consumer === null) {\n      return null;\n    }\n\n    // Outputs in the TCB look like one of the two:\n    // * _t1[\"outputField\"].subscribe(handler);\n    // * _t1.addEventListener(handler);\n    // Even with strict null checks disabled, we still produce the access as a separate statement\n    // so that it can be found here.\n    let expectedAccess: string;\n    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n      expectedAccess = 'addEventListener';\n    } else {\n      const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);\n      if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {\n        return null;\n      }\n      // Note that we only get the expectedAccess text from a single consumer of the binding. If\n      // there are multiple consumers (not supported in the `boundTarget` API) and one of them has\n      // an alias, it will not get matched here.\n      expectedAccess = bindingPropertyNames[0].classPropertyName;\n    }\n\n    function filter(n: ts.Node): n is ts.PropertyAccessExpression|ts.ElementAccessExpression {\n      if (!isAccessExpression(n)) {\n        return false;\n      }\n\n      if (ts.isPropertyAccessExpression(n)) {\n        return n.name.getText() === expectedAccess;\n      } else {\n        return ts.isStringLiteral(n.argumentExpression) &&\n            n.argumentExpression.text === expectedAccess;\n      }\n    }\n    const outputFieldAccesses =\n        findAllMatchingNodes(this.typeCheckBlock, {withSpan: eventBinding.keySpan, filter});\n\n    const bindings: BindingSymbol[] = [];\n    for (const outputFieldAccess of outputFieldAccesses) {\n      if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n        if (!ts.isPropertyAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n\n        const addEventListener = outputFieldAccess.name;\n        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n        const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n        const positionInFile = this.getTcbPositionForNode(addEventListener);\n        const target = this.getSymbol(consumer);\n\n        if (target === null || tsSymbol === undefined) {\n          continue;\n        }\n\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          tcbLocation: {\n            tcbPath: this.tcbPath,\n            isShimFile: this.tcbIsShim,\n            positionInFile,\n          },\n        });\n      } else {\n        if (!ts.isElementAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n        const tsSymbol =\n            this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n        if (tsSymbol === undefined) {\n          continue;\n        }\n\n\n        const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n        if (target === null) {\n          continue;\n        }\n\n        const positionInFile = this.getTcbPositionForNode(outputFieldAccess);\n        const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          tcbLocation: {\n            tcbPath: this.tcbPath,\n            isShimFile: this.tcbIsShim,\n            positionInFile,\n          },\n        });\n      }\n    }\n\n    if (bindings.length === 0) {\n      return null;\n    }\n    return {kind: SymbolKind.Output, bindings};\n  }\n\n  private getSymbolOfInputBinding(binding: TmplAstBoundAttribute|\n                                  TmplAstTextAttribute): InputBindingSymbol|DomBindingSymbol|null {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);\n    if (consumer === null) {\n      return null;\n    }\n\n    if (consumer instanceof TmplAstElement || consumer instanceof TmplAstTemplate) {\n      const host = this.getSymbol(consumer);\n      return host !== null ? {kind: SymbolKind.DomBinding, host} : null;\n    }\n\n    const nodes = findAllMatchingNodes(\n        this.typeCheckBlock, {withSpan: binding.sourceSpan, filter: isAssignment});\n    const bindings: BindingSymbol[] = [];\n    for (const node of nodes) {\n      if (!isAccessExpression(node.left)) {\n        continue;\n      }\n\n      const symbolInfo = this.getSymbolOfTsNode(node.left);\n      if (symbolInfo === null || symbolInfo.tsSymbol === null) {\n        continue;\n      }\n\n      const target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);\n      if (target === null) {\n        continue;\n      }\n      bindings.push({\n        ...symbolInfo,\n        tsSymbol: symbolInfo.tsSymbol,\n        kind: SymbolKind.Binding,\n        target,\n      });\n    }\n    if (bindings.length === 0) {\n      return null;\n    }\n\n    return {kind: SymbolKind.Input, bindings};\n  }\n\n  private getDirectiveSymbolForAccessExpression(\n      node: ts.ElementAccessExpression|ts.PropertyAccessExpression,\n      {isComponent, selector, isStructural}: TypeCheckableDirectiveMeta): DirectiveSymbol|null {\n    // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n    // The retrieved symbol for _t1 will be the variable declaration.\n    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n    if (tsSymbol?.declarations === undefined || tsSymbol.declarations.length === 0 ||\n        selector === null) {\n      return null;\n    }\n\n    const [declaration] = tsSymbol.declarations;\n    if (!ts.isVariableDeclaration(declaration) ||\n        !hasExpressionIdentifier(\n            // The expression identifier could be on the type (for regular directives) or the name\n            // (for generic directives and the ctor op).\n            declaration.getSourceFile(), declaration.type ?? declaration.name,\n            ExpressionIdentifier.DIRECTIVE)) {\n      return null;\n    }\n\n    const symbol = this.getSymbolOfTsNode(declaration);\n    if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) ||\n        !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n      return null;\n    }\n\n    const ref: Reference<ClassDeclaration> = new Reference(symbol.tsSymbol.valueDeclaration as any);\n    const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n    return {\n      ref,\n      kind: SymbolKind.Directive,\n      tsSymbol: symbol.tsSymbol,\n      tsType: symbol.tsType,\n      tcbLocation: symbol.tcbLocation,\n      isComponent,\n      isStructural,\n      selector,\n      ngModule,\n      isHostDirective: false,\n      isInScope: true,  // TODO: this should always be in scope in this context, right?\n    };\n  }\n\n  private getSymbolOfVariable(variable: TmplAstVariable): VariableSymbol|null {\n    const node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: variable.sourceSpan, filter: ts.isVariableDeclaration});\n    if (node === null || node.initializer === undefined) {\n      return null;\n    }\n\n    const expressionSymbol = this.getSymbolOfTsNode(node.initializer);\n    if (expressionSymbol === null) {\n      return null;\n    }\n\n    return {\n      tsType: expressionSymbol.tsType,\n      tsSymbol: expressionSymbol.tsSymbol,\n      initializerLocation: expressionSymbol.tcbLocation,\n      kind: SymbolKind.Variable,\n      declaration: variable,\n      localVarLocation: {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile: this.getTcbPositionForNode(node.name),\n      }\n    };\n  }\n\n  private getSymbolOfReference(ref: TmplAstReference): ReferenceSymbol|null {\n    const target = this.templateData.boundTarget.getReferenceTarget(ref);\n    // Find the node for the reference declaration, i.e. `var _t2 = _t1;`\n    let node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: ref.sourceSpan, filter: ts.isVariableDeclaration});\n    if (node === null || target === null || node.initializer === undefined) {\n      return null;\n    }\n\n    // Get the original declaration for the references variable, with the exception of template refs\n    // which are of the form var _t3 = (_t2 as any as i2.TemplateRef<any>)\n    // TODO(atscott): Consider adding an `ExpressionIdentifier` to tag variable declaration\n    // initializers as invalid for symbol retrieval.\n    const originalDeclaration = ts.isParenthesizedExpression(node.initializer) &&\n            ts.isAsExpression(node.initializer.expression) ?\n        this.getTypeChecker().getSymbolAtLocation(node.name) :\n        this.getTypeChecker().getSymbolAtLocation(node.initializer);\n    if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {\n      return null;\n    }\n    const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);\n    if (symbol === null || symbol.tsSymbol === null) {\n      return null;\n    }\n\n    const referenceVarTcbLocation: TcbLocation = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: this.getTcbPositionForNode(node),\n    };\n    if (target instanceof TmplAstTemplate || target instanceof TmplAstElement) {\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        target,\n        declaration: ref,\n        targetLocation: symbol.tcbLocation,\n        referenceVarLocation: referenceVarTcbLocation,\n      };\n    } else {\n      if (!ts.isClassDeclaration(target.directive.ref.node)) {\n        return null;\n      }\n\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        declaration: ref,\n        target: target.directive.ref.node,\n        targetLocation: symbol.tcbLocation,\n        referenceVarLocation: referenceVarTcbLocation,\n      };\n    }\n  }\n\n  private getSymbolOfPipe(expression: BindingPipe): PipeSymbol|null {\n    const methodAccess = findFirstMatchingNode(\n        this.typeCheckBlock,\n        {withSpan: expression.nameSpan, filter: ts.isPropertyAccessExpression});\n    if (methodAccess === null) {\n      return null;\n    }\n\n    const pipeVariableNode = methodAccess.expression;\n    const pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);\n    if (pipeDeclaration === undefined || pipeDeclaration.valueDeclaration === undefined) {\n      return null;\n    }\n\n    const pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);\n    // The instance should never be null, nor should the symbol lack a value declaration. This\n    // is because the node used to look for the `pipeInstance` symbol info is a value\n    // declaration of another symbol (i.e. the `pipeDeclaration` symbol).\n    if (pipeInstance === null || !isSymbolWithValueDeclaration(pipeInstance.tsSymbol)) {\n      return null;\n    }\n\n    const symbolInfo = this.getSymbolOfTsNode(methodAccess);\n    if (symbolInfo === null) {\n      return null;\n    }\n\n    return {\n      kind: SymbolKind.Pipe,\n      ...symbolInfo,\n      classSymbol: {\n        ...pipeInstance,\n        tsSymbol: pipeInstance.tsSymbol,\n      },\n    };\n  }\n\n  private getSymbolOfTemplateExpression(expression: AST): VariableSymbol|ReferenceSymbol\n      |ExpressionSymbol|null {\n    if (expression instanceof ASTWithSource) {\n      expression = expression.ast;\n    }\n\n    const expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);\n    if (expressionTarget !== null) {\n      return this.getSymbol(expressionTarget);\n    }\n\n    let withSpan = expression.sourceSpan;\n\n    // The `name` part of a `PropertyWrite` and a non-safe `Call` does not have its own\n    // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n    if (expression instanceof PropertyWrite) {\n      withSpan = expression.nameSpan;\n    }\n\n    let node: ts.Node|null = null;\n\n    // Property reads in templates usually map to a `PropertyAccessExpression`\n    // (e.g. `ctx.foo`) so try looking for one first.\n    if (expression instanceof PropertyRead) {\n      node = findFirstMatchingNode(\n          this.typeCheckBlock, {withSpan, filter: ts.isPropertyAccessExpression});\n    }\n\n    // Otherwise fall back to searching for any AST node.\n    if (node === null) {\n      node = findFirstMatchingNode(this.typeCheckBlock, {withSpan, filter: anyNodeFilter});\n    }\n\n    if (node === null) {\n      return null;\n    }\n\n    while (ts.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n\n    // - If we have safe property read (\"a?.b\") we want to get the Symbol for b, the `whenTrue`\n    // expression.\n    // - If our expression is a pipe binding (\"a | test:b:c\"), we want the Symbol for the\n    // `transform` on the pipe.\n    // - Otherwise, we retrieve the symbol for the node itself with no special considerations\n    if (expression instanceof SafePropertyRead && ts.isConditionalExpression(node)) {\n      const whenTrueSymbol = this.getSymbolOfTsNode(node.whenTrue);\n      if (whenTrueSymbol === null) {\n        return null;\n      }\n\n      return {\n        ...whenTrueSymbol,\n        kind: SymbolKind.Expression,\n        // Rather than using the type of only the `whenTrue` part of the expression, we should\n        // still get the type of the whole conditional expression to include `|undefined`.\n        tsType: this.getTypeChecker().getTypeAtLocation(node)\n      };\n    } else {\n      const symbolInfo = this.getSymbolOfTsNode(node);\n      return symbolInfo === null ? null : {...symbolInfo, kind: SymbolKind.Expression};\n    }\n  }\n\n  private getSymbolOfTsNode(node: ts.Node): TsNodeSymbolInfo|null {\n    while (ts.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n\n    let tsSymbol: ts.Symbol|undefined;\n    if (ts.isPropertyAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n    } else if (ts.isElementAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);\n    } else {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);\n    }\n\n    const positionInFile = this.getTcbPositionForNode(node);\n    const type = this.getTypeChecker().getTypeAtLocation(node);\n    return {\n      // If we could not find a symbol, fall back to the symbol on the type for the node.\n      // Some nodes won't have a \"symbol at location\" but will have a symbol for the type.\n      // Examples of this would be literals and `document.createElement('div')`.\n      tsSymbol: tsSymbol ?? type.symbol ?? null,\n      tsType: type,\n      tcbLocation: {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile,\n      },\n    };\n  }\n\n  private getTcbPositionForNode(node: ts.Node): number {\n    if (ts.isTypeReferenceNode(node)) {\n      return this.getTcbPositionForNode(node.typeName);\n    } else if (ts.isQualifiedName(node)) {\n      return node.right.getStart();\n    } else if (ts.isPropertyAccessExpression(node)) {\n      return node.name.getStart();\n    } else if (ts.isElementAccessExpression(node)) {\n      return node.argumentExpression.getStart();\n    } else {\n      return node.getStart();\n    }\n  }\n}\n\n/** Filter predicate function that matches any AST node. */\nfunction anyNodeFilter(n: ts.Node): n is ts.Node {\n  return true;\n}\n\nfunction sourceSpanEqual(a: ParseSourceSpan, b: ParseSourceSpan) {\n  return a.start.offset === b.start.offset && a.end.offset === b.end.offset;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, CssSelector, DomElementSchemaRegistry, ExternalExpr, LiteralPrimitive, ParseSourceSpan, PropertyRead, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate, TmplAstTextAttribute, WrappedNodeExpr} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\nimport {Reference, ReferenceEmitKind, ReferenceEmitter} from '../../imports';\nimport {IncrementalBuild} from '../../incremental/api';\nimport {DirectiveMeta, MetadataReader, MetadataReaderWithIndex, MetaKind, NgModuleIndex, NgModuleMeta, PipeMeta} from '../../metadata';\nimport {PerfCheckpoint, PerfEvent, PerfPhase, PerfRecorder} from '../../perf';\nimport {ProgramDriver, UpdateMode} from '../../program_driver';\nimport {ClassDeclaration, DeclarationNode, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ComponentScopeKind, ComponentScopeReader, TypeCheckScopeRegistry} from '../../scope';\nimport {isShim} from '../../shims';\nimport {getSourceFileOrNull, isSymbolWithValueDeclaration} from '../../util/src/typescript';\nimport {ElementSymbol, FullTemplateMapping, GlobalCompletion, NgTemplateDiagnostic, OptimizeFor, PotentialDirective, PotentialImport, PotentialImportKind, PotentialImportMode, PotentialPipe, ProgramTypeCheckAdapter, Symbol, TcbLocation, TemplateDiagnostic, TemplateId, TemplateSymbol, TemplateTypeChecker, TypeCheckableDirectiveMeta, TypeCheckingConfig} from '../api';\nimport {makeTemplateDiagnostic} from '../diagnostics';\n\nimport {CompletionEngine} from './completion';\nimport {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\nimport {shouldReportDiagnostic, translateDiagnostic} from './diagnostics';\nimport {TypeCheckShimGenerator} from './shim';\nimport {TemplateSourceManager} from './source';\nimport {findTypeCheckBlock, getTemplateMapping, TemplateSourceResolver} from './tcb_util';\nimport {SymbolBuilder} from './template_symbol_builder';\n\nconst REGISTRY = new DomElementSchemaRegistry();\n/**\n * Primary template type-checking engine, which performs type-checking using a\n * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the\n * `ProgramTypeCheckAdapter` for generation of template type-checking code.\n */\nexport class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n  private state = new Map<AbsoluteFsPath, FileTypeCheckingData>();\n\n  /**\n   * Stores the `CompletionEngine` which powers autocompletion for each component class.\n   *\n   * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n   * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n   * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n   */\n  private completionCache = new Map<ts.ClassDeclaration, CompletionEngine>();\n  /**\n   * Stores the `SymbolBuilder` which creates symbols for each component class.\n   *\n   * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n   * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n   * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n   */\n  private symbolBuilderCache = new Map<ts.ClassDeclaration, SymbolBuilder>();\n\n  /**\n   * Stores directives and pipes that are in scope for each component.\n   *\n   * Unlike other caches, the scope of a component is not affected by its template. It will be\n   * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n   * destroyed and replaced.\n   */\n  private scopeCache = new Map<ts.ClassDeclaration, ScopeData>();\n\n  /**\n   * Stores potential element tags for each component (a union of DOM tags as well as directive\n   * tags).\n   *\n   * Unlike other caches, the scope of a component is not affected by its template. It will be\n   * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n   * destroyed and replaced.\n   */\n  private elementTagCache = new Map<ts.ClassDeclaration, Map<string, PotentialDirective|null>>();\n\n  private isComplete = false;\n\n  constructor(\n      private originalProgram: ts.Program, readonly programDriver: ProgramDriver,\n      private typeCheckAdapter: ProgramTypeCheckAdapter, private config: TypeCheckingConfig,\n      private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n      private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n      private priorBuild: IncrementalBuild<unknown, FileTypeCheckingData>,\n      private readonly metaReader: MetadataReader,\n      private readonly localMetaReader: MetadataReaderWithIndex,\n      private readonly ngModuleIndex: NgModuleIndex,\n      private readonly componentScopeReader: ComponentScopeReader,\n      private readonly typeCheckScopeRegistry: TypeCheckScopeRegistry,\n      private readonly perf: PerfRecorder) {}\n\n  getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n    const {data} = this.getLatestComponentState(component);\n    if (data === null) {\n      return null;\n    }\n    return data.template;\n  }\n\n  getUsedDirectives(component: ts.ClassDeclaration): TypeCheckableDirectiveMeta[]|null {\n    return this.getLatestComponentState(component).data?.boundTarget.getUsedDirectives() || null;\n  }\n\n  getUsedPipes(component: ts.ClassDeclaration): string[]|null {\n    return this.getLatestComponentState(component).data?.boundTarget.getUsedPipes() || null;\n  }\n\n  private getLatestComponentState(component: ts.ClassDeclaration):\n      {data: TemplateData|null, tcb: ts.Node|null, tcbPath: AbsoluteFsPath, tcbIsShim: boolean} {\n    this.ensureShimForComponent(component);\n\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n\n    const fileRecord = this.getFileData(sfPath);\n\n    if (!fileRecord.shimData.has(shimPath)) {\n      return {data: null, tcb: null, tcbPath: shimPath, tcbIsShim: true};\n    }\n\n    const templateId = fileRecord.sourceManager.getTemplateId(component);\n    const shimRecord = fileRecord.shimData.get(shimPath)!;\n    const id = fileRecord.sourceManager.getTemplateId(component);\n\n    const program = this.programDriver.getProgram();\n    const shimSf = getSourceFileOrNull(program, shimPath);\n\n    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n      throw new Error(`Error: no shim file in program: ${shimPath}`);\n    }\n\n    let tcb: ts.Node|null = findTypeCheckBlock(shimSf, id, /*isDiagnosticsRequest*/ false);\n\n    let tcbPath = shimPath;\n    if (tcb === null) {\n      // Try for an inline block.\n      const inlineSf = getSourceFileOrError(program, sfPath);\n      tcb = findTypeCheckBlock(inlineSf, id, /*isDiagnosticsRequest*/ false);\n\n      if (tcb !== null) {\n        tcbPath = sfPath;\n      }\n    }\n\n    let data: TemplateData|null = null;\n    if (shimRecord.templates.has(templateId)) {\n      data = shimRecord.templates.get(templateId)!;\n    }\n\n    return {data, tcb, tcbPath, tcbIsShim: tcbPath === shimPath};\n  }\n\n  isTrackedTypeCheckFile(filePath: AbsoluteFsPath): boolean {\n    return this.getFileAndShimRecordsForPath(filePath) !== null;\n  }\n\n  private getFileRecordForTcbLocation({tcbPath, isShimFile}: TcbLocation): FileTypeCheckingData\n      |null {\n    if (!isShimFile) {\n      // The location is not within a shim file but corresponds with an inline TCB in an original\n      // source file; we can obtain the record directly by its path.\n      if (this.state.has(tcbPath)) {\n        return this.state.get(tcbPath)!;\n      } else {\n        return null;\n      }\n    }\n\n    // The location is within a type-checking shim file; find the type-checking data that owns this\n    // shim path.\n    const records = this.getFileAndShimRecordsForPath(tcbPath);\n    if (records !== null) {\n      return records.fileRecord;\n    } else {\n      return null;\n    }\n  }\n\n  private getFileAndShimRecordsForPath(shimPath: AbsoluteFsPath):\n      {fileRecord: FileTypeCheckingData, shimRecord: ShimTypeCheckingData}|null {\n    for (const fileRecord of this.state.values()) {\n      if (fileRecord.shimData.has(shimPath)) {\n        return {fileRecord, shimRecord: fileRecord.shimData.get(shimPath)!};\n      }\n    }\n    return null;\n  }\n\n  getTemplateMappingAtTcbLocation(tcbLocation: TcbLocation): FullTemplateMapping|null {\n    const fileRecord = this.getFileRecordForTcbLocation(tcbLocation);\n    if (fileRecord === null) {\n      return null;\n    }\n\n    const shimSf = this.programDriver.getProgram().getSourceFile(tcbLocation.tcbPath);\n    if (shimSf === undefined) {\n      return null;\n    }\n    return getTemplateMapping(\n        shimSf, tcbLocation.positionInFile, fileRecord.sourceManager,\n        /*isDiagnosticsRequest*/ false);\n  }\n\n  generateAllTypeCheckBlocks() {\n    this.ensureAllShimsForAllFiles();\n  }\n\n  /**\n   * Retrieve type-checking and template parse diagnostics from the given `ts.SourceFile` using the\n   * most recent type-checking program.\n   */\n  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[] {\n    switch (optimizeFor) {\n      case OptimizeFor.WholeProgram:\n        this.ensureAllShimsForAllFiles();\n        break;\n      case OptimizeFor.SingleFile:\n        this.ensureAllShimsForOneFile(sf);\n        break;\n    }\n\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sfPath = absoluteFromSourceFile(sf);\n      const fileRecord = this.state.get(sfPath)!;\n\n      const typeCheckProgram = this.programDriver.getProgram();\n\n      const diagnostics: (ts.Diagnostic|null)[] = [];\n      if (fileRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n\n      for (const [shimPath, shimRecord] of fileRecord.shimData) {\n        const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n        diagnostics.push(...shimRecord.genesisDiagnostics);\n\n        for (const templateData of shimRecord.templates.values()) {\n          diagnostics.push(...templateData.templateDiagnostics);\n        }\n      }\n\n      return diagnostics.filter((diag: ts.Diagnostic|null): diag is ts.Diagnostic => diag !== null);\n    });\n  }\n\n  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[] {\n    this.ensureShimForComponent(component);\n\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sf = component.getSourceFile();\n      const sfPath = absoluteFromSourceFile(sf);\n      const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n\n      const fileRecord = this.getFileData(sfPath);\n\n      if (!fileRecord.shimData.has(shimPath)) {\n        return [];\n      }\n\n      const templateId = fileRecord.sourceManager.getTemplateId(component);\n      const shimRecord = fileRecord.shimData.get(shimPath)!;\n\n      const typeCheckProgram = this.programDriver.getProgram();\n\n      const diagnostics: (TemplateDiagnostic|null)[] = [];\n      if (shimRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n\n      const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      diagnostics.push(...shimRecord.genesisDiagnostics);\n\n      for (const templateData of shimRecord.templates.values()) {\n        diagnostics.push(...templateData.templateDiagnostics);\n      }\n\n      return diagnostics.filter(\n          (diag: TemplateDiagnostic|null): diag is TemplateDiagnostic =>\n              diag !== null && diag.templateId === templateId);\n    });\n  }\n\n  getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null {\n    return this.getLatestComponentState(component).tcb;\n  }\n\n  getGlobalCompletions(\n      context: TmplAstTemplate|null, component: ts.ClassDeclaration,\n      node: AST|TmplAstNode): GlobalCompletion|null {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(\n        PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node));\n  }\n\n  getExpressionCompletionLocation(\n      ast: PropertyRead|SafePropertyRead, component: ts.ClassDeclaration): TcbLocation|null {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(\n        PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));\n  }\n\n  getLiteralCompletionLocation(\n      node: LiteralPrimitive|TmplAstTextAttribute, component: ts.ClassDeclaration): TcbLocation\n      |null {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(\n        PerfPhase.TtcAutocompletion, () => engine.getLiteralCompletionLocation(node));\n  }\n\n  invalidateClass(clazz: ts.ClassDeclaration): void {\n    this.completionCache.delete(clazz);\n    this.symbolBuilderCache.delete(clazz);\n    this.scopeCache.delete(clazz);\n    this.elementTagCache.delete(clazz);\n\n    const sf = clazz.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileData = this.getFileData(sfPath);\n    const templateId = fileData.sourceManager.getTemplateId(clazz);\n\n    fileData.shimData.delete(shimPath);\n    fileData.isComplete = false;\n\n    this.isComplete = false;\n  }\n\n  makeTemplateDiagnostic<T extends ErrorCode>(\n      clazz: ts.ClassDeclaration, sourceSpan: ParseSourceSpan, category: ts.DiagnosticCategory,\n      errorCode: T, message: string, relatedInformation?: {\n        text: string,\n        start: number,\n        end: number,\n        sourceFile: ts.SourceFile,\n      }[]): NgTemplateDiagnostic<T> {\n    const sfPath = absoluteFromSourceFile(clazz.getSourceFile());\n    const fileRecord = this.state.get(sfPath)!;\n    const templateId = fileRecord.sourceManager.getTemplateId(clazz);\n    const mapping = fileRecord.sourceManager.getSourceMapping(templateId);\n\n    return {\n      ...makeTemplateDiagnostic(\n          templateId, mapping, sourceSpan, category, ngErrorCode(errorCode), message,\n          relatedInformation),\n      __ngCode: errorCode\n    };\n  }\n\n  private getOrCreateCompletionEngine(component: ts.ClassDeclaration): CompletionEngine|null {\n    if (this.completionCache.has(component)) {\n      return this.completionCache.get(component)!;\n    }\n\n    const {tcb, data, tcbPath, tcbIsShim} = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n\n    const engine = new CompletionEngine(tcb, data, tcbPath, tcbIsShim);\n    this.completionCache.set(component, engine);\n    return engine;\n  }\n\n  private maybeAdoptPriorResultsForFile(sf: ts.SourceFile): void {\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.state.has(sfPath)) {\n      const existingResults = this.state.get(sfPath)!;\n\n      if (existingResults.isComplete) {\n        // All data for this file has already been generated, so no need to adopt anything.\n        return;\n      }\n    }\n\n    const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n    if (previousResults === null || !previousResults.isComplete) {\n      return;\n    }\n\n    this.perf.eventCount(PerfEvent.ReuseTypeCheckFile);\n    this.state.set(sfPath, previousResults);\n  }\n\n  private ensureAllShimsForAllFiles(): void {\n    if (this.isComplete) {\n      return;\n    }\n\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      const host = new WholeProgramTypeCheckingHost(this);\n      const ctx = this.newContext(host);\n\n      for (const sf of this.originalProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile || isShim(sf)) {\n          continue;\n        }\n\n        this.maybeAdoptPriorResultsForFile(sf);\n\n        const sfPath = absoluteFromSourceFile(sf);\n        const fileData = this.getFileData(sfPath);\n        if (fileData.isComplete) {\n          continue;\n        }\n\n        this.typeCheckAdapter.typeCheck(sf, ctx);\n\n        fileData.isComplete = true;\n      }\n\n      this.updateFromContext(ctx);\n      this.isComplete = true;\n    });\n  }\n\n  private ensureAllShimsForOneFile(sf: ts.SourceFile): void {\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      this.maybeAdoptPriorResultsForFile(sf);\n\n      const sfPath = absoluteFromSourceFile(sf);\n\n      const fileData = this.getFileData(sfPath);\n      if (fileData.isComplete) {\n        // All data for this file is present and accounted for already.\n        return;\n      }\n\n      const host = new SingleFileTypeCheckingHost(sfPath, fileData, this);\n      const ctx = this.newContext(host);\n\n      this.typeCheckAdapter.typeCheck(sf, ctx);\n\n      fileData.isComplete = true;\n\n      this.updateFromContext(ctx);\n    });\n  }\n\n  private ensureShimForComponent(component: ts.ClassDeclaration): void {\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n\n    this.maybeAdoptPriorResultsForFile(sf);\n\n    const fileData = this.getFileData(sfPath);\n\n    if (fileData.shimData.has(shimPath)) {\n      // All data for this component is available.\n      return;\n    }\n\n    const host = new SingleShimTypeCheckingHost(sfPath, fileData, this, shimPath);\n    const ctx = this.newContext(host);\n\n    this.typeCheckAdapter.typeCheck(sf, ctx);\n    this.updateFromContext(ctx);\n  }\n\n  private newContext(host: TypeCheckingHost): TypeCheckContextImpl {\n    const inlining =\n        this.programDriver.supportsInlineOperations ? InliningMode.InlineOps : InliningMode.Error;\n    return new TypeCheckContextImpl(\n        this.config, this.compilerHost, this.refEmitter, this.reflector, host, inlining, this.perf);\n  }\n\n  /**\n   * Remove any shim data that depends on inline operations applied to the type-checking program.\n   *\n   * This can be useful if new inlines need to be applied, and it's not possible to guarantee that\n   * they won't overwrite or corrupt existing inlines that are used by such shims.\n   */\n  clearAllShimDataUsingInlines(): void {\n    for (const fileData of this.state.values()) {\n      if (!fileData.hasInlines) {\n        continue;\n      }\n\n      for (const [shimFile, shimData] of fileData.shimData.entries()) {\n        if (shimData.hasInlines) {\n          fileData.shimData.delete(shimFile);\n        }\n      }\n\n      fileData.hasInlines = false;\n      fileData.isComplete = false;\n      this.isComplete = false;\n    }\n  }\n\n  private updateFromContext(ctx: TypeCheckContextImpl): void {\n    const updates = ctx.finalize();\n    return this.perf.inPhase(PerfPhase.TcbUpdateProgram, () => {\n      if (updates.size > 0) {\n        this.perf.eventCount(PerfEvent.UpdateTypeCheckProgram);\n      }\n      this.programDriver.updateFiles(updates, UpdateMode.Incremental);\n      this.priorBuild.recordSuccessfulTypeCheck(this.state);\n      this.perf.memory(PerfCheckpoint.TtcUpdateProgram);\n    });\n  }\n\n  getFileData(path: AbsoluteFsPath): FileTypeCheckingData {\n    if (!this.state.has(path)) {\n      this.state.set(path, {\n        hasInlines: false,\n        sourceManager: new TemplateSourceManager(),\n        isComplete: false,\n        shimData: new Map(),\n      });\n    }\n    return this.state.get(path)!;\n  }\n  getSymbolOfNode(node: TmplAstTemplate, component: ts.ClassDeclaration): TemplateSymbol|null;\n  getSymbolOfNode(node: TmplAstElement, component: ts.ClassDeclaration): ElementSymbol|null;\n  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null {\n    const builder = this.getOrCreateSymbolBuilder(component);\n    if (builder === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcSymbol, () => builder.getSymbol(node));\n  }\n\n  private getOrCreateSymbolBuilder(component: ts.ClassDeclaration): SymbolBuilder|null {\n    if (this.symbolBuilderCache.has(component)) {\n      return this.symbolBuilderCache.get(component)!;\n    }\n\n    const {tcb, data, tcbPath, tcbIsShim} = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n\n    const builder = new SymbolBuilder(\n        tcbPath, tcbIsShim, tcb, data, this.componentScopeReader,\n        () => this.programDriver.getProgram().getTypeChecker());\n    this.symbolBuilderCache.set(component, builder);\n    return builder;\n  }\n\n  getPotentialTemplateDirectives(component: ts.ClassDeclaration): PotentialDirective[] {\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    const inScopeDirectives = this.getScopeData(component)?.directives ?? [];\n    const resultingDirectives = new Map<ClassDeclaration<DeclarationNode>, PotentialDirective>();\n    // First, all in scope directives can be used.\n    for (const d of inScopeDirectives) {\n      resultingDirectives.set(d.ref.node, d);\n    }\n    // Any additional directives found from the global registry can be used, but are not in scope.\n    // In the future, we can also walk other registries for .d.ts files, or traverse the\n    // import/export graph.\n    for (const directiveClass of this.localMetaReader.getKnown(MetaKind.Directive)) {\n      const directiveMeta = this.metaReader.getDirectiveMetadata(new Reference(directiveClass));\n      if (directiveMeta === null) continue;\n      if (resultingDirectives.has(directiveClass)) continue;\n      const withScope = this.scopeDataOfDirectiveMeta(typeChecker, directiveMeta);\n      if (withScope === null) continue;\n      resultingDirectives.set(directiveClass, {...withScope, isInScope: false});\n    }\n    return Array.from(resultingDirectives.values());\n  }\n\n  getPotentialPipes(component: ts.ClassDeclaration): PotentialPipe[] {\n    // Very similar to the above `getPotentialTemplateDirectives`, but on pipes.\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    const inScopePipes = this.getScopeData(component)?.pipes ?? [];\n    const resultingPipes = new Map<ClassDeclaration<DeclarationNode>, PotentialPipe>();\n    for (const p of inScopePipes) {\n      resultingPipes.set(p.ref.node, p);\n    }\n    for (const pipeClass of this.localMetaReader.getKnown(MetaKind.Pipe)) {\n      const pipeMeta = this.metaReader.getPipeMetadata(new Reference(pipeClass));\n      if (pipeMeta === null) continue;\n      if (resultingPipes.has(pipeClass)) continue;\n      const withScope = this.scopeDataOfPipeMeta(typeChecker, pipeMeta);\n      if (withScope === null) continue;\n      resultingPipes.set(pipeClass, {...withScope, isInScope: false});\n    }\n    return Array.from(resultingPipes.values());\n  }\n\n  getDirectiveMetadata(dir: ts.ClassDeclaration): TypeCheckableDirectiveMeta|null {\n    if (!isNamedClassDeclaration(dir)) {\n      return null;\n    }\n    return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new Reference(dir));\n  }\n\n  getNgModuleMetadata(module: ts.ClassDeclaration): NgModuleMeta|null {\n    if (!isNamedClassDeclaration(module)) {\n      return null;\n    }\n    return this.metaReader.getNgModuleMetadata(new Reference(module));\n  }\n\n  getPipeMetadata(pipe: ts.ClassDeclaration): PipeMeta|null {\n    if (!isNamedClassDeclaration(pipe)) {\n      return null;\n    }\n    return this.metaReader.getPipeMetadata(new Reference(pipe));\n  }\n\n  getPotentialElementTags(component: ts.ClassDeclaration): Map<string, PotentialDirective|null> {\n    if (this.elementTagCache.has(component)) {\n      return this.elementTagCache.get(component)!;\n    }\n\n    const tagMap = new Map<string, PotentialDirective|null>();\n\n    for (const tag of REGISTRY.allKnownElementNames()) {\n      tagMap.set(tag, null);\n    }\n\n    const scope = this.getScopeData(component);\n    if (scope !== null) {\n      for (const directive of scope.directives) {\n        if (directive.selector === null) {\n          continue;\n        }\n\n        for (const selector of CssSelector.parse(directive.selector)) {\n          if (selector.element === null || tagMap.has(selector.element)) {\n            // Skip this directive if it doesn't match an element tag, or if another directive has\n            // already been included with the same element name.\n            continue;\n          }\n\n          tagMap.set(selector.element, directive);\n        }\n      }\n    }\n\n    this.elementTagCache.set(component, tagMap);\n    return tagMap;\n  }\n\n  getPotentialDomBindings(tagName: string): {attribute: string, property: string}[] {\n    const attributes = REGISTRY.allKnownAttributesOfElement(tagName);\n    return attributes.map(attribute => ({\n                            attribute,\n                            property: REGISTRY.getMappedPropName(attribute),\n                          }));\n  }\n\n  getPotentialDomEvents(tagName: string): string[] {\n    return REGISTRY.allKnownEventsOfElement(tagName);\n  }\n\n  getPrimaryAngularDecorator(target: ts.ClassDeclaration): ts.Decorator|null {\n    this.ensureAllShimsForOneFile(target.getSourceFile());\n\n    if (!isNamedClassDeclaration(target)) {\n      return null;\n    }\n    const ref = new Reference(target);\n    const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n    if (dirMeta !== null) {\n      return dirMeta.decorator;\n    }\n\n    const pipeMeta = this.metaReader.getPipeMetadata(ref);\n    if (pipeMeta !== null) {\n      return pipeMeta.decorator;\n    }\n\n    const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n    if (ngModuleMeta !== null) {\n      return ngModuleMeta.decorator;\n    }\n\n    return null;\n  }\n\n  getOwningNgModule(component: ts.ClassDeclaration): ts.ClassDeclaration|null {\n    if (!isNamedClassDeclaration(component)) {\n      return null;\n    }\n\n    const dirMeta = this.metaReader.getDirectiveMetadata(new Reference(component));\n    if (dirMeta !== null && dirMeta.isStandalone) {\n      return null;\n    }\n\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null || scope.kind !== ComponentScopeKind.NgModule ||\n        !isNamedClassDeclaration(scope.ngModule)) {\n      return null;\n    }\n\n    return scope.ngModule;\n  }\n\n  private emit(\n      kind: PotentialImportKind, refTo: Reference<ClassDeclaration>,\n      inContext: ts.ClassDeclaration): PotentialImport|null {\n    const emittedRef = this.refEmitter.emit(refTo, inContext.getSourceFile());\n    if (emittedRef.kind === ReferenceEmitKind.Failed) {\n      return null;\n    }\n    const emitted = emittedRef.expression;\n    if (emitted instanceof WrappedNodeExpr) {\n      let isForwardReference = false;\n      if (emitted.node.getStart() > inContext.getStart()) {\n        const declaration = this.programDriver.getProgram()\n                                .getTypeChecker()\n                                .getTypeAtLocation(emitted.node)\n                                .getSymbol()\n                                ?.declarations?.[0];\n        if (declaration && declaration.getSourceFile() === inContext.getSourceFile()) {\n          isForwardReference = true;\n        }\n      }\n      // An appropriate identifier is already in scope.\n      return {kind, symbolName: emitted.node.text, isForwardReference};\n    } else if (\n        emitted instanceof ExternalExpr && emitted.value.moduleName !== null &&\n        emitted.value.name !== null) {\n      return {\n        kind,\n        moduleSpecifier: emitted.value.moduleName,\n        symbolName: emitted.value.name,\n        isForwardReference: false,\n      };\n    }\n    return null;\n  }\n\n  getPotentialImportsFor(\n      toImport: Reference<ClassDeclaration>, inContext: ts.ClassDeclaration,\n      importMode: PotentialImportMode): ReadonlyArray<PotentialImport> {\n    const imports: PotentialImport[] = [];\n\n    const meta =\n        this.metaReader.getDirectiveMetadata(toImport) ?? this.metaReader.getPipeMetadata(toImport);\n    if (meta === null) {\n      return imports;\n    }\n\n    if (meta.isStandalone || importMode === PotentialImportMode.ForceDirect) {\n      const emitted = this.emit(PotentialImportKind.Standalone, toImport, inContext);\n      if (emitted !== null) {\n        imports.push(emitted);\n      }\n    }\n\n    const exportingNgModules = this.ngModuleIndex.getNgModulesExporting(meta.ref.node);\n    if (exportingNgModules !== null) {\n      for (const exporter of exportingNgModules) {\n        const emittedRef = this.emit(PotentialImportKind.NgModule, exporter, inContext);\n        if (emittedRef !== null) {\n          imports.push(emittedRef);\n        }\n      }\n    }\n\n    return imports;\n  }\n\n  private getScopeData(component: ts.ClassDeclaration): ScopeData|null {\n    if (this.scopeCache.has(component)) {\n      return this.scopeCache.get(component)!;\n    }\n\n    if (!isNamedClassDeclaration(component)) {\n      throw new Error(`AssertionError: components must have names`);\n    }\n\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null) {\n      return null;\n    }\n\n    const dependencies = scope.kind === ComponentScopeKind.NgModule ?\n        scope.compilation.dependencies :\n        scope.dependencies;\n\n    const data: ScopeData = {\n      directives: [],\n      pipes: [],\n      isPoisoned: scope.kind === ComponentScopeKind.NgModule ? scope.compilation.isPoisoned :\n                                                               scope.isPoisoned,\n    };\n\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    for (const dep of dependencies) {\n      if (dep.kind === MetaKind.Directive) {\n        const dirScope = this.scopeDataOfDirectiveMeta(typeChecker, dep);\n        if (dirScope === null) continue;\n        data.directives.push({...dirScope, isInScope: true});\n      } else if (dep.kind === MetaKind.Pipe) {\n        const pipeScope = this.scopeDataOfPipeMeta(typeChecker, dep);\n        if (pipeScope === null) continue;\n        data.pipes.push({...pipeScope, isInScope: true});\n      }\n    }\n\n    this.scopeCache.set(component, data);\n    return data;\n  }\n\n  private scopeDataOfDirectiveMeta(typeChecker: ts.TypeChecker, dep: DirectiveMeta):\n      Omit<PotentialDirective, 'isInScope'>|null {\n    if (dep.selector === null) {\n      // Skip this directive, it can't be added to a template anyway.\n      return null;\n    }\n    const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);\n    if (!isSymbolWithValueDeclaration(tsSymbol)) {\n      return null;\n    }\n\n    let ngModule: ClassDeclaration|null = null;\n    const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dep.ref.node);\n    if (moduleScopeOfDir !== null && moduleScopeOfDir.kind === ComponentScopeKind.NgModule) {\n      ngModule = moduleScopeOfDir.ngModule;\n    }\n\n    return {\n      ref: dep.ref,\n      isComponent: dep.isComponent,\n      isStructural: dep.isStructural,\n      selector: dep.selector,\n      tsSymbol,\n      ngModule,\n    };\n  }\n\n  private scopeDataOfPipeMeta(typeChecker: ts.TypeChecker, dep: PipeMeta):\n      Omit<PotentialPipe, 'isInScope'>|null {\n    const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);\n    if (tsSymbol === undefined) {\n      return null;\n    }\n    return {\n      ref: dep.ref,\n      name: dep.name,\n      tsSymbol,\n    };\n  }\n}\n\nfunction convertDiagnostic(\n    diag: ts.Diagnostic, sourceResolver: TemplateSourceResolver): TemplateDiagnostic|null {\n  if (!shouldReportDiagnostic(diag)) {\n    return null;\n  }\n  return translateDiagnostic(diag, sourceResolver);\n}\n\n/**\n * Data for template type-checking related to a specific input file in the user's program (which\n * contains components to be checked).\n */\nexport interface FileTypeCheckingData {\n  /**\n   * Whether the type-checking shim required any inline changes to the original file, which affects\n   * whether the shim can be reused.\n   */\n  hasInlines: boolean;\n\n  /**\n   * Source mapping information for mapping diagnostics from inlined type check blocks back to the\n   * original template.\n   */\n  sourceManager: TemplateSourceManager;\n\n  /**\n   * Data for each shim generated from this input file.\n   *\n   * A single input file will generate one or more shim files that actually contain template\n   * type-checking code.\n   */\n  shimData: Map<AbsoluteFsPath, ShimTypeCheckingData>;\n\n  /**\n   * Whether the template type-checker is certain that all components from this input file have had\n   * type-checking code generated into shims.\n   */\n  isComplete: boolean;\n}\n\n/**\n * Drives a `TypeCheckContext` to generate type-checking code for every component in the program.\n */\nclass WholeProgramTypeCheckingHost implements TypeCheckingHost {\n  constructor(private impl: TemplateTypeCheckerImpl) {}\n\n  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager {\n    return this.impl.getFileData(sfPath).sourceManager;\n  }\n\n  shouldCheckComponent(node: ts.ClassDeclaration): boolean {\n    const sfPath = absoluteFromSourceFile(node.getSourceFile());\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileData = this.impl.getFileData(sfPath);\n    // The component needs to be checked unless the shim which would contain it already exists.\n    return !fileData.shimData.has(shimPath);\n  }\n\n  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n    const fileData = this.impl.getFileData(sfPath);\n    fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      fileData.hasInlines = true;\n    }\n  }\n\n  recordComplete(sfPath: AbsoluteFsPath): void {\n    this.impl.getFileData(sfPath).isComplete = true;\n  }\n}\n\n/**\n * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.\n */\nclass SingleFileTypeCheckingHost implements TypeCheckingHost {\n  private seenInlines = false;\n\n  constructor(\n      protected sfPath: AbsoluteFsPath, protected fileData: FileTypeCheckingData,\n      protected impl: TemplateTypeCheckerImpl) {}\n\n  private assertPath(sfPath: AbsoluteFsPath): void {\n    if (this.sfPath !== sfPath) {\n      throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);\n    }\n  }\n\n  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager {\n    this.assertPath(sfPath);\n    return this.fileData.sourceManager;\n  }\n\n  shouldCheckComponent(node: ts.ClassDeclaration): boolean {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n    const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);\n\n    // Only need to generate a TCB for the class if no shim exists for it currently.\n    return !this.fileData.shimData.has(shimPath);\n  }\n\n  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n    this.assertPath(sfPath);\n\n    // Previous type-checking state may have required the use of inlines (assuming they were\n    // supported). If the current operation also requires inlines, this presents a problem:\n    // generating new inlines may invalidate any old inlines that old state depends on.\n    //\n    // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state\n    // relies on inlines, any old state that relied on them is simply cleared. This happens when the\n    // first new state that uses inlines is encountered.\n    if (data.hasInlines && !this.seenInlines) {\n      this.impl.clearAllShimDataUsingInlines();\n      this.seenInlines = true;\n    }\n\n    this.fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      this.fileData.hasInlines = true;\n    }\n  }\n\n  recordComplete(sfPath: AbsoluteFsPath): void {\n    this.assertPath(sfPath);\n    this.fileData.isComplete = true;\n  }\n}\n\n/**\n * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components\n * which map to a single shim of a single input file.\n */\nclass SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {\n  constructor(\n      sfPath: AbsoluteFsPath, fileData: FileTypeCheckingData, impl: TemplateTypeCheckerImpl,\n      private shimPath: AbsoluteFsPath) {\n    super(sfPath, fileData, impl);\n  }\n\n  shouldCheckNode(node: ts.ClassDeclaration): boolean {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n\n    // Only generate a TCB for the component if it maps to the requested shim file.\n    const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);\n    if (shimPath !== this.shimPath) {\n      return false;\n    }\n\n    // Only need to generate a TCB for the class if no shim exists for it currently.\n    return !this.fileData.shimData.has(shimPath);\n  }\n}\n\n/**\n * Cached scope information for a component.\n */\ninterface ScopeData {\n  directives: PotentialDirective[];\n  pipes: PotentialPipe[];\n  isPoisoned: boolean;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ASTWithSource, ParseSourceSpan, RecursiveAstVisitor, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {NgCompilerOptions} from '../../../core/api';\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../diagnostics';\nimport {NgTemplateDiagnostic, TemplateTypeChecker} from '../../api';\n\n/**\n * A Template Check receives information about the template it's checking and returns\n * information about the diagnostics to be generated.\n */\nexport interface TemplateCheck<Code extends ErrorCode> {\n  /** Unique template check code, used for configuration and searching the error. */\n  code: Code;\n\n  /** Runs check and returns information about the diagnostics to be generated. */\n  run(ctx: TemplateContext<Code>, component: ts.ClassDeclaration,\n      template: TmplAstNode[]): NgTemplateDiagnostic<Code>[];\n}\n\n/**\n * The TemplateContext provided to a Template Check to get diagnostic information.\n */\nexport interface TemplateContext<Code extends ErrorCode> {\n  /** Interface that provides information about template nodes. */\n  templateTypeChecker: TemplateTypeChecker;\n\n  /**\n   * TypeScript interface that provides type information about symbols that appear\n   * in the template (it is not to query types outside the Angular component).\n   */\n  typeChecker: ts.TypeChecker;\n\n  /**\n   * Creates a template diagnostic with the given information for the template being processed and\n   * using the diagnostic category configured for the extended template diagnostic.\n   */\n  makeTemplateDiagnostic(sourceSpan: ParseSourceSpan, message: string, relatedInformation?: {\n    text: string,\n    start: number,\n    end: number,\n    sourceFile: ts.SourceFile,\n  }[]): NgTemplateDiagnostic<Code>;\n}\n\n/**\n * A factory which creates a template check for a particular code and name. This binds the two\n * together and associates them with a specific `TemplateCheck`.\n */\nexport interface TemplateCheckFactory<\n  Code extends ErrorCode,\n  Name extends ExtendedTemplateDiagnosticName,\n> {\n  code: Code;\n  name: Name;\n  create(options: NgCompilerOptions): TemplateCheck<Code>|null;\n}\n\n/**\n * This abstract class provides a base implementation for the run method.\n */\nexport abstract class TemplateCheckWithVisitor<Code extends ErrorCode> implements\n    TemplateCheck<Code> {\n  abstract code: Code;\n\n  /**\n   * Base implementation for run function, visits all nodes in template and calls\n   * `visitNode()` for each one.\n   */\n  run(ctx: TemplateContext<Code>, component: ts.ClassDeclaration,\n      template: TmplAstNode[]): NgTemplateDiagnostic<Code>[] {\n    const visitor = new TemplateVisitor<Code>(ctx, component, this);\n    return visitor.getDiagnostics(template);\n  }\n\n  /**\n   * Visit a TmplAstNode or AST node of the template. Authors should override this\n   * method to implement the check and return diagnostics.\n   */\n  abstract visitNode(\n      ctx: TemplateContext<Code>, component: ts.ClassDeclaration,\n      node: TmplAstNode|AST): NgTemplateDiagnostic<Code>[];\n}\n\n/**\n * Visits all nodes in a template (TmplAstNode and AST) and calls `visitNode` for each one.\n */\nclass TemplateVisitor<Code extends ErrorCode> extends RecursiveAstVisitor implements\n    TmplAstRecursiveVisitor {\n  diagnostics: NgTemplateDiagnostic<Code>[] = [];\n\n  constructor(\n      private readonly ctx: TemplateContext<Code>, private readonly component: ts.ClassDeclaration,\n      private readonly check: TemplateCheckWithVisitor<Code>) {\n    super();\n  }\n\n  override visit(node: AST|TmplAstNode, context?: any) {\n    this.diagnostics.push(...this.check.visitNode(this.ctx, this.component, node));\n    node.visit(this);\n  }\n\n  visitAllNodes(nodes: TmplAstNode[]) {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n\n  visitAst(ast: AST) {\n    if (ast instanceof ASTWithSource) {\n      ast = ast.ast;\n    }\n    this.visit(ast);\n  }\n\n  visitElement(element: TmplAstElement) {\n    this.visitAllNodes(element.attributes);\n    this.visitAllNodes(element.inputs);\n    this.visitAllNodes(element.outputs);\n    this.visitAllNodes(element.references);\n    this.visitAllNodes(element.children);\n  }\n\n  visitTemplate(template: TmplAstTemplate) {\n    this.visitAllNodes(template.attributes);\n    if (template.tagName === 'ng-template') {\n      // Only visit input/outputs/templateAttrs if this isn't an inline template node\n      // generated for a structural directive (like `<div *ngIf></div>`). These nodes\n      // would be visited when the underlying element of an inline template node is processed.\n      this.visitAllNodes(template.inputs);\n      this.visitAllNodes(template.outputs);\n      this.visitAllNodes(template.templateAttrs);\n    }\n    this.visitAllNodes(template.variables);\n    this.visitAllNodes(template.references);\n    this.visitAllNodes(template.children);\n  }\n  visitContent(content: TmplAstContent): void {}\n  visitVariable(variable: TmplAstVariable): void {}\n  visitReference(reference: TmplAstReference): void {}\n  visitTextAttribute(attribute: TmplAstTextAttribute): void {}\n  visitBoundAttribute(attribute: TmplAstBoundAttribute): void {\n    this.visitAst(attribute.value);\n  }\n  visitBoundEvent(attribute: TmplAstBoundEvent): void {\n    this.visitAst(attribute.handler);\n  }\n  visitText(text: TmplAstText): void {}\n  visitBoundText(text: TmplAstBoundText): void {\n    this.visitAst(text.value);\n  }\n  visitIcu(icu: TmplAstIcu): void {}\n\n  getDiagnostics(template: TmplAstNode[]): NgTemplateDiagnostic<Code>[] {\n    this.diagnostics = [];\n    this.visitAllNodes(template);\n    return this.diagnostics;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, TmplAstBoundEvent, TmplAstNode} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\n/**\n * Ensures the two-way binding syntax is correct.\n * Parentheses should be inside the brackets \"[()]\".\n * Will return diagnostic information when \"([])\" is found.\n */\nclass InvalidBananaInBoxCheck extends TemplateCheckWithVisitor<ErrorCode.INVALID_BANANA_IN_BOX> {\n  override code = ErrorCode.INVALID_BANANA_IN_BOX as const;\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.INVALID_BANANA_IN_BOX>,\n      component: ts.ClassDeclaration,\n      node: TmplAstNode|AST,\n      ): NgTemplateDiagnostic<ErrorCode.INVALID_BANANA_IN_BOX>[] {\n    if (!(node instanceof TmplAstBoundEvent)) return [];\n\n    const name = node.name;\n    if (!name.startsWith('[') || !name.endsWith(']')) return [];\n\n    const boundSyntax = node.sourceSpan.toString();\n    const expectedBoundSyntax = boundSyntax.replace(`(${name})`, `[(${name.slice(1, -1)})]`);\n    const diagnostic = ctx.makeTemplateDiagnostic(\n        node.sourceSpan,\n        `In the two-way binding syntax the parentheses should be inside the brackets, ex. '${\n            expectedBoundSyntax}'.\n        Find more at https://angular.io/guide/two-way-binding`);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.INVALID_BANANA_IN_BOX, ExtendedTemplateDiagnosticName.INVALID_BANANA_IN_BOX> = {\n  code: ErrorCode.INVALID_BANANA_IN_BOX,\n  name: ExtendedTemplateDiagnosticName.INVALID_BANANA_IN_BOX,\n  create: () => new InvalidBananaInBoxCheck(),\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {NgCompilerOptions} from '../../../../core/api';\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\n/**\n * The list of known control flow directives present in the `CommonModule`,\n * and their corresponding imports.\n *\n * Note: there is no `ngSwitch` here since it's typically used as a regular\n * binding (e.g. `[ngSwitch]`), however the `ngSwitchCase` and `ngSwitchDefault`\n * are used as structural directives and a warning would be generated. Once the\n * `CommonModule` is included, the `ngSwitch` would also be covered.\n */\nexport const KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([\n  ['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'],\n  ['ngSwitchDefault', 'NgSwitchDefault']\n]);\n\n/**\n * Ensures that there are no known control flow directives (such as *ngIf and *ngFor)\n * used in a template of a *standalone* component without importing a `CommonModule`. Returns\n * diagnostics in case such a directive is detected.\n *\n * Note: this check only handles the cases when structural directive syntax is used (e.g. `*ngIf`).\n * Regular binding syntax (e.g. `[ngIf]`) is handled separately in type checker and treated as a\n * hard error instead of a warning.\n */\nclass MissingControlFlowDirectiveCheck extends\n    TemplateCheckWithVisitor<ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE> {\n  override code = ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE as const;\n\n  override run(\n      ctx: TemplateContext<ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE>,\n      component: ts.ClassDeclaration, template: TmplAstNode[]) {\n    const componentMetadata = ctx.templateTypeChecker.getDirectiveMetadata(component);\n    // Avoid running this check for non-standalone components.\n    if (!componentMetadata || !componentMetadata.isStandalone) {\n      return [];\n    }\n    return super.run(ctx, component, template);\n  }\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE>,\n      component: ts.ClassDeclaration,\n      node: TmplAstNode|AST): NgTemplateDiagnostic<ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE>[] {\n    if (!(node instanceof TmplAstTemplate)) return [];\n\n    const controlFlowAttr =\n        node.templateAttrs.find(attr => KNOWN_CONTROL_FLOW_DIRECTIVES.has(attr.name));\n    if (!controlFlowAttr) return [];\n\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol === null || symbol.directives.length > 0) {\n      return [];\n    }\n\n    const sourceSpan = controlFlowAttr.keySpan || controlFlowAttr.sourceSpan;\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(controlFlowAttr.name);\n    const errorMessage =\n        `The \\`*${controlFlowAttr.name}\\` directive was used in the template, ` +\n        `but neither the \\`${\n            correspondingImport}\\` directive nor the \\`CommonModule\\` was imported. ` +\n        `Please make sure that either the \\`${\n            correspondingImport}\\` directive or the \\`CommonModule\\` ` +\n        `is included in the \\`@Component.imports\\` array of this component.`;\n    const diagnostic = ctx.makeTemplateDiagnostic(sourceSpan, errorMessage);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE,\n    ExtendedTemplateDiagnosticName.MISSING_CONTROL_FLOW_DIRECTIVE> = {\n  code: ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE,\n  name: ExtendedTemplateDiagnosticName.MISSING_CONTROL_FLOW_DIRECTIVE,\n  create: (options: NgCompilerOptions) => {\n    return new MissingControlFlowDirectiveCheck();\n  },\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\n/**\n * Ensures a user doesn't forget to omit `let` when using ngfor.\n * Will return diagnostic information when `let` is missing.\n */\nclass MissingNgForOfLetCheck extends TemplateCheckWithVisitor<ErrorCode.MISSING_NGFOROF_LET> {\n  override code = ErrorCode.MISSING_NGFOROF_LET as const;\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.MISSING_NGFOROF_LET>, component: ts.ClassDeclaration,\n      node: TmplAstNode|AST): NgTemplateDiagnostic<ErrorCode.MISSING_NGFOROF_LET>[] {\n    const isTemplate = node instanceof TmplAstTemplate;\n    if (!(node instanceof TmplAstTemplate)) {\n      return [];\n    }\n\n    if (node.templateAttrs.length === 0) {\n      return [];\n    }\n    const attr = node.templateAttrs.find(x => x.name === 'ngFor');\n    if (attr === undefined) {\n      return [];\n    }\n\n    if (node.variables.length > 0) {\n      return [];\n    }\n    const errorString = 'Your ngFor is missing a value. Did you forget to add the `let` keyword?';\n    const diagnostic = ctx.makeTemplateDiagnostic(attr.sourceSpan, errorString);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.MISSING_NGFOROF_LET, ExtendedTemplateDiagnosticName.MISSING_NGFOROF_LET> = {\n  code: ErrorCode.MISSING_NGFOROF_LET,\n  name: ExtendedTemplateDiagnosticName.MISSING_NGFOROF_LET,\n  create: () => new MissingNgForOfLetCheck(),\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, Binary, TmplAstNode} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {NgCompilerOptions} from '../../../../core/api';\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic, SymbolKind} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\n/**\n * Ensures the left side of a nullish coalescing operation is nullable.\n * Returns diagnostics for the cases where the operator is useless.\n * This check should only be use if `strictNullChecks` is enabled,\n * otherwise it would produce inaccurate results.\n */\nclass NullishCoalescingNotNullableCheck extends\n    TemplateCheckWithVisitor<ErrorCode.NULLISH_COALESCING_NOT_NULLABLE> {\n  override code = ErrorCode.NULLISH_COALESCING_NOT_NULLABLE as const;\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.NULLISH_COALESCING_NOT_NULLABLE>,\n      component: ts.ClassDeclaration,\n      node: TmplAstNode|AST): NgTemplateDiagnostic<ErrorCode.NULLISH_COALESCING_NOT_NULLABLE>[] {\n    if (!(node instanceof Binary) || node.operation !== '??') return [];\n\n    const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.left, component);\n    if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const typeLeft = symbolLeft.tsType;\n    if (typeLeft.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n      // We should not make assumptions about the any and unknown types; using a nullish coalescing\n      // operator is acceptable for those.\n      return [];\n    }\n\n    // If the left operand's type is different from its non-nullable self, then it must\n    // contain a null or undefined so this nullish coalescing operator is useful. No diagnostic to\n    // report.\n    if (typeLeft.getNonNullableType() !== typeLeft) return [];\n\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component)!;\n    if (symbol.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const templateMapping =\n        ctx.templateTypeChecker.getTemplateMappingAtTcbLocation(symbol.tcbLocation);\n    if (templateMapping === null) {\n      return [];\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(\n        templateMapping.span,\n        `The left side of this nullish coalescing operation does not include 'null' or 'undefined' in its type, therefore the '??' operator can be safely removed.`);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.NULLISH_COALESCING_NOT_NULLABLE,\n    ExtendedTemplateDiagnosticName.NULLISH_COALESCING_NOT_NULLABLE> = {\n  code: ErrorCode.NULLISH_COALESCING_NOT_NULLABLE,\n  name: ExtendedTemplateDiagnosticName.NULLISH_COALESCING_NOT_NULLABLE,\n  create: (options: NgCompilerOptions) => {\n    // Require `strictNullChecks` to be enabled.\n    const strictNullChecks =\n        options.strictNullChecks === undefined ? !!options.strict : !!options.strictNullChecks;\n    if (!strictNullChecks) {\n      return null;\n    }\n\n    return new NullishCoalescingNotNullableCheck();\n  },\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, SafeCall, SafeKeyedRead, SafePropertyRead, TmplAstNode} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {NgCompilerOptions} from '../../../../core/api';\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic, SymbolKind} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\n/**\n * Ensures the left side of an optional chain operation is nullable.\n * Returns diagnostics for the cases where the operator is useless.\n * This check should only be use if `strictNullChecks` is enabled,\n * otherwise it would produce inaccurate results.\n */\nclass OptionalChainNotNullableCheck extends\n    TemplateCheckWithVisitor<ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE> {\n  override code = ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE as const;\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE>, component: ts.ClassDeclaration,\n      node: TmplAstNode|AST): NgTemplateDiagnostic<ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE>[] {\n    if (!(node instanceof SafeCall) && !(node instanceof SafePropertyRead) &&\n        !(node instanceof SafeKeyedRead))\n      return [];\n\n    const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.receiver, component);\n    if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const typeLeft = symbolLeft.tsType;\n    if (typeLeft.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n      // We should not make assumptions about the any and unknown types; using a nullish coalescing\n      // operator is acceptable for those.\n      return [];\n    }\n\n    // If the left operand's type is different from its non-nullable self, then it must\n    // contain a null or undefined so this nullish coalescing operator is useful. No diagnostic to\n    // report.\n    if (typeLeft.getNonNullableType() !== typeLeft) return [];\n\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component)!;\n    if (symbol.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const templateMapping =\n        ctx.templateTypeChecker.getTemplateMappingAtTcbLocation(symbol.tcbLocation);\n    if (templateMapping === null) {\n      return [];\n    }\n    const advice = node instanceof SafePropertyRead ?\n        `the '?.' operator can be replaced with the '.' operator` :\n        `the '?.' operator can be safely removed`;\n    const diagnostic = ctx.makeTemplateDiagnostic(\n        templateMapping.span,\n        `The left side of this optional chain operation does not include 'null' or 'undefined' in its type, therefore ${\n            advice}.`);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE,\n    ExtendedTemplateDiagnosticName.OPTIONAL_CHAIN_NOT_NULLABLE> = {\n  code: ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE,\n  name: ExtendedTemplateDiagnosticName.OPTIONAL_CHAIN_NOT_NULLABLE,\n  create: (options: NgCompilerOptions) => {\n    // Require `strictNullChecks` to be enabled.\n    const strictNullChecks =\n        options.strictNullChecks === undefined ? !!options.strict : !!options.strictNullChecks;\n    if (!strictNullChecks) {\n      return null;\n    }\n\n    return new OptionalChainNotNullableCheck();\n  },\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, TmplAstBoundAttribute, TmplAstNode} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\nconst STYLE_SUFFIXES = ['px', '%', 'em'];\n\n/**\n * A check which detects when the `.px`, `.%`, and `.em` suffixes are used with an attribute\n * binding. These suffixes are only available for style bindings.\n */\nclass SuffixNotSupportedCheck extends TemplateCheckWithVisitor<ErrorCode.SUFFIX_NOT_SUPPORTED> {\n  override code = ErrorCode.SUFFIX_NOT_SUPPORTED as const;\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.SUFFIX_NOT_SUPPORTED>, component: ts.ClassDeclaration,\n      node: TmplAstNode|AST): NgTemplateDiagnostic<ErrorCode.SUFFIX_NOT_SUPPORTED>[] {\n    if (!(node instanceof TmplAstBoundAttribute)) return [];\n\n    if (!node.keySpan.toString().startsWith('attr.') ||\n        !STYLE_SUFFIXES.some(suffix => node.name.endsWith(`.${suffix}`))) {\n      return [];\n    }\n\n    const diagnostic = ctx.makeTemplateDiagnostic(\n        node.keySpan,\n        `The ${\n            STYLE_SUFFIXES.map(suffix => `'.${suffix}'`)\n                .join(', ')} suffixes are only supported on style bindings.`);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.SUFFIX_NOT_SUPPORTED, ExtendedTemplateDiagnosticName.SUFFIX_NOT_SUPPORTED> = {\n  code: ErrorCode.SUFFIX_NOT_SUPPORTED,\n  name: ExtendedTemplateDiagnosticName.SUFFIX_NOT_SUPPORTED,\n  create: () => new SuffixNotSupportedCheck(),\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../../diagnostics';\nimport {NgTemplateDiagnostic} from '../../../api';\nimport {TemplateCheckFactory, TemplateCheckWithVisitor, TemplateContext} from '../../api';\n\n/**\n * Ensures that attributes that have the \"special\" angular binding prefix (attr., style., and\n * class.) are interpreted as bindings. For example, `<div attr.id=\"my-id\"></div>` will not\n * interpret this as an `AttributeBinding` to `id` but rather just a `TmplAstTextAttribute`. This\n * is likely not the intent of the developer. Instead, the intent is likely to have the `id` be set\n * to 'my-id'.\n */\nclass TextAttributeNotBindingSpec extends\n    TemplateCheckWithVisitor<ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING> {\n  override code = ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING as const;\n\n  override visitNode(\n      ctx: TemplateContext<ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING>,\n      component: ts.ClassDeclaration,\n      node: TmplAstNode|AST,\n      ): NgTemplateDiagnostic<ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING>[] {\n    if (!(node instanceof TmplAstTextAttribute)) return [];\n\n    const name = node.name;\n    if ((!name.startsWith('attr.') && !name.startsWith('style.') && !name.startsWith('class.'))) {\n      return [];\n    }\n\n    let errorString: string;\n    if (name.startsWith('attr.')) {\n      const staticAttr = name.replace('attr.', '');\n      errorString = `Static attributes should be written without the 'attr.' prefix.`;\n      if (node.value) {\n        errorString += ` For example, ${staticAttr}=\"${node.value}\".`;\n      }\n    } else {\n      const expectedKey = `[${name}]`;\n      const expectedValue =\n          // true/false are special cases because we don't want to convert them to strings but\n          // rather maintain the logical true/false when bound.\n          (node.value === 'true' || node.value === 'false') ? node.value : `'${node.value}'`;\n      errorString = 'Attribute, style, and class bindings should be enclosed with square braces.';\n      if (node.value) {\n        errorString += ` For example, '${expectedKey}=\"${expectedValue}\"'.`;\n      }\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, errorString);\n    return [diagnostic];\n  }\n}\n\nexport const factory: TemplateCheckFactory<\n    ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING,\n    ExtendedTemplateDiagnosticName.TEXT_ATTRIBUTE_NOT_BINDING> = {\n  code: ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING,\n  name: ExtendedTemplateDiagnosticName.TEXT_ATTRIBUTE_NOT_BINDING,\n  create: () => new TextAttributeNotBindingSpec(),\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '@angular/compiler';\nimport ts from 'typescript';\n\nimport {DiagnosticCategoryLabel, NgCompilerOptions} from '../../../core/api';\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../../diagnostics';\nimport {NgTemplateDiagnostic, TemplateDiagnostic, TemplateTypeChecker} from '../../api';\nimport {ExtendedTemplateChecker, TemplateCheck, TemplateCheckFactory, TemplateContext} from '../api';\n\nexport class ExtendedTemplateCheckerImpl implements ExtendedTemplateChecker {\n  private readonly partialCtx: Omit<TemplateContext<ErrorCode>, 'makeTemplateDiagnostic'>;\n  private readonly templateChecks: Map<TemplateCheck<ErrorCode>, ts.DiagnosticCategory>;\n\n  constructor(\n      templateTypeChecker: TemplateTypeChecker, typeChecker: ts.TypeChecker,\n      templateCheckFactories:\n          readonly TemplateCheckFactory<ErrorCode, ExtendedTemplateDiagnosticName>[],\n      options: NgCompilerOptions) {\n    this.partialCtx = {templateTypeChecker, typeChecker};\n    this.templateChecks = new Map<TemplateCheck<ErrorCode>, ts.DiagnosticCategory>();\n\n    for (const factory of templateCheckFactories) {\n      // Read the diagnostic category from compiler options.\n      const category = diagnosticLabelToCategory(\n          options?.extendedDiagnostics?.checks?.[factory.name] ??\n          options?.extendedDiagnostics?.defaultCategory ?? DiagnosticCategoryLabel.Warning);\n\n      // Skip the diagnostic if suppressed via compiler options.\n      if (category === null) {\n        continue;\n      }\n\n      // Try to create the check.\n      const check = factory.create(options);\n\n      // Skip the diagnostic if it was disabled due to unsupported options. For example, this can\n      // happen if the check requires `strictNullChecks: true` but that flag is disabled in compiler\n      // options.\n      if (check === null) {\n        continue;\n      }\n\n      // Use the check.\n      this.templateChecks.set(check, category);\n    }\n  }\n\n  getDiagnosticsForComponent(component: ts.ClassDeclaration): TemplateDiagnostic[] {\n    const template = this.partialCtx.templateTypeChecker.getTemplate(component);\n    // Skip checks if component has no template. This can happen if the user writes a\n    // `@Component()` but doesn't add the template, could happen in the language service\n    // when users are in the middle of typing code.\n    if (template === null) {\n      return [];\n    }\n    const diagnostics: TemplateDiagnostic[] = [];\n\n    for (const [check, category] of this.templateChecks.entries()) {\n      const ctx: TemplateContext<ErrorCode> = {\n        ...this.partialCtx,\n        // Wrap `templateTypeChecker.makeTemplateDiagnostic()` to implicitly provide all the known\n        // options.\n        makeTemplateDiagnostic: (span: ParseSourceSpan, message: string, relatedInformation?: {\n          text: string,\n          start: number,\n          end: number,\n          sourceFile: ts.SourceFile,\n        }[]): NgTemplateDiagnostic<ErrorCode> => {\n          return this.partialCtx.templateTypeChecker.makeTemplateDiagnostic(\n              component, span, category, check.code, message, relatedInformation);\n        },\n      };\n\n      diagnostics.push(...check.run(ctx, component, template));\n    }\n\n    return diagnostics;\n  }\n}\n\n/**\n * Converts a `DiagnosticCategoryLabel` to its equivalent `ts.DiagnosticCategory` or `null` if\n * the label is `DiagnosticCategoryLabel.Suppress`.\n */\nfunction diagnosticLabelToCategory(label: DiagnosticCategoryLabel): ts.DiagnosticCategory|null {\n  switch (label) {\n    case DiagnosticCategoryLabel.Warning:\n      return ts.DiagnosticCategory.Warning;\n    case DiagnosticCategoryLabel.Error:\n      return ts.DiagnosticCategory.Error;\n    case DiagnosticCategoryLabel.Suppress:\n      return null;\n    default:\n      return assertNever(label);\n  }\n}\n\nfunction assertNever(value: never): never {\n  throw new Error(`Unexpected call to 'assertNever()' with value:\\n${value}`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ExtendedTemplateDiagnosticName} from '../../../../ngtsc/diagnostics';\n\n/**\n * Options supported by the legacy View Engine compiler, which are still consumed by the Angular Ivy\n * compiler for backwards compatibility.\n *\n * These are expected to be removed at some point in the future.\n *\n * @publicApi\n */\nexport interface LegacyNgcOptions {\n  /** generate all possible generated files  */\n  allowEmptyCodegenFiles?: boolean;\n\n  /**\n   * Whether to type check the entire template.\n   *\n   * This flag currently controls a couple aspects of template type-checking, including\n   * whether embedded views are checked.\n   *\n   * For maximum type-checking, set this to `true`, and set `strictTemplates` to `true`.\n   *\n   * It is an error for this flag to be `false`, while `strictTemplates` is set to `true`.\n   *\n   * @deprecated The `fullTemplateTypeCheck` option has been superseded by the more granular\n   * `strictTemplates` family of compiler options. Usage of `fullTemplateTypeCheck` is therefore\n   * deprecated, `strictTemplates` and its related options should be used instead.\n   */\n  fullTemplateTypeCheck?: boolean;\n\n  /**\n   * Whether to generate a flat module index of the given name and the corresponding\n   * flat module metadata. This option is intended to be used when creating flat\n   * modules similar to how `@angular/core` and `@angular/common` are packaged.\n   * When this option is used the `package.json` for the library should refer to the\n   * generated flat module index instead of the library index file. When using this\n   * option only one .metadata.json file is produced that contains all the metadata\n   * necessary for symbols exported from the library index.\n   * In the generated .ngfactory.ts files flat module index is used to import symbols\n   * including both the public API from the library index as well as shrouded internal\n   * symbols.\n   * By default the .ts file supplied in the `files` field is assumed to be the\n   * library index. If more than one is specified, uses `libraryIndex` to select the\n   * file to use. If more than one .ts file is supplied and no `libraryIndex` is supplied\n   * an error is produced.\n   * A flat module index .d.ts and .js will be created with the given `flatModuleOutFile`\n   * name in the same location as the library index .d.ts file is emitted.\n   * For example, if a library uses `public_api.ts` file as the library index of the\n   * module the `tsconfig.json` `files` field would be `[\"public_api.ts\"]`. The\n   * `flatModuleOutFile` options could then be set to, for example `\"index.js\"`, which\n   * produces `index.d.ts` and  `index.metadata.json` files. The library's\n   * `package.json`'s `module` field would be `\"index.js\"` and the `typings` field would\n   * be `\"index.d.ts\"`.\n   */\n  flatModuleOutFile?: string;\n\n  /**\n   * Preferred module id to use for importing flat module. References generated by `ngc`\n   * will use this module name when importing symbols from the flat module. This is only\n   * meaningful when `flatModuleOutFile` is also supplied. It is otherwise ignored.\n   */\n  flatModuleId?: string;\n\n  /**\n   * Always report errors a parameter is supplied whose injection type cannot\n   * be determined. When this value option is not provided or is `false`, constructor\n   * parameters of classes marked with `@Injectable` whose type cannot be resolved will\n   * produce a warning. With this option `true`, they produce an error. When this option is\n   * not provided is treated as if it were `false`.\n   */\n  strictInjectionParameters?: boolean;\n\n  /**\n   * Whether to remove blank text nodes from compiled templates. It is `false` by default starting\n   * from Angular 6.\n   */\n  preserveWhitespaces?: boolean;\n}\n\n/**\n * Options related to template type-checking and its strictness.\n *\n * @publicApi\n */\nexport interface StrictTemplateOptions {\n  /**\n   * If `true`, implies all template strictness flags below (unless individually disabled).\n   *\n   * This flag is a superset of the deprecated `fullTemplateTypeCheck` option.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is `true`.\n   */\n  strictTemplates?: boolean;\n\n\n  /**\n   * Whether to check the type of a binding to a directive/component input against the type of the\n   * field on the directive/component.\n   *\n   * For example, if this is `false` then the expression `[input]=\"expr\"` will have `expr` type-\n   * checked, but not the assignment of the resulting type to the `input` property of whichever\n   * directive or component is receiving the binding. If set to `true`, both sides of the assignment\n   * are checked.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set.\n   */\n  strictInputTypes?: boolean;\n\n  /**\n   * Whether to check if the input binding attempts to assign to a restricted field (readonly,\n   * private, or protected) on the directive/component.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\", \"strictTemplates\" and/or\n   * \"strictInputTypes\" is set. Note that if `strictInputTypes` is not set, or set to `false`, this\n   * flag has no effect.\n   *\n   * Tracking issue for enabling this by default: https://github.com/angular/angular/issues/38400\n   */\n  strictInputAccessModifiers?: boolean;\n\n  /**\n   * Whether to use strict null types for input bindings for directives.\n   *\n   * If this is `true`, applications that are compiled with TypeScript's `strictNullChecks` enabled\n   * will produce type errors for bindings which can evaluate to `undefined` or `null` where the\n   * inputs's type does not include `undefined` or `null` in its type. If set to `false`, all\n   * binding expressions are wrapped in a non-null assertion operator to effectively disable strict\n   * null checks.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set. Note that if `strictInputTypes` is\n   * not set, or set to `false`, this flag has no effect.\n   */\n  strictNullInputTypes?: boolean;\n\n  /**\n   * Whether to check text attributes that happen to be consumed by a directive or component.\n   *\n   * For example, in a template containing `<input matInput disabled>` the `disabled` attribute ends\n   * up being consumed as an input with type `boolean` by the `matInput` directive. At runtime, the\n   * input will be set to the attribute's string value, which is an empty string for attributes\n   * without a value, so with this flag set to `true`, an error would be reported. If set to\n   * `false`, text attributes will never report an error.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set. Note that if `strictInputTypes` is\n   * not set, or set to `false`, this flag has no effect.\n   */\n  strictAttributeTypes?: boolean;\n\n  /**\n   * Whether to use a strict type for null-safe navigation operations.\n   *\n   * If this is `false`, then the return type of `a?.b` or `a?()` will be `any`. If set to `true`,\n   * then the return type of `a?.b` for example will be the same as the type of the ternary\n   * expression `a != null ? a.b : a`.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set.\n   */\n  strictSafeNavigationTypes?: boolean;\n\n  /**\n   * Whether to infer the type of local references.\n   *\n   * If this is `true`, the type of a `#ref` variable on a DOM node in the template will be\n   * determined by the type of `document.createElement` for the given DOM node. If set to `false`,\n   * the type of `ref` for DOM nodes will be `any`.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set.\n   */\n  strictDomLocalRefTypes?: boolean;\n\n  /**\n   * Whether to infer the type of the `$event` variable in event bindings for directive outputs or\n   * animation events.\n   *\n   * If this is `true`, the type of `$event` will be inferred based on the generic type of\n   * `EventEmitter`/`Subject` of the output. If set to `false`, the `$event` variable will be of\n   * type `any`.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set.\n   */\n  strictOutputEventTypes?: boolean;\n\n  /**\n   * Whether to infer the type of the `$event` variable in event bindings to DOM events.\n   *\n   * If this is `true`, the type of `$event` will be inferred based on TypeScript's\n   * `HTMLElementEventMap`, with a fallback to the native `Event` type. If set to `false`, the\n   * `$event` variable will be of type `any`.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set.\n   */\n  strictDomEventTypes?: boolean;\n\n  /**\n   * Whether to include the generic type of components when type-checking the template.\n   *\n   * If no component has generic type parameters, this setting has no effect.\n   *\n   * If a component has generic type parameters and this setting is `true`, those generic parameters\n   * will be included in the context type for the template. If `false`, any generic parameters will\n   * be set to `any` in the template context type.\n   *\n   * Defaults to `false`, even if \"fullTemplateTypeCheck\" is set.\n   */\n  strictContextGenerics?: boolean;\n\n  /**\n   * Whether object or array literals defined in templates use their inferred type, or are\n   * interpreted as `any`.\n   *\n   * Defaults to `false` unless `fullTemplateTypeCheck` or `strictTemplates` are set.\n   */\n  strictLiteralTypes?: boolean;\n}\n\n/**\n * A label referring to a `ts.DiagnosticCategory` or `'suppress'`, meaning the associated diagnostic\n * should not be displayed at all.\n *\n * @publicApi\n */\nexport enum DiagnosticCategoryLabel {\n  /** Treat the diagnostic as a warning, don't fail the compilation. */\n  Warning = 'warning',\n\n  /** Treat the diagnostic as a hard error, fail the compilation. */\n  Error = 'error',\n\n  /** Ignore the diagnostic altogether. */\n  Suppress = 'suppress',\n}\n\n/**\n * Options which control how diagnostics are emitted from the compiler.\n *\n * @publicApi\n */\nexport interface DiagnosticOptions {\n  /** Options which control how diagnostics are emitted from the compiler. */\n  extendedDiagnostics?: {\n    /**\n     * The category to use for configurable diagnostics which are not overridden by `checks`. Uses\n     * `warning` by default.\n     */\n    defaultCategory?: DiagnosticCategoryLabel;\n\n    /**\n     * A map of each extended template diagnostic's name to its category. This can be expanded in\n     * the future with more information for each check or for additional diagnostics not part of the\n     * extended template diagnostics system.\n     */\n    checks?: {[Name in ExtendedTemplateDiagnosticName]?: DiagnosticCategoryLabel};\n  };\n}\n\n/**\n * Options which control behavior useful for \"monorepo\" build cases using Bazel (such as the\n * internal Google monorepo, g3).\n *\n * @publicApi\n */\nexport interface BazelAndG3Options {\n  /**\n   * Enables the generation of alias re-exports of directives/pipes that are visible from an\n   * NgModule from that NgModule's file.\n   *\n   * This option should be disabled for application builds or for Angular Package Format libraries\n   * (where NgModules along with their directives/pipes are exported via a single entrypoint).\n   *\n   * For other library compilations which are intended to be path-mapped into an application build\n   * (or another library), enabling this option enables the resulting deep imports to work\n   * correctly.\n   *\n   * A consumer of such a path-mapped library will write an import like:\n   *\n   * ```typescript\n   * import {LibModule} from 'lib/deep/path/to/module';\n   * ```\n   *\n   * The compiler will attempt to generate imports of directives/pipes from that same module\n   * specifier (the compiler does not rewrite the user's given import path, unlike View Engine).\n   *\n   * ```typescript\n   * import {LibDir, LibCmp, LibPipe} from 'lib/deep/path/to/module';\n   * ```\n   *\n   * It would be burdensome for users to have to re-export all directives/pipes alongside each\n   * NgModule to support this import model. Enabling this option tells the compiler to generate\n   * private re-exports alongside the NgModule of all the directives/pipes it makes available, to\n   * support these future imports.\n   */\n  generateDeepReexports?: boolean;\n\n  /**\n   * The `.d.ts` file for NgModules contain type pointers to their declarations, imports, and\n   * exports. Without this flag, the generated type definition will include\n   * components/directives/pipes/NgModules that are declared or imported locally in the NgModule and\n   * not necessarily exported to consumers.\n   *\n   * With this flag set, the type definition generated in the `.d.ts` for an NgModule will be\n   * filtered to only list those types which are publicly exported by the NgModule.\n   */\n  onlyPublishPublicTypingsForNgModules?: boolean;\n\n  /**\n   * Insert JSDoc type annotations needed by Closure Compiler\n   */\n  annotateForClosureCompiler?: boolean;\n}\n\n/**\n * Options related to i18n compilation support.\n *\n * @publicApi\n */\nexport interface I18nOptions {\n  /**\n   * Locale of the imported translations\n   */\n  i18nInLocale?: string;\n\n  /**\n   * Export format (xlf, xlf2 or xmb) when the xi18n operation is requested.\n   */\n  i18nOutFormat?: string;\n\n  /**\n   * Path to the extracted message file to emit when the xi18n operation is requested.\n   */\n  i18nOutFile?: string;\n\n\n  /**\n   * Locale of the application (used when xi18n is requested).\n   */\n  i18nOutLocale?: string;\n\n  /**\n   * Render `$localize` messages with legacy format ids.\n   *\n   * The default value for now is `true`.\n   *\n   * Use this option when use are using the `$localize` based localization messages but\n   * have not migrated the translation files to use the new `$localize` message id format.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n\n  /**\n   * Whether translation variable name should contain external message id\n   * (used by Closure Compiler's output of `goog.getMsg` for transition period)\n   */\n  i18nUseExternalIds?: boolean;\n\n  /**\n   * If templates are stored in external files (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * Ideally we would always normalize, but for backward compatibility this flag allows the template\n   * parser to avoid normalizing line endings in ICU expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n}\n\n/**\n * Options that specify compilation target.\n *\n * @publicApi\n */\nexport interface TargetOptions {\n  /**\n   * Specifies the compilation mode to use. The following modes are available:\n   * - 'full': generates fully AOT compiled code using Ivy instructions.\n   * - 'partial': generates code in a stable, but intermediate form suitable for publication to NPM.\n   * - 'experimental-local': generates code based on each individual source file without using its\n   * dependencies. This mode is suitable only for fast edit/refresh during development. It will be\n   * eventually replaced by the value `local` once the feature is ready to be public.\n   *\n   * The default value is 'full'.\n   */\n  compilationMode?: 'full'|'partial'|'experimental-local';\n}\n\n/**\n * Miscellaneous options that don't fall into any other category\n *\n * @publicApi\n */\nexport interface MiscOptions {\n  /**\n   * Whether the compiler should avoid generating code for classes that haven't been exported.\n   * Defaults to `true`.\n   */\n  compileNonExportedClasses?: boolean;\n\n  /**\n   * Disable TypeScript Version Check.\n   */\n  disableTypeScriptVersionCheck?: boolean;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ErrorCode, ExtendedTemplateDiagnosticName} from '../../diagnostics';\n\nimport {TemplateCheckFactory} from './api';\nimport {factory as invalidBananaInBoxFactory} from './checks/invalid_banana_in_box';\nimport {factory as missingControlFlowDirectiveFactory} from './checks/missing_control_flow_directive';\nimport {factory as missingNgForOfLetFactory} from './checks/missing_ngforof_let';\nimport {factory as nullishCoalescingNotNullableFactory} from './checks/nullish_coalescing_not_nullable';\nimport {factory as optionalChainNotNullableFactory} from './checks/optional_chain_not_nullable';\nimport {factory as suffixNotSupportedFactory} from './checks/suffix_not_supported';\nimport {factory as textAttributeNotBindingFactory} from './checks/text_attribute_not_binding';\n\nexport {ExtendedTemplateCheckerImpl} from './src/extended_template_checker';\n\nexport const ALL_DIAGNOSTIC_FACTORIES:\n    readonly TemplateCheckFactory<ErrorCode, ExtendedTemplateDiagnosticName>[] = [\n      invalidBananaInBoxFactory,\n      nullishCoalescingNotNullableFactory,\n      optionalChainNotNullableFactory,\n      missingControlFlowDirectiveFactory,\n      textAttributeNotBindingFactory,\n      missingNgForOfLetFactory,\n      suffixNotSupportedFactory,\n    ];\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {findFlatIndexEntryPoint, FlatIndexGenerator} from '../../entry_point';\nimport {AbsoluteFsPath, resolve} from '../../file_system';\nimport {isShim, ShimAdapter, ShimReferenceTagger} from '../../shims';\nimport {PerFileShimGenerator, TopLevelShimGenerator} from '../../shims/api';\nimport {TypeCheckShimGenerator} from '../../typecheck';\nimport {normalizeSeparators} from '../../util/src/path';\nimport {getRootDirs, isNonDeclarationTsPath, RequiredDelegations} from '../../util/src/typescript';\nimport {ExtendedTsCompilerHost, NgCompilerAdapter, NgCompilerOptions, UnifiedModulesHost} from '../api';\n\n// A persistent source of bugs in CompilerHost delegation has been the addition by TS of new,\n// optional methods on ts.CompilerHost. Since these methods are optional, it's not a type error that\n// the delegating host doesn't implement or delegate them. This causes subtle runtime failures. No\n// more. This infrastructure ensures that failing to delegate a method is a compile-time error.\n\n/**\n * Delegates all methods of `ExtendedTsCompilerHost` to a delegate, with the exception of\n * `getSourceFile` and `fileExists` which are implemented in `NgCompilerHost`.\n *\n * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n * generated for this class.\n */\nexport class DelegatingCompilerHost implements\n    Omit<RequiredDelegations<ExtendedTsCompilerHost>, 'getSourceFile'|'fileExists'> {\n  createHash;\n  directoryExists;\n  fileNameToModuleName;\n  getCancellationToken;\n  getCanonicalFileName;\n  getCurrentDirectory;\n  getDefaultLibFileName;\n  getDefaultLibLocation;\n  getDirectories;\n  getEnvironmentVariable;\n  getModifiedResourceFiles;\n  getNewLine;\n  getParsedCommandLine;\n  getSourceFileByPath;\n  readDirectory;\n  readFile;\n  readResource;\n  transformResource;\n  realpath;\n  resolveModuleNames;\n  resolveTypeReferenceDirectives;\n  resourceNameToFileName;\n  trace;\n  useCaseSensitiveFileNames;\n  writeFile;\n  getModuleResolutionCache;\n  hasInvalidatedResolutions;\n  resolveModuleNameLiterals;\n  resolveTypeReferenceDirectiveReferences;\n\n  constructor(protected delegate: ExtendedTsCompilerHost) {\n    // Excluded are 'getSourceFile' and 'fileExists', which are actually implemented by\n    // NgCompilerHost\n    // below.\n    this.createHash = this.delegateMethod('createHash');\n    this.directoryExists = this.delegateMethod('directoryExists');\n    this.fileNameToModuleName = this.delegateMethod('fileNameToModuleName');\n    this.getCancellationToken = this.delegateMethod('getCancellationToken');\n    this.getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n    this.getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n    this.getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n    this.getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n    this.getDirectories = this.delegateMethod('getDirectories');\n    this.getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n    this.getModifiedResourceFiles = this.delegateMethod('getModifiedResourceFiles');\n    this.getNewLine = this.delegateMethod('getNewLine');\n    this.getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n    this.getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n    this.readDirectory = this.delegateMethod('readDirectory');\n    this.readFile = this.delegateMethod('readFile');\n    this.readResource = this.delegateMethod('readResource');\n    this.transformResource = this.delegateMethod('transformResource');\n    this.realpath = this.delegateMethod('realpath');\n    this.resolveModuleNames = this.delegateMethod('resolveModuleNames');\n    this.resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n    this.resourceNameToFileName = this.delegateMethod('resourceNameToFileName');\n    this.trace = this.delegateMethod('trace');\n    this.useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n    this.writeFile = this.delegateMethod('writeFile');\n    this.getModuleResolutionCache = this.delegateMethod('getModuleResolutionCache');\n    this.hasInvalidatedResolutions = this.delegateMethod('hasInvalidatedResolutions');\n    // The following methods are required in TS 5.0+, but they don't exist in earlier versions.\n    // TODO(crisbeto): remove the `ts-ignore` when dropping support for TypeScript 4.9.\n    // @ts-ignore\n    this.resolveModuleNameLiterals = this.delegateMethod('resolveModuleNameLiterals');\n    this.resolveTypeReferenceDirectiveReferences =\n        // @ts-ignore\n        this.delegateMethod('resolveTypeReferenceDirectiveReferences');\n  }\n\n  private delegateMethod<M extends keyof ExtendedTsCompilerHost>(name: M):\n      ExtendedTsCompilerHost[M] {\n    return this.delegate[name] !== undefined ? (this.delegate[name] as any).bind(this.delegate) :\n                                               undefined;\n  }\n}\n\n/**\n * A wrapper around `ts.CompilerHost` (plus any extension methods from `ExtendedTsCompilerHost`).\n *\n * In order for a consumer to include Angular compilation in their TypeScript compiler, the\n * `ts.Program` must be created with a host that adds Angular-specific files (e.g.\n * the template type-checking file, etc) to the compilation. `NgCompilerHost` is the\n * host implementation which supports this.\n *\n * The interface implementations here ensure that `NgCompilerHost` fully delegates to\n * `ExtendedTsCompilerHost` methods whenever present.\n */\nexport class NgCompilerHost extends DelegatingCompilerHost implements\n    RequiredDelegations<ExtendedTsCompilerHost>, ExtendedTsCompilerHost, NgCompilerAdapter {\n  readonly entryPoint: AbsoluteFsPath|null = null;\n  readonly constructionDiagnostics: ts.Diagnostic[];\n\n  readonly inputFiles: ReadonlyArray<string>;\n  readonly rootDirs: ReadonlyArray<AbsoluteFsPath>;\n\n\n  constructor(\n      delegate: ExtendedTsCompilerHost, inputFiles: ReadonlyArray<string>,\n      rootDirs: ReadonlyArray<AbsoluteFsPath>, private shimAdapter: ShimAdapter,\n      private shimTagger: ShimReferenceTagger, entryPoint: AbsoluteFsPath|null,\n      diagnostics: ts.Diagnostic[]) {\n    super(delegate);\n\n    this.entryPoint = entryPoint;\n    this.constructionDiagnostics = diagnostics;\n    this.inputFiles = [...inputFiles, ...shimAdapter.extraInputFiles];\n    this.rootDirs = rootDirs;\n\n    if (this.resolveModuleNames === undefined) {\n      // In order to reuse the module resolution cache during the creation of the type-check\n      // program, we'll need to provide `resolveModuleNames` if the delegate did not provide one.\n      this.resolveModuleNames = this.createCachedResolveModuleNamesFunction();\n    }\n  }\n\n  /**\n   * Retrieves a set of `ts.SourceFile`s which should not be emitted as JS files.\n   *\n   * Available after this host is used to create a `ts.Program` (which causes all the files in the\n   * program to be enumerated).\n   */\n  get ignoreForEmit(): Set<ts.SourceFile> {\n    return this.shimAdapter.ignoreForEmit;\n  }\n\n  /**\n   * Retrieve the array of shim extension prefixes for which shims were created for each original\n   * file.\n   */\n  get shimExtensionPrefixes(): string[] {\n    return this.shimAdapter.extensionPrefixes;\n  }\n\n  /**\n   * Performs cleanup that needs to happen after a `ts.Program` has been created using this host.\n   */\n  postProgramCreationCleanup(): void {\n    this.shimTagger.finalize();\n  }\n\n  /**\n   * Create an `NgCompilerHost` from a delegate host, an array of input filenames, and the full set\n   * of TypeScript and Angular compiler options.\n   */\n  static wrap(\n      delegate: ts.CompilerHost, inputFiles: ReadonlyArray<string>, options: NgCompilerOptions,\n      oldProgram: ts.Program|null): NgCompilerHost {\n    const topLevelShimGenerators: TopLevelShimGenerator[] = [];\n    const perFileShimGenerators: PerFileShimGenerator[] = [];\n\n    const rootDirs = getRootDirs(delegate, options as ts.CompilerOptions);\n\n    perFileShimGenerators.push(new TypeCheckShimGenerator());\n\n    let diagnostics: ts.Diagnostic[] = [];\n\n    const normalizedTsInputFiles: AbsoluteFsPath[] = [];\n    for (const inputFile of inputFiles) {\n      if (!isNonDeclarationTsPath(inputFile)) {\n        continue;\n      }\n      normalizedTsInputFiles.push(resolve(inputFile));\n    }\n\n    let entryPoint: AbsoluteFsPath|null = null;\n    if (options.flatModuleOutFile != null && options.flatModuleOutFile !== '') {\n      entryPoint = findFlatIndexEntryPoint(normalizedTsInputFiles);\n      if (entryPoint === null) {\n        // This error message talks specifically about having a single .ts file in \"files\". However\n        // the actual logic is a bit more permissive. If a single file exists, that will be taken,\n        // otherwise the highest level (shortest path) \"index.ts\" file will be used as the flat\n        // module entry point instead. If neither of these conditions apply, the error below is\n        // given.\n        //\n        // The user is not informed about the \"index.ts\" option as this behavior is deprecated -\n        // an explicit entrypoint should always be specified.\n        diagnostics.push({\n          category: ts.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.CONFIG_FLAT_MODULE_NO_INDEX),\n          file: undefined,\n          start: undefined,\n          length: undefined,\n          messageText:\n              'Angular compiler option \"flatModuleOutFile\" requires one and only one .ts file in the \"files\" field.',\n        });\n      } else {\n        const flatModuleId = options.flatModuleId || null;\n        const flatModuleOutFile = normalizeSeparators(options.flatModuleOutFile);\n        const flatIndexGenerator =\n            new FlatIndexGenerator(entryPoint, flatModuleOutFile, flatModuleId);\n        topLevelShimGenerators.push(flatIndexGenerator);\n      }\n    }\n\n    const shimAdapter = new ShimAdapter(\n        delegate, normalizedTsInputFiles, topLevelShimGenerators, perFileShimGenerators,\n        oldProgram);\n    const shimTagger =\n        new ShimReferenceTagger(perFileShimGenerators.map(gen => gen.extensionPrefix));\n    return new NgCompilerHost(\n        delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, diagnostics);\n  }\n\n  /**\n   * Check whether the given `ts.SourceFile` is a shim file.\n   *\n   * If this returns false, the file is user-provided.\n   */\n  isShim(sf: ts.SourceFile): boolean {\n    return isShim(sf);\n  }\n\n  /**\n   * Check whether the given `ts.SourceFile` is a resource file.\n   *\n   * This simply returns `false` for the compiler-cli since resource files are not added as root\n   * files to the project.\n   */\n  isResource(sf: ts.SourceFile): boolean {\n    return false;\n  }\n\n  getSourceFile(\n      fileName: string, languageVersion: ts.ScriptTarget,\n      onError?: ((message: string) => void)|undefined,\n      shouldCreateNewSourceFile?: boolean|undefined): ts.SourceFile|undefined {\n    // Is this a previously known shim?\n    const shimSf = this.shimAdapter.maybeGenerate(resolve(fileName));\n    if (shimSf !== null) {\n      // Yes, so return it.\n      return shimSf;\n    }\n\n    // No, so it's a file which might need shims (or a file which doesn't exist).\n    const sf =\n        this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    if (sf === undefined) {\n      return undefined;\n    }\n\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n\n  fileExists(fileName: string): boolean {\n    // Consider the file as existing whenever\n    //  1) it really does exist in the delegate host, or\n    //  2) at least one of the shim generators recognizes it\n    // Note that we can pass the file name as branded absolute fs path because TypeScript\n    // internally only passes POSIX-like paths.\n    //\n    // Also note that the `maybeGenerate` check below checks for both `null` and `undefined`.\n    return this.delegate.fileExists(fileName) ||\n        this.shimAdapter.maybeGenerate(resolve(fileName)) != null;\n  }\n\n  get unifiedModulesHost(): UnifiedModulesHost|null {\n    return this.fileNameToModuleName !== undefined ? this as UnifiedModulesHost : null;\n  }\n\n  private createCachedResolveModuleNamesFunction(): ts.CompilerHost['resolveModuleNames'] {\n    const moduleResolutionCache = ts.createModuleResolutionCache(\n        this.getCurrentDirectory(), this.getCanonicalFileName.bind(this));\n\n    return (moduleNames, containingFile, reusedNames, redirectedReference, options) => {\n      return moduleNames.map(moduleName => {\n        const module = ts.resolveModuleName(\n            moduleName, containingFile, options, this, moduleResolutionCache, redirectedReference);\n        return module.resolvedModule;\n      });\n    };\n  }\n}\n", "\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgtscProgram} from '../ngtsc/program';\n\nimport {CompilerHost, CompilerOptions, Program} from './api';\n\nexport function createProgram({rootNames, options, host, oldProgram}: {\n  rootNames: ReadonlyArray<string>,\n  options: CompilerOptions,\n  host: CompilerHost,\n  oldProgram?: Program\n}): Program {\n  return new NgtscProgram(rootNames, options, host, oldProgram as NgtscProgram | undefined);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {absoluteFrom, AbsoluteFsPath, FileSystem, getFileSystem, ReadonlyFileSystem, relative, resolve} from '../src/ngtsc/file_system';\n\nimport {NgCompilerOptions} from './ngtsc/core/api';\nimport {replaceTsWithNgInErrors} from './ngtsc/diagnostics';\nimport * as api from './transformers/api';\nimport * as ng from './transformers/entry_points';\nimport {createMessageDiagnostic} from './transformers/util';\n\nconst defaultFormatHost: ts.FormatDiagnosticsHost = {\n  getCurrentDirectory: () => ts.sys.getCurrentDirectory(),\n  getCanonicalFileName: fileName => fileName,\n  getNewLine: () => ts.sys.newLine\n};\n\nexport function formatDiagnostics(\n    diags: ReadonlyArray<ts.Diagnostic>,\n    host: ts.FormatDiagnosticsHost = defaultFormatHost): string {\n  if (diags && diags.length) {\n    return diags\n        .map(\n            diagnostic => replaceTsWithNgInErrors(\n                ts.formatDiagnosticsWithColorAndContext([diagnostic], host)))\n        .join('');\n  } else {\n    return '';\n  }\n}\n\n/** Used to read configuration files. */\nexport type ConfigurationHost = Pick<\n    ReadonlyFileSystem, 'readFile'|'exists'|'lstat'|'resolve'|'join'|'dirname'|'extname'|'pwd'>;\n\nexport interface ParsedConfiguration {\n  project: string;\n  options: api.CompilerOptions;\n  rootNames: string[];\n  projectReferences?: readonly ts.ProjectReference[]|undefined;\n  emitFlags: api.EmitFlags;\n  errors: ts.Diagnostic[];\n}\n\nexport function calcProjectFileAndBasePath(\n    project: string, host: ConfigurationHost = getFileSystem()):\n    {projectFile: AbsoluteFsPath, basePath: AbsoluteFsPath} {\n  const absProject = host.resolve(project);\n  const projectIsDir = host.lstat(absProject).isDirectory();\n  const projectFile = projectIsDir ? host.join(absProject, 'tsconfig.json') : absProject;\n  const projectDir = projectIsDir ? absProject : host.dirname(absProject);\n  const basePath = host.resolve(projectDir);\n\n  return {projectFile, basePath};\n}\n\nexport function readConfiguration(\n    project: string, existingOptions?: api.CompilerOptions,\n    host: ConfigurationHost = getFileSystem()): ParsedConfiguration {\n  try {\n    const fs = getFileSystem();\n\n    const readConfigFile = (configFile: string) =>\n        ts.readConfigFile(configFile, file => host.readFile(host.resolve(file)));\n    const readAngularCompilerOptions =\n        (configFile: string, parentOptions: NgCompilerOptions = {}): NgCompilerOptions => {\n          const {config, error} = readConfigFile(configFile);\n\n          if (error) {\n            // Errors are handled later on by 'parseJsonConfigFileContent'\n            return parentOptions;\n          }\n\n          // we are only interested into merging 'angularCompilerOptions' as\n          // other options like 'compilerOptions' are merged by TS\n          let existingNgCompilerOptions = {...config.angularCompilerOptions, ...parentOptions};\n          if (!config.extends) {\n            return existingNgCompilerOptions;\n          }\n\n          const extendsPaths: string[] =\n              typeof config.extends === 'string' ? [config.extends] : config.extends;\n\n          // Call readAngularCompilerOptions recursively to merge NG Compiler options\n          // Reverse the array so the overrides happen from right to left.\n          return [...extendsPaths].reverse().reduce((prevOptions, extendsPath) => {\n            const extendedConfigPath = getExtendedConfigPath(\n                configFile,\n                extendsPath,\n                host,\n                fs,\n            );\n\n            return extendedConfigPath === null ?\n                prevOptions :\n                readAngularCompilerOptions(extendedConfigPath, prevOptions);\n          }, existingNgCompilerOptions);\n        };\n\n    const {projectFile, basePath} = calcProjectFileAndBasePath(project, host);\n    const configFileName = host.resolve(host.pwd(), projectFile);\n    const {config, error} = readConfigFile(projectFile);\n\n    if (error) {\n      return {\n        project,\n        errors: [error],\n        rootNames: [],\n        options: {},\n        emitFlags: api.EmitFlags.Default\n      };\n    }\n\n    const existingCompilerOptions: api.CompilerOptions = {\n      genDir: basePath,\n      basePath,\n      ...readAngularCompilerOptions(configFileName),\n      ...existingOptions,\n    };\n\n    const parseConfigHost = createParseConfigHost(host, fs);\n    const {options, errors, fileNames: rootNames, projectReferences} =\n        ts.parseJsonConfigFileContent(\n            config, parseConfigHost, basePath, existingCompilerOptions, configFileName);\n\n    let emitFlags = api.EmitFlags.Default;\n    if (!(options.skipMetadataEmit || options.flatModuleOutFile)) {\n      emitFlags |= api.EmitFlags.Metadata;\n    }\n    if (options.skipTemplateCodegen) {\n      emitFlags = emitFlags & ~api.EmitFlags.Codegen;\n    }\n    return {project: projectFile, rootNames, projectReferences, options, errors, emitFlags};\n  } catch (e) {\n    const errors: ts.Diagnostic[] = [{\n      category: ts.DiagnosticCategory.Error,\n      messageText: (e as Error).stack ?? (e as Error).message,\n      file: undefined,\n      start: undefined,\n      length: undefined,\n      source: 'angular',\n      code: api.UNKNOWN_ERROR_CODE,\n    }];\n    return {project: '', errors, rootNames: [], options: {}, emitFlags: api.EmitFlags.Default};\n  }\n}\n\nfunction createParseConfigHost(host: ConfigurationHost, fs = getFileSystem()): ts.ParseConfigHost {\n  return {\n    fileExists: host.exists.bind(host),\n    readDirectory: ts.sys.readDirectory,\n    readFile: host.readFile.bind(host),\n    useCaseSensitiveFileNames: fs.isCaseSensitive(),\n  };\n}\n\nfunction getExtendedConfigPath(\n    configFile: string, extendsValue: string, host: ConfigurationHost,\n    fs: FileSystem): AbsoluteFsPath|null {\n  const result = getExtendedConfigPathWorker(configFile, extendsValue, host, fs);\n  if (result !== null) {\n    return result;\n  }\n\n  // Try to resolve the paths with a json extension append a json extension to the file in case if\n  // it is missing and the resolution failed. This is to replicate TypeScript behaviour, see:\n  // https://github.com/microsoft/TypeScript/blob/294a5a7d784a5a95a8048ee990400979a6bc3a1c/src/compiler/commandLineParser.ts#L2806\n  return getExtendedConfigPathWorker(configFile, `${extendsValue}.json`, host, fs);\n}\n\nfunction getExtendedConfigPathWorker(\n    configFile: string, extendsValue: string, host: ConfigurationHost,\n    fs: FileSystem): AbsoluteFsPath|null {\n  if (extendsValue.startsWith('.') || fs.isRooted(extendsValue)) {\n    const extendedConfigPath = host.resolve(host.dirname(configFile), extendsValue);\n    if (host.exists(extendedConfigPath)) {\n      return extendedConfigPath;\n    }\n  } else {\n    const parseConfigHost = createParseConfigHost(host, fs);\n\n    // Path isn't a rooted or relative path, resolve like a module.\n    const {\n      resolvedModule,\n    } =\n        ts.nodeModuleNameResolver(\n            extendsValue, configFile,\n            // TODO(crisbeto): the `moduleResolution` should be ts.ModuleResolutionKind.Node10, but\n            // it is temporarily hardcoded to the raw value while we're on TS 4.9 internally where\n            // the key is called `NodeJs`. The hardcoded value should be removed once the internal\n            // monorepo is on TS 5.0.\n            {moduleResolution: 2, resolveJsonModule: true}, parseConfigHost);\n    if (resolvedModule) {\n      return absoluteFrom(resolvedModule.resolvedFileName);\n    }\n  }\n\n  return null;\n}\n\nexport interface PerformCompilationResult {\n  diagnostics: ReadonlyArray<ts.Diagnostic>;\n  program?: api.Program;\n  emitResult?: ts.EmitResult;\n}\n\nexport function exitCodeFromResult(diags: ReadonlyArray<ts.Diagnostic>|undefined): number {\n  if (!diags) return 0;\n  if (diags.every((diag) => diag.category !== ts.DiagnosticCategory.Error)) {\n    // If we have a result and didn't get any errors, we succeeded.\n    return 0;\n  }\n\n  // Return 2 if any of the errors were unknown.\n  return diags.some(d => d.source === 'angular' && d.code === api.UNKNOWN_ERROR_CODE) ? 2 : 1;\n}\n\nexport function performCompilation<CbEmitRes extends ts.EmitResult = ts.EmitResult>({\n  rootNames,\n  options,\n  host,\n  oldProgram,\n  emitCallback,\n  mergeEmitResultsCallback,\n  gatherDiagnostics = defaultGatherDiagnostics,\n  customTransformers,\n  emitFlags = api.EmitFlags.Default,\n  forceEmit = false,\n  modifiedResourceFiles = null\n}: {\n  rootNames: string[],\n  options: api.CompilerOptions,\n  host?: api.CompilerHost,\n  oldProgram?: api.Program,\n  emitCallback?: api.TsEmitCallback<CbEmitRes>,\n  mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback<CbEmitRes>,\n  gatherDiagnostics?: (program: api.Program) => ReadonlyArray<ts.Diagnostic>,\n  customTransformers?: api.CustomTransformers,\n  emitFlags?: api.EmitFlags,\n  forceEmit?: boolean,\n  modifiedResourceFiles?: Set<string>| null,\n}): PerformCompilationResult {\n  let program: api.Program|undefined;\n  let emitResult: ts.EmitResult|undefined;\n  let allDiagnostics: Array<ts.Diagnostic> = [];\n  try {\n    if (!host) {\n      host = ng.createCompilerHost({options});\n    }\n    if (modifiedResourceFiles) {\n      host.getModifiedResourceFiles = () => modifiedResourceFiles;\n    }\n\n    program = ng.createProgram({rootNames, host, options, oldProgram});\n\n    const beforeDiags = Date.now();\n    allDiagnostics.push(...gatherDiagnostics(program!));\n    if (options.diagnostics) {\n      const afterDiags = Date.now();\n      allDiagnostics.push(\n          createMessageDiagnostic(`Time for diagnostics: ${afterDiags - beforeDiags}ms.`));\n    }\n\n    if (!hasErrors(allDiagnostics)) {\n      emitResult = program!.emit(\n          {emitCallback, mergeEmitResultsCallback, customTransformers, emitFlags, forceEmit});\n      allDiagnostics.push(...emitResult.diagnostics);\n      return {diagnostics: allDiagnostics, program, emitResult};\n    }\n    return {diagnostics: allDiagnostics, program};\n  } catch (e) {\n    // We might have a program with unknown state, discard it.\n    program = undefined;\n    allDiagnostics.push({\n      category: ts.DiagnosticCategory.Error,\n      messageText: (e as Error).stack ?? (e as Error).message,\n      code: api.UNKNOWN_ERROR_CODE,\n      file: undefined,\n      start: undefined,\n      length: undefined,\n    });\n    return {diagnostics: allDiagnostics, program};\n  }\n}\nexport function defaultGatherDiagnostics(program: api.Program): ReadonlyArray<ts.Diagnostic> {\n  const allDiagnostics: Array<ts.Diagnostic> = [];\n\n  function checkDiagnostics(diags: ReadonlyArray<ts.Diagnostic>|undefined) {\n    if (diags) {\n      allDiagnostics.push(...diags);\n      return !hasErrors(diags);\n    }\n    return true;\n  }\n\n  let checkOtherDiagnostics = true;\n  // Check parameter diagnostics\n  checkOtherDiagnostics = checkOtherDiagnostics &&\n      checkDiagnostics([...program.getTsOptionDiagnostics(), ...program.getNgOptionDiagnostics()]);\n\n  // Check syntactic diagnostics\n  checkOtherDiagnostics =\n      checkOtherDiagnostics && checkDiagnostics(program.getTsSyntacticDiagnostics());\n\n  // Check TypeScript semantic and Angular structure diagnostics\n  checkOtherDiagnostics =\n      checkOtherDiagnostics &&\n      checkDiagnostics(\n          [...program.getTsSemanticDiagnostics(), ...program.getNgStructuralDiagnostics()]);\n\n  // Check Angular semantic diagnostics\n  checkOtherDiagnostics =\n      checkOtherDiagnostics && checkDiagnostics(program.getNgSemanticDiagnostics());\n\n  return allDiagnostics;\n}\n\nfunction hasErrors(diags: ReadonlyArray<ts.Diagnostic>) {\n  return diags.some(d => d.category === ts.DiagnosticCategory.Error);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {DEFAULT_ERROR_CODE, SOURCE} from './api';\n\n\nexport function error(msg: string): never {\n  throw new Error(`Internal error: ${msg}`);\n}\n\nexport function createMessageDiagnostic(messageText: string): ts.Diagnostic {\n  return {\n    file: undefined,\n    start: undefined,\n    length: undefined,\n    category: ts.DiagnosticCategory.Message,\n    messageText,\n    code: DEFAULT_ERROR_CODE,\n    source: SOURCE,\n  };\n}\n\n/**\n * Strip multiline comment start and end markers from the `commentText` string.\n *\n * This will also strip the JSDOC comment start marker (`/**`).\n */\nexport function stripComment(commentText: string): string {\n  return commentText.replace(/^\\/\\*\\*?/, '').replace(/\\*\\/$/, '').trim();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {isAliasImportDeclaration, loadIsReferencedAliasDeclarationPatch} from '../../ngtsc/imports';\nimport {Decorator, ReflectionHost} from '../../ngtsc/reflection';\n\n/**\n * Whether a given decorator should be treated as an Angular decorator.\n * Either it's used in @angular/core, or it's imported from there.\n */\nfunction isAngularDecorator(decorator: Decorator, isCore: boolean): boolean {\n  return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');\n}\n\n/*\n #####################################################################\n  Code below has been extracted from the tsickle decorator downlevel transformer\n  and a few local modifications have been applied:\n\n    1. Tsickle by default processed all decorators that had the `@Annotation` JSDoc.\n       We modified the transform to only be concerned with known Angular decorators.\n    2. Tsickle by default added `@nocollapse` to all generated `ctorParameters` properties.\n       We only do this when `annotateForClosureCompiler` is enabled.\n    3. Tsickle does not handle union types for dependency injection. i.e. if a injected type\n       is denoted with `@Optional`, the actual type could be set to `T | null`.\n       See: https://github.com/angular/angular-cli/commit/826803d0736b807867caff9f8903e508970ad5e4.\n    4. Tsickle relied on `emitDecoratorMetadata` to be set to `true`. This is due to a limitation\n       in TypeScript transformers that never has been fixed. We were able to work around this\n       limitation so that `emitDecoratorMetadata` doesn't need to be specified.\n       See: `patchAliasReferenceResolution` for more details.\n\n  Here is a link to the tsickle revision on which this transformer is based:\n  https://github.com/angular/tsickle/blob/fae06becb1570f491806060d83f29f2d50c43cdd/src/decorator_downlevel_transformer.ts\n #####################################################################\n*/\n\nconst DECORATOR_INVOCATION_JSDOC_TYPE = '!Array<{type: !Function, args: (undefined|!Array<?>)}>';\n\n/**\n * Extracts the type of the decorator (the function or expression invoked), as well as all the\n * arguments passed to the decorator. Returns an AST with the form:\n *\n *     // For @decorator(arg1, arg2)\n *     { type: decorator, args: [arg1, arg2] }\n */\nfunction extractMetadataFromSingleDecorator(\n    decorator: ts.Decorator, diagnostics: ts.Diagnostic[]): ts.ObjectLiteralExpression {\n  const metadataProperties: ts.ObjectLiteralElementLike[] = [];\n  const expr = decorator.expression;\n  switch (expr.kind) {\n    case ts.SyntaxKind.Identifier:\n      // The decorator was a plain @Foo.\n      metadataProperties.push(ts.factory.createPropertyAssignment('type', expr));\n      break;\n    case ts.SyntaxKind.CallExpression:\n      // The decorator was a call, like @Foo(bar).\n      const call = expr as ts.CallExpression;\n      metadataProperties.push(ts.factory.createPropertyAssignment('type', call.expression));\n      if (call.arguments.length) {\n        const args: ts.Expression[] = [];\n        for (const arg of call.arguments) {\n          args.push(arg);\n        }\n        const argsArrayLiteral =\n            ts.factory.createArrayLiteralExpression(ts.factory.createNodeArray(args, true));\n        metadataProperties.push(ts.factory.createPropertyAssignment('args', argsArrayLiteral));\n      }\n      break;\n    default:\n      diagnostics.push({\n        file: decorator.getSourceFile(),\n        start: decorator.getStart(),\n        length: decorator.getEnd() - decorator.getStart(),\n        messageText:\n            `${ts.SyntaxKind[decorator.kind]} not implemented in gathering decorator metadata.`,\n        category: ts.DiagnosticCategory.Error,\n        code: 0,\n      });\n      break;\n  }\n  return ts.factory.createObjectLiteralExpression(metadataProperties);\n}\n\n/**\n * createCtorParametersClassProperty creates a static 'ctorParameters' property containing\n * downleveled decorator information.\n *\n * The property contains an arrow function that returns an array of object literals of the shape:\n *     static ctorParameters = () => [{\n *       type: SomeClass|undefined,  // the type of the param that's decorated, if it's a value.\n *       decorators: [{\n *         type: DecoratorFn,  // the type of the decorator that's invoked.\n *         args: [ARGS],       // the arguments passed to the decorator.\n *       }]\n *     }];\n */\nfunction createCtorParametersClassProperty(\n    diagnostics: ts.Diagnostic[],\n    entityNameToExpression: (n: ts.EntityName) => ts.Expression | undefined,\n    ctorParameters: ParameterDecorationInfo[],\n    isClosureCompilerEnabled: boolean): ts.PropertyDeclaration {\n  const params: ts.Expression[] = [];\n\n  for (const ctorParam of ctorParameters) {\n    if (!ctorParam.type && ctorParam.decorators.length === 0) {\n      params.push(ts.factory.createNull());\n      continue;\n    }\n\n    const paramType = ctorParam.type ?\n        typeReferenceToExpression(entityNameToExpression, ctorParam.type) :\n        undefined;\n    const members = [ts.factory.createPropertyAssignment(\n        'type', paramType || ts.factory.createIdentifier('undefined'))];\n\n    const decorators: ts.ObjectLiteralExpression[] = [];\n    for (const deco of ctorParam.decorators) {\n      decorators.push(extractMetadataFromSingleDecorator(deco, diagnostics));\n    }\n    if (decorators.length) {\n      members.push(ts.factory.createPropertyAssignment(\n          'decorators', ts.factory.createArrayLiteralExpression(decorators)));\n    }\n    params.push(ts.factory.createObjectLiteralExpression(members));\n  }\n\n  const initializer = ts.factory.createArrowFunction(\n      undefined, undefined, [], undefined,\n      ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      ts.factory.createArrayLiteralExpression(params, true));\n  const ctorProp = ts.factory.createPropertyDeclaration(\n      [ts.factory.createToken(ts.SyntaxKind.StaticKeyword)], 'ctorParameters', undefined, undefined,\n      initializer);\n  if (isClosureCompilerEnabled) {\n    ts.setSyntheticLeadingComments(ctorProp, [\n      {\n        kind: ts.SyntaxKind.MultiLineCommentTrivia,\n        text: [\n          `*`,\n          ` * @type {function(): !Array<(null|{`,\n          ` *   type: ?,`,\n          ` *   decorators: (undefined|${DECORATOR_INVOCATION_JSDOC_TYPE}),`,\n          ` * })>}`,\n          ` * @nocollapse`,\n          ` `,\n        ].join('\\n'),\n        pos: -1,\n        end: -1,\n        hasTrailingNewLine: true,\n      },\n    ]);\n  }\n  return ctorProp;\n}\n\n/**\n * Returns an expression representing the (potentially) value part for the given node.\n *\n * This is a partial re-implementation of TypeScript's serializeTypeReferenceNode. This is a\n * workaround for https://github.com/Microsoft/TypeScript/issues/17516 (serializeTypeReferenceNode\n * not being exposed). In practice this implementation is sufficient for Angular's use of type\n * metadata.\n */\nfunction typeReferenceToExpression(\n    entityNameToExpression: (n: ts.EntityName) => ts.Expression | undefined,\n    node: ts.TypeNode): ts.Expression|undefined {\n  let kind = node.kind;\n  if (ts.isLiteralTypeNode(node)) {\n    // Treat literal types like their base type (boolean, string, number).\n    kind = node.literal.kind;\n  }\n  switch (kind) {\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.ConstructorType:\n      return ts.factory.createIdentifier('Function');\n    case ts.SyntaxKind.ArrayType:\n    case ts.SyntaxKind.TupleType:\n      return ts.factory.createIdentifier('Array');\n    case ts.SyntaxKind.TypePredicate:\n    case ts.SyntaxKind.TrueKeyword:\n    case ts.SyntaxKind.FalseKeyword:\n    case ts.SyntaxKind.BooleanKeyword:\n      return ts.factory.createIdentifier('Boolean');\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.StringKeyword:\n      return ts.factory.createIdentifier('String');\n    case ts.SyntaxKind.ObjectKeyword:\n      return ts.factory.createIdentifier('Object');\n    case ts.SyntaxKind.NumberKeyword:\n    case ts.SyntaxKind.NumericLiteral:\n      return ts.factory.createIdentifier('Number');\n    case ts.SyntaxKind.TypeReference:\n      const typeRef = node as ts.TypeReferenceNode;\n      // Ignore any generic types, just return the base type.\n      return entityNameToExpression(typeRef.typeName);\n    case ts.SyntaxKind.UnionType:\n      const childTypeNodes =\n          (node as ts.UnionTypeNode)\n              .types.filter(\n                  t => !(ts.isLiteralTypeNode(t) && t.literal.kind === ts.SyntaxKind.NullKeyword));\n      return childTypeNodes.length === 1 ?\n          typeReferenceToExpression(entityNameToExpression, childTypeNodes[0]) :\n          undefined;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Checks whether a given symbol refers to a value that exists at runtime (as distinct from a type).\n *\n * Expands aliases, which is important for the case where\n *   import * as x from 'some-module';\n * and x is now a value (the module object).\n */\nfunction symbolIsRuntimeValue(typeChecker: ts.TypeChecker, symbol: ts.Symbol): boolean {\n  if (symbol.flags & ts.SymbolFlags.Alias) {\n    symbol = typeChecker.getAliasedSymbol(symbol);\n  }\n\n  // Note that const enums are a special case, because\n  // while they have a value, they don't exist at runtime.\n  return (symbol.flags & ts.SymbolFlags.Value & ts.SymbolFlags.ConstEnumExcludes) !== 0;\n}\n\n/** ParameterDecorationInfo describes the information for a single constructor parameter. */\ninterface ParameterDecorationInfo {\n  /**\n   * The type declaration for the parameter. Only set if the type is a value (e.g. a class, not an\n   * interface).\n   */\n  type: ts.TypeNode|null;\n  /** The list of decorators found on the parameter, null if none. */\n  decorators: ts.Decorator[];\n}\n\n/**\n * Gets a transformer for downleveling Angular constructor parameter and property decorators.\n *\n * Note that Angular class decorators are never processed as those rely on side effects that\n * would otherwise no longer be executed. i.e. the creation of a component definition.\n *\n * @param typeChecker Reference to the program's type checker.\n * @param host Reflection host that is used for determining decorators.\n * @param diagnostics List which will be populated with diagnostics if any.\n * @param isCore Whether the current TypeScript program is for the `@angular/core` package.\n * @param isClosureCompilerEnabled Whether closure annotations need to be added where needed.\n */\nexport function getDownlevelDecoratorsTransform(\n    typeChecker: ts.TypeChecker, host: ReflectionHost, diagnostics: ts.Diagnostic[],\n    isCore: boolean, isClosureCompilerEnabled: boolean): ts.TransformerFactory<ts.SourceFile> {\n  function addJSDocTypeAnnotation(node: ts.Node, jsdocType: string): void {\n    if (!isClosureCompilerEnabled) {\n      return;\n    }\n\n    ts.setSyntheticLeadingComments(node, [\n      {\n        kind: ts.SyntaxKind.MultiLineCommentTrivia,\n        text: `* @type {${jsdocType}} `,\n        pos: -1,\n        end: -1,\n        hasTrailingNewLine: true,\n      },\n    ]);\n  }\n\n  /**\n   * createPropDecoratorsClassProperty creates a static 'propDecorators'\n   * property containing type information for every property that has a\n   * decorator applied.\n   *\n   *     static propDecorators: {[key: string]: {type: Function, args?:\n   * any[]}[]} = { propA: [{type: MyDecorator, args: [1, 2]}, ...],\n   *       ...\n   *     };\n   */\n  function createPropDecoratorsClassProperty(\n      diagnostics: ts.Diagnostic[],\n      properties: Map<string, ts.Decorator[]>): ts.PropertyDeclaration {\n    //  `static propDecorators: {[key: string]: ` + {type: Function, args?:\n    //  any[]}[] + `} = {\\n`);\n    const entries: ts.ObjectLiteralElementLike[] = [];\n    for (const [name, decorators] of properties.entries()) {\n      entries.push(ts.factory.createPropertyAssignment(\n          name,\n          ts.factory.createArrayLiteralExpression(\n              decorators.map(deco => extractMetadataFromSingleDecorator(deco, diagnostics)))));\n    }\n    const initializer = ts.factory.createObjectLiteralExpression(entries, true);\n    const prop = ts.factory.createPropertyDeclaration(\n        [ts.factory.createToken(ts.SyntaxKind.StaticKeyword)], 'propDecorators', undefined,\n        undefined, initializer);\n    addJSDocTypeAnnotation(prop, `!Object<string, ${DECORATOR_INVOCATION_JSDOC_TYPE}>`);\n    return prop;\n  }\n\n  return (context: ts.TransformationContext) => {\n    // Ensure that referenced type symbols are not elided by TypeScript. Imports for\n    // such parameter type symbols previously could be type-only, but now might be also\n    // used in the `ctorParameters` static property as a value. We want to make sure\n    // that TypeScript does not elide imports for such type references. Read more\n    // about this in the description for `loadIsReferencedAliasDeclarationPatch`.\n    const referencedParameterTypes = loadIsReferencedAliasDeclarationPatch(context);\n\n    /**\n     * Converts an EntityName (from a type annotation) to an expression (accessing a value).\n     *\n     * For a given qualified name, this walks depth first to find the leftmost identifier,\n     * and then converts the path into a property access that can be used as expression.\n     */\n    function entityNameToExpression(name: ts.EntityName): ts.Expression|undefined {\n      const symbol = typeChecker.getSymbolAtLocation(name);\n      // Check if the entity name references a symbol that is an actual value. If it is not, it\n      // cannot be referenced by an expression, so return undefined.\n      if (!symbol || !symbolIsRuntimeValue(typeChecker, symbol) || !symbol.declarations ||\n          symbol.declarations.length === 0) {\n        return undefined;\n      }\n      // If we deal with a qualified name, build up a property access expression\n      // that could be used in the JavaScript output.\n      if (ts.isQualifiedName(name)) {\n        const containerExpr = entityNameToExpression(name.left);\n        if (containerExpr === undefined) {\n          return undefined;\n        }\n        return ts.factory.createPropertyAccessExpression(containerExpr, name.right);\n      }\n      const decl = symbol.declarations[0];\n      // If the given entity name has been resolved to an alias import declaration,\n      // ensure that the alias declaration is not elided by TypeScript, and use its\n      // name identifier to reference it at runtime.\n      if (isAliasImportDeclaration(decl)) {\n        referencedParameterTypes.add(decl);\n        // If the entity name resolves to an alias import declaration, we reference the\n        // entity based on the alias import name. This ensures that TypeScript properly\n        // resolves the link to the import. Cloning the original entity name identifier\n        // could lead to an incorrect resolution at local scope. e.g. Consider the following\n        // snippet: `constructor(Dep: Dep) {}`. In such a case, the local `Dep` identifier\n        // would resolve to the actual parameter name, and not to the desired import.\n        // This happens because the entity name identifier symbol is internally considered\n        // as type-only and therefore TypeScript tries to resolve it as value manually.\n        // We can help TypeScript and avoid this non-reliable resolution by using an identifier\n        // that is not type-only and is directly linked to the import alias declaration.\n        if (decl.name !== undefined) {\n          return ts.setOriginalNode(ts.factory.createIdentifier(decl.name.text), decl.name);\n        }\n      }\n      // Clone the original entity name identifier so that it can be used to reference\n      // its value at runtime. This is used when the identifier is resolving to a file\n      // local declaration (otherwise it would resolve to an alias import declaration).\n      return ts.setOriginalNode(ts.factory.createIdentifier(name.text), name);\n    }\n\n    /**\n     * Transforms a class element. Returns a three tuple of name, transformed element, and\n     * decorators found. Returns an undefined name if there are no decorators to lower on the\n     * element, or the element has an exotic name.\n     */\n    function transformClassElement(element: ts.ClassElement):\n        [string|undefined, ts.ClassElement, ts.Decorator[]] {\n      element = ts.visitEachChild(element, decoratorDownlevelVisitor, context);\n      const decoratorsToKeep: ts.Decorator[] = [];\n      const toLower: ts.Decorator[] = [];\n      const decorators = host.getDecoratorsOfDeclaration(element) || [];\n      for (const decorator of decorators) {\n        // We only deal with concrete nodes in TypeScript sources, so we don't\n        // need to handle synthetically created decorators.\n        const decoratorNode = decorator.node! as ts.Decorator;\n        if (!isAngularDecorator(decorator, isCore)) {\n          decoratorsToKeep.push(decoratorNode);\n          continue;\n        }\n        toLower.push(decoratorNode);\n      }\n      if (!toLower.length) return [undefined, element, []];\n\n      if (!element.name || !ts.isIdentifier(element.name)) {\n        // Method has a weird name, e.g.\n        //   [Symbol.foo]() {...}\n        diagnostics.push({\n          file: element.getSourceFile(),\n          start: element.getStart(),\n          length: element.getEnd() - element.getStart(),\n          messageText: `Cannot process decorators for class element with non-analyzable name.`,\n          category: ts.DiagnosticCategory.Error,\n          code: 0,\n        });\n        return [undefined, element, []];\n      }\n\n      const elementModifiers = ts.canHaveModifiers(element) ? ts.getModifiers(element) : undefined;\n      let modifiers: ts.NodeArray<ts.ModifierLike>|undefined;\n\n      if (decoratorsToKeep.length || elementModifiers?.length) {\n        modifiers = ts.setTextRange(\n            ts.factory.createNodeArray([...decoratorsToKeep, ...(elementModifiers || [])]),\n            (element as ts.HasModifiers).modifiers);\n      }\n\n      return [element.name.text, cloneClassElementWithModifiers(element, modifiers), toLower];\n    }\n\n    /**\n     * Transforms a constructor. Returns the transformed constructor and the list of parameter\n     * information collected, consisting of decorators and optional type.\n     */\n    function transformConstructor(ctor: ts.ConstructorDeclaration):\n        [ts.ConstructorDeclaration, ParameterDecorationInfo[]] {\n      ctor = ts.visitEachChild(ctor, decoratorDownlevelVisitor, context);\n\n      const newParameters: ts.ParameterDeclaration[] = [];\n      const oldParameters = ctor.parameters;\n      const parametersInfo: ParameterDecorationInfo[] = [];\n\n      for (const param of oldParameters) {\n        const decoratorsToKeep: ts.Decorator[] = [];\n        const paramInfo: ParameterDecorationInfo = {decorators: [], type: null};\n        const decorators = host.getDecoratorsOfDeclaration(param) || [];\n\n        for (const decorator of decorators) {\n          // We only deal with concrete nodes in TypeScript sources, so we don't\n          // need to handle synthetically created decorators.\n          const decoratorNode = decorator.node! as ts.Decorator;\n          if (!isAngularDecorator(decorator, isCore)) {\n            decoratorsToKeep.push(decoratorNode);\n            continue;\n          }\n          paramInfo!.decorators.push(decoratorNode);\n        }\n        if (param.type) {\n          // param has a type provided, e.g. \"foo: Bar\".\n          // The type will be emitted as a value expression in entityNameToExpression, which takes\n          // care not to emit anything for types that cannot be expressed as a value (e.g.\n          // interfaces).\n          paramInfo!.type = param.type;\n        }\n        parametersInfo.push(paramInfo);\n\n        // Must pass 'undefined' to avoid emitting decorator metadata.\n        let modifiers: ts.ModifierLike[]|undefined;\n        const paramModifiers = ts.getModifiers(param);\n\n        if (decoratorsToKeep.length || paramModifiers?.length) {\n          modifiers = [...decoratorsToKeep, ...(paramModifiers || [])];\n        }\n\n        const newParam = ts.factory.updateParameterDeclaration(\n            param, modifiers, param.dotDotDotToken, param.name, param.questionToken, param.type,\n            param.initializer);\n        newParameters.push(newParam);\n      }\n      const updated = ts.factory.updateConstructorDeclaration(\n          ctor, ts.getModifiers(ctor), newParameters, ctor.body);\n      return [updated, parametersInfo];\n    }\n\n    /**\n     * Transforms a single class declaration:\n     * - dispatches to strip decorators on members\n     * - converts decorators on the class to annotations\n     * - creates a ctorParameters property\n     * - creates a propDecorators property\n     */\n    function transformClassDeclaration(classDecl: ts.ClassDeclaration): ts.ClassDeclaration {\n      const newMembers: ts.ClassElement[] = [];\n      const decoratedProperties = new Map<string, ts.Decorator[]>();\n      let classParameters: ParameterDecorationInfo[]|null = null;\n\n      for (const member of classDecl.members) {\n        switch (member.kind) {\n          case ts.SyntaxKind.PropertyDeclaration:\n          case ts.SyntaxKind.GetAccessor:\n          case ts.SyntaxKind.SetAccessor:\n          case ts.SyntaxKind.MethodDeclaration: {\n            const [name, newMember, decorators] = transformClassElement(member);\n            newMembers.push(newMember);\n            if (name) decoratedProperties.set(name, decorators);\n            continue;\n          }\n          case ts.SyntaxKind.Constructor: {\n            const ctor = member as ts.ConstructorDeclaration;\n            if (!ctor.body) break;\n            const [newMember, parametersInfo] =\n                transformConstructor(member as ts.ConstructorDeclaration);\n            classParameters = parametersInfo;\n            newMembers.push(newMember);\n            continue;\n          }\n          default:\n            break;\n        }\n        newMembers.push(ts.visitEachChild(member, decoratorDownlevelVisitor, context));\n      }\n\n      // Note: The `ReflectionHost.getDecoratorsOfDeclaration()` method will not\n      // return all decorators, but only ones that could be possible Angular decorators.\n      const possibleAngularDecorators = host.getDecoratorsOfDeclaration(classDecl) || [];\n\n      // Keep track if we come across an Angular class decorator. This is used\n      // to determine whether constructor parameters should be captured or not.\n      const hasAngularDecorator =\n          possibleAngularDecorators.some(d => isAngularDecorator(d, isCore));\n\n      if (classParameters) {\n        if (hasAngularDecorator || classParameters.some(p => !!p.decorators.length)) {\n          // Capture constructor parameters if the class has Angular decorator applied,\n          // or if any of the parameters has decorators applied directly.\n          newMembers.push(createCtorParametersClassProperty(\n              diagnostics, entityNameToExpression, classParameters, isClosureCompilerEnabled));\n        }\n      }\n      if (decoratedProperties.size) {\n        newMembers.push(createPropDecoratorsClassProperty(diagnostics, decoratedProperties));\n      }\n\n      const members = ts.setTextRange(\n          ts.factory.createNodeArray(newMembers, classDecl.members.hasTrailingComma),\n          classDecl.members);\n\n      return ts.factory.updateClassDeclaration(\n          classDecl, classDecl.modifiers, classDecl.name, classDecl.typeParameters,\n          classDecl.heritageClauses, members);\n    }\n\n    /**\n     * Transformer visitor that looks for Angular decorators and replaces them with\n     * downleveled static properties. Also collects constructor type metadata for\n     * class declaration that are decorated with an Angular decorator.\n     */\n    function decoratorDownlevelVisitor(node: ts.Node): ts.Node {\n      if (ts.isClassDeclaration(node)) {\n        return transformClassDeclaration(node);\n      }\n      return ts.visitEachChild(node, decoratorDownlevelVisitor, context);\n    }\n\n    return (sf: ts.SourceFile) => {\n      // Downlevel decorators and constructor parameter types. We will keep track of all\n      // referenced constructor parameter types so that we can instruct TypeScript to\n      // not elide their imports if they previously were only type-only.\n      return ts.visitEachChild(sf, decoratorDownlevelVisitor, context);\n    };\n  };\n}\n\nfunction cloneClassElementWithModifiers(\n    node: ts.ClassElement, modifiers: readonly ts.ModifierLike[]|undefined): ts.ClassElement {\n  let clone: ts.ClassElement;\n\n  if (ts.isMethodDeclaration(node)) {\n    clone = ts.factory.createMethodDeclaration(\n        modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters,\n        node.parameters, node.type, node.body);\n  } else if (ts.isPropertyDeclaration(node)) {\n    clone = ts.factory.createPropertyDeclaration(\n        modifiers, node.name, node.questionToken, node.type, node.initializer);\n  } else if (ts.isGetAccessor(node)) {\n    clone = ts.factory.createGetAccessorDeclaration(\n        modifiers, node.name, node.parameters, node.type, node.body);\n  } else if (ts.isSetAccessor(node)) {\n    clone =\n        ts.factory.createSetAccessorDeclaration(modifiers, node.name, node.parameters, node.body);\n  } else {\n    throw new Error(`Unsupported decorated member with kind ${ts.SyntaxKind[node.kind]}`);\n  }\n\n  return ts.setOriginalNode(clone, node);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * This file is used as a private API channel to shared Angular FW APIs with @angular/cli.\n *\n * Any changes to this file should be discussed with the Angular CLI team.\n */\n\nimport ts from 'typescript';\n\nimport {TypeScriptReflectionHost} from '../src/ngtsc/reflection';\nimport {getDownlevelDecoratorsTransform} from '../src/transformers/downlevel_decorators_transform/index';\n\n/**\n * Known values for global variables in `@angular/core` that Terser should set using\n * https://github.com/terser-js/terser#conditional-compilation\n */\nexport const GLOBAL_DEFS_FOR_TERSER = {\n  ngDevMode: false,\n  ngI18nClosureMode: false,\n};\n\nexport const GLOBAL_DEFS_FOR_TERSER_WITH_AOT = {\n  ...GLOBAL_DEFS_FOR_TERSER,\n  ngJitMode: false,\n};\n\n/**\n * Transform for downleveling Angular decorators and Angular-decorated class constructor\n * parameters for dependency injection. This transform can be used by the CLI for JIT-mode\n * compilation where constructor parameters and associated Angular decorators should be\n * downleveled so that apps are not exposed to the ES2015 temporal dead zone limitation\n * in TypeScript. See https://github.com/angular/angular-cli/pull/14473 for more details.\n */\nexport function constructorParametersDownlevelTransform(program: ts.Program):\n    ts.TransformerFactory<ts.SourceFile> {\n  const typeChecker = program.getTypeChecker();\n  const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n  return getDownlevelDecoratorsTransform(\n      typeChecker, reflectionHost, [], /* isCore */ false,\n      /* enableClosureCompiler */ false);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Implement this interface if you want to provide different logging\n * output from the standard ConsoleLogger.\n */\nexport interface Logger {\n  level: LogLevel;\n  debug(...args: string[]): void;\n  info(...args: string[]): void;\n  warn(...args: string[]): void;\n  error(...args: string[]): void;\n}\n\nexport enum LogLevel {\n  debug,\n  info,\n  warn,\n  error,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Logger, LogLevel} from './logger';\n\nconst RESET = '\\x1b[0m';\nconst RED = '\\x1b[31m';\nconst YELLOW = '\\x1b[33m';\nconst BLUE = '\\x1b[36m';\n\nexport const DEBUG = `${BLUE}Debug:${RESET}`;\nexport const WARN = `${YELLOW}Warning:${RESET}`;\nexport const ERROR = `${RED}Error:${RESET}`;\n\n/**\n * A simple logger that outputs directly to the Console.\n *\n * The log messages can be filtered based on severity via the `logLevel`\n * constructor parameter.\n */\nexport class ConsoleLogger implements Logger {\n  constructor(public level: LogLevel) {}\n  debug(...args: string[]) {\n    if (this.level <= LogLevel.debug) console.debug(DEBUG, ...args);\n  }\n  info(...args: string[]) {\n    if (this.level <= LogLevel.info) console.info(...args);\n  }\n  warn(...args: string[]) {\n    if (this.level <= LogLevel.warn) console.warn(WARN, ...args);\n  }\n  error(...args: string[]) {\n    if (this.level <= LogLevel.error) console.error(ERROR, ...args);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {NodeJSFileSystem, setFileSystem} from './src/ngtsc/file_system';\n\nexport {VERSION} from './src/version';\n\nexport * from './src/transformers/api';\nexport * from './src/transformers/entry_points';\n\nexport * from './src/perform_compile';\n\n// TODO(tbosch): remove this once usages in G3 are changed to `CompilerOptions`\nexport {CompilerOptions as AngularCompilerOptions} from './src/transformers/api';\n\n// Internal exports needed for packages relying on the compiler-cli.\n// TODO: Remove this when the CLI has switched to the private entry-point.\nexport * from './private/tooling';\n\n// Exposed as they are needed for relying on the `linker`.\nexport * from './src/ngtsc/logging';\nexport * from './src/ngtsc/file_system';\n\n// Exports for dealing with the `ngtsc` program.\nexport {NgTscPlugin, PluginCompilerHost} from './src/ngtsc/tsc_plugin';\nexport {NgtscProgram} from './src/ngtsc/program';\nexport {OptimizeFor} from './src/ngtsc/typecheck/api';\n\n// **Note**: Explicit named exports to make this file work with CJS/ESM interop without\n// needing to use a default import. NodeJS will expose named CJS exports as named ESM exports.\n// TODO(devversion): Remove these duplicate exports once devmode&prodmode is combined/ESM.\nexport {ConsoleLogger, Logger, LogLevel} from './src/ngtsc/logging';\nexport {NodeJSFileSystem} from './src/ngtsc/file_system';\n\nsetFileSystem(new NodeJSFileSystem());\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ImportManager} from './import_manager';\n\n/** Function that can be used to remap a generated import. */\nexport type ImportRemapper = (moduleName: string, inFile: string) => string;\n\n/** Mapping between a source file and the changes that have to be applied to it. */\nexport type ChangesByFile = ReadonlyMap<ts.SourceFile, PendingChange[]>;\n\n/** Change that needs to be applied to a file. */\nexport interface PendingChange {\n  /** Index at which to start changing the file. */\n  start: number;\n  /**\n   * Amount of text that should be removed after the `start`.\n   * No text will be removed if omitted.\n   */\n  removeLength?: number;\n  /** New text that should be inserted. */\n  text: string;\n}\n\n/** Tracks changes that have to be made for specific files. */\nexport class ChangeTracker {\n  private readonly _changes = new Map<ts.SourceFile, PendingChange[]>();\n  private readonly _importManager: ImportManager;\n\n  constructor(private _printer: ts.Printer, private _importRemapper?: ImportRemapper) {\n    this._importManager = new ImportManager(\n        currentFile => ({\n          addNewImport: (start, text) => this.insertText(currentFile, start, text),\n          updateExistingImport: (namedBindings, text) => this.replaceText(\n              currentFile, namedBindings.getStart(), namedBindings.getWidth(), text),\n        }),\n        this._printer);\n  }\n\n  /**\n   * Tracks the insertion of some text.\n   * @param sourceFile File in which the text is being inserted.\n   * @param start Index at which the text is insert.\n   * @param text Text to be inserted.\n   */\n  insertText(sourceFile: ts.SourceFile, index: number, text: string): void {\n    this._trackChange(sourceFile, {start: index, text});\n  }\n\n  /**\n   * Replaces text within a file.\n   * @param sourceFile File in which to replace the text.\n   * @param start Index from which to replace the text.\n   * @param removeLength Length of the text being replaced.\n   * @param text Text to be inserted instead of the old one.\n   */\n  replaceText(sourceFile: ts.SourceFile, start: number, removeLength: number, text: string): void {\n    this._trackChange(sourceFile, {start, removeLength, text});\n  }\n\n  /**\n   * Replaces the text of an AST node with a new one.\n   * @param oldNode Node to be replaced.\n   * @param newNode New node to be inserted.\n   * @param emitHint Hint when formatting the text of the new node.\n   * @param sourceFileWhenPrinting File to use when printing out the new node. This is important\n   * when copying nodes from one file to another, because TypeScript might not output literal nodes\n   * without it.\n   */\n  replaceNode(\n      oldNode: ts.Node, newNode: ts.Node, emitHint = ts.EmitHint.Unspecified,\n      sourceFileWhenPrinting?: ts.SourceFile): void {\n    const sourceFile = oldNode.getSourceFile();\n    this.replaceText(\n        sourceFile, oldNode.getStart(), oldNode.getWidth(),\n        this._printer.printNode(emitHint, newNode, sourceFileWhenPrinting || sourceFile));\n  }\n\n  /**\n   * Removes the text of an AST node from a file.\n   * @param node Node whose text should be removed.\n   */\n  removeNode(node: ts.Node): void {\n    this._trackChange(\n        node.getSourceFile(), {start: node.getStart(), removeLength: node.getWidth(), text: ''});\n  }\n\n  /**\n   * Adds an import to a file.\n   * @param sourceFile File to which to add the import.\n   * @param symbolName Symbol being imported.\n   * @param moduleName Module from which the symbol is imported.\n   */\n  addImport(\n      sourceFile: ts.SourceFile, symbolName: string, moduleName: string,\n      alias: string|null = null): ts.Expression {\n    if (this._importRemapper) {\n      moduleName = this._importRemapper(moduleName, sourceFile.fileName);\n    }\n\n    // It's common for paths to be manipulated with Node's `path` utilties which\n    // can yield a path with back slashes. Normalize them since outputting such\n    // paths will also cause TS to escape the forward slashes.\n    moduleName = normalizePath(moduleName);\n\n    return this._importManager.addImportToSourceFile(sourceFile, symbolName, moduleName, alias);\n  }\n\n  /**\n   * Gets the changes that should be applied to all the files in the migration.\n   * The changes are sorted in the order in which they should be applied.\n   */\n  recordChanges(): ChangesByFile {\n    this._importManager.recordChanges();\n    return this._changes;\n  }\n\n  /**\n   * Adds a change to a `ChangesByFile` map.\n   * @param file File that the change is associated with.\n   * @param change Change to be added.\n   */\n  private _trackChange(file: ts.SourceFile, change: PendingChange): void {\n    const changes = this._changes.get(file);\n\n    if (changes) {\n      // Insert the changes in reverse so that they're applied in reverse order.\n      // This ensures that the offsets of subsequent changes aren't affected by\n      // previous changes changing the file's text.\n      const insertIndex = changes.findIndex(current => current.start <= change.start);\n\n      if (insertIndex === -1) {\n        changes.push(change);\n      } else {\n        changes.splice(insertIndex, 0, change);\n      }\n    } else {\n      this._changes.set(file, [change]);\n    }\n  }\n}\n\n/** Normalizes a path to use posix separators. */\nexport function normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {dirname, resolve} from 'path';\nimport ts from 'typescript';\n\n/** Update recorder for managing imports. */\nexport interface ImportManagerUpdateRecorder {\n  addNewImport(start: number, importText: string): void;\n  updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string): void;\n}\n\n/** Possible types of quotes for imports. */\nconst enum QuoteStyle {\n  Single,\n  Double,\n}\n\n/**\n * Import manager that can be used to add TypeScript imports to given source\n * files. The manager ensures that multiple transformations are applied properly\n * without shifted offsets and that similar existing import declarations are re-used.\n */\nexport class ImportManager {\n  /** Map of import declarations that need to be updated to include the given symbols. */\n  private updatedImports =\n      new Map<ts.ImportDeclaration, {propertyName?: ts.Identifier, importName: ts.Identifier}[]>();\n  /** Map of source-files and their previously used identifier names. */\n  private usedIdentifierNames = new Map<ts.SourceFile, string[]>();\n  /** Map of source files and the new imports that have to be added to them. */\n  private newImports: Map<ts.SourceFile, {\n    importStartIndex: number,\n    defaultImports: Map<string, ts.Identifier>,\n    namedImports: Map<string, ts.ImportSpecifier[]>,\n  }> = new Map();\n  /** Map between a file and the implied quote style for imports. */\n  private quoteStyles: Record<string, QuoteStyle> = {};\n\n  /**\n   * Array of previously resolved symbol imports. Cache can be re-used to return\n   * the same identifier without checking the source-file again.\n   */\n  private importCache: {\n    sourceFile: ts.SourceFile,\n    symbolName: string|null,\n    alias: string|null,\n    moduleName: string,\n    identifier: ts.Identifier\n  }[] = [];\n\n  constructor(\n      private getUpdateRecorder: (sf: ts.SourceFile) => ImportManagerUpdateRecorder,\n      private printer: ts.Printer) {}\n\n  /**\n   * Adds an import to the given source-file and returns the TypeScript\n   * identifier that can be used to access the newly imported symbol.\n   */\n  addImportToSourceFile(\n      sourceFile: ts.SourceFile, symbolName: string|null, moduleName: string,\n      alias: string|null = null, typeImport = false): ts.Expression {\n    const sourceDir = dirname(sourceFile.fileName);\n    let importStartIndex = 0;\n    let existingImport: ts.ImportDeclaration|null = null;\n\n    // In case the given import has been already generated previously, we just return\n    // the previous generated identifier in order to avoid duplicate generated imports.\n    const cachedImport = this.importCache.find(\n        c => c.sourceFile === sourceFile && c.symbolName === symbolName &&\n            c.moduleName === moduleName && c.alias === alias);\n    if (cachedImport) {\n      return cachedImport.identifier;\n    }\n\n    // Walk through all source-file top-level statements and search for import declarations\n    // that already match the specified \"moduleName\" and can be updated to import the\n    // given symbol. If no matching import can be found, the last import in the source-file\n    // will be used as starting point for a new import that will be generated.\n    for (let i = sourceFile.statements.length - 1; i >= 0; i--) {\n      const statement = sourceFile.statements[i];\n\n      if (!ts.isImportDeclaration(statement) || !ts.isStringLiteral(statement.moduleSpecifier) ||\n          !statement.importClause) {\n        continue;\n      }\n\n      if (importStartIndex === 0) {\n        importStartIndex = this._getEndPositionOfNode(statement);\n      }\n\n      const moduleSpecifier = statement.moduleSpecifier.text;\n\n      if (moduleSpecifier.startsWith('.') &&\n              resolve(sourceDir, moduleSpecifier) !== resolve(sourceDir, moduleName) ||\n          moduleSpecifier !== moduleName) {\n        continue;\n      }\n\n      if (statement.importClause.namedBindings) {\n        const namedBindings = statement.importClause.namedBindings;\n\n        // In case a \"Type\" symbol is imported, we can't use namespace imports\n        // because these only export symbols available at runtime (no types)\n        if (ts.isNamespaceImport(namedBindings) && !typeImport) {\n          return ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(namedBindings.name.text),\n              ts.factory.createIdentifier(alias || symbolName || 'default'));\n        } else if (ts.isNamedImports(namedBindings) && symbolName) {\n          const existingElement = namedBindings.elements.find(e => {\n            // TODO(crisbeto): if an alias conflicts with an existing import, it may cause invalid\n            // code to be generated. This is unlikely, but we may want to revisit it in the future.\n            if (alias) {\n              return e.propertyName && e.name.text === alias && e.propertyName.text === symbolName;\n            }\n            return e.propertyName ? e.propertyName.text === symbolName : e.name.text === symbolName;\n          });\n\n          if (existingElement) {\n            return ts.factory.createIdentifier(existingElement.name.text);\n          }\n\n          // In case the symbol could not be found in an existing import, we\n          // keep track of the import declaration as it can be updated to include\n          // the specified symbol name without having to create a new import.\n          existingImport = statement;\n        }\n      } else if (statement.importClause.name && !symbolName) {\n        return ts.factory.createIdentifier(statement.importClause.name.text);\n      }\n    }\n\n    if (existingImport) {\n      const {propertyName, name} = this._getImportParts(sourceFile, symbolName!, alias);\n\n      // Since it can happen that multiple classes need to be imported within the\n      // specified source file and we want to add the identifiers to the existing\n      // import declaration, we need to keep track of the updated import declarations.\n      // We can't directly update the import declaration for each identifier as this\n      // would throw off the recorder offsets. We need to keep track of the new identifiers\n      // for the import and perform the import transformation as batches per source-file.\n      this.updatedImports.set(\n          existingImport,\n          (this.updatedImports.get(existingImport) || []).concat({propertyName, importName: name}));\n\n      // Keep track of all updated imports so that we don't generate duplicate\n      // similar imports as these can't be statically analyzed in the source-file yet.\n      this.importCache.push({sourceFile, moduleName, symbolName, alias, identifier: name});\n\n      return name;\n    }\n\n    let identifier: ts.Identifier|null = null;\n\n    if (!this.newImports.has(sourceFile)) {\n      this.newImports.set(sourceFile, {\n        importStartIndex,\n        defaultImports: new Map(),\n        namedImports: new Map(),\n      });\n    }\n\n    if (symbolName) {\n      const {propertyName, name} = this._getImportParts(sourceFile, symbolName, alias);\n      const importMap = this.newImports.get(sourceFile)!.namedImports;\n      identifier = name;\n\n      if (!importMap.has(moduleName)) {\n        importMap.set(moduleName, []);\n      }\n\n      importMap.get(moduleName)!.push(ts.factory.createImportSpecifier(false, propertyName, name));\n    } else {\n      const importMap = this.newImports.get(sourceFile)!.defaultImports;\n      identifier = this._getUniqueIdentifier(sourceFile, 'defaultExport');\n      importMap.set(moduleName, identifier);\n    }\n\n    // Keep track of all generated imports so that we don't generate duplicate\n    // similar imports as these can't be statically analyzed in the source-file yet.\n    this.importCache.push({sourceFile, symbolName, moduleName, alias, identifier});\n\n    return identifier;\n  }\n\n  /**\n   * Stores the collected import changes within the appropriate update recorders. The\n   * updated imports can only be updated *once* per source-file because previous updates\n   * could otherwise shift the source-file offsets.\n   */\n  recordChanges() {\n    this.updatedImports.forEach((expressions, importDecl) => {\n      const sourceFile = importDecl.getSourceFile();\n      const recorder = this.getUpdateRecorder(sourceFile);\n      const namedBindings = importDecl.importClause!.namedBindings as ts.NamedImports;\n      const newNamedBindings = ts.factory.updateNamedImports(\n          namedBindings,\n          namedBindings.elements.concat(expressions.map(\n              ({propertyName, importName}) =>\n                  ts.factory.createImportSpecifier(false, propertyName, importName))));\n\n      const newNamedBindingsText =\n          this.printer.printNode(ts.EmitHint.Unspecified, newNamedBindings, sourceFile);\n      recorder.updateExistingImport(namedBindings, newNamedBindingsText);\n    });\n\n    this.newImports.forEach(({importStartIndex, defaultImports, namedImports}, sourceFile) => {\n      const recorder = this.getUpdateRecorder(sourceFile);\n      const useSingleQuotes = this._getQuoteStyle(sourceFile) === QuoteStyle.Single;\n\n      defaultImports.forEach((identifier, moduleName) => {\n        const newImport = ts.factory.createImportDeclaration(\n            undefined, ts.factory.createImportClause(false, identifier, undefined),\n            ts.factory.createStringLiteral(moduleName, useSingleQuotes));\n\n        recorder.addNewImport(\n            importStartIndex, this._getNewImportText(importStartIndex, newImport, sourceFile));\n      });\n\n      namedImports.forEach((specifiers, moduleName) => {\n        const newImport = ts.factory.createImportDeclaration(\n            undefined,\n            ts.factory.createImportClause(\n                false, undefined, ts.factory.createNamedImports(specifiers)),\n            ts.factory.createStringLiteral(moduleName, useSingleQuotes));\n\n        recorder.addNewImport(\n            importStartIndex, this._getNewImportText(importStartIndex, newImport, sourceFile));\n      });\n    });\n  }\n\n  /** Gets an unique identifier with a base name for the given source file. */\n  private _getUniqueIdentifier(sourceFile: ts.SourceFile, baseName: string): ts.Identifier {\n    if (this.isUniqueIdentifierName(sourceFile, baseName)) {\n      this._recordUsedIdentifier(sourceFile, baseName);\n      return ts.factory.createIdentifier(baseName);\n    }\n\n    let name = null;\n    let counter = 1;\n    do {\n      name = `${baseName}_${counter++}`;\n    } while (!this.isUniqueIdentifierName(sourceFile, name));\n\n    this._recordUsedIdentifier(sourceFile, name!);\n    return ts.factory.createIdentifier(name!);\n  }\n\n  /**\n   * Checks whether the specified identifier name is used within the given\n   * source file.\n   */\n  private isUniqueIdentifierName(sourceFile: ts.SourceFile, name: string) {\n    if (this.usedIdentifierNames.has(sourceFile) &&\n        this.usedIdentifierNames.get(sourceFile)!.indexOf(name) !== -1) {\n      return false;\n    }\n\n    // Walk through the source file and search for an identifier matching\n    // the given name. In that case, it's not guaranteed that this name\n    // is unique in the given declaration scope and we just return false.\n    const nodeQueue: ts.Node[] = [sourceFile];\n    while (nodeQueue.length) {\n      const node = nodeQueue.shift()!;\n      if (ts.isIdentifier(node) && node.text === name &&\n          // Identifiers that are aliased in an import aren't\n          // problematic since they're used under a different name.\n          (!ts.isImportSpecifier(node.parent) || node.parent.propertyName !== node)) {\n        return false;\n      }\n      nodeQueue.push(...node.getChildren());\n    }\n    return true;\n  }\n\n  private _recordUsedIdentifier(sourceFile: ts.SourceFile, identifierName: string) {\n    this.usedIdentifierNames.set(\n        sourceFile, (this.usedIdentifierNames.get(sourceFile) || []).concat(identifierName));\n  }\n\n  /**\n   * Determines the full end of a given node. By default the end position of a node is\n   * before all trailing comments. This could mean that generated imports shift comments.\n   */\n  private _getEndPositionOfNode(node: ts.Node) {\n    const nodeEndPos = node.getEnd();\n    const commentRanges = ts.getTrailingCommentRanges(node.getSourceFile().text, nodeEndPos);\n    if (!commentRanges || !commentRanges.length) {\n      return nodeEndPos;\n    }\n    return commentRanges[commentRanges.length - 1]!.end;\n  }\n\n  /** Gets the text that should be added to the file for a newly-created import declaration. */\n  private _getNewImportText(\n      importStartIndex: number, newImport: ts.ImportDeclaration,\n      sourceFile: ts.SourceFile): string {\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newImport, sourceFile);\n\n    // If the import is generated at the start of the source file, we want to add\n    // a new-line after the import. Otherwise if the import is generated after an\n    // existing import, we need to prepend a new-line so that the import is not on\n    // the same line as the existing import anchor\n    return importStartIndex === 0 ? `${text}\\n` : `\\n${text}`;\n  }\n\n  /**\n   * Gets the different parts necessary to construct an import specifier.\n   * @param sourceFile File in which the import is being inserted.\n   * @param symbolName Name of the symbol.\n   * @param alias Alias that the symbol may be available under.\n   * @returns Object containing the different parts. E.g. `{name: 'alias', propertyName: 'name'}`\n   * would correspond to `import {name as alias}` while `{name: 'name', propertyName: undefined}`\n   * corresponds to `import {name}`.\n   */\n  private _getImportParts(sourceFile: ts.SourceFile, symbolName: string, alias: string|null) {\n    const symbolIdentifier = ts.factory.createIdentifier(symbolName);\n    const aliasIdentifier = alias ? ts.factory.createIdentifier(alias) : null;\n    const generatedUniqueIdentifier = this._getUniqueIdentifier(sourceFile, alias || symbolName);\n    const needsGeneratedUniqueName = generatedUniqueIdentifier.text !== (alias || symbolName);\n    let propertyName: ts.Identifier|undefined;\n    let name: ts.Identifier;\n\n    if (needsGeneratedUniqueName) {\n      propertyName = symbolIdentifier;\n      name = generatedUniqueIdentifier;\n    } else if (aliasIdentifier) {\n      propertyName = symbolIdentifier;\n      name = aliasIdentifier;\n    } else {\n      name = symbolIdentifier;\n    }\n\n    return {propertyName, name};\n  }\n\n  /** Gets the quote style that is used for a file's imports. */\n  private _getQuoteStyle(sourceFile: ts.SourceFile): QuoteStyle {\n    if (!this.quoteStyles.hasOwnProperty(sourceFile.fileName)) {\n      let quoteStyle: QuoteStyle|undefined;\n\n      // Walk through the top-level imports and try to infer the quotes.\n      for (const statement of sourceFile.statements) {\n        if (ts.isImportDeclaration(statement) &&\n            ts.isStringLiteralLike(statement.moduleSpecifier)) {\n          // Use `getText` instead of the actual text since it includes the quotes.\n          quoteStyle = statement.moduleSpecifier.getText().trim().startsWith('\"') ?\n              QuoteStyle.Double :\n              QuoteStyle.Single;\n          break;\n        }\n      }\n\n      // Otherwise fall back to single quotes.\n      this.quoteStyles[sourceFile.fileName] = quoteStyle ?? QuoteStyle.Single;\n    }\n\n    return this.quoteStyles[sourceFile.fileName];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {json, normalize, virtualFs, workspaces} from '@angular-devkit/core';\nimport {Tree} from '@angular-devkit/schematics';\n\n/**\n * Gets all tsconfig paths from a CLI project by reading the workspace configuration\n * and looking for common tsconfig locations.\n */\nexport async function getProjectTsConfigPaths(tree: Tree):\n    Promise<{buildPaths: string[]; testPaths: string[];}> {\n  // Start with some tsconfig paths that are generally used within CLI projects. Note\n  // that we are not interested in IDE-specific tsconfig files (e.g. /tsconfig.json)\n  const buildPaths = new Set<string>();\n  const testPaths = new Set<string>();\n\n  const workspace = await getWorkspace(tree);\n  for (const [, project] of workspace.projects) {\n    for (const [name, target] of project.targets) {\n      if (name !== 'build' && name !== 'test') {\n        continue;\n      }\n\n      for (const [, options] of allTargetOptions(target)) {\n        const tsConfig = options.tsConfig;\n        // Filter out tsconfig files that don't exist in the CLI project.\n        if (typeof tsConfig !== 'string' || !tree.exists(tsConfig)) {\n          continue;\n        }\n\n        if (name === 'build') {\n          buildPaths.add(normalize(tsConfig));\n        } else {\n          testPaths.add(normalize(tsConfig));\n        }\n      }\n    }\n  }\n\n  return {\n    buildPaths: [...buildPaths],\n    testPaths: [...testPaths],\n  };\n}\n\n/** Get options for all configurations for the passed builder target. */\nfunction*\n    allTargetOptions(target: workspaces.TargetDefinition):\n        Iterable<[string | undefined, Record<string, json.JsonValue|undefined>]> {\n  if (target.options) {\n    yield [undefined, target.options];\n  }\n\n  if (!target.configurations) {\n    return;\n  }\n\n  for (const [name, options] of Object.entries(target.configurations)) {\n    if (options) {\n      yield [name, options];\n    }\n  }\n}\n\nfunction createHost(tree: Tree): workspaces.WorkspaceHost {\n  return {\n    async readFile(path: string): Promise<string> {\n      const data = tree.read(path);\n      if (!data) {\n        throw new Error('File not found.');\n      }\n\n      return virtualFs.fileBufferToString(data);\n    },\n    async writeFile(path: string, data: string): Promise<void> {\n      return tree.overwrite(path, data);\n    },\n    async isDirectory(path: string): Promise<boolean> {\n      // Approximate a directory check.\n      // We don't need to consider empty directories and hence this is a good enough approach.\n      // This is also per documentation, see:\n      // https://angular.io/guide/schematics-for-libraries#get-the-project-configuration\n      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;\n    },\n    async isFile(path: string): Promise<boolean> {\n      return tree.exists(path);\n    },\n  };\n}\n\nasync function getWorkspace(tree: Tree): Promise<workspaces.WorkspaceDefinition> {\n  const host = createHost(tree);\n  const {workspace} = await workspaces.readWorkspace('/', host);\n\n  return workspace;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Tree} from '@angular-devkit/schematics';\nimport {dirname, relative, resolve} from 'path';\nimport ts from 'typescript';\n\nimport {parseTsconfigFile} from './parse_tsconfig';\n\ntype FakeReadFileFn = (fileName: string) => string|undefined;\n\n/**\n * Creates a TypeScript program instance for a TypeScript project within\n * the virtual file system tree.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n */\nexport function createMigrationProgram(\n    tree: Tree, tsconfigPath: string, basePath: string, fakeFileRead?: FakeReadFileFn,\n    additionalFiles?: string[]) {\n  const {rootNames, options, host} =\n      createProgramOptions(tree, tsconfigPath, basePath, fakeFileRead, additionalFiles);\n  return ts.createProgram(rootNames, options, host);\n}\n\n/**\n * Creates the options necessary to instantiate a TypeScript program.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n * @param optionOverrides Overrides of the parsed compiler options.\n */\nexport function createProgramOptions(\n    tree: Tree, tsconfigPath: string, basePath: string, fakeFileRead?: FakeReadFileFn,\n    additionalFiles?: string[], optionOverrides?: ts.CompilerOptions) {\n  // Resolve the tsconfig path to an absolute path. This is needed as TypeScript otherwise\n  // is not able to resolve root directories in the given tsconfig. More details can be found\n  // in the following issue: https://github.com/microsoft/TypeScript/issues/37731.\n  tsconfigPath = resolve(basePath, tsconfigPath);\n  const parsed = parseTsconfigFile(tsconfigPath, dirname(tsconfigPath));\n  const options = optionOverrides ? {...parsed.options, ...optionOverrides} : parsed.options;\n  const host = createMigrationCompilerHost(tree, options, basePath, fakeFileRead);\n  return {rootNames: parsed.fileNames.concat(additionalFiles || []), options, host};\n}\n\nfunction createMigrationCompilerHost(\n    tree: Tree, options: ts.CompilerOptions, basePath: string,\n    fakeRead?: FakeReadFileFn): ts.CompilerHost {\n  const host = ts.createCompilerHost(options, true);\n  const defaultReadFile = host.readFile;\n\n  // We need to overwrite the host \"readFile\" method, as we want the TypeScript\n  // program to be based on the file contents in the virtual file tree. Otherwise\n  // if we run multiple migrations we might have intersecting changes and\n  // source files.\n  host.readFile = fileName => {\n    const treeRelativePath = relative(basePath, fileName);\n    let result: string|undefined = fakeRead?.(treeRelativePath);\n\n    if (typeof result !== 'string') {\n      // If the relative path resolved to somewhere outside of the tree, fall back to\n      // TypeScript's default file reading function since the `tree` will throw an error.\n      result = treeRelativePath.startsWith('..') ? defaultReadFile.call(host, fileName) :\n                                                   tree.read(treeRelativePath)?.toString();\n    }\n\n    // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset,\n    // which breaks the CLI UpdateRecorder.\n    // See: https://github.com/angular/angular/pull/30719\n    return typeof result === 'string' ? result.replace(/^\\uFEFF/, '') : undefined;\n  };\n\n  return host;\n}\n\n/**\n * Checks whether a file can be migrate by our automated migrations.\n * @param basePath Absolute path to the project.\n * @param sourceFile File being checked.\n * @param program Program that includes the source file.\n */\nexport function canMigrateFile(\n    basePath: string, sourceFile: ts.SourceFile, program: ts.Program): boolean {\n  // We shouldn't migrate .d.ts files, files from an external library or type checking files.\n  if (sourceFile.fileName.endsWith('.ngtypecheck.ts') || sourceFile.isDeclarationFile ||\n      program.isSourceFileFromExternalLibrary(sourceFile)) {\n    return false;\n  }\n\n  // Our migrations are set up to create a `Program` from the project's tsconfig and to migrate all\n  // the files within the program. This can include files that are outside of the Angular CLI\n  // project. We can't migrate files outside of the project, because our file system interactions\n  // go through the CLI's `Tree` which assumes that all files are within the project. See:\n  // https://github.com/angular/angular-cli/blob/0b0961c9c233a825b6e4bb59ab7f0790f9b14676/packages/angular_devkit/schematics/src/tree/host-tree.ts#L131\n  return !relative(basePath, sourceFile.fileName).startsWith('..');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport ts from 'typescript';\n\nexport function parseTsconfigFile(tsconfigPath: string, basePath: string): ts.ParsedCommandLine {\n  const {config} = ts.readConfigFile(tsconfigPath, ts.sys.readFile);\n  const parseConfigHost = {\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n    fileExists: ts.sys.fileExists,\n    readDirectory: ts.sys.readDirectory,\n    readFile: ts.sys.readFile,\n  };\n\n  // Throw if incorrect arguments are passed to this function. Passing relative base paths\n  // results in root directories not being resolved and in later type checking runtime errors.\n  // More details can be found here: https://github.com/microsoft/TypeScript/issues/37731.\n  if (!path.isAbsolute(basePath)) {\n    throw Error('Unexpected relative base path has been specified.');\n  }\n\n  return ts.parseJsonConfigFileContent(config, parseConfigHost, basePath, {});\n}\n", "/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgtscProgram} from '@angular/compiler-cli';\nimport ts from 'typescript';\n\nimport {ChangeTracker, ImportRemapper} from '../../utils/change_tracker';\nimport {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\nimport {closestNode} from '../../utils/typescript/nodes';\n\nimport {findClassDeclaration, findLiteralProperty, getNodeLookup, offsetsToNodes, ReferenceResolver, UniqueItemTracker} from './util';\n\n/** Keeps track of the places from which we need to remove AST nodes. */\ninterface RemovalLocations {\n  arrays: UniqueItemTracker<ts.ArrayLiteralExpression, ts.Node>;\n  imports: UniqueItemTracker<ts.NamedImports, ts.Node>;\n  exports: UniqueItemTracker<ts.NamedExports, ts.Node>;\n  unknown: Set<ts.Node>;\n}\n\nexport function pruneNgModules(\n    program: NgtscProgram, host: ts.CompilerHost, basePath: string, rootFileNames: string[],\n    sourceFiles: ts.SourceFile[], printer: ts.Printer, importRemapper?: ImportRemapper,\n    referenceLookupExcludedFiles?: RegExp) {\n  const filesToRemove = new Set<ts.SourceFile>();\n  const tracker = new ChangeTracker(printer, importRemapper);\n  const tsProgram = program.getTsProgram();\n  const typeChecker = tsProgram.getTypeChecker();\n  const referenceResolver =\n      new ReferenceResolver(program, host, rootFileNames, basePath, referenceLookupExcludedFiles);\n  const removalLocations: RemovalLocations = {\n    arrays: new UniqueItemTracker<ts.ArrayLiteralExpression, ts.Node>(),\n    imports: new UniqueItemTracker<ts.NamedImports, ts.Node>(),\n    exports: new UniqueItemTracker<ts.NamedExports, ts.Node>(),\n    unknown: new Set<ts.Node>()\n  };\n  const classesToRemove = new Set<ts.ClassDeclaration>();\n  const barrelExports = new UniqueItemTracker<ts.SourceFile, ts.ExportDeclaration>();\n  const nodesToRemove = new Set<ts.Node>();\n\n  sourceFiles.forEach(function walk(node: ts.Node) {\n    if (ts.isClassDeclaration(node) && canRemoveClass(node, typeChecker)) {\n      collectRemovalLocations(node, removalLocations, referenceResolver, program);\n      classesToRemove.add(node);\n    } else if (\n        ts.isExportDeclaration(node) && !node.exportClause && node.moduleSpecifier &&\n        ts.isStringLiteralLike(node.moduleSpecifier) && node.moduleSpecifier.text.startsWith('.')) {\n      const exportedSourceFile =\n          typeChecker.getSymbolAtLocation(node.moduleSpecifier)?.valueDeclaration?.getSourceFile();\n\n      if (exportedSourceFile) {\n        barrelExports.track(exportedSourceFile, node);\n      }\n    }\n    node.forEachChild(walk);\n  });\n\n  // We collect all the places where we need to remove references first before generating the\n  // removal instructions since we may have to remove multiple references from one node.\n  removeArrayReferences(removalLocations.arrays, tracker);\n  removeImportReferences(removalLocations.imports, tracker);\n  removeExportReferences(removalLocations.exports, tracker);\n  addRemovalTodos(removalLocations.unknown, tracker);\n\n  // Collect all the nodes to be removed before determining which files to delete since we need\n  // to know it ahead of time when deleting barrel files that export other barrel files.\n  (function trackNodesToRemove(nodes: Set<ts.Node>) {\n    for (const node of nodes) {\n      const sourceFile = node.getSourceFile();\n\n      if (!filesToRemove.has(sourceFile) && canRemoveFile(sourceFile, nodes)) {\n        const barrelExportsForFile = barrelExports.get(sourceFile);\n        nodesToRemove.add(node);\n        filesToRemove.add(sourceFile);\n        barrelExportsForFile && trackNodesToRemove(barrelExportsForFile);\n      } else {\n        nodesToRemove.add(node);\n      }\n    }\n  })(classesToRemove);\n\n  for (const node of nodesToRemove) {\n    const sourceFile = node.getSourceFile();\n\n    if (!filesToRemove.has(sourceFile) && canRemoveFile(sourceFile, nodesToRemove)) {\n      filesToRemove.add(sourceFile);\n    } else {\n      tracker.removeNode(node);\n    }\n  }\n\n  return {pendingChanges: tracker.recordChanges(), filesToRemove};\n}\n\n/**\n * Collects all the nodes that a module needs to be removed from.\n * @param ngModule Module being removed.\n * @param removalLocations\n * @param referenceResolver\n * @param program\n */\nfunction collectRemovalLocations(\n    ngModule: ts.ClassDeclaration, removalLocations: RemovalLocations,\n    referenceResolver: ReferenceResolver, program: NgtscProgram) {\n  const refsByFile = referenceResolver.findReferencesInProject(ngModule.name!);\n  const tsProgram = program.getTsProgram();\n  const nodes = new Set<ts.Node>();\n\n  for (const [fileName, refs] of refsByFile) {\n    const sourceFile = tsProgram.getSourceFile(fileName);\n\n    if (sourceFile) {\n      offsetsToNodes(getNodeLookup(sourceFile), refs, nodes);\n    }\n  }\n\n  for (const node of nodes) {\n    const closestArray = closestNode(node, ts.isArrayLiteralExpression);\n    if (closestArray) {\n      removalLocations.arrays.track(closestArray, node);\n      continue;\n    }\n\n    const closestImport = closestNode(node, ts.isNamedImports);\n    if (closestImport) {\n      removalLocations.imports.track(closestImport, node);\n      continue;\n    }\n\n    const closestExport = closestNode(node, ts.isNamedExports);\n    if (closestExport) {\n      removalLocations.exports.track(closestExport, node);\n      continue;\n    }\n\n    removalLocations.unknown.add(node);\n  }\n}\n\n/**\n * Removes all tracked array references.\n * @param locations Locations from which to remove the references.\n * @param tracker Tracker in which to register the changes.\n */\nfunction removeArrayReferences(\n    locations: UniqueItemTracker<ts.ArrayLiteralExpression, ts.Node>,\n    tracker: ChangeTracker): void {\n  for (const [array, toRemove] of locations.getEntries()) {\n    const newElements = filterRemovedElements(array.elements, toRemove);\n    tracker.replaceNode(\n        array,\n        ts.factory.updateArrayLiteralExpression(\n            array, ts.factory.createNodeArray(newElements, array.elements.hasTrailingComma)));\n  }\n}\n\n/**\n * Removes all tracked import references.\n * @param locations Locations from which to remove the references.\n * @param tracker Tracker in which to register the changes.\n */\nfunction removeImportReferences(\n    locations: UniqueItemTracker<ts.NamedImports, ts.Node>, tracker: ChangeTracker) {\n  for (const [namedImports, toRemove] of locations.getEntries()) {\n    const newElements = filterRemovedElements(namedImports.elements, toRemove);\n\n    // If no imports are left, we can try to drop the entire import.\n    if (newElements.length === 0) {\n      const importClause = closestNode(namedImports, ts.isImportClause);\n\n      // If the import clause has a name we can only drop then named imports.\n      // e.g. `import Foo, {ModuleToRemove} from './foo';` becomes `import Foo from './foo';`.\n      if (importClause && importClause.name) {\n        tracker.replaceNode(\n            importClause,\n            ts.factory.updateImportClause(\n                importClause, importClause.isTypeOnly, importClause.name, undefined));\n      } else {\n        // Otherwise we can drop the entire declaration.\n        const declaration = closestNode(namedImports, ts.isImportDeclaration);\n\n        if (declaration) {\n          tracker.removeNode(declaration);\n        }\n      }\n    } else {\n      // Otherwise we just drop the imported symbols and keep the declaration intact.\n      tracker.replaceNode(namedImports, ts.factory.updateNamedImports(namedImports, newElements));\n    }\n  }\n}\n\n/**\n * Removes all tracked export references.\n * @param locations Locations from which to remove the references.\n * @param tracker Tracker in which to register the changes.\n */\nfunction removeExportReferences(\n    locations: UniqueItemTracker<ts.NamedExports, ts.Node>, tracker: ChangeTracker) {\n  for (const [namedExports, toRemove] of locations.getEntries()) {\n    const newElements = filterRemovedElements(namedExports.elements, toRemove);\n\n    // If no exports are left, we can drop the entire declaration.\n    if (newElements.length === 0) {\n      const declaration = closestNode(namedExports, ts.isExportDeclaration);\n\n      if (declaration) {\n        tracker.removeNode(declaration);\n      }\n    } else {\n      // Otherwise we just drop the exported symbols and keep the declaration intact.\n      tracker.replaceNode(namedExports, ts.factory.updateNamedExports(namedExports, newElements));\n    }\n  }\n}\n\n/**\n * Determines whether an `@NgModule` class is safe to remove. A module is safe to remove if:\n * 1. It has no `declarations`.\n * 2. It has no `providers`.\n * 3. It has no `bootstrap` components.\n * 4. It has no `ModuleWithProviders` in its `imports`.\n * 5. It has no class members. Empty construstors are ignored.\n * @param node Class that is being checked.\n * @param typeChecker\n */\nfunction canRemoveClass(node: ts.ClassDeclaration, typeChecker: ts.TypeChecker): boolean {\n  const decorator = findNgModuleDecorator(node, typeChecker)?.node;\n\n  // We can't remove a declaration if it's not a valid `NgModule`.\n  if (!decorator || !ts.isCallExpression(decorator.expression)) {\n    return false;\n  }\n\n  // Unsupported case, e.g. `@NgModule(SOME_VALUE)`.\n  if (decorator.expression.arguments.length > 0 &&\n      !ts.isObjectLiteralExpression(decorator.expression.arguments[0])) {\n    return false;\n  }\n\n  // We can't remove modules that have class members. We make an exception for an\n  // empty constructor which may have been generated by a tool and forgotten.\n  if (node.members.length > 0 && node.members.some(member => !isEmptyConstructor(member))) {\n    return false;\n  }\n\n  // An empty `NgModule` call can be removed.\n  if (decorator.expression.arguments.length === 0) {\n    return true;\n  }\n\n  const literal = decorator.expression.arguments[0] as ts.ObjectLiteralExpression;\n  const imports = findLiteralProperty(literal, 'imports');\n\n  if (imports && isNonEmptyNgModuleProperty(imports)) {\n    // We can't remove the class if at least one import isn't identifier, because it may be a\n    // `ModuleWithProviders` which is the equivalent of having something in the `providers` array.\n    for (const dep of imports.initializer.elements) {\n      if (!ts.isIdentifier(dep)) {\n        return false;\n      }\n\n      const depDeclaration = findClassDeclaration(dep, typeChecker);\n      const depNgModule =\n          depDeclaration ? findNgModuleDecorator(depDeclaration, typeChecker) : null;\n\n      // If any of the dependencies of the class is an `NgModule` that can't be removed, the class\n      // itself can't be removed either, because it may be part of a transitive dependency chain.\n      if (depDeclaration !== null && depNgModule !== null &&\n          !canRemoveClass(depDeclaration, typeChecker)) {\n        return false;\n      }\n    }\n  }\n\n  // We can't remove classes that have any `declarations`, `providers` or `bootstrap` elements.\n  // Also err on the side of caution and don't remove modules where any of the aforementioned\n  // properties aren't initialized to an array literal.\n  for (const prop of literal.properties) {\n    if (isNonEmptyNgModuleProperty(prop) &&\n        (prop.name.text === 'declarations' || prop.name.text === 'providers' ||\n         prop.name.text === 'bootstrap')) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Checks whether a node is a non-empty property from an NgModule's metadata. This is defined as a\n * property assignment with a static name, initialized to an array literal with more than one\n * element.\n * @param node Node to be checked.\n */\nfunction isNonEmptyNgModuleProperty(node: ts.Node): node is ts.PropertyAssignment&\n    {name: ts.Identifier, initializer: ts.ArrayLiteralExpression} {\n  return ts.isPropertyAssignment(node) && ts.isIdentifier(node.name) &&\n      ts.isArrayLiteralExpression(node.initializer) && node.initializer.elements.length > 0;\n}\n\n/**\n * Determines if a file is safe to delete. A file is safe to delete if all it contains are\n * import statements, class declarations that are about to be deleted and non-exported code.\n * @param sourceFile File that is being checked.\n * @param nodesToBeRemoved Nodes that are being removed as a part of the migration.\n */\nfunction canRemoveFile(sourceFile: ts.SourceFile, nodesToBeRemoved: Set<ts.Node>) {\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) || nodesToBeRemoved.has(node)) {\n      continue;\n    }\n\n    if (ts.isExportDeclaration(node) ||\n        (ts.canHaveModifiers(node) &&\n         ts.getModifiers(node)?.some(m => m.kind === ts.SyntaxKind.ExportKeyword))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Gets whether an AST node contains another AST node.\n * @param parent Parent node that may contain the child.\n * @param child Child node that is being checked.\n */\nfunction contains(parent: ts.Node, child: ts.Node): boolean {\n  return parent === child ||\n      (parent.getSourceFile().fileName === child.getSourceFile().fileName &&\n       child.getStart() >= parent.getStart() && child.getStart() <= parent.getEnd());\n}\n\n/**\n * Removes AST nodes from a node array.\n * @param elements Array from which to remove the nodes.\n * @param toRemove Nodes that should be removed.\n */\nfunction filterRemovedElements<T extends ts.Node>(\n    elements: ts.NodeArray<T>, toRemove: Set<ts.Node>): T[] {\n  return elements.filter(el => {\n    for (const node of toRemove) {\n      // Check that the element contains the node, despite knowing with relative certainty that it\n      // does, because this allows us to unwrap some nodes. E.g. if we have `[((toRemove))]`, we\n      // want to remove the entire parenthesized expression, rather than just `toRemove`.\n      if (contains(el, node)) {\n        return false;\n      }\n    }\n    return true;\n  });\n}\n\n/** Returns whether a node as an empty constructor. */\nfunction isEmptyConstructor(node: ts.Node): boolean {\n  return ts.isConstructorDeclaration(node) && node.parameters.length === 0 &&\n      (node.body == null || node.body.statements.length === 0);\n}\n\n/**\n * Adds TODO comments to nodes that couldn't be removed manually.\n * @param nodes Nodes to which to add the TODO.\n * @param tracker Tracker in which to register the changes.\n */\nfunction addRemovalTodos(nodes: Set<ts.Node>, tracker: ChangeTracker) {\n  for (const node of nodes) {\n    // Note: the comment is inserted using string manipulation, instead of going through the AST,\n    // because this way we preserve more of the app's original formatting.\n    // Note: in theory this can duplicate comments if the module pruning runs multiple times on\n    // the same node. In practice it is unlikely, because the second time the node won't be picked\n    // up by the language service as a reference, because the class won't exist anymore.\n    tracker.insertText(\n        node.getSourceFile(), node.getFullStart(),\n        ` /* TODO(standalone-migration): clean up removed NgModule reference manually. */ `);\n  }\n}\n\n/** Finds the `NgModule` decorator in a class, if it exists. */\nfunction findNgModuleDecorator(node: ts.ClassDeclaration, typeChecker: ts.TypeChecker): NgDecorator|\n    null {\n  const decorators = getAngularDecorators(typeChecker, ts.getDecorators(node) || []);\n  return decorators.find(decorator => decorator.name === 'NgModule') || null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {getImportOfIdentifier, Import} from './imports';\n\nexport function getCallDecoratorImport(\n    typeChecker: ts.TypeChecker, decorator: ts.Decorator): Import|null {\n  // Note that this does not cover the edge case where decorators are called from\n  // a namespace import: e.g. \"@core.Component()\". This is not handled by Ngtsc either.\n  if (!ts.isCallExpression(decorator.expression) ||\n      !ts.isIdentifier(decorator.expression.expression)) {\n    return null;\n  }\n\n  const identifier = decorator.expression.expression;\n  return getImportOfIdentifier(typeChecker, identifier);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nexport type Import = {\n  name: string,\n  importModule: string,\n  node: ts.ImportDeclaration\n};\n\n/** Gets import information about the specified identifier by using the Type checker. */\nexport function getImportOfIdentifier(typeChecker: ts.TypeChecker, node: ts.Identifier): Import|\n    null {\n  const symbol = typeChecker.getSymbolAtLocation(node);\n\n  if (!symbol || symbol.declarations === undefined || !symbol.declarations.length) {\n    return null;\n  }\n\n  const decl = symbol.declarations[0];\n\n  if (!ts.isImportSpecifier(decl)) {\n    return null;\n  }\n\n  const importDecl = decl.parent.parent.parent;\n\n  if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n    return null;\n  }\n\n  return {\n    // Handles aliased imports: e.g. \"import {Component as myComp} from ...\";\n    name: decl.propertyName ? decl.propertyName.text : decl.name.text,\n    importModule: importDecl.moduleSpecifier.text,\n    node: importDecl\n  };\n}\n\n\n/**\n * Gets a top-level import specifier with a specific name that is imported from a particular module.\n * E.g. given a file that looks like:\n *\n * ```\n * import { Component, Directive } from '@angular/core';\n * import { Foo } from './foo';\n * ```\n *\n * Calling `getImportSpecifier(sourceFile, '@angular/core', 'Directive')` will yield the node\n * referring to `Directive` in the top import.\n *\n * @param sourceFile File in which to look for imports.\n * @param moduleName Name of the import's module.\n * @param specifierName Original name of the specifier to look for. Aliases will be resolved to\n *    their original name.\n */\nexport function getImportSpecifier(\n    sourceFile: ts.SourceFile, moduleName: string|RegExp,\n    specifierName: string): ts.ImportSpecifier|null {\n  return getImportSpecifiers(sourceFile, moduleName, [specifierName])[0] ?? null;\n}\n\nexport function getImportSpecifiers(\n    sourceFile: ts.SourceFile, moduleName: string|RegExp,\n    specifierNames: string[]): ts.ImportSpecifier[] {\n  const matches: ts.ImportSpecifier[] = [];\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const isMatch = typeof moduleName === 'string' ? node.moduleSpecifier.text === moduleName :\n                                                       moduleName.test(node.moduleSpecifier.text);\n      const namedBindings = node.importClause?.namedBindings;\n      if (isMatch && namedBindings && ts.isNamedImports(namedBindings)) {\n        for (const specifierName of specifierNames) {\n          const match = findImportSpecifier(namedBindings.elements, specifierName);\n          if (match) {\n            matches.push(match);\n          }\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n\n/**\n * Replaces an import inside a named imports node with a different one.\n *\n * @param node Node that contains the imports.\n * @param existingImport Import that should be replaced.\n * @param newImportName Import that should be inserted.\n */\nexport function replaceImport(\n    node: ts.NamedImports, existingImport: string, newImportName: string) {\n  const isAlreadyImported = findImportSpecifier(node.elements, newImportName);\n  if (isAlreadyImported) {\n    return node;\n  }\n\n  const existingImportNode = findImportSpecifier(node.elements, existingImport);\n  if (!existingImportNode) {\n    return node;\n  }\n\n  const importPropertyName =\n      existingImportNode.propertyName ? ts.factory.createIdentifier(newImportName) : undefined;\n  const importName = existingImportNode.propertyName ? existingImportNode.name :\n                                                       ts.factory.createIdentifier(newImportName);\n\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter(current => current !== existingImportNode),\n    // Create a new import while trying to preserve the alias of the old one.\n    ts.factory.createImportSpecifier(false, importPropertyName, importName)\n  ]);\n}\n\n/**\n * Removes a symbol from the named imports and updates a node\n * that represents a given named imports.\n *\n * @param node Node that contains the imports.\n * @param symbol Symbol that should be removed.\n * @returns An updated node (ts.NamedImports).\n */\nexport function removeSymbolFromNamedImports(node: ts.NamedImports, symbol: ts.ImportSpecifier) {\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter(current => current !== symbol),\n  ]);\n}\n\n/** Finds an import specifier with a particular name. */\nexport function findImportSpecifier(\n    nodes: ts.NodeArray<ts.ImportSpecifier>, specifierName: string): ts.ImportSpecifier|undefined {\n  return nodes.find(element => {\n    const {name, propertyName} = element;\n    return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {getCallDecoratorImport} from './typescript/decorators';\n\nexport type CallExpressionDecorator = ts.Decorator&{\n  expression: ts.CallExpression;\n};\n\nexport interface NgDecorator {\n  name: string;\n  moduleName: string;\n  node: CallExpressionDecorator;\n  importNode: ts.ImportDeclaration;\n}\n\n/**\n * Gets all decorators which are imported from an Angular package (e.g. \"@angular/core\")\n * from a list of decorators.\n */\nexport function getAngularDecorators(\n    typeChecker: ts.TypeChecker, decorators: ReadonlyArray<ts.Decorator>): NgDecorator[] {\n  return decorators.map(node => ({node, importData: getCallDecoratorImport(typeChecker, node)}))\n      .filter(({importData}) => importData && importData.importModule.startsWith('@angular/'))\n      .map(({node, importData}) => ({\n             node: node as CallExpressionDecorator,\n             name: importData!.name,\n             moduleName: importData!.importModule,\n             importNode: importData!.node\n           }));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n/** Checks whether the given TypeScript node has the specified modifier set. */\nexport function hasModifier(node: ts.Node, modifierKind: ts.SyntaxKind) {\n  return ts.canHaveModifiers(node) && !!node.modifiers &&\n      node.modifiers.some(m => m.kind === modifierKind);\n}\n\n/** Find the closest parent node of a particular kind. */\nexport function closestNode<T extends ts.Node>(node: ts.Node, predicate: (n: ts.Node) => n is T): T|\n    null {\n  let current = node.parent;\n\n  while (current && !ts.isSourceFile(current)) {\n    if (predicate(current)) {\n      return current;\n    }\n    current = current.parent;\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a particular node is part of a null check. E.g. given:\n * `foo.bar ? foo.bar.value : null` the null check would be `foo.bar`.\n */\nexport function isNullCheck(node: ts.Node): boolean {\n  if (!node.parent) {\n    return false;\n  }\n\n  // `foo.bar && foo.bar.value` where `node` is `foo.bar`.\n  if (ts.isBinaryExpression(node.parent) && node.parent.left === node) {\n    return true;\n  }\n\n  // `foo.bar && foo.bar.parent && foo.bar.parent.value`\n  // where `node` is `foo.bar`.\n  if (node.parent.parent && ts.isBinaryExpression(node.parent.parent) &&\n      node.parent.parent.left === node.parent) {\n    return true;\n  }\n\n  // `if (foo.bar) {...}` where `node` is `foo.bar`.\n  if (ts.isIfStatement(node.parent) && node.parent.expression === node) {\n    return true;\n  }\n\n  // `foo.bar ? foo.bar.value : null` where `node` is `foo.bar`.\n  if (ts.isConditionalExpression(node.parent) && node.parent.condition === node) {\n    return true;\n  }\n\n  return false;\n}\n\n/** Checks whether a property access is safe (e.g. `foo.parent?.value`). */\nexport function isSafeAccess(node: ts.Node): boolean {\n  return node.parent != null && ts.isPropertyAccessExpression(node.parent) &&\n      node.parent.expression === node && node.parent.questionDotToken != null;\n}\n", "/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgtscProgram} from '@angular/compiler-cli';\nimport {PotentialImport} from '@angular/compiler-cli/private/migrations';\nimport {dirname, relative} from 'path';\nimport ts from 'typescript';\n\nimport {normalizePath} from '../../utils/change_tracker';\nimport {closestNode} from '../../utils/typescript/nodes';\n\n/** Map used to look up nodes based on their positions in a source file. */\nexport type NodeLookup = Map<number, ts.Node[]>;\n\n/** Utility to type a class declaration with a name. */\nexport type NamedClassDeclaration = ts.ClassDeclaration&{name: ts.Identifier};\n\n/** Text span of an AST node. */\nexport type ReferenceSpan = [start: number, end: number];\n\n/** Mapping between a file name and spans for node references inside of it. */\nexport type ReferencesByFile = Map<string, ReferenceSpan[]>;\n\n/** Utility class used to track a one-to-many relationship where all the items are unique. */\nexport class UniqueItemTracker<K, V> {\n  private _nodes = new Map<K, Set<V>>();\n\n  track(key: K, item: V) {\n    const set = this._nodes.get(key);\n\n    if (set) {\n      set.add(item);\n    } else {\n      this._nodes.set(key, new Set([item]));\n    }\n  }\n\n  get(key: K): Set<V>|undefined {\n    return this._nodes.get(key);\n  }\n\n  getEntries(): IterableIterator<[K, Set<V>]> {\n    return this._nodes.entries();\n  }\n}\n\n/** Resolves references to nodes. */\nexport class ReferenceResolver {\n  private _languageService: ts.LanguageService|undefined;\n\n  /**\n   * If set, allows the language service to *only* read a specific file.\n   * Used to speed up single-file lookups.\n   */\n  private _tempOnlyFile: string|null = null;\n\n  constructor(\n      private _program: NgtscProgram, private _host: ts.CompilerHost,\n      private _rootFileNames: string[], private _basePath: string,\n      private _excludedFiles?: RegExp) {}\n\n  /** Finds all references to a node within the entire project. */\n  findReferencesInProject(node: ts.Node): ReferencesByFile {\n    const languageService = this._getLanguageService();\n    const fileName = node.getSourceFile().fileName;\n    const start = node.getStart();\n    let referencedSymbols: ts.ReferencedSymbol[];\n\n    // The language service can throw if it fails to read a file.\n    // Silently continue since we're making the lookup on a best effort basis.\n    try {\n      referencedSymbols = languageService.findReferences(fileName, start) || [];\n    } catch (e: any) {\n      console.error('Failed reference lookup for node ' + node.getText(), e.message);\n      referencedSymbols = [];\n    }\n\n    const results: ReferencesByFile = new Map();\n\n    for (const symbol of referencedSymbols) {\n      for (const ref of symbol.references) {\n        if (!ref.isDefinition || symbol.definition.kind === ts.ScriptElementKind.alias) {\n          if (!results.has(ref.fileName)) {\n            results.set(ref.fileName, []);\n          }\n\n          results.get(ref.fileName)!.push(\n              [ref.textSpan.start, ref.textSpan.start + ref.textSpan.length]);\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /** Finds all references to a node within a single file. */\n  findSameFileReferences(node: ts.Node, fileName: string): ReferenceSpan[] {\n    // Even though we're only passing in a single file into `getDocumentHighlights`, the language\n    // service ends up traversing the entire project. Prevent it from reading any files aside from\n    // the one we're interested in by intercepting it at the compiler host level.\n    // This is an order of magnitude faster on a large project.\n    this._tempOnlyFile = fileName;\n\n    const nodeStart = node.getStart();\n    const results: ReferenceSpan[] = [];\n    let highlights: ts.DocumentHighlights[]|undefined;\n\n    // The language service can throw if it fails to read a file.\n    // Silently continue since we're making the lookup on a best effort basis.\n    try {\n      highlights =\n          this._getLanguageService().getDocumentHighlights(fileName, nodeStart, [fileName]);\n    } catch (e: any) {\n      console.error('Failed reference lookup for node ' + node.getText(), e.message);\n    }\n\n    if (highlights) {\n      for (const file of highlights) {\n        // We are pretty much guaranteed to only have one match from the current file since it is\n        // the only one being passed in `getDocumentHighlight`, but we check here just in case.\n        if (file.fileName === fileName) {\n          for (const {textSpan: {start, length}, kind} of file.highlightSpans) {\n            if (kind !== ts.HighlightSpanKind.none) {\n              results.push([start, start + length]);\n            }\n          }\n        }\n      }\n    }\n\n    // Restore full project access to the language service.\n    this._tempOnlyFile = null;\n    return results;\n  }\n\n  /** Used by the language service  */\n  private _readFile(path: string) {\n    if ((this._tempOnlyFile !== null && path !== this._tempOnlyFile) ||\n        this._excludedFiles?.test(path)) {\n      return '';\n    }\n    return this._host.readFile(path);\n  }\n\n  /** Gets a language service that can be used to perform lookups. */\n  private _getLanguageService(): ts.LanguageService {\n    if (!this._languageService) {\n      const rootFileNames = this._rootFileNames.slice();\n\n      this._program.getTsProgram().getSourceFiles().forEach(({fileName}) => {\n        if (!this._excludedFiles?.test(fileName) && !rootFileNames.includes(fileName)) {\n          rootFileNames.push(fileName);\n        }\n      });\n\n      this._languageService = ts.createLanguageService(\n          {\n            getCompilationSettings: () => this._program.getTsProgram().getCompilerOptions(),\n            getScriptFileNames: () => rootFileNames,\n            // The files won't change so we can return the same version.\n            getScriptVersion: () => '0',\n            getScriptSnapshot: (path: string) => {\n              const content = this._readFile(path);\n              return content ? ts.ScriptSnapshot.fromString(content) : undefined;\n            },\n            getCurrentDirectory: () => this._basePath,\n            getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),\n            readFile: path => this._readFile(path),\n            fileExists: (path: string) => this._host.fileExists(path)\n          },\n          ts.createDocumentRegistry(), ts.LanguageServiceMode.PartialSemantic);\n    }\n\n    return this._languageService;\n  }\n}\n\n/** Creates a NodeLookup object from a source file. */\nexport function getNodeLookup(sourceFile: ts.SourceFile): NodeLookup {\n  const lookup: NodeLookup = new Map();\n\n  sourceFile.forEachChild(function walk(node) {\n    const nodesAtStart = lookup.get(node.getStart());\n\n    if (nodesAtStart) {\n      nodesAtStart.push(node);\n    } else {\n      lookup.set(node.getStart(), [node]);\n    }\n\n    node.forEachChild(walk);\n  });\n\n  return lookup;\n}\n\n/**\n * Converts node offsets to the nodes they correspond to.\n * @param lookup Data structure used to look up nodes at particular positions.\n * @param offsets Offsets of the nodes.\n * @param results Set in which to store the results.\n */\nexport function offsetsToNodes(\n    lookup: NodeLookup, offsets: ReferenceSpan[], results: Set<ts.Node>): Set<ts.Node> {\n  for (const [start, end] of offsets) {\n    const match = lookup.get(start)?.find(node => node.getEnd() === end);\n\n    if (match) {\n      results.add(match);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Finds the class declaration that is being referred to by a node.\n * @param reference Node referring to a class declaration.\n * @param typeChecker\n */\nexport function findClassDeclaration(\n    reference: ts.Node, typeChecker: ts.TypeChecker): ts.ClassDeclaration|null {\n  return typeChecker.getTypeAtLocation(reference).getSymbol()?.declarations?.find(\n             ts.isClassDeclaration) ||\n      null;\n}\n\n/** Finds a property with a specific name in an object literal expression. */\nexport function findLiteralProperty(literal: ts.ObjectLiteralExpression, name: string) {\n  return literal.properties.find(\n      prop => prop.name && ts.isIdentifier(prop.name) && prop.name.text === name);\n}\n\n/** Gets a relative path between two files that can be used inside a TypeScript import. */\nexport function getRelativeImportPath(fromFile: string, toFile: string): string {\n  let path = relative(dirname(fromFile), toFile).replace(/\\.ts$/, '');\n\n  // `relative` returns paths inside the same directory without `./`\n  if (!path.startsWith('.')) {\n    path = './' + path;\n  }\n\n  // Using the Node utilities can yield paths with forward slashes on Windows.\n  return normalizePath(path);\n}\n\n/** Function used to remap the generated `imports` for a component to known shorter aliases. */\nexport function knownInternalAliasRemapper(imports: PotentialImport[]) {\n  return imports.map(\n      current => current.moduleSpecifier === '@angular/common' && current.symbolName === 'NgForOf' ?\n          {...current, symbolName: 'NgFor'} :\n          current);\n}\n\n/**\n * Gets the closest node that matches a predicate, including the node that the search started from.\n * @param node Node from which to start the search.\n * @param predicate Predicate that the result needs to pass.\n */\nexport function closestOrSelf<T extends ts.Node>(\n    node: ts.Node, predicate: (n: ts.Node) => n is T): T|null {\n  return predicate(node) ? node : closestNode(node, predicate);\n}\n\n/**\n * Checks whether a node is referring to a specific class declaration.\n * @param node Node that is being checked.\n * @param className Name of the class that the node might be referring to.\n * @param moduleName Name of the Angular module that should contain the class.\n * @param typeChecker\n */\nexport function isClassReferenceInAngularModule(\n    node: ts.Node, className: string|RegExp, moduleName: string,\n    typeChecker: ts.TypeChecker): boolean {\n  const symbol = typeChecker.getTypeAtLocation(node).getSymbol();\n  const externalName = `@angular/${moduleName}`;\n  const internalName = `angular2/rc/packages/${moduleName}`;\n\n  return !!symbol?.declarations?.some(decl => {\n    const closestClass = closestOrSelf(decl, ts.isClassDeclaration);\n    const closestClassFileName = closestClass?.getSourceFile().fileName;\n\n    if (!closestClass || !closestClassFileName || !closestClass.name ||\n        !ts.isIdentifier(closestClass.name) ||\n        (!closestClassFileName.includes(externalName) &&\n         !closestClassFileName.includes(internalName))) {\n      return false;\n    }\n\n    return typeof className === 'string' ? closestClass.name.text === className :\n                                           className.test(closestClass.name.text);\n  });\n}\n", "/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {NgtscProgram} from '@angular/compiler-cli';\nimport {TemplateTypeChecker} from '@angular/compiler-cli/private/migrations';\nimport {dirname, join} from 'path';\nimport ts from 'typescript';\n\nimport {ChangeTracker, ImportRemapper} from '../../utils/change_tracker';\nimport {getAngularDecorators} from '../../utils/ng_decorators';\nimport {closestNode} from '../../utils/typescript/nodes';\n\nimport {ComponentImportsRemapper, convertNgModuleDeclarationToStandalone, extractDeclarationsFromModule, findTestObjectsToMigrate, migrateTestDeclarations} from './to-standalone';\nimport {closestOrSelf, findClassDeclaration, findLiteralProperty, getNodeLookup, getRelativeImportPath, isClassReferenceInAngularModule, NamedClassDeclaration, NodeLookup, offsetsToNodes, ReferenceResolver, UniqueItemTracker} from './util';\n\n/** Information extracted from a `bootstrapModule` call necessary to migrate it. */\ninterface BootstrapCallAnalysis {\n  /** The call itself. */\n  call: ts.CallExpression;\n  /** Class that is being bootstrapped. */\n  module: ts.ClassDeclaration;\n  /** Metadata of the module class being bootstrapped. */\n  metadata: ts.ObjectLiteralExpression;\n  /** Component that the module is bootstrapping. */\n  component: NamedClassDeclaration;\n  /** Classes declared by the bootstrapped module. */\n  declarations: ts.ClassDeclaration[];\n}\n\nexport function toStandaloneBootstrap(\n    program: NgtscProgram, host: ts.CompilerHost, basePath: string, rootFileNames: string[],\n    sourceFiles: ts.SourceFile[], printer: ts.Printer, importRemapper?: ImportRemapper,\n    referenceLookupExcludedFiles?: RegExp, componentImportRemapper?: ComponentImportsRemapper) {\n  const tracker = new ChangeTracker(printer, importRemapper);\n  const typeChecker = program.getTsProgram().getTypeChecker();\n  const templateTypeChecker = program.compiler.getTemplateTypeChecker();\n  const referenceResolver =\n      new ReferenceResolver(program, host, rootFileNames, basePath, referenceLookupExcludedFiles);\n  const bootstrapCalls: BootstrapCallAnalysis[] = [];\n  const testObjects = new Set<ts.ObjectLiteralExpression>();\n  const allDeclarations = new Set<ts.ClassDeclaration>();\n\n  // `bootstrapApplication` doesn't include Protractor support by default\n  // anymore so we have to opt the app in, if we detect it being used.\n  const additionalProviders = hasImport(program, rootFileNames, 'protractor') ?\n      new Map([['provideProtractorTestingSupport', '@angular/platform-browser']]) :\n      null;\n\n  for (const sourceFile of sourceFiles) {\n    sourceFile.forEachChild(function walk(node) {\n      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n          node.expression.name.text === 'bootstrapModule' &&\n          isClassReferenceInAngularModule(node.expression, 'PlatformRef', 'core', typeChecker)) {\n        const call = analyzeBootstrapCall(node, typeChecker, templateTypeChecker);\n\n        if (call) {\n          bootstrapCalls.push(call);\n        }\n      }\n      node.forEachChild(walk);\n    });\n\n    findTestObjectsToMigrate(sourceFile, typeChecker).forEach(obj => testObjects.add(obj));\n  }\n\n  for (const call of bootstrapCalls) {\n    call.declarations.forEach(decl => allDeclarations.add(decl));\n    migrateBootstrapCall(\n        call, tracker, additionalProviders, referenceResolver, typeChecker, printer);\n  }\n\n  // The previous migrations explicitly skip over bootstrapped\n  // declarations so we have to migrate them now.\n  for (const declaration of allDeclarations) {\n    convertNgModuleDeclarationToStandalone(\n        declaration, allDeclarations, tracker, templateTypeChecker, componentImportRemapper);\n  }\n\n  migrateTestDeclarations(testObjects, allDeclarations, tracker, templateTypeChecker, typeChecker);\n  return tracker.recordChanges();\n}\n\n/**\n * Extracts all of the information from a `bootstrapModule` call\n * necessary to convert it to `bootstrapApplication`.\n * @param call Call to be analyzed.\n * @param typeChecker\n * @param templateTypeChecker\n */\nfunction analyzeBootstrapCall(\n    call: ts.CallExpression, typeChecker: ts.TypeChecker,\n    templateTypeChecker: TemplateTypeChecker): BootstrapCallAnalysis|null {\n  if (call.arguments.length === 0 || !ts.isIdentifier(call.arguments[0])) {\n    return null;\n  }\n\n  const declaration = findClassDeclaration(call.arguments[0], typeChecker);\n\n  if (!declaration) {\n    return null;\n  }\n\n  const decorator = getAngularDecorators(typeChecker, ts.getDecorators(declaration) || [])\n                        .find(decorator => decorator.name === 'NgModule');\n\n  if (!decorator || decorator.node.expression.arguments.length === 0 ||\n      !ts.isObjectLiteralExpression(decorator.node.expression.arguments[0])) {\n    return null;\n  }\n\n  const metadata = decorator.node.expression.arguments[0];\n  const bootstrapProp = findLiteralProperty(metadata, 'bootstrap');\n\n  if (!bootstrapProp || !ts.isPropertyAssignment(bootstrapProp) ||\n      !ts.isArrayLiteralExpression(bootstrapProp.initializer) ||\n      bootstrapProp.initializer.elements.length === 0 ||\n      !ts.isIdentifier(bootstrapProp.initializer.elements[0])) {\n    return null;\n  }\n\n  const component = findClassDeclaration(bootstrapProp.initializer.elements[0], typeChecker);\n\n  if (component && component.name && ts.isIdentifier(component.name)) {\n    return {\n      module: declaration,\n      metadata,\n      component: component as NamedClassDeclaration,\n      call,\n      declarations: extractDeclarationsFromModule(declaration, templateTypeChecker)\n    };\n  }\n\n  return null;\n}\n\n/**\n * Converts a `bootstrapModule` call to `bootstrapApplication`.\n * @param analysis Analysis result of the call.\n * @param tracker Tracker in which to register the changes.\n * @param additionalFeatures Additional providers, apart from the auto-detected ones, that should\n * be added to the bootstrap call.\n * @param referenceResolver\n * @param typeChecker\n * @param printer\n */\nfunction migrateBootstrapCall(\n    analysis: BootstrapCallAnalysis, tracker: ChangeTracker,\n    additionalProviders: Map<string, string>|null, referenceResolver: ReferenceResolver,\n    typeChecker: ts.TypeChecker, printer: ts.Printer) {\n  const sourceFile = analysis.call.getSourceFile();\n  const moduleSourceFile = analysis.metadata.getSourceFile();\n  const providers = findLiteralProperty(analysis.metadata, 'providers');\n  const imports = findLiteralProperty(analysis.metadata, 'imports');\n  const nodesToCopy = new Set<ts.Node>();\n  const providersInNewCall: ts.Expression[] = [];\n  const moduleImportsInNewCall: ts.Expression[] = [];\n  let nodeLookup: NodeLookup|null = null;\n\n  // Comment out the metadata so that it'll be removed when we run the module pruning afterwards.\n  // If the pruning is left for some reason, the user will still have an actionable TODO.\n  tracker.insertText(\n      moduleSourceFile, analysis.metadata.getStart(),\n      '/* TODO(standalone-migration): clean up removed NgModule class manually. \\n');\n  tracker.insertText(moduleSourceFile, analysis.metadata.getEnd(), ' */');\n\n  if (providers && ts.isPropertyAssignment(providers)) {\n    nodeLookup = nodeLookup || getNodeLookup(moduleSourceFile);\n\n    if (ts.isArrayLiteralExpression(providers.initializer)) {\n      providersInNewCall.push(...providers.initializer.elements);\n    } else {\n      providersInNewCall.push(ts.factory.createSpreadElement(providers.initializer));\n    }\n\n    addNodesToCopy(sourceFile, providers, nodeLookup, tracker, nodesToCopy, referenceResolver);\n  }\n\n  if (imports && ts.isPropertyAssignment(imports)) {\n    nodeLookup = nodeLookup || getNodeLookup(moduleSourceFile);\n    migrateImportsForBootstrapCall(\n        sourceFile, imports, nodeLookup, moduleImportsInNewCall, providersInNewCall, tracker,\n        nodesToCopy, referenceResolver, typeChecker);\n  }\n\n  if (additionalProviders) {\n    additionalProviders.forEach((moduleSpecifier, name) => {\n      providersInNewCall.push(ts.factory.createCallExpression(\n          tracker.addImport(sourceFile, name, moduleSpecifier), undefined, undefined));\n    });\n  }\n\n  if (nodesToCopy.size > 0) {\n    let text = '\\n\\n';\n    nodesToCopy.forEach(node => {\n      const transformedNode = remapDynamicImports(sourceFile.fileName, node);\n\n      // Use `getText` to try an preserve the original formatting. This only works if the node\n      // hasn't been transformed. If it has, we have to fall back to the printer.\n      if (transformedNode === node) {\n        text += transformedNode.getText() + '\\n';\n      } else {\n        text += printer.printNode(ts.EmitHint.Unspecified, transformedNode, node.getSourceFile());\n      }\n    });\n    text += '\\n';\n    tracker.insertText(sourceFile, getLastImportEnd(sourceFile), text);\n  }\n\n  replaceBootstrapCallExpression(analysis, providersInNewCall, moduleImportsInNewCall, tracker);\n}\n\n/**\n * Replaces a `bootstrapModule` call with `bootstrapApplication`.\n * @param analysis Analysis result of the `bootstrapModule` call.\n * @param providers Providers that should be added to the new call.\n * @param modules Modules that are being imported into the new call.\n * @param tracker Object keeping track of the changes to the different files.\n */\nfunction replaceBootstrapCallExpression(\n    analysis: BootstrapCallAnalysis, providers: ts.Expression[], modules: ts.Expression[],\n    tracker: ChangeTracker): void {\n  const sourceFile = analysis.call.getSourceFile();\n  const componentPath =\n      getRelativeImportPath(sourceFile.fileName, analysis.component.getSourceFile().fileName);\n  const args = [tracker.addImport(sourceFile, analysis.component.name.text, componentPath)];\n  const bootstrapExpression =\n      tracker.addImport(sourceFile, 'bootstrapApplication', '@angular/platform-browser');\n\n  if (providers.length > 0 || modules.length > 0) {\n    const combinedProviders: ts.Expression[] = [];\n\n    if (modules.length > 0) {\n      const importProvidersExpression =\n          tracker.addImport(sourceFile, 'importProvidersFrom', '@angular/core');\n      combinedProviders.push(\n          ts.factory.createCallExpression(importProvidersExpression, [], modules));\n    }\n\n    // Push the providers after `importProvidersFrom` call for better readability.\n    combinedProviders.push(...providers);\n\n    const providersArray = ts.factory.createNodeArray(\n        combinedProviders,\n        analysis.metadata.properties.hasTrailingComma && combinedProviders.length > 2);\n    const initializer = remapDynamicImports(\n        sourceFile.fileName,\n        ts.factory.createArrayLiteralExpression(providersArray, combinedProviders.length > 1));\n\n    args.push(ts.factory.createObjectLiteralExpression(\n        [ts.factory.createPropertyAssignment('providers', initializer)], true));\n  }\n\n  tracker.replaceNode(\n      analysis.call, ts.factory.createCallExpression(bootstrapExpression, [], args),\n      // Note: it's important to pass in the source file that the nodes originated from!\n      // Otherwise TS won't print out literals inside of the providers that we're copying\n      // over from the module file.\n      undefined, analysis.metadata.getSourceFile());\n}\n\n/**\n * Processes the `imports` of an NgModule so that they can be used in the `bootstrapApplication`\n * call inside of a different file.\n * @param sourceFile File to which the imports will be moved.\n * @param imports Node declaring the imports.\n * @param nodeLookup Map used to look up nodes based on their positions in a file.\n * @param importsForNewCall Array keeping track of the imports that are being added to the new call.\n * @param providersInNewCall Array keeping track of the providers in the new call.\n * @param tracker Tracker in which changes to files are being stored.\n * @param nodesToCopy Nodes that should be copied to the new file.\n * @param referenceResolver\n * @param typeChecker\n */\nfunction migrateImportsForBootstrapCall(\n    sourceFile: ts.SourceFile, imports: ts.PropertyAssignment, nodeLookup: NodeLookup,\n    importsForNewCall: ts.Expression[], providersInNewCall: ts.Expression[], tracker: ChangeTracker,\n    nodesToCopy: Set<ts.Node>, referenceResolver: ReferenceResolver,\n    typeChecker: ts.TypeChecker): void {\n  if (!ts.isArrayLiteralExpression(imports.initializer)) {\n    importsForNewCall.push(imports.initializer);\n    return;\n  }\n\n  for (const element of imports.initializer.elements) {\n    // If the reference is to a `RouterModule.forRoot` call, we can try to migrate it.\n    if (ts.isCallExpression(element) && ts.isPropertyAccessExpression(element.expression) &&\n        element.arguments.length > 0 && element.expression.name.text === 'forRoot' &&\n        isClassReferenceInAngularModule(\n            element.expression.expression, 'RouterModule', 'router', typeChecker)) {\n      const options = element.arguments[1] as ts.Expression | undefined;\n      const features = options ? getRouterModuleForRootFeatures(sourceFile, options, tracker) : [];\n\n      // If the features come back as null, it means that the router\n      // has a configuration that can't be migrated automatically.\n      if (features !== null) {\n        providersInNewCall.push(ts.factory.createCallExpression(\n            tracker.addImport(sourceFile, 'provideRouter', '@angular/router'), [],\n            [element.arguments[0], ...features]));\n        addNodesToCopy(\n            sourceFile, element.arguments[0], nodeLookup, tracker, nodesToCopy, referenceResolver);\n        if (options) {\n          addNodesToCopy(sourceFile, options, nodeLookup, tracker, nodesToCopy, referenceResolver);\n        }\n        continue;\n      }\n    }\n\n    if (ts.isIdentifier(element)) {\n      // `BrowserAnimationsModule` can be replaced with `provideAnimations`.\n      const animationsModule = 'platform-browser/animations';\n      const animationsImport = `@angular/${animationsModule}`;\n\n      if (isClassReferenceInAngularModule(\n              element, 'BrowserAnimationsModule', animationsModule, typeChecker)) {\n        providersInNewCall.push(ts.factory.createCallExpression(\n            tracker.addImport(sourceFile, 'provideAnimations', animationsImport), [], []));\n        continue;\n      }\n\n      // `NoopAnimationsModule` can be replaced with `provideNoopAnimations`.\n      if (isClassReferenceInAngularModule(\n              element, 'NoopAnimationsModule', animationsModule, typeChecker)) {\n        providersInNewCall.push(ts.factory.createCallExpression(\n            tracker.addImport(sourceFile, 'provideNoopAnimations', animationsImport), [], []));\n        continue;\n      }\n\n      // `HttpClientModule` can be replaced with `provideHttpClient()`.\n      const httpClientModule = 'common/http';\n      const httpClientImport = `@angular/${httpClientModule}`;\n      if (isClassReferenceInAngularModule(\n              element, 'HttpClientModule', httpClientModule, typeChecker)) {\n        const callArgs = [\n          // we add `withInterceptorsFromDi()` to the call to ensure that class-based interceptors\n          // still work\n          ts.factory.createCallExpression(\n              tracker.addImport(sourceFile, 'withInterceptorsFromDi', httpClientImport), [], [])\n        ];\n        providersInNewCall.push(ts.factory.createCallExpression(\n            tracker.addImport(sourceFile, 'provideHttpClient', httpClientImport), [], callArgs));\n        continue;\n      }\n    }\n\n    const target =\n        // If it's a call, it'll likely be a `ModuleWithProviders`\n        // expression so the target is going to be call's expression.\n        ts.isCallExpression(element) && ts.isPropertyAccessExpression(element.expression) ?\n        element.expression.expression :\n        element;\n    const classDeclaration = findClassDeclaration(target, typeChecker);\n    const decorators = classDeclaration ?\n        getAngularDecorators(typeChecker, ts.getDecorators(classDeclaration) || []) :\n        undefined;\n\n    if (!decorators || decorators.length === 0 ||\n        decorators.every(\n            ({name}) => name !== 'Directive' && name !== 'Component' && name !== 'Pipe')) {\n      importsForNewCall.push(element);\n      addNodesToCopy(sourceFile, element, nodeLookup, tracker, nodesToCopy, referenceResolver);\n    }\n  }\n}\n\n/**\n * Generates the call expressions that can be used to replace the options\n * object that is passed into a `RouterModule.forRoot` call.\n * @param sourceFile File that the `forRoot` call is coming from.\n * @param options Node that is passed as the second argument to the `forRoot` call.\n * @param tracker Tracker in which to track imports that need to be inserted.\n * @returns Null if the options can't be migrated, otherwise an array of call expressions.\n */\nfunction getRouterModuleForRootFeatures(\n    sourceFile: ts.SourceFile, options: ts.Expression, tracker: ChangeTracker): ts.CallExpression[]|\n    null {\n  // Options that aren't a static object literal can't be migrated.\n  if (!ts.isObjectLiteralExpression(options)) {\n    return null;\n  }\n\n  const featureExpressions: ts.CallExpression[] = [];\n  const configOptions: ts.PropertyAssignment[] = [];\n  const inMemoryScrollingOptions: ts.PropertyAssignment[] = [];\n  const features = new UniqueItemTracker<string, ts.Expression|null>();\n\n  for (const prop of options.properties) {\n    // We can't migrate options that we can't easily analyze.\n    if (!ts.isPropertyAssignment(prop) ||\n        (!ts.isIdentifier(prop.name) && !ts.isStringLiteralLike(prop.name))) {\n      return null;\n    }\n\n    switch (prop.name.text) {\n      // `preloadingStrategy` maps to the `withPreloading` function.\n      case 'preloadingStrategy':\n        features.track('withPreloading', prop.initializer);\n        break;\n\n      // `enableTracing: true` maps to the `withDebugTracing` feature.\n      case 'enableTracing':\n        if (prop.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n          features.track('withDebugTracing', null);\n        }\n        break;\n\n      // `initialNavigation: 'enabled'` and `initialNavigation: 'enabledBlocking'` map to the\n      // `withEnabledBlockingInitialNavigation` feature, while `initialNavigation: 'disabled'` maps\n      // to the `withDisabledInitialNavigation` feature.\n      case 'initialNavigation':\n        if (!ts.isStringLiteralLike(prop.initializer)) {\n          return null;\n        }\n        if (prop.initializer.text === 'enabledBlocking' || prop.initializer.text === 'enabled') {\n          features.track('withEnabledBlockingInitialNavigation', null);\n        } else if (prop.initializer.text === 'disabled') {\n          features.track('withDisabledInitialNavigation', null);\n        }\n        break;\n\n      // `useHash: true` maps to the `withHashLocation` feature.\n      case 'useHash':\n        if (prop.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n          features.track('withHashLocation', null);\n        }\n        break;\n\n      // `errorHandler` maps to the `withNavigationErrorHandler` feature.\n      case 'errorHandler':\n        features.track('withNavigationErrorHandler', prop.initializer);\n        break;\n\n      // `anchorScrolling` and `scrollPositionRestoration` arguments have to be combined into an\n      // object literal that is passed into the `withInMemoryScrolling` feature.\n      case 'anchorScrolling':\n      case 'scrollPositionRestoration':\n        inMemoryScrollingOptions.push(prop);\n        break;\n\n      // All remaining properties can be passed through the `withRouterConfig` feature.\n      default:\n        configOptions.push(prop);\n        break;\n    }\n  }\n\n  if (inMemoryScrollingOptions.length > 0) {\n    features.track(\n        'withInMemoryScrolling',\n        ts.factory.createObjectLiteralExpression(inMemoryScrollingOptions));\n  }\n\n  if (configOptions.length > 0) {\n    features.track('withRouterConfig', ts.factory.createObjectLiteralExpression(configOptions));\n  }\n\n  for (const [feature, featureArgs] of features.getEntries()) {\n    const callArgs: ts.Expression[] = [];\n    featureArgs.forEach(arg => {\n      if (arg !== null) {\n        callArgs.push(arg);\n      }\n    });\n    featureExpressions.push(ts.factory.createCallExpression(\n        tracker.addImport(sourceFile, feature, '@angular/router'), [], callArgs));\n  }\n\n  return featureExpressions;\n}\n\n/**\n * Finds all the nodes that are referenced inside a root node and would need to be copied into a\n * new file in order for the node to compile, and tracks them.\n * @param targetFile File to which the nodes will be copied.\n * @param rootNode Node within which to look for references.\n * @param nodeLookup Map used to look up nodes based on their positions in a file.\n * @param tracker Tracker in which changes to files are stored.\n * @param nodesToCopy Set that keeps track of the nodes being copied.\n * @param referenceResolver\n */\nfunction addNodesToCopy(\n    targetFile: ts.SourceFile, rootNode: ts.Node, nodeLookup: NodeLookup, tracker: ChangeTracker,\n    nodesToCopy: Set<ts.Node>, referenceResolver: ReferenceResolver): void {\n  const refs = findAllSameFileReferences(rootNode, nodeLookup, referenceResolver);\n\n  for (const ref of refs) {\n    const importSpecifier = closestOrSelf(ref, ts.isImportSpecifier);\n    const importDeclaration =\n        importSpecifier ? closestNode(importSpecifier, ts.isImportDeclaration) : null;\n\n    // If the reference is in an import, we need to add an import to the main file.\n    if (importDeclaration && importSpecifier &&\n        ts.isStringLiteralLike(importDeclaration.moduleSpecifier)) {\n      const moduleName = importDeclaration.moduleSpecifier.text.startsWith('.') ?\n          remapRelativeImport(targetFile.fileName, importDeclaration.moduleSpecifier) :\n          importDeclaration.moduleSpecifier.text;\n      const symbolName = importSpecifier.propertyName ? importSpecifier.propertyName.text :\n                                                        importSpecifier.name.text;\n      const alias = importSpecifier.propertyName ? importSpecifier.name.text : null;\n      tracker.addImport(targetFile, symbolName, moduleName, alias);\n      continue;\n    }\n\n    const variableDeclaration = closestOrSelf(ref, ts.isVariableDeclaration);\n    const variableStatement =\n        variableDeclaration ? closestNode(variableDeclaration, ts.isVariableStatement) : null;\n\n    // If the reference is a variable, we can attempt to import it or copy it over.\n    if (variableDeclaration && variableStatement && ts.isIdentifier(variableDeclaration.name)) {\n      if (isExported(variableStatement)) {\n        tracker.addImport(\n            targetFile, variableDeclaration.name.text,\n            getRelativeImportPath(targetFile.fileName, ref.getSourceFile().fileName));\n      } else {\n        nodesToCopy.add(variableStatement);\n      }\n      continue;\n    }\n\n    // Otherwise check if the reference is inside of an exportable declaration, e.g. a function.\n    // This code that is safe to copy over into the new file or import it, if it's exported.\n    const closestExportable = closestOrSelf(ref, isExportableDeclaration);\n    if (closestExportable) {\n      if (isExported(closestExportable) && closestExportable.name) {\n        tracker.addImport(\n            targetFile, closestExportable.name.text,\n            getRelativeImportPath(targetFile.fileName, ref.getSourceFile().fileName));\n      } else {\n        nodesToCopy.add(closestExportable);\n      }\n    }\n  }\n}\n\n/**\n * Finds all the nodes referenced within the root node in the same file.\n * @param rootNode Node from which to start looking for references.\n * @param nodeLookup Map used to look up nodes based on their positions in a file.\n * @param referenceResolver\n */\nfunction findAllSameFileReferences(\n    rootNode: ts.Node, nodeLookup: NodeLookup, referenceResolver: ReferenceResolver): Set<ts.Node> {\n  const results = new Set<ts.Node>();\n  const traversedTopLevelNodes = new Set<ts.Node>();\n  const excludeStart = rootNode.getStart();\n  const excludeEnd = rootNode.getEnd();\n\n  (function walk(node) {\n    if (!isReferenceIdentifier(node)) {\n      node.forEachChild(walk);\n      return;\n    }\n\n    const refs = referencesToNodeWithinSameFile(\n        node, nodeLookup, excludeStart, excludeEnd, referenceResolver);\n\n    if (refs === null) {\n      return;\n    }\n\n    for (const ref of refs) {\n      if (results.has(ref)) {\n        continue;\n      }\n\n      results.add(ref);\n\n      const closestTopLevel = closestNode(ref, isTopLevelStatement);\n      // Avoid re-traversing the same top-level nodes since we know what the result will be.\n      if (!closestTopLevel || traversedTopLevelNodes.has(closestTopLevel)) {\n        continue;\n      }\n\n      // Keep searching, starting from the closest top-level node. We skip import declarations,\n      // because we already know about them and they may put the search into an infinite loop.\n      if (!ts.isImportDeclaration(closestTopLevel) &&\n          isOutsideRange(\n              excludeStart, excludeEnd, closestTopLevel.getStart(), closestTopLevel.getEnd())) {\n        traversedTopLevelNodes.add(closestTopLevel);\n        walk(closestTopLevel);\n      }\n    }\n  })(rootNode);\n\n  return results;\n}\n\n/**\n * Finds all the nodes referring to a specific node within the same file.\n * @param node Node whose references we're lookip for.\n * @param nodeLookup Map used to look up nodes based on their positions in a file.\n * @param excludeStart Start of a range that should be excluded from the results.\n * @param excludeEnd End of a range that should be excluded from the results.\n * @param referenceResolver\n */\nfunction referencesToNodeWithinSameFile(\n    node: ts.Identifier, nodeLookup: NodeLookup, excludeStart: number, excludeEnd: number,\n    referenceResolver: ReferenceResolver): Set<ts.Node>|null {\n  const offsets =\n      referenceResolver.findSameFileReferences(node, node.getSourceFile().fileName)\n          .filter(([start, end]) => isOutsideRange(excludeStart, excludeEnd, start, end));\n\n  if (offsets.length > 0) {\n    const nodes = offsetsToNodes(nodeLookup, offsets, new Set());\n\n    if (nodes.size > 0) {\n      return nodes;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Transforms a node so that any dynamic imports with relative file paths it contains are remapped\n * as if they were specified in a different file. If no transformations have occurred, the original\n * node will be returned.\n * @param targetFileName File name to which to remap the imports.\n * @param rootNode Node being transformed.\n */\nfunction remapDynamicImports<T extends ts.Node>(targetFileName: string, rootNode: T): T {\n  let hasChanged = false;\n  const transformer: ts.TransformerFactory<ts.Node> = context => {\n    return sourceFile => ts.visitNode(sourceFile, function walk(node: ts.Node): ts.Node {\n      if (ts.isCallExpression(node) && node.expression.kind === ts.SyntaxKind.ImportKeyword &&\n          node.arguments.length > 0 && ts.isStringLiteralLike(node.arguments[0]) &&\n          node.arguments[0].text.startsWith('.')) {\n        hasChanged = true;\n        return context.factory.updateCallExpression(node, node.expression, node.typeArguments, [\n          context.factory.createStringLiteral(\n              remapRelativeImport(targetFileName, node.arguments[0])),\n          ...node.arguments.slice(1)\n        ]);\n      }\n      return ts.visitEachChild(node, walk, context);\n    });\n  };\n\n  const result = ts.transform(rootNode, [transformer]).transformed[0] as T;\n  return hasChanged ? result : rootNode;\n}\n\n/**\n * Checks whether a node is a statement at the top level of a file.\n * @param node Node to be checked.\n */\nfunction isTopLevelStatement(node: ts.Node): node is ts.Node {\n  return node.parent != null && ts.isSourceFile(node.parent);\n}\n\n/**\n * Asserts that a node is an identifier that might be referring to a symbol. This excludes\n * identifiers of named nodes like property assignments.\n * @param node Node to be checked.\n */\nfunction isReferenceIdentifier(node: ts.Node): node is ts.Identifier {\n  return ts.isIdentifier(node) &&\n      (!ts.isPropertyAssignment(node.parent) && !ts.isParameter(node.parent) ||\n       node.parent.name !== node);\n}\n\n/**\n * Checks whether a range is completely outside of another range.\n * @param excludeStart Start of the exclusion range.\n * @param excludeEnd End of the exclusion range.\n * @param start Start of the range that is being checked.\n * @param end End of the range that is being checked.\n */\nfunction isOutsideRange(\n    excludeStart: number, excludeEnd: number, start: number, end: number): boolean {\n  return (start < excludeStart && end < excludeStart) || start > excludeEnd;\n}\n\n/**\n * Remaps the specifier of a relative import from its original location to a new one.\n * @param targetFileName Name of the file that the specifier will be moved to.\n * @param specifier Specifier whose path is being remapped.\n */\nfunction remapRelativeImport(targetFileName: string, specifier: ts.StringLiteralLike): string {\n  return getRelativeImportPath(\n      targetFileName, join(dirname(specifier.getSourceFile().fileName), specifier.text));\n}\n\n/**\n * Whether a node is exported.\n * @param node Node to be checked.\n */\nfunction isExported(node: ts.Node): node is ts.Node {\n  return ts.canHaveModifiers(node) && node.modifiers ?\n      node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword) :\n      false;\n}\n\n/**\n * Asserts that a node is an exportable declaration, which means that it can either be exported or\n * it can be safely copied into another file.\n * @param node Node to be checked.\n */\nfunction isExportableDeclaration(node: ts.Node): node is ts.EnumDeclaration|ts.ClassDeclaration|\n    ts.FunctionDeclaration|ts.InterfaceDeclaration|ts.TypeAliasDeclaration {\n  return ts.isEnumDeclaration(node) || ts.isClassDeclaration(node) ||\n      ts.isFunctionDeclaration(node) || ts.isInterfaceDeclaration(node) ||\n      ts.isTypeAliasDeclaration(node);\n}\n\n/**\n * Gets the index after the last import in a file. Can be used to insert new code into the file.\n * @param sourceFile File in which to search for imports.\n */\nfunction getLastImportEnd(sourceFile: ts.SourceFile): number {\n  let index = 0;\n\n  for (const statement of sourceFile.statements) {\n    if (ts.isImportDeclaration(statement)) {\n      index = Math.max(index, statement.getEnd());\n    } else {\n      break;\n    }\n  }\n\n  return index;\n}\n\n/** Checks if any of the program's files has an import of a specific module. */\nfunction hasImport(program: NgtscProgram, rootFileNames: string[], moduleName: string): boolean {\n  const tsProgram = program.getTsProgram();\n  const deepImportStart = moduleName + '/';\n\n  for (const fileName of rootFileNames) {\n    const sourceFile = tsProgram.getSourceFile(fileName);\n\n    if (!sourceFile) {\n      continue;\n    }\n\n    for (const statement of sourceFile.statements) {\n      if (ts.isImportDeclaration(statement) && ts.isStringLiteralLike(statement.moduleSpecifier) &&\n          (statement.moduleSpecifier.text === moduleName ||\n           statement.moduleSpecifier.text.startsWith(deepImportStart))) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n", "/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgtscProgram} from '@angular/compiler-cli';\nimport {PotentialImport, PotentialImportKind, PotentialImportMode, Reference, TemplateTypeChecker} from '@angular/compiler-cli/private/migrations';\nimport ts from 'typescript';\n\nimport {ChangesByFile, ChangeTracker, ImportRemapper} from '../../utils/change_tracker';\nimport {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\nimport {getImportSpecifier} from '../../utils/typescript/imports';\nimport {closestNode} from '../../utils/typescript/nodes';\nimport {isReferenceToImport} from '../../utils/typescript/symbol';\n\nimport {findClassDeclaration, findLiteralProperty, isClassReferenceInAngularModule, NamedClassDeclaration} from './util';\n\n/**\n * Function that can be used to prcess the dependencies that\n * are going to be added to the imports of a component.\n */\nexport type ComponentImportsRemapper =\n    (imports: PotentialImport[], component: ts.ClassDeclaration) => PotentialImport[];\n\n/**\n * Converts all declarations in the specified files to standalone.\n * @param sourceFiles Files that should be migrated.\n * @param program\n * @param printer\n * @param fileImportRemapper Optional function that can be used to remap file-level imports.\n * @param componentImportRemapper Optional function that can be used to remap component-level\n * imports.\n */\nexport function toStandalone(\n    sourceFiles: ts.SourceFile[], program: NgtscProgram, printer: ts.Printer,\n    fileImportRemapper?: ImportRemapper,\n    componentImportRemapper?: ComponentImportsRemapper): ChangesByFile {\n  const templateTypeChecker = program.compiler.getTemplateTypeChecker();\n  const typeChecker = program.getTsProgram().getTypeChecker();\n  const modulesToMigrate = new Set<ts.ClassDeclaration>();\n  const testObjectsToMigrate = new Set<ts.ObjectLiteralExpression>();\n  const declarations = new Set<ts.ClassDeclaration>();\n  const tracker = new ChangeTracker(printer, fileImportRemapper);\n\n  for (const sourceFile of sourceFiles) {\n    const modules = findNgModuleClassesToMigrate(sourceFile, typeChecker);\n    const testObjects = findTestObjectsToMigrate(sourceFile, typeChecker);\n\n    for (const module of modules) {\n      const allModuleDeclarations = extractDeclarationsFromModule(module, templateTypeChecker);\n      const unbootstrappedDeclarations = filterNonBootstrappedDeclarations(\n          allModuleDeclarations, module, templateTypeChecker, typeChecker);\n\n      if (unbootstrappedDeclarations.length > 0) {\n        modulesToMigrate.add(module);\n        unbootstrappedDeclarations.forEach(decl => declarations.add(decl));\n      }\n    }\n\n    testObjects.forEach(obj => testObjectsToMigrate.add(obj));\n  }\n\n  for (const declaration of declarations) {\n    convertNgModuleDeclarationToStandalone(\n        declaration, declarations, tracker, templateTypeChecker, componentImportRemapper);\n  }\n\n  for (const node of modulesToMigrate) {\n    migrateNgModuleClass(node, declarations, tracker, typeChecker, templateTypeChecker);\n  }\n\n  migrateTestDeclarations(\n      testObjectsToMigrate, declarations, tracker, templateTypeChecker, typeChecker);\n  return tracker.recordChanges();\n}\n\n/**\n * Converts a single declaration defined through an NgModule to standalone.\n * @param decl Declaration being converted.\n * @param tracker Tracker used to track the file changes.\n * @param allDeclarations All the declarations that are being converted as a part of this migration.\n * @param typeChecker\n * @param importRemapper\n */\nexport function convertNgModuleDeclarationToStandalone(\n    decl: ts.ClassDeclaration, allDeclarations: Set<ts.ClassDeclaration>, tracker: ChangeTracker,\n    typeChecker: TemplateTypeChecker, importRemapper?: ComponentImportsRemapper): void {\n  const directiveMeta = typeChecker.getDirectiveMetadata(decl);\n\n  if (directiveMeta && directiveMeta.decorator && !directiveMeta.isStandalone) {\n    let decorator = addStandaloneToDecorator(directiveMeta.decorator);\n\n    if (directiveMeta.isComponent) {\n      const importsToAdd = getComponentImportExpressions(\n          decl, allDeclarations, tracker, typeChecker, importRemapper);\n\n      if (importsToAdd.length > 0) {\n        const hasTrailingComma = importsToAdd.length > 2 &&\n            !!extractMetadataLiteral(directiveMeta.decorator)?.properties.hasTrailingComma;\n        decorator = addPropertyToAngularDecorator(\n            decorator,\n            ts.factory.createPropertyAssignment(\n                'imports',\n                ts.factory.createArrayLiteralExpression(\n                    // Create a multi-line array when it has a trailing comma.\n                    ts.factory.createNodeArray(importsToAdd, hasTrailingComma), hasTrailingComma)));\n      }\n    }\n\n    tracker.replaceNode(directiveMeta.decorator, decorator);\n  } else {\n    const pipeMeta = typeChecker.getPipeMetadata(decl);\n\n    if (pipeMeta && pipeMeta.decorator && !pipeMeta.isStandalone) {\n      tracker.replaceNode(pipeMeta.decorator, addStandaloneToDecorator(pipeMeta.decorator));\n    }\n  }\n}\n\n/**\n * Gets the expressions that should be added to a component's\n * `imports` array based on its template dependencies.\n * @param decl Component class declaration.\n * @param allDeclarations All the declarations that are being converted as a part of this migration.\n * @param tracker\n * @param typeChecker\n * @param importRemapper\n */\nfunction getComponentImportExpressions(\n    decl: ts.ClassDeclaration, allDeclarations: Set<ts.ClassDeclaration>, tracker: ChangeTracker,\n    typeChecker: TemplateTypeChecker, importRemapper?: ComponentImportsRemapper): ts.Expression[] {\n  const templateDependencies = findTemplateDependencies(decl, typeChecker);\n  const usedDependenciesInMigration =\n      new Set(templateDependencies.filter(dep => allDeclarations.has(dep.node)));\n  const imports: ts.Expression[] = [];\n  const seenImports = new Set<string>();\n  const resolvedDependencies: PotentialImport[] = [];\n\n  for (const dep of templateDependencies) {\n    const importLocation = findImportLocation(\n        dep as Reference<NamedClassDeclaration>, decl,\n        usedDependenciesInMigration.has(dep) ? PotentialImportMode.ForceDirect :\n                                               PotentialImportMode.Normal,\n        typeChecker);\n\n    if (importLocation && !seenImports.has(importLocation.symbolName)) {\n      seenImports.add(importLocation.symbolName);\n      resolvedDependencies.push(importLocation);\n    }\n  }\n\n  const processedDependencies =\n      importRemapper ? importRemapper(resolvedDependencies, decl) : resolvedDependencies;\n\n  for (const importLocation of processedDependencies) {\n    if (importLocation.moduleSpecifier) {\n      const identifier = tracker.addImport(\n          decl.getSourceFile(), importLocation.symbolName, importLocation.moduleSpecifier);\n      imports.push(identifier);\n    } else {\n      const identifier = ts.factory.createIdentifier(importLocation.symbolName);\n\n      if (importLocation.isForwardReference) {\n        const forwardRefExpression =\n            tracker.addImport(decl.getSourceFile(), 'forwardRef', '@angular/core');\n        const arrowFunction = ts.factory.createArrowFunction(\n            undefined, undefined, [], undefined, undefined, identifier);\n        imports.push(\n            ts.factory.createCallExpression(forwardRefExpression, undefined, [arrowFunction]));\n      } else {\n        imports.push(identifier);\n      }\n    }\n  }\n\n  return imports;\n}\n\n/**\n * Moves all of the declarations of a class decorated with `@NgModule` to its imports.\n * @param node Class being migrated.\n * @param allDeclarations All the declarations that are being converted as a part of this migration.\n * @param tracker\n * @param typeChecker\n * @param templateTypeChecker\n */\nfunction migrateNgModuleClass(\n    node: ts.ClassDeclaration, allDeclarations: Set<ts.ClassDeclaration>, tracker: ChangeTracker,\n    typeChecker: ts.TypeChecker, templateTypeChecker: TemplateTypeChecker) {\n  const decorator = templateTypeChecker.getNgModuleMetadata(node)?.decorator;\n  const metadata = decorator ? extractMetadataLiteral(decorator) : null;\n\n  if (metadata) {\n    moveDeclarationsToImports(metadata, allDeclarations, typeChecker, templateTypeChecker, tracker);\n  }\n}\n\n/**\n * Moves all the symbol references from the `declarations` array to the `imports`\n * array of an `NgModule` class and removes the `declarations`.\n * @param literal Object literal used to configure the module that should be migrated.\n * @param allDeclarations All the declarations that are being converted as a part of this migration.\n * @param typeChecker\n * @param tracker\n */\nfunction moveDeclarationsToImports(\n    literal: ts.ObjectLiteralExpression, allDeclarations: Set<ts.ClassDeclaration>,\n    typeChecker: ts.TypeChecker, templateTypeChecker: TemplateTypeChecker,\n    tracker: ChangeTracker): void {\n  const declarationsProp = findLiteralProperty(literal, 'declarations');\n\n  if (!declarationsProp) {\n    return;\n  }\n\n  const declarationsToPreserve: ts.Expression[] = [];\n  const declarationsToCopy: ts.Expression[] = [];\n  const properties: ts.ObjectLiteralElementLike[] = [];\n  const importsProp = findLiteralProperty(literal, 'imports');\n  const hasAnyArrayTrailingComma = literal.properties.some(\n      prop => ts.isPropertyAssignment(prop) && ts.isArrayLiteralExpression(prop.initializer) &&\n          prop.initializer.elements.hasTrailingComma);\n\n  // Separate the declarations that we want to keep and ones we need to copy into the `imports`.\n  if (ts.isPropertyAssignment(declarationsProp)) {\n    // If the declarations are an array, we can analyze it to\n    // find any classes from the current migration.\n    if (ts.isArrayLiteralExpression(declarationsProp.initializer)) {\n      for (const el of declarationsProp.initializer.elements) {\n        if (ts.isIdentifier(el)) {\n          const correspondingClass = findClassDeclaration(el, typeChecker);\n\n          if (!correspondingClass ||\n              // Check whether the declaration is either standalone already or is being converted\n              // in this migration. We need to check if it's standalone already, in order to correct\n              // some cases where the main app and the test files are being migrated in separate\n              // programs.\n              isStandaloneDeclaration(correspondingClass, allDeclarations, templateTypeChecker)) {\n            declarationsToCopy.push(el);\n          } else {\n            declarationsToPreserve.push(el);\n          }\n        } else {\n          declarationsToCopy.push(el);\n        }\n      }\n    } else {\n      // Otherwise create a spread that will be copied into the `imports`.\n      declarationsToCopy.push(ts.factory.createSpreadElement(declarationsProp.initializer));\n    }\n  }\n\n  // If there are no `imports`, create them with the declarations we want to copy.\n  if (!importsProp && declarationsToCopy.length > 0) {\n    properties.push(ts.factory.createPropertyAssignment(\n        'imports',\n        ts.factory.createArrayLiteralExpression(ts.factory.createNodeArray(\n            declarationsToCopy, hasAnyArrayTrailingComma && declarationsToCopy.length > 2))));\n  }\n\n  for (const prop of literal.properties) {\n    if (!isNamedPropertyAssignment(prop)) {\n      properties.push(prop);\n      continue;\n    }\n\n    // If we have declarations to preserve, update the existing property, otherwise drop it.\n    if (prop === declarationsProp) {\n      if (declarationsToPreserve.length > 0) {\n        const hasTrailingComma = ts.isArrayLiteralExpression(prop.initializer) ?\n            prop.initializer.elements.hasTrailingComma :\n            hasAnyArrayTrailingComma;\n        properties.push(ts.factory.updatePropertyAssignment(\n            prop, prop.name,\n            ts.factory.createArrayLiteralExpression(ts.factory.createNodeArray(\n                declarationsToPreserve, hasTrailingComma && declarationsToPreserve.length > 2))));\n      }\n      continue;\n    }\n\n    // If we have an `imports` array and declarations\n    // that should be copied, we merge the two arrays.\n    if (prop === importsProp && declarationsToCopy.length > 0) {\n      let initializer: ts.Expression;\n\n      if (ts.isArrayLiteralExpression(prop.initializer)) {\n        initializer = ts.factory.updateArrayLiteralExpression(\n            prop.initializer,\n            ts.factory.createNodeArray(\n                [...prop.initializer.elements, ...declarationsToCopy],\n                prop.initializer.elements.hasTrailingComma));\n      } else {\n        initializer = ts.factory.createArrayLiteralExpression(ts.factory.createNodeArray(\n            [ts.factory.createSpreadElement(prop.initializer), ...declarationsToCopy],\n            // Expect the declarations to be greater than 1 since\n            // we have the pre-existing initializer already.\n            hasAnyArrayTrailingComma && declarationsToCopy.length > 1));\n      }\n\n      properties.push(ts.factory.updatePropertyAssignment(prop, prop.name, initializer));\n      continue;\n    }\n\n    // Retain any remaining properties.\n    properties.push(prop);\n  }\n\n  tracker.replaceNode(\n      literal,\n      ts.factory.updateObjectLiteralExpression(\n          literal, ts.factory.createNodeArray(properties, literal.properties.hasTrailingComma)),\n      ts.EmitHint.Expression);\n}\n\n/** Adds `standalone: true` to a decorator node. */\nfunction addStandaloneToDecorator(node: ts.Decorator): ts.Decorator {\n  return addPropertyToAngularDecorator(\n      node,\n      ts.factory.createPropertyAssignment(\n          'standalone', ts.factory.createToken(ts.SyntaxKind.TrueKeyword)));\n}\n\n/**\n * Adds a property to an Angular decorator node.\n * @param node Decorator to which to add the property.\n * @param property Property to add.\n */\nfunction addPropertyToAngularDecorator(\n    node: ts.Decorator, property: ts.PropertyAssignment): ts.Decorator {\n  // Invalid decorator.\n  if (!ts.isCallExpression(node.expression) || node.expression.arguments.length > 1) {\n    return node;\n  }\n\n  let literalProperties: ts.ObjectLiteralElementLike[];\n  let hasTrailingComma = false;\n\n  if (node.expression.arguments.length === 0) {\n    literalProperties = [property];\n  } else if (ts.isObjectLiteralExpression(node.expression.arguments[0])) {\n    hasTrailingComma = node.expression.arguments[0].properties.hasTrailingComma;\n    literalProperties = [...node.expression.arguments[0].properties, property];\n  } else {\n    // Unsupported case (e.g. `@Component(SOME_CONST)`). Return the original node.\n    return node;\n  }\n\n  // Use `createDecorator` instead of `updateDecorator`, because\n  // the latter ends up duplicating the node's leading comment.\n  return ts.factory.createDecorator(ts.factory.createCallExpression(\n      node.expression.expression, node.expression.typeArguments,\n      [ts.factory.createObjectLiteralExpression(\n          ts.factory.createNodeArray(literalProperties, hasTrailingComma),\n          literalProperties.length > 1)]));\n}\n\n/** Checks if a node is a `PropertyAssignment` with a name. */\nfunction isNamedPropertyAssignment(node: ts.Node): node is ts.PropertyAssignment&\n    {name: ts.Identifier} {\n  return ts.isPropertyAssignment(node) && node.name && ts.isIdentifier(node.name);\n}\n\n/**\n * Finds the import from which to bring in a template dependency of a component.\n * @param target Dependency that we're searching for.\n * @param inComponent Component in which the dependency is used.\n * @param importMode Mode in which to resolve the import target.\n * @param typeChecker\n */\nfunction findImportLocation(\n    target: Reference<NamedClassDeclaration>, inComponent: ts.ClassDeclaration,\n    importMode: PotentialImportMode, typeChecker: TemplateTypeChecker): PotentialImport|null {\n  const importLocations = typeChecker.getPotentialImportsFor(target, inComponent, importMode);\n  let firstSameFileImport: PotentialImport|null = null;\n  let firstModuleImport: PotentialImport|null = null;\n\n  for (const location of importLocations) {\n    // Prefer a standalone import, if we can find one.\n    // Otherwise fall back to the first module-based import.\n    if (location.kind === PotentialImportKind.Standalone) {\n      return location;\n    }\n    if (!location.moduleSpecifier && !firstSameFileImport) {\n      firstSameFileImport = location;\n    }\n    if (location.kind === PotentialImportKind.NgModule && !firstModuleImport &&\n        // Éµ is used for some internal Angular modules that we want to skip over.\n        !location.symbolName.startsWith('Éµ')) {\n      firstModuleImport = location;\n    }\n  }\n\n  return firstSameFileImport || firstModuleImport || importLocations[0] || null;\n}\n\n/**\n * Checks whether a node is an `NgModule` metadata element with at least one element.\n * E.g. `declarations: [Foo]` or `declarations: SOME_VAR` would match this description,\n * but not `declarations: []`.\n */\nfunction hasNgModuleMetadataElements(node: ts.Node): node is ts.PropertyAssignment&\n    {initializer: ts.ArrayLiteralExpression} {\n  return ts.isPropertyAssignment(node) &&\n      (!ts.isArrayLiteralExpression(node.initializer) || node.initializer.elements.length > 0);\n}\n\n/** Finds all modules whose declarations can be migrated. */\nfunction findNgModuleClassesToMigrate(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker) {\n  const modules: ts.ClassDeclaration[] = [];\n\n  if (getImportSpecifier(sourceFile, '@angular/core', 'NgModule')) {\n    sourceFile.forEachChild(function walk(node) {\n      if (ts.isClassDeclaration(node)) {\n        const decorator = getAngularDecorators(typeChecker, ts.getDecorators(node) || [])\n                              .find(current => current.name === 'NgModule');\n        const metadata = decorator ? extractMetadataLiteral(decorator.node) : null;\n\n        if (metadata) {\n          const declarations = findLiteralProperty(metadata, 'declarations');\n\n          if (declarations != null && hasNgModuleMetadataElements(declarations)) {\n            modules.push(node);\n          }\n        }\n      }\n\n      node.forEachChild(walk);\n    });\n  }\n\n  return modules;\n}\n\n/** Finds all testing object literals that need to be migrated. */\nexport function findTestObjectsToMigrate(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker) {\n  const testObjects: ts.ObjectLiteralExpression[] = [];\n  const testBedImport = getImportSpecifier(sourceFile, '@angular/core/testing', 'TestBed');\n  const catalystImport = getImportSpecifier(sourceFile, /testing\\/catalyst$/, 'setupModule');\n\n  if (testBedImport || catalystImport) {\n    sourceFile.forEachChild(function walk(node) {\n      if (ts.isCallExpression(node) && node.arguments.length > 0 &&\n          // `arguments[0]` is the testing module config.\n          ts.isObjectLiteralExpression(node.arguments[0])) {\n        if ((testBedImport && ts.isPropertyAccessExpression(node.expression) &&\n             node.expression.name.text === 'configureTestingModule' &&\n             isReferenceToImport(typeChecker, node.expression.expression, testBedImport)) ||\n            (catalystImport && ts.isIdentifier(node.expression) &&\n             isReferenceToImport(typeChecker, node.expression, catalystImport))) {\n          testObjects.push(node.arguments[0]);\n        }\n      }\n\n      node.forEachChild(walk);\n    });\n  }\n\n  return testObjects;\n}\n\n/**\n * Finds the classes corresponding to dependencies used in a component's template.\n * @param decl Component in whose template we're looking for dependencies.\n * @param typeChecker\n */\nfunction findTemplateDependencies(decl: ts.ClassDeclaration, typeChecker: TemplateTypeChecker):\n    Reference<NamedClassDeclaration>[] {\n  const results: Reference<NamedClassDeclaration>[] = [];\n  const usedDirectives = typeChecker.getUsedDirectives(decl);\n  const usedPipes = typeChecker.getUsedPipes(decl);\n\n  if (usedDirectives !== null) {\n    for (const dir of usedDirectives) {\n      if (ts.isClassDeclaration(dir.ref.node)) {\n        results.push(dir.ref as Reference<NamedClassDeclaration>);\n      }\n    }\n  }\n\n  if (usedPipes !== null) {\n    const potentialPipes = typeChecker.getPotentialPipes(decl);\n\n    for (const pipe of potentialPipes) {\n      if (ts.isClassDeclaration(pipe.ref.node) &&\n          usedPipes.some(current => pipe.name === current)) {\n        results.push(pipe.ref as Reference<NamedClassDeclaration>);\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Removes any declarations that are a part of a module's `bootstrap`\n * array from an array of declarations.\n * @param declarations Anaalyzed declarations of the module.\n * @param ngModule Module whote declarations are being filtered.\n * @param templateTypeChecker\n * @param typeChecker\n */\nfunction filterNonBootstrappedDeclarations(\n    declarations: ts.ClassDeclaration[], ngModule: ts.ClassDeclaration,\n    templateTypeChecker: TemplateTypeChecker, typeChecker: ts.TypeChecker) {\n  const metadata = templateTypeChecker.getNgModuleMetadata(ngModule);\n  const metaLiteral =\n      metadata && metadata.decorator ? extractMetadataLiteral(metadata.decorator) : null;\n  const bootstrapProp = metaLiteral ? findLiteralProperty(metaLiteral, 'bootstrap') : null;\n\n  // If there's no `bootstrap`, we can't filter.\n  if (!bootstrapProp) {\n    return declarations;\n  }\n\n  // If we can't analyze the `bootstrap` property, we can't safely determine which\n  // declarations aren't bootstrapped so we assume that all of them are.\n  if (!ts.isPropertyAssignment(bootstrapProp) ||\n      !ts.isArrayLiteralExpression(bootstrapProp.initializer)) {\n    return [];\n  }\n\n  const bootstrappedClasses = new Set<ts.ClassDeclaration>();\n\n  for (const el of bootstrapProp.initializer.elements) {\n    const referencedClass = ts.isIdentifier(el) ? findClassDeclaration(el, typeChecker) : null;\n\n    // If we can resolve an element to a class, we can filter it out,\n    // otherwise assume that the array isn't static.\n    if (referencedClass) {\n      bootstrappedClasses.add(referencedClass);\n    } else {\n      return [];\n    }\n  }\n\n  return declarations.filter(ref => !bootstrappedClasses.has(ref));\n}\n\n/**\n * Extracts all classes that are referenced in a module's `declarations` array.\n * @param ngModule Module whose declarations are being extraced.\n * @param templateTypeChecker\n */\nexport function extractDeclarationsFromModule(\n    ngModule: ts.ClassDeclaration,\n    templateTypeChecker: TemplateTypeChecker): ts.ClassDeclaration[] {\n  const metadata = templateTypeChecker.getNgModuleMetadata(ngModule);\n  return metadata ? metadata.declarations.filter(decl => ts.isClassDeclaration(decl.node))\n                        .map(decl => decl.node) as ts.ClassDeclaration[] :\n                    [];\n}\n\n/**\n * Migrates the `declarations` from a unit test file to standalone.\n * @param testObjects Object literals used to configure the testing modules.\n * @param declarationsOutsideOfTestFiles Non-testing declarations that are part of this migration.\n * @param tracker\n * @param templateTypeChecker\n * @param typeChecker\n */\nexport function migrateTestDeclarations(\n    testObjects: Set<ts.ObjectLiteralExpression>,\n    declarationsOutsideOfTestFiles: Set<ts.ClassDeclaration>, tracker: ChangeTracker,\n    templateTypeChecker: TemplateTypeChecker, typeChecker: ts.TypeChecker) {\n  const {decorators, componentImports} = analyzeTestingModules(testObjects, typeChecker);\n  const allDeclarations = new Set(declarationsOutsideOfTestFiles);\n\n  for (const decorator of decorators) {\n    const closestClass = closestNode(decorator.node, ts.isClassDeclaration);\n\n    if (decorator.name === 'Pipe' || decorator.name === 'Directive') {\n      tracker.replaceNode(decorator.node, addStandaloneToDecorator(decorator.node));\n\n      if (closestClass) {\n        allDeclarations.add(closestClass);\n      }\n    } else if (decorator.name === 'Component') {\n      const newDecorator = addStandaloneToDecorator(decorator.node);\n      const importsToAdd = componentImports.get(decorator.node);\n\n      if (closestClass) {\n        allDeclarations.add(closestClass);\n      }\n\n      if (importsToAdd && importsToAdd.size > 0) {\n        const hasTrailingComma = importsToAdd.size > 2 &&\n            !!extractMetadataLiteral(decorator.node)?.properties.hasTrailingComma;\n        const importsArray = ts.factory.createNodeArray(Array.from(importsToAdd), hasTrailingComma);\n\n        tracker.replaceNode(\n            decorator.node,\n            addPropertyToAngularDecorator(\n                newDecorator,\n                ts.factory.createPropertyAssignment(\n                    'imports', ts.factory.createArrayLiteralExpression(importsArray))));\n      } else {\n        tracker.replaceNode(decorator.node, newDecorator);\n      }\n    }\n  }\n\n  for (const obj of testObjects) {\n    moveDeclarationsToImports(obj, allDeclarations, typeChecker, templateTypeChecker, tracker);\n  }\n}\n\n/**\n * Analyzes a set of objects used to configure testing modules and returns the AST\n * nodes that need to be migrated and the imports that should be added to the imports\n * of any declared components.\n * @param testObjects Object literals that should be analyzed.\n */\nfunction analyzeTestingModules(\n    testObjects: Set<ts.ObjectLiteralExpression>, typeChecker: ts.TypeChecker) {\n  const seenDeclarations = new Set<ts.Declaration>();\n  const decorators: NgDecorator[] = [];\n  const componentImports = new Map<ts.Decorator, Set<ts.Expression>>();\n\n  for (const obj of testObjects) {\n    const declarations = extractDeclarationsFromTestObject(obj, typeChecker);\n\n    if (declarations.length === 0) {\n      continue;\n    }\n\n    const importsProp = findLiteralProperty(obj, 'imports');\n    const importElements = importsProp && hasNgModuleMetadataElements(importsProp) ?\n        importsProp.initializer.elements.filter(el => {\n          // Filter out calls since they may be a `ModuleWithProviders`.\n          return !ts.isCallExpression(el) &&\n              // Also filter out the animations modules since they throw errors if they're imported\n              // multiple times and it's common for apps to use the `NoopAnimationsModule` to\n              // disable animations in screenshot tests.\n              !isClassReferenceInAngularModule(\n                  el, /^BrowserAnimationsModule|NoopAnimationsModule$/,\n                  'platform-browser/animations', typeChecker);\n        }) :\n        null;\n\n    for (const decl of declarations) {\n      if (seenDeclarations.has(decl)) {\n        continue;\n      }\n\n      const [decorator] = getAngularDecorators(typeChecker, ts.getDecorators(decl) || []);\n\n      if (decorator) {\n        seenDeclarations.add(decl);\n        decorators.push(decorator);\n\n        if (decorator.name === 'Component' && importElements) {\n          // We try to de-duplicate the imports being added to a component, because it may be\n          // declared in different testing modules with a different set of imports.\n          let imports = componentImports.get(decorator.node);\n          if (!imports) {\n            imports = new Set();\n            componentImports.set(decorator.node, imports);\n          }\n          importElements.forEach(imp => imports!.add(imp));\n        }\n      }\n    }\n  }\n\n  return {decorators, componentImports};\n}\n\n/**\n * Finds the class declarations that are being referred\n * to in the `declarations` of an object literal.\n * @param obj Object literal that may contain the declarations.\n * @param typeChecker\n */\nfunction extractDeclarationsFromTestObject(\n    obj: ts.ObjectLiteralExpression, typeChecker: ts.TypeChecker): ts.ClassDeclaration[] {\n  const results: ts.ClassDeclaration[] = [];\n  const declarations = findLiteralProperty(obj, 'declarations');\n\n  if (declarations && hasNgModuleMetadataElements(declarations)) {\n    for (const element of declarations.initializer.elements) {\n      const declaration = findClassDeclaration(element, typeChecker);\n\n      // Note that we only migrate classes that are in the same file as the testing module,\n      // because external fixture components are somewhat rare and handling them is going\n      // to involve a lot of assumptions that are likely to be incorrect.\n      if (declaration && declaration.getSourceFile().fileName === obj.getSourceFile().fileName) {\n        results.push(declaration);\n      }\n    }\n  }\n\n  return results;\n}\n\n/** Extracts the metadata object literal from an Angular decorator. */\nfunction extractMetadataLiteral(decorator: ts.Decorator): ts.ObjectLiteralExpression|null {\n  // `arguments[0]` is the metadata object literal.\n  return ts.isCallExpression(decorator.expression) && decorator.expression.arguments.length === 1 &&\n          ts.isObjectLiteralExpression(decorator.expression.arguments[0]) ?\n      decorator.expression.arguments[0] :\n      null;\n}\n\n/**\n * Checks whether a class is a standalone declaration.\n * @param node Class being checked.\n * @param declarationsInMigration Classes that are being converted to standalone in this migration.\n * @param templateTypeChecker\n */\nfunction isStandaloneDeclaration(\n    node: ts.ClassDeclaration, declarationsInMigration: Set<ts.ClassDeclaration>,\n    templateTypeChecker: TemplateTypeChecker): boolean {\n  if (declarationsInMigration.has(node)) {\n    return true;\n  }\n\n  const metadata =\n      templateTypeChecker.getDirectiveMetadata(node) || templateTypeChecker.getPipeMetadata(node);\n  return metadata != null && metadata.isStandalone;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nexport function getValueSymbolOfDeclaration(node: ts.Node, typeChecker: ts.TypeChecker): ts.Symbol|\n    undefined {\n  let symbol = typeChecker.getSymbolAtLocation(node);\n\n  while (symbol && symbol.flags & ts.SymbolFlags.Alias) {\n    symbol = typeChecker.getAliasedSymbol(symbol);\n  }\n\n  return symbol;\n}\n\n/** Checks whether a node is referring to a specific import specifier. */\nexport function isReferenceToImport(\n    typeChecker: ts.TypeChecker, node: ts.Node, importSpecifier: ts.ImportSpecifier): boolean {\n  const nodeSymbol = typeChecker.getTypeAtLocation(node).getSymbol();\n  const importSymbol = typeChecker.getTypeAtLocation(importSpecifier).getSymbol();\n  return !!(nodeSymbol?.declarations?.[0] && importSymbol?.declarations?.[0]) &&\n      nodeSymbol.declarations[0] === importSymbol.declarations[0];\n}\n\n/** Checks whether a node's type is nullable (`null`, `undefined` or `void`). */\nexport function isNullableType(typeChecker: ts.TypeChecker, node: ts.Node) {\n  // Skip expressions in the form of `foo.bar!.baz` since the `TypeChecker` seems\n  // to identify them as null, even though the user indicated that it won't be.\n  if (node.parent && ts.isNonNullExpression(node.parent)) {\n    return false;\n  }\n\n  const type = typeChecker.getTypeAtLocation(node);\n  const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n  let hasSeenNullableType = false;\n\n  // Trace the type of the node back to a type node, walk\n  // through all of its sub-nodes and look for nullable types.\n  if (typeNode) {\n    (function walk(current: ts.Node) {\n      if (current.kind === ts.SyntaxKind.NullKeyword ||\n          current.kind === ts.SyntaxKind.UndefinedKeyword ||\n          current.kind === ts.SyntaxKind.VoidKeyword) {\n        hasSeenNullableType = true;\n        // Note that we don't descend into type literals, because it may cause\n        // us to mis-identify the root type as nullable, because it has a nullable\n        // property (e.g. `{ foo: string | null }`).\n      } else if (!hasSeenNullableType && !ts.isTypeLiteralNode(current)) {\n        current.forEachChild(walk);\n      }\n    })(typeNode);\n  }\n\n  return hasSeenNullableType;\n}\n\n/**\n * Walks through the types and sub-types of a node, looking for a\n * type that has the same name as one of the passed-in ones.\n */\nexport function hasOneOfTypes(\n    typeChecker: ts.TypeChecker, node: ts.Node, types: string[]): boolean {\n  const type = typeChecker.getTypeAtLocation(node);\n  const typeNode =\n      type ? typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None) : undefined;\n  let hasMatch = false;\n  if (typeNode) {\n    (function walk(current: ts.Node) {\n      if (ts.isIdentifier(current) && types.includes(current.text)) {\n        hasMatch = true;\n      } else if (!hasMatch && !ts.isTypeLiteralNode(current)) {\n        current.forEachChild(walk);\n      }\n    })(typeNode);\n  }\n  return hasMatch;\n}\n"],
  "mappings": "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,IAAOC,WAAP,MAAc;EAClB,YAAmB,OAA2B,YAA2B;AAAtD,SAAA,QAAA;AAA2B,SAAA,aAAA;EAA8B;EAC5E,MAAM,SAAkB,SAAY;AAClC,WAAO,QAAQ,aAAa,MAAM,OAAO;EAC3C;;AAgBI,SAAUC,UAAS,SAAkB,OAAe,UAAe,MAAI;AAC3E,QAAM,SAAgB,CAAA;AAEtB,QAAMC,SAAQ,QAAQ,QAClB,CAAC,QAAc,QAAQ,MAAO,KAAK,OAAO,KAAK,IAAI,MAAM,SAAS,OAAO,IACzE,CAAC,QAAc,IAAI,MAAM,SAAS,OAAO;AAC7C,QAAM,QAAQ,SAAM;AAClB,UAAM,YAAYA,OAAM,GAAG;AAC3B,QAAI,WAAW;AACb,aAAO,KAAK,SAAS;;EAEzB,CAAC;AACD,SAAO;AACT;;;ACxGM,IAAgB,wBAAhB,MAAqC;;;;ACK3C,IAAM,UAAU;AAChB,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,SAAS;AA0Df,IAAM,SAAmB;EACvB;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;E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",
  "names": ["path", "path", "sf", "path", "path", "path", "path", "fs", "module", "element", "ViewEncapsulation", "ChangeDetectionStrategy", "SecurityContext", "MissingTranslationStrategy", "text", "Endian", "TypeModifier", "BuiltinTypeName", "UnaryOperator", "BinaryOperator", "fn", "template", "text", "_a", "StmtModifier", "text", "leadingComment", "_a", "template", "literal", "R3FactoryDelegateType", "FactoryTarget", "_visitor", "element", "template", "variable", "reference", "text", "Text", "Icu", "text", "text", "text", "Text", "_Visitor", "Text", "digest", "text", "Icu", "element", "node", "variable", "reference", "invalid", "_a", "ParseErrorLevel", "_a", "fn", "fn", "R3SelectorScopeMode", "R3TemplateDependencyKind", "_a", "RecursiveAstVisitor", "ParsedPropertyType", "_Mode", "ast", "_a", "receiver", "call", "guardedExpression", "visit", "p", "_a", "shallowPart", "selector", "sep", "part", "TagContentType", "ElementAttributeKind", "_a", "OpKind", "ExpressionKind", "SemanticVariableKind", "VisitorContextFlag", "variable", "template", "variable", "preambleOps", "processLexicalScope", "Fence", "idx", "template", "element", "_a", "text", "property", "reference", "call", "TokenType", "text", "identifierName", "text", "_a", "text", "ParseContextFlags", "id", "RecursiveAstVisitor", "Text", "Element", "Comment", "visitAll", "visit", "property", "_a", "_a", "CharacterReferenceType", "error", "Parser", "text", "Comment", "Text", "Element", "element", "Parser", "element", "Element", "visitAll", "text", "Text", "isHostBinding", "error", "selector", "PreparsedElementType", "TEMPLATE_ATTR_PREFIX", "visitAll", "element", "text", "literal", "_a", "srcSpan", "keySpan", "reference", "Text", "Comment", "TagType", "element", "template", "text", "visitAll", "_a", "Text", "text", "Icu", "node", "element", "visitAll", "text", "variable", "text", "serializerVisitor", "variable", "localizedString", "text", "_a", "serializerVisitor", "NG_CONTENT_SELECT_ATTR", "invalid", "variable", "isRoot", "element", "_a", "isNgContainer", "template", "text", "value", "reference", "call", "getAttributeNameLiterals", "literal", "parsedTemplate", "visitAll", "_a", "template", "call", "bindingFn", "_a", "template", "property", "self", "error", "global", "VERSION", "MEANING_SEPARATOR", "ID_SEPARATOR", "_Visitor", "_VisitorMode", "_Visitor", "Element", "visitAll", "text", "Text", "node", "Comment", "p", "ID_SEPARATOR", "MEANING_SEPARATOR", "Parser", "_PLACEHOLDER_TAG", "_SOURCE_TAG", "Text", "text", "visitAll", "element", "Icu", "_VERSION", "_XMLNS", "_DEFAULT_SOURCE_LANG", "_PLACEHOLDER_TAG", "_MARKER_TAG", "_SOURCE_TAG", "_TARGET_TAG", "_UNIT_TAG", "_WriteVisitor", "Text", "XmlToI18n", "text", "visitAll", "element", "Icu", "serializer", "FactoryTarget", "template", "element", "variable", "reference", "text", "dir", "RecursiveAstVisitor", "_a", "templateEntities", "_a", "MINIMUM_PARTIAL_LINKER_VERSION", "_a", "template", "MINIMUM_PARTIAL_LINKER_VERSION", "MINIMUM_PARTIAL_LINKER_VERSION", "MINIMUM_PARTIAL_LINKER_VERSION", "MINIMUM_PARTIAL_LINKER_VERSION", "MINIMUM_PARTIAL_LINKER_VERSION", "VERSION", "EmitFlags", "import_typescript", "import_typescript", "serializer", "import_typescript", "ts", "import_typescript", "import_typescript", "ErrorCode", "import_typescript", "ts", "ExtendedTemplateDiagnosticName", "import_typescript", "import_typescript", "import_typescript", "ts", "fs", "ts", "ImportFlags", "ts", "normalizeSeparators", "path", "import_typescript", "ts", "_a", "Reference", "importExpr", "property", "reference", "ts", "fn", "resolve", "Reference", "self", "ts", "error", "import_typescript", "MetaKind", "MatchSource", "import_typescript", "import_typescript", "ts", "ClassMemberKind", "import_typescript", "ts", "import_typescript", "import_typescript", "ts", "ts", "ts", "isDeclaration", "ts", "module", "ts", "import_typescript", "ts", "element", "Reference", "ts", "_a", "readBaseClass", "Reference", "type", "template", "path", "_a", "import_typescript", "fn", "_a", "Reference", "ts", "import_typescript", "ts", "element", "property", "literal", "Reference", "module", "member", "fn", "path", "_a", "Reference", "ts", "import_typescript", "ts", "import_typescript", "isAngularDecorator", "ts", "_a", "Reference", "import_typescript", "import_typescript", "ts", "path", "import_typescript", "ts", "PerfPhase", "PerfEvent", "PerfCheckpoint", "fn", "mark", "fn", "ComponentScopeKind", "exportScope", "import_typescript", "isExported", "ts", "ref", "module", "import_typescript", "ts", "CompilationMode", "HandlerPrecedence", "HandlerFlags", "import_typescript", "ts", "import_typescript", "TraitState", "visit", "ts", "_a", "import_typescript", "import_typescript", "ts", "UNARY_OPERATORS", "BINARY_OPERATORS", "factory", "_a", "template", "element", "import_typescript", "ts", "import_typescript", "PureAnnotation", "UNARY_OPERATORS", "ts", "BINARY_OPERATORS", "call", "template", "import_typescript", "ts", "ts", "import_typescript", "import_typescript", "ts", "node", "property", "ts", "import_typescript", "ts", "parseInputsArray", "extractHostBindings", "Reference", "parseMappingStringArray", "parseMappingString", "error", "_a", "Reference", "import_typescript", "import_typescript", "ts", "fn", "resolve", "_a", "Reference", "prevEntry", "_a", "ts", "bootstrap", "rawImports", "element", "importExpr", "Reference", "path", "import_typescript", "template", "ts", "element", "reference", "fn", "resolve", "error", "Reference", "EMPTY_ARRAY", "template", "_a", "Reference", "ts", "importExpr", "import_typescript", "ts", "reflector", "import_typescript", "_a", "ts", "Reference", "import_typescript", "ts", "import_typescript", "ts", "import_typescript", "ts", "UpdateMode", "import_typescript", "import_typescript", "ts", "ts", "IncrementalStateKind", "PhaseKind", "IdentifierKind", "AbsoluteSourceSpan", "RecursiveAstVisitor", "AbsoluteSourceSpan", "element", "template", "text", "reference", "variable", "_a", "name", "sourceSpan", "node", "Reference", "_a", "import_typescript", "url", "fromFile", "ts", "_a", "_a", "Reference", "OptimizeFor", "CompletionKind", "PotentialImportKind", "PotentialImportMode", "SymbolKind", "import_typescript", "_a", "ts", "template", "ts", "import_typescript", "import_typescript", "ts", "CommentTriviaType", "ExpressionIdentifier", "_a", "ts", "import_typescript", "import_typescript", "element", "schemas", "ts", "import_typescript", "import_typescript", "ts", "import_typescript", "import_typescript", "import_typescript", "import_typescript", "type", "ts", "reference", "Reference", "ts", "owningModule", "TcbInliningRequirement", "ts", "getTemplateId", "ts", "ts", "import_typescript", "ts", "_a", "variable", "element", "import_typescript", "ts", "import_typescript", "import_typescript", "ts", "import_typescript", "ts", "ast", "literal", "expr", "call", "RecursiveAstVisitor", "TcbGenericContextBehavior", "Context", "Scope", "ts", "element", "template", "variable", "guard", "_a", "call", "ast", "input", "import_typescript", "ts", "fn", "InliningMode", "template", "ts", "text", "error", "fn", "text", "import_typescript", "template", "element", "_a", "ts", "Reference", "variable", "REGISTRY", "_a", "path", "Reference", "p", "module", "template", "TemplateVisitor", "RecursiveAstVisitor", "element", "variable", "reference", "text", "template", "factory", "factory", "import_typescript", "ts", "factory", "import_typescript", "ts", "factory", "factory", "factory", "import_typescript", "DiagnosticCategoryLabel", "_a", "factory", "template", "ts", "factory", "CompilationTicketKind", "_a", "ts", "template", "Reference", "sf", "factory", "import_typescript", "DelegatingCompilerHost", "ts", "normalizeSeparators", "module", "ts", "_a", "import_typescript", "import_typescript", "import_typescript", "LogLevel", "import_fs", "import_path", "import_typescript", "import_typescript", "import_path", "import_typescript", "ImportManager", "ts", "identifierName", "text", "ImportManager", "text", "ts", "path", "import_core", "path", "import_path", "import_typescript", "path", "import_typescript", "ts", "ts", "_a", "import_typescript", "import_typescript", "import_typescript", "ts", "_a", "element", "ts", "import_typescript", "ts", "import_path", "import_typescript", "ts", "path", "_a", "reference", "literal", "_a", "ts", "literal", "import_path", "import_typescript", "import_typescript", "import_typescript", "_a", "module", "_a", "ts", "literal", "property", "element", "ts", "call", "decorator", "text", "element", "MigrationMode", "ts"]
}
