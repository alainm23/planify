<?xml version="1.0"?>
<?xml-stylesheet href="attributes.xslt" type="text/xsl"?>
<xsd:schema
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:html="http://www.w3.org/1999/xhtml"
	xmlns:gv="urn:graphviz">
	
	<!--
		microformats in xsd:documentation
		========================================
		
		class
			val: a value of the enclosing attribute
		
		rel
			attr: link to an attribute
			type: link to an attribute type
	
	-->
	
	<!-- NOTES -->
	<xsd:annotation id="introduction">
		<xsd:documentation>
			<html:p>
				All Graphviz attributes are specified by name-value pairs. Thus, to
				set the fillcolor of a node <html:code>abc</html:code>, one would use
			</html:p>
			<html:p>
				<html:code>abc [fillcolor = red]</html:code>
			</html:p>
			<html:p>
				Similarly, to set the arrowhead style of an edge <html:code>abc -> def</html:code>, 
				one would use
			</html:p>
			<html:p>
				<html:code>abc -> def [arrowhead = diamond]</html:code>
			</html:p>
			<html:p>
				Further details concerning the setting of attributes can be found
				in the description of the 
				<html:a href="http://www.graphviz.org/doc/info/lang.html">DOT language.</html:a>
			</html:p>
		</xsd:documentation>	</xsd:annotation>
	
	<xsd:annotation id="points">
		<xsd:documentation>
			<html:p>
				At present, most device-independent units are either inches or
				<html:a href="http://en.wikipedia.org/wiki/Point_(typography)">points</html:a>, 
				which we take as 72 points per inch.
			</html:p>
		</xsd:documentation>
	
	</xsd:annotation>
	
	<xsd:annotation id="undirected">
		<xsd:documentation>
			<html:p>
				Some attributes, such as
				<html:a rel="attr">dir</html:a> or <html:a rel="attr">arrowtail</html:a>, are 
				ambiguous when used in 
				<html:a href="http://www.graphviz.org/doc/info/lang.html">DOT</html:a>
				with an undirected graph since the head and tail of an edge are meaningless. 
				As a convention, the first time an undirected edge appears, the
				<html:a href="http://www.graphviz.org/doc/info/lang.html">DOT</html:a>
				parser will assign the left node as the tail node and the right node as
				the head. For example, the edge <html:code>A -- B</html:code> will have tail <html:code>A</html:code>
				and head <html:code>B</html:code>. It is the user's responsibility to handle such
				edges consistently. If the edge appears later, in the format
			</html:p>
			<html:p>
				<html:code>B -- A [taillabel = "tail"]</html:code>
			</html:p>
			<html:p>
				the drawing will attach the tail label to node <html:code>A</html:code>.
				To avoid possible confusion when such attributes are required, the user
				is encouraged to use a directed graph.
				If it is important to make the graph appear undirected, this can be
				done using the <html:a rel="attr">dir</html:a>, <html:a rel="attr">arrowtail</html:a>
				or <html:a rel="attr">arrowhead</html:a> attributes.
			</html:p>
		</xsd:documentation>
	</xsd:annotation>
	
	<!-- ATTRIBUTE TYPES -->
	
	<!--
	<xsd:simpleType name="arrowType">
	</xsd:simpleType>
	-->
	
	<xsd:simpleType name="clusterMode">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="local" />
			<xsd:enumeration value="global" />
			<xsd:enumeration value="none" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<!--
	<xsd:simpleType name="color">
	</xsd:simpleType>
	-->
	
	<xsd:simpleType name="colorList">
		<xsd:list itemType="color" />
	</xsd:simpleType>
	
	<xsd:simpleType name="dirType">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					For undirected edges <html:code>T -- H;</html:code>, one of the nodes, usually
					the righthand one, is treated as the head for the purpose of 
					interpreting <html:span class="val">forward</html:span> and <html:span class="val">back</html:span>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="forward" />
			<xsd:enumeration value="back" />
			<xsd:enumeration value="both" />
			<xsd:enumeration value="none" />
		</xsd:restriction>
	</xsd:simpleType>
	
	
	<xsd:simpleType name="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					String allowing escape sequences which are replaced according
					to the context.
					For node attributes, the substring <html:code>\N</html:code> is replaced by the name of the node,
					and the substring <html:code>\G</html:code> by the name of the graph.
					For graph or cluster attributes, the substring <html:code>\G</html:code> is replaced by the 
					name of the graph or cluster.
					For edge attributes, the substring <html:code>\E</html:code> is replaced by the name of the edge,
					the substring <html:code>\G</html:code> is replaced by the name of the graph or cluster,
					and the substrings <html:code>\T</html:code> and <html:code>\H</html:code> by the names of 
					the tail and head nodes, respectively. 
					The name of an edge is the string formed from the name of the
					tail node, the appropriate edge operator (<html:code>--</html:code> or <html:code>-></html:code>) and the name of the
					head node. 
				</html:p>
				<html:p>
					In addition, if the associated attribute is 
					<html:a rel="attr">label</html:a>,
					<html:a rel="attr">headlabel</html:a> or <html:a rel="attr">taillabel</html:a>, 
					the escape sequences <html:code>\n</html:code>, <html:code>\l</html:code> and <html:code>\r</html:code>
					divide the label into lines, centered, left-justified, and right-justified,
					respectively.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string" />
	</xsd:simpleType>
	<!--
		layerList
		layerRange
		lblString
	-->
	
	<xsd:simpleType name="outputMode">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					These specify the order in which nodes and edges are drawn in concrete
					output. The default <html:span class="val">breadthfirst</html:span> is the simplest, but when the graph
					layout does not avoid edge-node overlap, this mode will sometimes have
					edges drawn over nodes and sometimes on top of nodes. If the mode
					<html:span class="val">nodesfirst</html:span> is chosen, all nodes are drawn first, followed by the
					edges. This guarantees an edge-node overlap will not be mistaken for
					an edge ending at a node. On the other hand, usually for aesthetic
					reasons, it may be desirable that all edges appear beneath nodes, even
					if the resulting drawing is ambiguous. This can be achieved by choosing
					<html:span class="val">edgesfirst</html:span>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="breadthfirst" />
			<xsd:enumeration value="nodesfirst" />
			<xsd:enumeration value="edgesfirst" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="packMode">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					These specify the granularity of packing connected components when
					the <html:a rel="attr">pack</html:a> attribute is true. A value of <html:span class="val">node</html:span> causes
					packing at the node and edge label, with no overlapping of these objects.
					This produces a layout with the least area, but it also allows interleaving,
					where a node of one component may lie between two nodes in another
					component. A value of <html:span class="val">graph</html:span> does a packing using the bounding box of the
					component. Thus, there will be a rectangular region around a component
					free of elements of any other component.
					A value of <html:span class="val">clust</html:span> guarantees that top-level clusters are kept intact.
					What effect a value has also depends on the layout algorithm. For
					example, neato does not support clusters, so a value of <html:span class="val">clust</html:span> will
					have the same effect as the default <html:span class="val">node</html:span> value.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="node" />
			<xsd:enumeration value="clust" />
			<xsd:enumeration value="graph" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="pagedir">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					These specify the 8 row or column major orders for traversing a 
					rectangular array, the first character corresponding to the major
					order and the second to the minor order. Thus, for "BL", the
					major order is from bottom to top, and the minor order is from left
					to right. This means the bottom row is traversed first, from left
					to right, then the next row up, from left to right, and so on,
					until the topmost row is traversed.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="BL" />
			<xsd:enumeration value="BR" />
			<xsd:enumeration value="TL" />
			<xsd:enumeration value="TR" />
			<xsd:enumeration value="RB" />
			<xsd:enumeration value="RT" />
			<xsd:enumeration value="LB" />
			<xsd:enumeration value="LT" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<!--
		point
		pointf
	-->
	
	<xsd:simpleType name="pointfList">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					List of <html:a rel="type">pointf</html:a>, separated by spaces.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:list itemType="pointf" />
	</xsd:simpleType>
	<!--
		portPos
	-->
	
	<xsd:simpleType name="rankType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="same" />
			<xsd:enumeration value="min" />
			<xsd:enumeration value="source" />
			<xsd:enumeration value="max" />
			<xsd:enumeration value="sink" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="rankdir">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Corresponding to directed graphs drawn
					from top to bottom, from left to right, from bottom to top, and from
					right to left, respectively.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="TB" />
			<xsd:enumeration value="LR" />
			<xsd:enumeration value="BT" />
			<xsd:enumeration value="RL" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<!--
		rect
	-->
	
	<xsd:simpleType name="shape">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="box" />
			<xsd:enumeration value="polygon" />
			<xsd:enumeration value="ellipse" />
			<xsd:enumeration value="circle" />
			<xsd:enumeration value="point" />
			<xsd:enumeration value="egg" />
			<xsd:enumeration value="triangle" />
			<xsd:enumeration value="plaintext" />
			<xsd:enumeration value="diamond" />
			<xsd:enumeration value="trapezium" />
			<xsd:enumeration value="parallelogram" />
			<xsd:enumeration value="house" />
			<xsd:enumeration value="pentagon" />
			<xsd:enumeration value="hexagon" />
			<xsd:enumeration value="septagon" />
			<xsd:enumeration value="octagon" />
			<xsd:enumeration value="doublecircle" />
			<xsd:enumeration value="doubleoctagon" />
			<xsd:enumeration value="tripleoctagon" />
			<xsd:enumeration value="invtriangle" />
			<xsd:enumeration value="invtrapezium" />
			<xsd:enumeration value="invhouse" />
			<xsd:enumeration value="Mdiamond" />
			<xsd:enumeration value="Msquare" />
			<xsd:enumeration value="Mcircle" />
			<xsd:enumeration value="rect" />
			<xsd:enumeration value="rectangle" />
			<xsd:enumeration value="none" />
			<xsd:enumeration value="note" />
			<xsd:enumeration value="tab" />
			<xsd:enumeration value="box3d" />
			<xsd:enumeration value="component" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<!--
		splineType
		startType
		style
		viewPort
	-->
	
	<!--  ATTRIBUTES -->

	<xsd:attribute name="imagepath" type="xsd:string" default="UTF-8">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies the path to images referenced within the graph.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="Damping" type="xsd:decimal" default="0.99" gv:layouts="neato">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Factor damping force motions. On each iteration, a nodes movement
					is limited to this factor of its potential motion. By being less than
					1.0, the system tends to "cool", thereby preventing cycling.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="K" type="xsd:decimal" default="0.3" gv:layouts="fdp">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Spring constant used in virtual physical model. It roughly corresponds
					to an ideal edge length (in inches), in that increasing K tends to 
					increase the distance between nodes.
					Note that the edge attribute <html:a rel="attr">len</html:a> can be used to
					override this value for adjacent nodes.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="URL" type="xsd:anyURI" gv:formats="svg ps ps2 map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Hyperlinks incorporated into device-dependent output. 
					At present, used in ps2, cmap, i*map and svg formats. 
					For all these formats, URLs can be attached to nodes, edges and
					clusters. URL attributes can also be attached to the root graph in ps2,
					cmap and i*map formats. This serves as the base URL for relative URLs in the 
					former, and as the default image map file in the latter.
				</html:p>
				<html:p>
					For svg, cmapx and imap output, the active area for a node is its 
					visible image. 
					For example, an unfilled node with no drawn boundary will only be active on its label. 
					For other output, the active area is its bounding box.
					The active area for a cluster is its bounding box. 
					For edges, the active areas are small circles where the edge contacts its head
					and tail nodes. In addition, for svg, cmapx and imap, the active area 
					includes a thin polygon approximating the edge. The circles may 
					overlap the related node, and the edge URL dominates.
					If the edge has a label, this will also be active. 
					Finally, if the edge has a head or tail label, this will also be active.
				</html:p>
				<html:p>
					Note that, for edges, the attributes <html:a rel="attr">headURL</html:a>,
					<html:a rel="attr">tailURL</html:a>, <html:a rel="attr">labelURL</html:a> and
					<html:a rel="attr">edgeURL</html:a> allow control of various parts of an
					edge. Also note that, if active areas of two edges overlap, it is unspecified 
					which area dominates.
				</html:p>
  			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="arrowhead" type="arrowType" default="normal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Style of arrowhead on the head node of an edge. 
					See also the <html:a rel="attr">dir</html:a> attribute, 
					and the <html:a rel="note">undirected</html:a> note.			
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="arrowsize" type="xsd:decimal" default="1.0">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Multiplicative scale factor for arrowheads.			
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="arrowtail" type="arrowType" default="normal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Style of arrowhead on the tail node of an edge. 
					See also the <html:a rel="attr">dir</html:a> attribute, 
					and the <html:a rel="note">undirected</html:a> note.			
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="bb" type="rect">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Bounding box of drawing in integer points.			
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="bgcolor" type="color">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					When attached to the root graph, this color is used as the background for 
					entire canvas. When a cluster attribute, it is used as the initial
					background for the cluster. If a cluster has a filled 
					<html:a rel="attr">style</html:a>, the
					cluster's <html:a rel="attr">fillcolor</html:a> will overlay the 
					background color.
				</html:p>
				<html:p>
					If no background color is specified for the root graph, no graphics
					operation are performed on the background. This works fine for
					PostScript but for bitmap output, all bits are initialized to something.
					This means that when the bitmap output is included in some other
					document, all of the bits within the bitmap's bounding box will be
					set, overwriting whatever color or graphics where already on the page.
					If this effect is not desired, and you only want to set bits explicitly
					assigned in drawing the graph, set <html:a rel="attr">bgcolor</html:a>="transparent".
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="center" type="xsd:boolean" default="false">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true, the drawing is centered in the output canvas.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="charset" type="xsd:string" default="UTF-8">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies the character encoding used when interpreting string input
					as a text label. The default value is <html:span class="val">UTF-8</html:span>.
					The other legal value is <html:span class="val">iso-8859-1</html:span> or, 
					equivalently,
					<html:span class="val">Latin1</html:span>. The <html:a rel="attr">charset</html:a> attribute is case-insensitive.
					Note that if the character encoding used in the input does not
					match the <html:a rel="attr">charset</html:a> value, the resulting output may be very strange.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="clusterrank" type="clusterMode" default="local" gv:layouts="dot">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Mode used for handling clusters. If <html:a rel="attr">clusterrank</html:a> is <html:span class="val">local</html:span>, a
					subgraph whose name begins with "cluster" is given special treatment.
					The subgraph is laid out separately, and then integrated as a unit into
					its parent graph, with a bounding rectangle drawn about it. 
					If the cluster has a <html:a rel="attr">label</html:a> parameter, this label
					is displayed within the rectangle.
					Note also that there can be clusters within clusters.
					At present, the modes <html:span class="val">global</html:span> and <html:span class="val">none</html:span>
					appear to be identical, both turning off the special cluster processing.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="color" type="colorList" default="black">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Basic drawing color for graphics, not text. For the latter, use the
					<html:a rel="attr">fontcolor</html:a> attribute.
				</html:p>
				<html:p>
					For edges, the value
					can either be a single <html:a rel="type">color</html:a> or a <html:a rel="type">colorList</html:a>.
					In the latter case, the edge is drawn using parallel splines or lines,
					one for each color in the list, in the order given.
					The head arrow, if any, is drawn using the first color in the list, 
					and the tail arrow, if any, the second color. This supports the common 
					case of drawing opposing edges, but using parallel splines instead of 
					separately routed multiedges.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="colorscheme" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This attribute specifies a color scheme namespace. If defined, it specifies
					the context for interpreting color names. In particular, if a 
					<html:a rel="type">color</html:a> value has form <html:code>xxx</html:code> or <html:code>//xxx</html:code>, 
					then the color <html:code>xxx</html:code> will be evaluated according to the current color scheme.
					If no color scheme is set, the standard X11 naming is used.
					For example, if <html:code>colorscheme=bugn9</html:code>, then <html:code>color=7</html:code>
					is interpreted as <html:code>/bugn9/7</html:code>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="comment" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Comments are inserted into output. Device-dependent.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="compound" type="xsd:boolean" default="false" gv:layouts="dot">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:span class="val">true</html:span>, allow edges between clusters. (See <html:a rel="attr">lhead</html:a> and <html:a rel="attr">ltail</html:a> below.)
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="concentrate" type="xsd:boolean" default="false" gv:layouts="dot">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:span class="val">true</html:span>, use edge concentrators.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="constraint" type="xsd:boolean" default="true" gv:layouts="dot">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:span class="val">false</html:span>, the edge is not used in ranking the nodes.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="decorate" type="xsd:boolean" default="false">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:span class="val">true</html:span>, attach edge label to edge by a 2-segment
					polyline, underlining the label, then going to the closest point of spline.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="defaultdist" type="xsd:decimal" gv:layouts="neato">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This specifies the distance between nodes in separate connected
					components. If set too small, connected components may overlap.
					Only applicable if <html:a rel="attr">pack</html:a>=false.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="dim" type="xsd:integer" default="2" gv:layouts="fdp neato">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Set the number of dimensions used for the layout. The maximum value
					allowed is 10.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="dir" type="dirType">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Set edge type for drawing arrowheads. This indicates which ends of the
					edge should be decorated with an arrowhead. The actual style of the
					arrowhead can be specified using the <html:a rel="attr">arrowhead</html:a>
					and <html:a rel="attr">arrowtail</html:a> attributes.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="diredgeconstraints" type="xsd:string" default="false" gv:layouts="neato">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Only valid when <html:a rel="attr">mode</html:a>="ipsep".
					If <html:span class="val">true</html:span>, constraints are generated for each edge in the largest (heuristic) 
					directed acyclic subgraph such that the edge must point downwards.
					If <html:span class="val">hier</html:span>, generates level constraints similar to those used with
					<html:a rel="attr">mode</html:a>="hier". The main difference is that, in the latter
					case, only these constraints are involved, so a faster solver can be used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="distortion" type="xsd:decimal" default="0.0">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Distortion factor for <html:a rel="attr">shape</html:a>=polygon. 
					Positive values cause top part to
					be larger than bottom; negative values do the opposite.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="dpi" type="xsd:decimal" default="96.0">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This specifies the expected number of pixels per inch on a display device.
					For bitmap output, this guarantees that text rendering will be
					done more accurately, both in size and in placement. For SVG output,
					it is used to guarantee that the dimensions in the output correspond to
					the correct number of points or inches.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="edgeURL" type="xsd:anyURI" gv:formats="svg map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:a rel="attr">edgeURL</html:a> is defined, this is the link used for the non-label
					parts of an edge. This value overrides any <html:a rel="attr">URL</html:a>
					defined for the edge.
					Also, this value is used near the head or tail node unless overridden
					by a <html:a rel="attr">headURL</html:a> or <html:a rel="attr">tailURL</html:a> value,
					respectively.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="edgehref" type="xsd:anyURI" gv:formats="svg map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Synonym for <html:a rel="attr">edgeURL</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="edgetarget" type="escString" gv:formats="svg map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the edge has a <html:a rel="attr">URL</html:a> or <html:a rel="attr">edgeURL</html:a>
					attribute, this attribute determines which window of the 
					browser is used
					for the URL attached to the non-label part of the edge. 
					Setting it to "_graphviz" will open a new window if it 
					doesn't already exist, or reuse it if it does.
					If undefined, the value of the <html:a rel="attr">target</html:a> is used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="edgetooltip" type="escString" gv:formats="svg cmap">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Tooltip annotation attached to the non-label part of an edge. 
					This is used only if the edge has a <html:a rel="attr">URL</html:a> 
					or <html:a rel="attr">edgeURL</html:a> attribute.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="epsilon" type="xsd:decimal" gv:layouts="neato">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Terminating condition. If the length squared of all energy gradients are
					&lt; <html:a rel="attr">epsilon</html:a>, the algorithm stops.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="esep" type="xsd:decimal" gv:layouts="neato circo fdp">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Fraction to increase polygons (multiply
					coordinates by 1 + esep) for purposes of spline edge routing. 
					This should normally be strictly less than 
					<html:a rel="attr">sep</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fillcolor" type="color">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Color used to fill the background of a node or cluster 
					assuming <html:a rel="attr">style</html:a>=filled.
					If <html:a rel="attr">fillcolor</html:a> is not defined, <html:a rel="attr">color</html:a> is 
					used. (For clusters, if <html:a rel="attr">color</html:a> is not defined, 
					<html:a rel="attr">bgcolor</html:a> is used.) If this is not defined,
					the default is used, except for 
					<html:a rel="attr">shape</html:a>=point or when the output
					format is MIF,
					which use black by default.
				</html:p>
				<html:p>
					Note that a cluster inherits the root graph's attributes if defined.
					Thus, if the root graph has defined a <html:a rel="attr">fillcolor</html:a>, this will override a
					<html:a rel="attr">color</html:a> or <html:a rel="attr">bgcolor</html:a> attribute set for the cluster.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fixedsize" type="xsd:boolean" default="false">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true, the node size is specified by the values of the
					<html:a rel="attr">width</html:a>  
					and <html:a rel="attr">height</html:a> attributes only 
					and is not expanded to contain the text label.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fontcolor" type="color" default="black">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Color used for text.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fontname" type="xsd:string" default="Times-Roman">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Font used for text. This very much depends on the output format and, for 
					non-bitmap output such as PostScript or SVG, the availability of the font
					when the graph is displayed or printed. As such, it is best to rely on
					font faces that are generally available, such as Times-Roman, Helvetica or
					Courier.
				</html:p>
				<html:p>
					If Graphviz was built using the 
					<html:a href="http://pdx.freedesktop.org/~fontconfig/fontconfig-user.html">fontconfig library</html:a>, the latter library
					will be used to search for the font. However, if the <html:a rel="attr">fontname</html:a> string
					contains a slash character "/", it is treated as a pathname for the font
					file, though font lookup will append the usual font suffixes.
				</html:p>
				<html:p>
					If Graphviz does not use fontconfig, <html:a rel="attr">fontname</html:a> will be
					considered the name of a Type 1 or True Type font file. 
					If you specify <html:code>fontname=schlbk</html:code>, the tool will look for a 
					file named  <html:code>schlbk.ttf</html:code> or <html:code>schlbk.pfa</html:code> or <html:code>schlbk.pfb</html:code>
					in one of the directories specified by 
					the <html:a rel="attr">fontpath</html:a> attribute.
					The lookup does support various aliases for the common fonts.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fontnames" type="xsd:string" gv:formats="svg">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Allows user control of how basic fontnames are represented in SVG output.
					If <html:a rel="attr">fontnames</html:a> is undefined or <html:span class="val">svg</html:span>, 
					the output will try to use known SVG fontnames. For example, the
					default font <html:code>Times-Roman</html:code> will be mapped to the
					basic SVG font <html:code>serif</html:code>. This can be overridden by setting
					<html:a rel="attr">fontnames</html:a> to <html:span class="val">ps</html:span> or <html:span class="val">gd</html:span>.
					In the former case, known PostScript font names such as
					<html:code>Times-Roman</html:code> will be used in the output.
					In the latter case, the fontconfig font conventions
					are used. Thus, <html:code>Times-Roman</html:code> would be treated as
					<html:code>Nimbus Roman No9 L</html:code>. These last two options are useful
					with SVG viewers that support these richer fontname spaces.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fontpath" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Directory list used by libgd to search for bitmap fonts if Graphviz
					was not built with the fontconfig library.
					If <html:a rel="attr">fontpath</html:a> is not set, the environment 
					variable <html:code>DOTFONTPATH</html:code> is checked.
					If that is not set, <html:code>GDFONTPATH</html:code> is checked.
					If not set, libgd uses its compiled-in font path.
					Note that fontpath is an attribute of the root graph.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="fontsize" type="xsd:decimal" default="14.0">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Font size, in <html:a rel="note">points</html:a>, used for text.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="group" type="xsd:string" gv:layouts="dot">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the end points of an edge belong to the same group, i.e., have the
					same group attribute, parameters are set to avoid crossings and keep
					the edges straight.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headURL" type="xsd:anyURI" gv:formats="svg map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:a rel="attr">headURL</html:a> is defined, it is
					output as part of the head label of the edge. 
					Also, this value is used near the head node, overriding any
					<html:a rel="attr">URL</html:a> value.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headclip" type="xsd:boolean" default="true">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:span class="val">true</html:span>, the head of an edge is clipped to the boundary of the head node;
					otherwise, the end of the edge goes to the center of the node, or the
					center of a port, if applicable.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headhref" type="xsd:anyURI" gv:formats="svg map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Synonym for <html:a rel="attr">headURL</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headlabel" type="lblString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Text label to be placed near head of edge.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headport" type="portPos" default="center">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Indicates where on the head node to attach the head of the edge.
					In the default case, the edge is aimed towards the center of the node,
					and then clipped at the node boundary.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headtarget" type="escString" gv:formats="svg map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the edge has a <html:a rel="attr">headURL</html:a>, 
					this attribute determines which window of the 
					browser is used
					for the URL. Setting it to "_graphviz" will open a new window if it 
					doesn't already exist, or reuse it if it does.
					If undefined, the value of the <html:a rel="attr">target</html:a> is used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="headtooltip" type="escString" gv:formats="svg cmap">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Tooltip annotation attached to the head of an edge. This is used only
					if the edge has a <html:a rel="attr">headURL</html:a> attribute.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="height" type="xsd:decimal" default="0.5">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Height of node, in inches. This is taken as the initial, minimum height
					of the node. If <html:a rel="attr">fixedsize</html:a> is true, this
					will be the final height of the node. Otherwise, if the node label
					requires more height to fit, the node's height will be increased to
					contain the label. Note also that, if the output format is dot, the
					value given to <html:a rel="attr">height</html:a> will be the final value.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="href" type="xsd:anyURI" gv:formats="svg ps ps2 map">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Synonym for <html:a rel="attr">URL</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="image" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Gives the name of a file containing an image to be displayed inside
					a node. The image file must be in one of the recognized formats, 
					typically JPEG, PNG, GIF or Postscript, and be able to be converted
					into the desired output format.  
				</html:p>
				<html:p>
					Unlike with the <html:a rel="attr">shapefile</html:a> attribute, 
					the image is treated as node
					content rather than the entire node. In particular, an image can
					be contained in a node of any shape, not just a rectangle.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="imagescale" type="xsd:string" default="false">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Attribute controlling how an image fills its
					containing node. In general, the image is given its natural size,
					(cf. <html:a rel="attr">dpi</html:a>),
					and the node size is made large enough to contain its image, its
					label, its margin, and its peripheries. 
					Its width and height will also be at least as large as its
					minimum <html:a rel="attr">width</html:a> and <html:a rel="attr">height</html:a>. 
					If, however, <html:code>fixedsize=true</html:code>,
					the width and height attributes specify the exact size of the node. 
				</html:p>
				<html:p>
					During rendering, in the default case (<html:code>imagescale=false</html:code>),
					the image retains its natural size.
					If <html:span class="val">true</html:span>,
					the image is uniformly scaled (i.e., its aspect ratio is
					preserved) to fit inside the node. 
					At least one dimension of the image will be as large as possible
					given the size of the node.
					When <html:span class="val">width</html:span>,
					the width of the image is scaled to fill the node width.
					The corresponding property holds when <html:tt>imagescale=height</html:tt>.
					When <html:span class="val">both</html:span>,
					both the height and the width are scaled separately to fill the node.
				</html:p>
				<html:p>
					In all cases, if a dimension of the image is larger than the
					corresponding dimension of the node, that dimension of the
					image is scaled down to fit the node. As with the case of
					expansion, if <html:code>imagescale=true</html:code>, width and height are
					scaled uniformly.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="label" type="lblString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Text label attached to objects.
					If a node's <html:a rel="attr">shape</html:a> is record, then the label can
					have a <html:a href="http://www.graphviz.org/doc/info/shapes.html#record">special format</html:a> 
					which describes the record layout.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelURL" type="xsd:anyURI">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:a rel="attr">labelURL</html:a> is defined, this is the link used for the label
					of an edge. This value overrides any <html:a rel="attr">URL</html:a>
					defined for the edge.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelangle" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This, along with <html:a rel="attr">labeldistance</html:a>, determine 
					where the
					headlabel (taillabel) are placed with respect to the head (tail)
					in polar coordinates. The origin in the coordinate system is
					the point where the edge touches the node. The ray of 0 degrees
					goes from the origin back along the edge, parallel to the edge
					at the origin. 
				</html:p>
				<html:p>
					The angle, in degrees, specifies the rotation from the 0 degree ray,
					with positive angles moving counterclockwise and negative angles
					moving clockwise.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labeldistance" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Multiplicative scaling factor adjusting the distance that 
					the headlabel (taillabel) is from the head (tail) node.
					The default distance is 10 points. See <html:a rel="attr">labelangle</html:a>
					for more details.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelfloat" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true, allows edge labels to be less constrained in position.
					In particular, it may appear on top of other edges.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelfontcolor" type="color">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Color used for headlabel and taillabel.
					If not set, defaults to edge's fontcolor.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelfontname" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Font used for headlabel and taillabel. 
					If not set, defaults to edge's fontname.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelfontsize" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Font size, in <html:a rel="note">points</html:a>, used for headlabel and taillabel.
					If not set, defaults to edge's fontsize.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelhref" type="xsd:anyURI">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Synonym for <html:a rel="attr">labelURL</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labeljust" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Justification for cluster labels. If <html:span class="val">r</html:span>, the label
					is right-justified within bounding rectangle; if <html:span class="val">l</html:span>, left-justified;
					else the label is centered.
					Note that a subgraph inherits attributes from its parent. Thus, if
					the root graph sets <html:a rel="attr">labeljust</html:a> to <html:span class="val">l</html:span>, the subgraph inherits
					this value.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labelloc" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Top/bottom placement of graph and cluster labels. 
					If the attribute is <html:span class="val">t</html:span>, place label at the top;
					if the attribute is <html:span class="val">b</html:span>, place label at the bottom.
					By default, root
					graph labels go on the bottom and cluster labels go on the top.
					Note that a subgraph inherits attributes from its parent. Thus, if
					the root graph sets <html:a rel="attr">labelloc</html:a> to <html:span class="val">b</html:span>, the subgraph inherits
					this value.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labeltarget" type="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the edge has a <html:a rel="attr">URL</html:a> or <html:a rel="attr">labelURL</html:a>
					attribute, this attribute determines which window of the 
					browser is used
					for the URL attached to the label.
					Setting it to "_graphviz" will open a new window if it 
					doesn't already exist, or reuse it if it does.
					If undefined, the value of the <html:a rel="attr">target</html:a> is used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="labeltooltip" type="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Tooltip annotation attached to label of an edge. 
					This is used only if the edge has a <html:a rel="attr">URL</html:a> 
					or <html:a rel="attr">labelURL</html:a> attribute.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="landscape" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true, the graph is rendered in landscape mode. Synonymous with
					<html:code><html:a rel="attr">rotate</html:a>=90</html:code> or 
					<html:code><html:a rel="attr">orientation</html:a>=landscape</html:code>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="layer" type="layerRange">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies layers in which the node or edge is present.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="layers" type="layerList">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies a linearly ordered list of layer names attached to the graph
					The graph is then output in separate layers. Only those components 
					belonging to the current output layer appear. For more information,
					see the page <html:a href="http://www.graphviz.org/Documentation/html/layers/">How to use drawing layers (overlays)</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="layersep" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies the separator characters used to split the 
					<html:a rel="attr">layers </html:a>attribute into a list of layer names.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="layout" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies the name of the layout algorithm to use, such as <html:span class="val">dot</html:span>
					or <html:span class="val">neato</html:span>. Normally, graphs should be kept independent of a type of
					layout. In some cases, however, it can be convenient to embed the type
					of layout desired within the graph. For example, a graph containing
					position information from a layout might want to record what the
					associated layout algorithm was.
				</html:p>
				<html:p>
					This attribute takes precedence over 
					the <html:a href="http://www.graphviz.org/doc/info/command.html#minusK">-K flag</html:a> 
					or the actual command name used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="len" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Preferred edge length, in inches.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="levelsgap" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies strictness of level constraints in neato
					when <html:code><html:a rel="attr">mode</html:a>="ipsep" or "hier"</html:code>.
					Larger positive values mean stricter constraints, which demand more 
					separation between levels. On the other hand, negative values will relax 
					the constraints by allowing some overlap between the levels.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="lhead" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Logical head of an edge. When <html:a rel="attr">compound</html:a> is true,
					if <html:a rel="attr">lhead</html:a> is defined and is the name of a cluster containing 
					the real head,
					the edge is clipped to the boundary of the cluster.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="lp" type="point">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Label position, in <html:a rel="note">points</html:a>.
					The position indicates the center of the label.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="ltail" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Logical tail of an edge. When <html:a rel="attr">compound</html:a> is true,
					if <html:a rel="attr">ltail</html:a> is defined and is the name of a cluster 
					containing the real tail,
					the edge is clipped to the boundary of the cluster.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="margin" type="pointf">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					For graphs, this sets x and y margins of canvas, in inches. If the margin
					is a single double, both margins are set equal to the given value.
				</html:p>
				<html:p>
					Note that the margin is not part of the drawing but just empty space 
					left around the drawing. It basically corresponds to a translation of 
					drawing, as would be necessary to center a drawing on a page. Nothing
					is actually drawn in the margin. To actually extend the background of
					a drawing, see the <html:a rel="attr">pad</html:a> attribute.
				</html:p>
				<html:p>
					For nodes, this attribute specifies space left around the node's label.
					By default, the value is <html:code>0.11,0.055</html:code>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="maxiter" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Sets the number of iterations used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="mclimit" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Multiplicative scale factor used to alter the MinQuit (default = 8)
					and MaxIter (default = 24) parameters used during crossing
					minimization. These correspond to the 
					number of tries without improvement before quitting and the
					maximum number of iterations in each pass.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="mindist" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specifies the minimum separation between all nodes.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="minlen" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
				Minimum edge length (rank difference between head and tail).
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="mode" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Technique for optimizing the layout. If <html:a rel="attr">mode</html:a> is <html:span class="val">major</html:span>,
					neato uses stress majorization. If <html:a rel="attr">mode</html:a> is <html:span class="val">KK</html:span>,
					neato uses a version of the gradient descent method. The only advantage
					to the latter technique is that it is sometimes appreciably faster for
					small (number of nodes &lt; 100) graphs. A significant disadvantage is that
					it may cycle.
				</html:p>
				<html:p>
					There are two new, experimental modes in neato, <html:span class="val">hier</html:span>, which adds a top-down
					directionality similar to the layout used in dot, and <html:span class="val">ipsep</html:span>, which 
					allows the graph to specify minimum vertical and horizontal distances
					between nodes. (See the <html:a rel="attr">sep</html:a> attribute.)
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="model" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This value specifies how the distance matrix is computed for the input
					graph. The distance matrix specifies the ideal distance between every
					pair of nodes. neato attemps to find a layout which best achieves
					these distances. By default, it uses the length of the shortest path,
					where the length of each edge is given by its <html:a rel="attr">len</html:a>
					attribute. If <html:a rel="attr">model</html:a> is <html:span class="val">circuit</html:span>, neato uses the
					circuit resistance 
					model to compute the distances. This tends to emphasize clusters. If
					<html:a rel="attr">model</html:a> is <html:span class="val">subset</html:span>, neato uses the subset model. This sets the
					edge length to be the number of nodes that are neighbors of exactly one
					of the end points, and then calculates the shortest paths. This helps
					to separate nodes with high degree. 
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="mosek" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If Graphviz is built with MOSEK defined, mode=ipsep and mosek=true, 
					the Mosek software (www.mosek.com) is use to solve the ipsep constraints.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="nodesep" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Minimum space between two adjacent nodes in the same rank, in inches.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="nojustify" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					By default, the justification of multi-line labels is done within the
					largest context that makes sense. Thus, in the label of a polygonal
					node, a left-justified line will align with the left side of the node
					(shifted by the prescribed <html:a rel="attr">margin</html:a>).
					In record nodes, left-justified
					line will line up with the left side of the enclosing column of fields.
					If <html:a rel="attr">nojustify</html:a> is <html:span class="val">true</html:span>, multi-line labels will be justified 
					in the context of itself. For example, if the attribute is set, 
					the first label line is long, and the second is shorter and left-justified,
					the second will align with the left-most character in the first line,
					regardless of  how large the node might be.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="normalize" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If set, normalize coordinates of final
					layout so that the first point is at the origin, and then rotate the
					layout so that the first edge is horizontal.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="nslimit" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Used to set number of iterations in
					network simplex applications, used in
					computing node x coordinates.
					If defined, # iterations =  <html:a rel="attr">nslimit</html:a> * # nodes;
					otherwise,  # iterations = MAXINT.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>

	<xsd:attribute name="nslimit1" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Used to set number of iterations in
					network simplex applications, used for ranking nodes.
					If defined, # iterations =  <html:a rel="attr">nslimit1</html:a> * # nodes;
					otherwise,  # iterations = MAXINT.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="ordering" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If "out" for a graph G, and n is a node in G, then edges n-&gt;* appear
					left-to-right in the same order in which they are defined.
					If "in", the edges *-&gt;n appear
					left-to-right in the same order in which they are defined for all
					nodes n.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<!--
	<xsd:attribute name="orientation" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				Angle, in degrees, used to rotate node shapes.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="orientation" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				If "[lL]*", set graph orientation to landscape
				Used only if <html:a rel="attr">rotate</html:a> is not defined.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	-->
	
	<xsd:attribute name="outputorder" type="outputMode">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Specify order in which nodes and edges are drawn.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="overlap" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Determines if and how node overlaps should be removed. Nodes are first
					enlarged using the <html:a rel="attr">sep</html:a> attribute. 
					If <html:span class="val">true</html:span>, overlaps are retained.
					If the value is <html:span class="val">scale</html:span>, overlaps are removed by uniformly scaling in x and y.
					If the value converts to <html:span class="val">false</html:span>, node overlaps are removed by a 
					Voronoi-based technique. 
					If the value is <html:span class="val">scalexy</html:span>, x and y are separately
					scaled to remove overlaps. 
					If the value is <html:span class="val">orthoxy</html:span> or <html:span class="val">orthoyx</html:span>, overlaps
					are moved by optimizing two constraint problems, one for the x axis and
					one for the y. The suffix indicates which axis is processed first.
					If the value is <html:span class="val">ortho</html:span>, the technique is similar to <html:span class="val">orthoxy</html:span> except a
					heuristic is used to reduce the bias between the two passes.
					If the value is <html:span class="val">ortho_yx</html:span>, the technique is the same as <html:span class="val">ortho</html:span>, except
					the roles of x and y are reversed.
					The values <html:span class="val">portho</html:span>, <html:span class="val">porthoxy</html:span>, <html:span class="val">porthoxy</html:span>, and <html:span class="val">portho_yx</html:span> are similar
					to the previous four, except only pseudo-orthogonal ordering is
					enforced.
				</html:p>
				<html:p>
					If the value is <html:span class="val">compress</html:span>, the layout will be scaled down as much as
					possible without introducing any overlaps, obviously assuming there are
					none to begin with.
				</html:p>
				<html:p>
					If the value is <html:span class="val">ipsep</html:span>, and the layout is done by neato with 
					<html:a rel="attr">mode</html:a>="ipsep", the overlap removal constraints are
					incorporated into the layout algorithm itself.
					N.B. At present, this only supports one level of clustering.
				</html:p>
				<html:p>
					If the value is <html:span class="val">vpsc</html:span>, overlap removal is similarly to <html:span class="val">ortho</html:span>, except
					quadratic optimization is used to minimize node displacement.
					N.B. At present, this mode only works when <html:a rel="attr">mode</html:a>="ipsep".
				</html:p>
				<html:p>
					Except for fdp, the layouts assume <html:code>overlap="true"</html:code> as the default. 
					Fdp first uses a number of passes using built-in, force-directed technique
					to remove overlaps. Thus, fdp accepts <html:a rel="attr">overlap</html:a> with an integer
					prefix followed by a colon, specifying the number of tries. If there is
					no prefix, no initial tries will be performed. If there is nothing following
					a colon, none of the above methods will be attempted. By default, fdp
					uses <html:code>overlap="9:portho"</html:code>. Note that <html:code>overlap="true"</html:code>,
					<html:code>overlap="0:true"</html:code> and <html:code>overlap="0:"</html:code> all turn off all overlap
					removal.
				</html:p>
				<html:p>
					Except for the Voronoi method, all of these transforms preserve the
					orthogonal ordering of the original layout. That is, if the x coordinates
					of two nodes are originally the same, they will remain the same, and if
					the x coordinate of one node is originally less than the x coordinate of
					another, this relation will still hold in the transformed layout. The
					similar properties hold for the y coordinates.
					This is not quite true for the "porth*" cases. For these, orthogonal
					ordering is only preserved among nodes related by an edge.
				</html:p>
				<html:p>
					<html:b>NOTE</html:b>The methods <html:span class="val">orthoxy</html:span> and <html:span class="val">orthoyx</html:span> are still evolving. The semantics of these may change, or these methods may disappear altogether.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="pack" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This is true if the value of pack is <html:span class="val">true</html:span> (case-insensitive) or a
					non-negative integer. If true, each connected component of the graph is 
					laid out separately, and then the graphs are packed tightly. 
					If pack has an integral value, this is used as the size,
					in <html:a href="#points">points</html:a>, of
					a margin around each part; otherwise, a default margin of 8 is used.
					If pack is interpreted as false, the entire graph is laid out together.
					The granularity and method of packing is influenced by the
					<html:a rel="attr">packmode</html:a> attribute.
				</html:p>
				<html:p>
					For layouts which always do packing, such a twopi, the <html:a rel="attr">pack</html:a>
					attribute is just used to set the margin.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="packmode" type="packMode">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This indicates the granularity and method used for packing
					(cf. <html:a rel="type">packMode</html:a>). Note that defining
					<html:a rel="attr">packmode</html:a> will automatically turn on packing as though one had
					set <html:code>pack=true</html:code>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="pad" type="pointf">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					The pad attribute specifies how much, in inches, to extend the 
					drawing area around the minimal area needed to draw the graph.
					If the pad is a single double, both the x and y pad values are set 
					equal to the given value. This area is part of the
					drawing and will be filled with the background color, if appropriate. 
				</html:p>
				<html:p>
					Normally, a small pad is used for aesthetic reasons, especially when
					a background color is used, to avoid having nodes and edges abutting
					the boundary of the drawn region.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="page" type="pointf">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Width and height of output pages, in inches. If this is set and is
					smaller than the size of the layout, a rectangular array of pages of
					the specified page size is overlaid on the layout, with origins
					aligned in the lower-left corner, thereby partitioning the layout
					into pages. The pages are then produced one at a time, in
					<html:a rel="attr">pagedir</html:a> order.
				</html:p>
				<html:p>
					At present, this only works for PostScript output. For other types of
					output, one should use another tool to split the output into multiple
					output files. Or use the <html:a rel="attr">viewport</html:a> to generate
					multiple files.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="pagedir" type="pagedir">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the <html:a rel="attr">page</html:a> attribute is set and applicable,
					this attribute specifies the order in which the pages are emitted.
					This is limited to one of the 8 row or column major orders.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="pencolor" type="color">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Color used to draw the bounding box around a cluster.
					If <html:a rel="attr">pencolor</html:a> is not defined, <html:a rel="attr">color</html:a> is 
					used. If this is not defined, <html:a rel="attr">bgcolor</html:a> is used.
					If this is not defined, the default is used.
				</html:p>
				<html:p>
					Note that a cluster inherits the root graph's attributes if defined.
					Thus, if the root graph has defined a <html:a rel="attr">pencolor</html:a>, this will override a
					<html:a rel="attr">color</html:a> or <html:a rel="attr">bgcolor</html:a> attribute set for the cluster.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="peripheries" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Set number of peripheries used in polygonal shapes and cluster
					boundaries. Note that
					<html:a href="http://www.graphviz.org/doc/info/shapes.html#epsf">user-defined shapes</html:a> are treated as a 
					form of box shape, so the default
					peripheries value is 1 and the user-defined shape will be drawn in
					a bounding rectangle. Setting <html:code>peripheries=0</html:code> will turn this off.
					Also, 1 is the maximum peripheries value for clusters.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="pin" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true and the node has a pos attribute on input, neato prevents the
					node from moving from the input position. This property can also be specified
					in the pos attribute itself (cf. the <html:a rel="attr">point</html:a> type).
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="pos" type="splineType">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Position of node, or spline control points.
					For nodes, the position indicates the center of the node.
					On output, the coordinates are in <html:a href="#points">points</html:a>.
				</html:p>
				<html:p>
					In neato and fdp, pos can be used to set the initial position of a node.
					By default, the coordinates are assumed to be in inches. However, the
					<html:a href="http://www.graphviz.org/doc/info/command.html#d:s">-s</html:a> command line flag can be used to specify
					different units.
				</html:p>
				<html:p>
					When the <html:a href="http://www.graphviz.org/doc/info/command.html#d:n">-n</html:a> command line flag is used with
					neato, it is assumed the positions have been set by one of the layout
					programs, and are therefore in points. Thus, <html:code>neato -n</html:code> can accept
					input correctly without requiring a <html:code>-s</html:code> flag and, in fact, 
					ignores any such flag.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="quantum" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:a rel="attr">quantum</html:a> &gt; 0.0, node label dimensions
					will be rounded to integral multiples of the quantum.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="rank" type="rankType">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Rank constraints on the nodes in a subgraph.
					If <html:span class="val">same</html:span>, all nodes are placed on the same rank. 
					If <html:span class="val">min</html:span>, all nodes are placed on the minimum rank. 
					If <html:span class="val">source</html:span>, all nodes are placed on the minimum rank, and
					the only nodes on the minimum rank belong to some subgraph whose
					rank attribute is "source" or "min". 
					Analogous criteria hold for <html:a rel="attr">rank</html:a>=<html:span class="val">max</html:span> and <html:a rel="attr">rank</html:a>=<html:span class="val">sink</html:span>.
					(Note: the
					minimum rank is topmost or leftmost, and the maximum rank is bottommost
					or rightmost.)
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="rankdir" type="rankdir">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Sets direction of graph layout. For example, if <html:a rel="attr">rankdir</html:a>="LR", 
					and barring cycles, an edge <html:code>T -&gt; H;</html:code> will go
					from left to right. By default, graphs are laid out from top to bottom.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="ranksep" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					In dot, this gives the desired rank separation, in inches. This is
					the minimum vertical distance between the bottom of the nodes in one
					rank and the tops of nodes in the next. If the value
					contains "equally", the centers of all ranks are spaced equally apart.
					Note that both
					settings are possible, e.g., ranksep = "1.2 equally".
					In twopi, specifies radial separation of concentric circles.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="ratio" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Sets the aspect ratio (drawing height/drawing width) for the drawing. 
					Note that this is adjusted before
					the <html:a rel="attr">size</html:a> attribute constraints are enforced.
				</html:p>
				<html:p>
					If <html:a rel="attr">ratio</html:a> is numeric, it is taken as the desired aspect ratio.
					Then, if the actual aspect ratio is less than the desired ratio, 
					the drawing height is scaled up to achieve the
					desired ratio; if the actual ratio is greater than that desired ratio, 
					the drawing width is scaled up.
				</html:p>
				<html:p>
					If <html:a rel="attr">ratio</html:a> = <html:span class="val">fill</html:span> and the <html:a rel="attr">size</html:a>
					attribute is set, node positions are scaled, separately in both x
					and y, so that the final drawing exactly fills the specified size.
				</html:p>
				<html:p>
					If <html:a rel="attr">ratio</html:a> = <html:span class="val">compress</html:span> and the <html:a rel="attr">size</html:a>
					attribute is set, dot attempts to compress the initial layout to fit 
					in the given size. This achieves a tighter packing of nodes but 
					reduces the balance and symmetry. This feature only works in dot.
				</html:p>
				<html:p>
					If <html:a rel="attr">ratio</html:a> = <html:span class="val">expand</html:span>, the <html:a rel="attr">size</html:a>
					attribute is set, and both the width and the height of the graph are
					less than the value in  <html:a rel="attr">size</html:a>, node positions are scaled 
					uniformly until at least
					one dimension fits <html:a rel="attr">size</html:a> exactly.
					Note that this is distinct from using <html:a rel="attr">size</html:a> as the
					desired size, as here the drawing is expanded before edges are generated and
					all node and text sizes remain unchanged.
				</html:p>
				<html:p>
					If <html:a rel="attr">ratio</html:a> = <html:span class="val">auto</html:span>, the <html:a rel="attr">page</html:a>
					attribute is set and the graph cannot be drawn on a single page,
					then <html:a rel="attr">size</html:a> is set to an ``ideal'' value.
					In particular, the size in a given dimension will be the smallest integral
					multiple of the page size in that dimension which is at least half the
					current size. The two dimensions are then scaled independently to the
					new size. This feature only works in dot.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="rects" type="rect">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Rectangles for fields of records, in <html:a rel="note">points</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="regular" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true, force polygon to be regular.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="remincross" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If true and there are multiple clusters, run cross
					minimization a second time.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="resolution" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This is a synonym for the <html:a rel="attr">dpi</html:a> attribute.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="root" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					This specifies nodes to be used as the center of the 
					layout and the root of the generated spanning tree. As a graph attribute,
					this gives the name of the node. As a node attribute (circo only), it
					specifies that the node should be used as a central node. In twopi,
					this will actually be the central node. In circo, the block containing
					the node will be central in the drawing of its connected component.
					If not defined,
					twopi will pick a most central node, and circo will pick a random node.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="rotate" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If 90, set drawing orientation to landscape.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="samehead" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Edges with the same head and the same <html:a rel="attr">samehead</html:a> value are aimed
					at the same point on the head.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="sametail" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Edges with the same tail and the same <html:a rel="attr">sametail</html:a> value are aimed
					at the same point on the tail.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="samplepoints" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the input graph defines the <html:a rel="attr"><html:a rel="attr">vertices</html:a></html:a> 
					attribute, and output is dot or xdot, this gives
					the number of points used for a node whose shape is a circle or ellipse.
					It plays the same role in neato, when adjusting the layout to avoid
					overlapping nodes, and in image maps.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="searchsize" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					During network simplex, maximum number of edges with negative cut values
					to search when looking for one with minimum cut value.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="sep" type="pointf">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Fraction to increase polygons (multiply
					coordinates by 1 + sep) for purposes of determining overlap. Guarantees
					a minimal non-zero distance between nodes.
					If unset but <html:a rel="attr">esep</html:a> is defined, <html:a rel="attr">sep</html:a> will be
					set to <html:code>esep/0.8</html:code>. If <html:a rel="attr">esep</html:a> is unset, the default value
					is used. 
				</html:p>
				<html:p>
					When <html:a rel="attr">overlap</html:a>="ipsep" or "vpsc",
					<html:a rel="attr">sep</html:a> gives a minimum distance, in inches, to be left between nodes.
					In this case, if <html:a rel="attr">sep</html:a> is a pointf, the x and y separations can be
					specified separately.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="shape" type="shape">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Set the shape of a node.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="shapefile" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					(Deprecated) If defined, shapefile specifies a file containing user-supplied node content. 
					The <html:a rel="attr">shape</html:a> of the node is set to box. 
					The image in the shapefile must be
					rectangular. The image formats supported as well as the precise semantics of 
					how the file is used depends on the
					<html:a href="http://www.graphviz.org/doc/info/output.html">output format</html:a>.  For further details, see
					<html:a href="http://www.graphviz.org/Documentation/html/shapehowto.html#ext_image">External PostScript files</html:a>.
				</html:p>
				<html:p>
					There is one exception to this usage. 
					If <html:a rel="attr">shape</html:a> is set to "epsf", shapefile gives
					a filename containing a definition of the node in PostScript. 
					The graphics defined must be contain all of the
					node content, including any desired boundaries.
					For further details, see
					<html:a href="http://www.graphviz.org/Documentation/html/shapehowto.html#ext_ps">
					External PostScript files</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="showboxes" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Print guide boxes in PostScript at the beginning of
					routesplines if 1, or at the end if 2. (Debugging)
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="sides" type="xsd:integer">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Number of sides if <html:a rel="attr">shape</html:a>=polygon.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="size" type="pointf">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Maximum width and height of drawing, in inches.
					If defined and the drawing is too large, the drawing is uniformly 
					scaled down so that it fits within the given size. 
				</html:p>
				<html:p>
					If <html:a rel="attr">size</html:a> ends in an exclamation point (<html:tt>!</html:tt>), 
					then it is taken to be
					the desired size. In this case, if both dimensions of the drawing are
					less than <html:a rel="attr">size</html:a>, the drawing is scaled up uniformly until at
					least one dimension equals its dimension in <html:a rel="attr">size</html:a>.
				</html:p>
				<html:p>
					Note that there is some interaction between the <html:a rel="attr">size</html:a> and
					<html:a rel="attr">ratio</html:a> attributes.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="skew" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Skew factor for <html:a rel="attr">shape</html:a>=polygon. Positive values
					skew top of polygon to right; negative to left.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="splines" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Controls how, and if, edges are represented. If true, edges are drawn as
					splines routed around nodes; if false, edges are drawn as line segments.
					If set to "", no edges are drawn at all.
				</html:p>
				<html:p>
					(1 March 2007) The values <html:span class="val">line</html:span> and <html:span class="val">spline</html:span> can be
					used as synonyms for <html:span class="val">false</html:span> and <html:span class="val">true</html:span>, respectively.
					In addition, the value <html:span class="val">polyline</html:span> specifies that edges should be
					drawn as polylines.
				</html:p>
				<html:p>
					By default, the attribute is unset. How this is interpreted depends on
					the layout. For dot, the default is to draw edges as splines. For all
					other layouts, the default is to draw edges as line segments. Note that
					for these latter layouts, if <html:code>splines="true"</html:code>, this
					requires non-overlapping nodes (cf. <html:a rel="attr">overlap</html:a>).
					If fdp is used for layout and <html:tt>splines="compound"</html:tt>, then the edges are
					drawn to avoid clusters as well as nodes.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="start" type="startType">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Parameter used to determine the initial layout of nodes. If unset, the
					nodes are randomly placed in a unit square with
					the same seed is always used for the random number generator, so the
					initial placement is repeatable.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="style" type="style">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Set style for node or edge. For cluster subgraph, if "filled", the
					cluster box's background is filled.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="stylesheet" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					A URL or pathname specifying an XML style sheet, used in SVG output.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tailURL" type="xsd:anyURI">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:a rel="attr">tailURL</html:a> is defined, it is
					output as part of the tail label of the edge.
					Also, this value is used near the tail node, overriding any
					<html:a rel="attr">URL</html:a> value.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tailclip" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If <html:span class="val">true</html:span>, the tail of an edge is clipped to the boundary of the tail node;
					otherwise, the end of the edge goes to the center of the node, or the
					center of a port, if applicable.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tailhref" type="xsd:anyURI">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Synonym for <html:a rel="attr">tailURL</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="taillabel" type="lblString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Text label to be placed near tail of edge.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tailport" type="portPos">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Indicates where on the tail node to attach the tail of the edge.
					See <html:a rel="note">undirected</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tailtarget" type="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the edge has a <html:a rel="attr">tailURL</html:a>, 
					this attribute determines which window of the 
					browser is used
					for the URL. Setting it to "_graphviz" will open a new window if it 
					doesn't already exist, or reuse it if it does.
					If undefined, the value of the <html:a rel="attr">target</html:a> is used.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tailtooltip" type="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Tooltip annotation attached to the tail of an edge. This is used only
					if the edge has a <html:a rel="attr">tailURL</html:a> attribute.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="target" type="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the object has a URL, this attribute determines which window 
					of the browser is used for the URL.
					See <html:a href="http://www.w3.org/TR/html401/present/frames.html#adef-target">W3C documentation</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="tooltip" type="escString">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Tooltip annotation attached to the node or edge. If unset, Graphviz
					will use the object's <html:a rel="attr">label</html:a> if defined.
					Note that if the label is a record specification or an HTML-like
					label, the resulting tooltip may be unhelpful. In this case, if
					tooltips will be generated, the user should set a <html:tt>tooltip</html:tt>
					attribute explicitly.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="truecolor" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If set explicitly to true or false, the value determines whether or not
					internal bitmap rendering relies on a truecolor color model or uses
					a color palette.
					If the attribute is unset, truecolor is not used 
					unless there is a <html:a rel="attr">shapefile</html:a> property
					for some node in the graph. 
					The output model will use the input model when possible.
				</html:p>
				<html:p>
					Use of color palettes results in less memory usage during creation of the
					bitmaps and smaller output files.
				</html:p>
				<html:p>
					Usually, the only time it is necessary to specify the truetype model
					is if the graph uses more than 256 colors.
					However, if one uses <html:a rel="attr">bgcolor</html:a>=transparent with 
					a color palette, font
					antialiasing can show up as a fuzzy white area around characters.
					Using <html:a rel="attr">truecolor</html:a>=true avoids this problem.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="vertices" type="pointfList">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					If the input graph defines this attribute, the node is polygonal,
					and output is dot or xdot, this attribute provides the
					coordinates of the vertices of the node's polygon, in inches.
					If the node is an ellipse or circle, the 
					<html:a rel="attr">samplepoints</html:a> attribute affects
					the output.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="viewport" type="viewPort">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Clipping window on final drawing.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="voro_margin" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Factor to scale up drawing to allow margin for expansion in
					Voronoi technique. dim' = (1+2*margin)*dim.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="weight" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Weight of edge. In dot, the heavier the weight, the shorter,
					straighter and more vertical the edge is. In neato, the heavier the
					weight, the more neato will try to place the end points so that the
					length of the edge is <html:a rel="attr">len</html:a>.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="width" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Width of node, in inches. This is taken as the initial, minimum width
					of the node. If <html:a rel="attr">fixedsize</html:a> is true, this
					will be the final width of the node. Otherwise, if the node label
					requires more width to fit, the node's width will be increased to
					contain the label. Note also that, if the output format is dot, the
					value given to <html:a rel="attr">width</html:a> will be the final value.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
	
	<xsd:attribute name="z" type="xsd:decimal">
		<xsd:annotation>
			<xsd:documentation>
				<html:p>
					Provides z coordinate value for 3D layouts and displays. If the
					graph has <html:a rel="attr">dim</html:a> set to 3 (or more), 
					neato will use a node's <html:a rel="attr">z</html:a> value
					for the z coordinate of its initial position if 
					its <html:a rel="attr">pos</html:a> attribute is also defined.
				</html:p>
				<html:p>
					Even if no <html:a rel="attr">z</html:a> values are specified in the input, it is necessary to
					declare a <html:a rel="attr">z</html:a> attribute for nodes, e.g, using <html:tt>node[z=""]</html:tt>
					in order to get z values on output.
					Thus, setting <html:tt>dim=3</html:tt> but not declaring <html:a rel="attr">z</html:a> will 
					cause <html:tt>neato -Tvrml</html:tt> to
					layout the graph in 3D but project the layout onto the xy-plane
					for the rendering. If the <html:a rel="attr">z</html:a> attribute is declared, the final rendering
					will be in 3D.
				</html:p>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:attribute>
		
	<!-- COMPONENTS -->
	
	<xsd:complexType name="edge">
		<xsd:attribute ref="URL" />
		<xsd:attribute ref="arrowhead" default="normal" />
		<xsd:attribute ref="arrowsize" default="1.0" />
		<xsd:attribute ref="arrowtail" default="normal" />
		<xsd:attribute ref="color" default="black" />
		<xsd:attribute ref="colorscheme" />
		<xsd:attribute ref="comment" />
		<xsd:attribute ref="constraint" default="true" />
		<xsd:attribute ref="decorate" default="false" />
		<xsd:attribute ref="dir" />
		<xsd:attribute ref="edgeURL" />
		<xsd:attribute ref="edgehref"/>
		<xsd:attribute ref="edgetarget" />
		<xsd:attribute ref="edgetooltip" />
		<xsd:attribute ref="fontcolor" default="black" />
		<xsd:attribute ref="fontname" default="Times-Roman" />
		<xsd:attribute ref="fontsize" default="14.0" />
		<xsd:attribute ref="headURL" />
		<xsd:attribute ref="headclip" default="true" />
		<xsd:attribute ref="headhref"/>
		<xsd:attribute ref="headlabel" />
		<xsd:attribute ref="headport" default="center"/>
		<xsd:attribute ref="headtarget" />
		<xsd:attribute ref="headtooltip" />
		<xsd:attribute ref="href" />
		<xsd:attribute ref="label" />
		<xsd:attribute ref="labelURL" />
		<xsd:attribute ref="labelangle" default="-25.0" />
		<xsd:attribute ref="labeldistance" default="1.0" />
		<xsd:attribute ref="labelfloat" default="false" />
		<xsd:attribute ref="labelfontcolor" default="black" />
		<xsd:attribute ref="labelfontname" default="Times-Roman" />
		<xsd:attribute ref="labelfontsize" default="14.0" />
		<xsd:attribute ref="labelhref" />
		<xsd:attribute ref="labeltarget" />
		<xsd:attribute ref="labeltooltip" />
		<xsd:attribute ref="layer" />
		<xsd:attribute ref="len" />
		<xsd:attribute ref="lhead" />
		<xsd:attribute ref="lp" />
		<xsd:attribute ref="ltail" />
		<xsd:attribute ref="minlen" default="1" />
		<xsd:attribute ref="nojustify" default="false" />
		<xsd:attribute ref="pos" />
		<xsd:attribute ref="samehead" />
		<xsd:attribute ref="sametail" />
		<xsd:attribute ref="showboxes" default="0" />
		<xsd:attribute ref="style" />
		<xsd:attribute ref="tailURL" />
		<xsd:attribute ref="tailclip" default="true" />
		<xsd:attribute ref="tailhref"/>
		<xsd:attribute ref="taillabel" />
		<xsd:attribute ref="tailport" default="center"/>
		<xsd:attribute ref="tailtarget" />
		<xsd:attribute ref="tailtooltip" />
		<xsd:attribute ref="target" />
		<xsd:attribute ref="tooltip" />
		<xsd:attribute ref="weight" default="1.0" />
	</xsd:complexType>

	<xsd:complexType name="node">
		<xsd:attribute ref="URL" />
		<xsd:attribute ref="color" default="black" />
		<xsd:attribute ref="colorscheme" />
		<xsd:attribute ref="comment" />
		<xsd:attribute ref="distortion" default="0.0" />
		<xsd:attribute ref="fillcolor" default="lightgrey" />
		<xsd:attribute ref="fixedsize" default="false" />
		<xsd:attribute ref="fontcolor" default="black" />
		<xsd:attribute ref="fontname" default="Times-Roman" />
		<xsd:attribute ref="fontsize" default="14.0" />
		<xsd:attribute ref="group" />
		<xsd:attribute ref="height" default="0.5" />
		<xsd:attribute ref="image" />
		<xsd:attribute ref="imagescale" default="false" />
		<xsd:attribute ref="label" default="\N" />
		<xsd:attribute ref="layer" />
		<xsd:attribute ref="margin" />
		<xsd:attribute ref="nojustify" default="false" />
	<!--	<xsd:attribute ref="orientation" default="0.0" /> -->
		<xsd:attribute ref="peripheries" />
		<xsd:attribute ref="pin" default="false" />
		<xsd:attribute ref="pos" />
		<xsd:attribute ref="rects" />
		<xsd:attribute ref="regular" default="false" />
		<xsd:attribute ref="root" default="false" />
		<xsd:attribute ref="samplepoints" default="false" />
		<xsd:attribute ref="shape" default="ellipse" />
		<xsd:attribute ref="shapefile" />
		<xsd:attribute ref="showboxes" default="0" />
		<xsd:attribute ref="sides" default="4" />
		<xsd:attribute ref="skew" default="0.0" />
		<xsd:attribute ref="style" />
		<xsd:attribute ref="target" />
		<xsd:attribute ref="tooltip" />
		<xsd:attribute ref="vertices" />
		<xsd:attribute ref="width" default="0.75" />
		<xsd:attribute ref="z" default="0.0" />
	</xsd:complexType>
	
	<xsd:complexType name="graph">
		<xsd:attribute ref="imagepath" />
		<xsd:attribute ref="Damping" default="0.99" />
		<xsd:attribute ref="K" default="0.3" />
		<xsd:attribute ref="URL" />
		<xsd:attribute ref="bb" />
		<xsd:attribute ref="bgcolor" />
		<xsd:attribute ref="center" />
		<xsd:attribute ref="charset" />
		<xsd:attribute ref="clusterrank" default="local" />
		<xsd:attribute ref="colorscheme" />
		<xsd:attribute ref="comment" />
		<xsd:attribute ref="compound" default="false" />
		<xsd:attribute ref="concentrate" default="false" />
		<xsd:attribute ref="defaultdist" />
		<xsd:attribute ref="dim" default="2" />
		<xsd:attribute ref="diredgeconstraints" default="false" />
		<xsd:attribute ref="dpi" default="96.0" />
		<xsd:attribute ref="epsilon" />
		<xsd:attribute ref="esep" />
		<xsd:attribute ref="fontcolor" default="black" />
		<xsd:attribute ref="fontname" default="Times-Roman" />
		<xsd:attribute ref="fontnames" />
		<xsd:attribute ref="fontpath" />
		<xsd:attribute ref="fontsize" default="14.0" />
		<xsd:attribute ref="label" />
		<xsd:attribute ref="labeljust" default="c" />
		<xsd:attribute ref="labelloc" default="b" />
		<xsd:attribute ref="landscape" default="false" />
		<xsd:attribute ref="layers" default="false" />
		<xsd:attribute ref="layersep" default=" :	" />
		<xsd:attribute ref="layout" />
		<xsd:attribute ref="levelsgap" default="0.0" />
		<xsd:attribute ref="lp" />
		<xsd:attribute ref="margin" />
		<xsd:attribute ref="maxiter" />
		<xsd:attribute ref="mclimit" default="1.0" />
		<xsd:attribute ref="mindist" default="1.0" />
		<xsd:attribute ref="mode" default="major" />
		<xsd:attribute ref="model" default="shortpath" />
		<xsd:attribute ref="mosek" default="false" />
		<xsd:attribute ref="nodesep" default="0.25" />
		<xsd:attribute ref="nojustify" default="false" />
		<xsd:attribute ref="normalize" default="false" />
		<xsd:attribute ref="nslimit" />
		<xsd:attribute ref="nslimit1" />
		<xsd:attribute ref="ordering" />
		<!-- <xsd:attribute ref="orientation" /> -->
		<xsd:attribute ref="outputorder" default="breadthfirst" />
		<xsd:attribute ref="overlap" default="true" />
		<xsd:attribute ref="pack" default="false" />
		<xsd:attribute ref="packmode" default="node" />
		<xsd:attribute ref="pad" />
		<xsd:attribute ref="page" />
		<xsd:attribute ref="pagedir" />
		<xsd:attribute ref="quantum" default="0.0" />
		<xsd:attribute ref="rankdir" default="TB" />
		<xsd:attribute ref="ranksep" />
		<xsd:attribute ref="ratio" />
		<xsd:attribute ref="remincross" default="false" />
		<xsd:attribute ref="resolution" default="96.0" />
		<xsd:attribute ref="root" />
		<xsd:attribute ref="rotate" default="0" />
		<xsd:attribute ref="searchsize" default="30" />
		<xsd:attribute ref="sep" default="0.1" />
		<xsd:attribute ref="showboxes" default="0" />
		<xsd:attribute ref="size" />
		<xsd:attribute ref="splines" />
		<xsd:attribute ref="start" />
		<xsd:attribute ref="stylesheet" />
		<xsd:attribute ref="target" />
		<xsd:attribute ref="truecolor" />
		<xsd:attribute ref="viewport" />
		<xsd:attribute ref="voro_margin" default="0.05" />
	</xsd:complexType>

	<xsd:complexType name="subgraph">
		<xsd:attribute ref="rank" />
	</xsd:complexType>

	<xsd:complexType name="cluster">
		<xsd:attribute ref="K" />
		<xsd:attribute ref="URL" />
		<xsd:attribute ref="bgcolor" />
		<xsd:attribute ref="color" default="black" />
		<xsd:attribute ref="colorscheme" />
		<xsd:attribute ref="fillcolor" default="black" />
		<xsd:attribute ref="fixedsize" default="false" />
		<xsd:attribute ref="fontcolor" default="black" />
		<xsd:attribute ref="fontname" default="Times-Roman" />
		<xsd:attribute ref="fontsize" default="14.0" />
		<xsd:attribute ref="label" />
		<xsd:attribute ref="labeljust" default="c" />
		<xsd:attribute ref="labelloc" default="t" />
		<xsd:attribute ref="lp" />
		<xsd:attribute ref="nojustify" default="false" />
		<xsd:attribute ref="pencolor" default="black" />
		<xsd:attribute ref="style" />
		<xsd:attribute ref="target" />
		<xsd:attribute ref="tooltip" />
	</xsd:complexType>

</xsd:schema>
