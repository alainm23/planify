<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="telepathy-glib"/>
  <c:include name="telepathy-glib/telepathy-glib.h"/>
  <namespace name="TelepathyGLib"
             version="0.12"
             shared-library="libtelepathy-glib.so.0"
             c:identifier-prefixes="Tp"
             c:symbol-prefixes="tp">
    <alias name="Handle" c:type="TpHandle">
      <doc xml:space="preserve">Type representing Telepathy handles within telepathy-glib.

This is guint despite the wire protocol having 32-bit integers, because
dbus-glib expects GArrays of guint and so on. If the dbus-glib ABI changes
in future, telepathy-glib is likely to have a matching ABI change.</doc>
      <type name="guint" c:type="guint"/>
    </alias>
    <alias name="IntSet" c:type="TpIntSet" introspectable="0">
      <doc xml:space="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntset&lt;/type&gt;, but it's
now just a backwards compatibility typedef.</doc>
      <type name="Intset" c:type="TpIntset"/>
    </alias>
    <alias name="IntSetFastIter"
           c:type="TpIntSetFastIter"
           introspectable="0"
           deprecated="1">
      <doc xml:space="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntsetFastIter&lt;/type&gt;,
but it's now just a backwards compatibility typedef.</doc>
      <doc-deprecated xml:space="preserve">since 0.19.0. Use #TpIntsetFastIter instead</doc-deprecated>
      <type name="IntsetFastIter" c:type="TpIntsetFastIter"/>
    </alias>
    <alias name="IntSetIter"
           c:type="TpIntSetIter"
           introspectable="0"
           deprecated="1">
      <doc xml:space="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntsetIter&lt;/type&gt;, but
it's now just a backwards compatibility typedef.</doc>
      <doc-deprecated xml:space="preserve">since 0.19.0. Use #TpIntsetFastIter instead</doc-deprecated>
      <type name="IntsetIter" c:type="TpIntsetIter"/>
    </alias>
    <constant name="ACCOUNT_MANAGER_BUS_NAME"
              value="org.freedesktop.Telepathy.AccountManager"
              c:type="TP_ACCOUNT_MANAGER_BUS_NAME">
      <doc xml:space="preserve">The account manager's well-known bus name</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCOUNT_MANAGER_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/AccountManager"
              c:type="TP_ACCOUNT_MANAGER_OBJECT_PATH">
      <doc xml:space="preserve">The account manager's standard object path</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCOUNT_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Account/"
              c:type="TP_ACCOUNT_OBJECT_PATH_BASE">
      <doc xml:space="preserve">The common prefix of the object path for all Account objects.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="AccessControlType" c:type="TpAccessControlType">
      <doc xml:space="preserve">&lt;![CDATA[         A type for communication access control. These control           policies are used in           CommunicationPolicy.DRAFT           as well as most rich presence interfaces.          New interfaces should use this type, and NOT           Rich_Presence_Access_Control_Type.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="whitelist"
              value="0"
              c:identifier="TP_ACCESS_CONTROL_TYPE_WHITELIST">
        <doc xml:space="preserve">&lt;![CDATA[           Only allow contacts that are in a certain whitelist.            The associated variant             in Access_Control is a list of             Contact_Handle representing             the whitelist, with signature au.         ]]&gt;</doc>
      </member>
      <member name="publish_list"
              value="1"
              c:identifier="TP_ACCESS_CONTROL_TYPE_PUBLISH_LIST">
        <doc xml:space="preserve">&lt;![CDATA[           Allow contacts in the user's 'publish' list. The associated           variant in Access_Control is ignored.         ]]&gt;</doc>
      </member>
      <member name="group"
              value="2"
              c:identifier="TP_ACCESS_CONTROL_TYPE_GROUP">
        <doc xml:space="preserve">&lt;![CDATA[           Only allow contacts that are in a certain group.            The associated variant in Access_Control is a             Group_Handle representing the permitted             group.         ]]&gt;</doc>
      </member>
      <member name="open" value="3" c:identifier="TP_ACCESS_CONTROL_TYPE_OPEN">
        <doc xml:space="preserve">&lt;![CDATA[           Allow all contacts.  The associated           variant in Access_Control is ignored.         ]]&gt;</doc>
      </member>
      <member name="subscribe_or_publish_list"
              value="4"
              c:identifier="TP_ACCESS_CONTROL_TYPE_SUBSCRIBE_OR_PUBLISH_LIST">
        <doc xml:space="preserve">&lt;![CDATA[           Allow all contacts in the user's 'subscribe' or 'publish'           list. The associated variant in Access_Control is           ignored.         ]]&gt;</doc>
      </member>
      <member name="closed"
              value="5"
              c:identifier="TP_ACCESS_CONTROL_TYPE_CLOSED">
        <doc xml:space="preserve">&lt;![CDATA[           Forbid all contacts. The associated variant in           Access_Control is ignored.         ]]&gt;</doc>
      </member>
      <member name="not_understood"
              value="6"
              c:identifier="TP_ACCESS_CONTROL_TYPE_NOT_UNDERSTOOD">
        <doc xml:space="preserve">&lt;![CDATA[           The access control rule is too complex to be represented             in the current Telepathy API. The associated variant is             meaningless. Setting this mode is never valid; the             connection manager MUST raise an error if this is attempted.                         XEP-0016 Privacy Lists can easily produce access control             mechanisms that can't be expressed in a simpler API. We             need to be able to at least indicate that fact.                       The associated variant in Access_Control is             ignored.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="Account"
           c:symbol-prefix="account"
           c:type="TpAccount"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpAccount"
           glib:get-type="tp_account_get_type"
           glib:type-struct="AccountClass">
      <doc xml:space="preserve">The Telepathy Account Manager stores the user's configured real-time
communication accounts. This object represents a stored account.

If this account is deleted from the account manager, the
#TpProxy::invalidated signal will be emitted
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

One can connect to the #GObject::notify signal to get change notifications
for many of the properties on this object. Refer to each property's
documentation for whether it can be used in this way.

#TpAccount objects should normally be obtained from the #TpAccountManager.

Since 0.16, #TpAccount always has a non-%NULL #TpProxy:factory, and its
#TpProxy:factory will be propagated to its #TpConnection
(if any). If a #TpAccount is created without going via the
#TpAccountManager or specifying a #TpProxy:factory, the default
is to use a new #TpAutomaticClientFactory.</doc>
      <constructor name="new"
                   c:identifier="tp_account_new"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">Convenience function to create a new account proxy. The returned #TpAccount
is not guaranteed to be ready at the point of return.</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_account() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an account proxy, or %NULL if @object_path is
   not valid</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:space="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The non-NULL object path of this account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_addressing"
                c:identifier="tp_account_get_feature_quark_addressing">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connection"
                c:identifier="tp_account_get_feature_quark_connection"
                version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for representing the connection feature of a
         #TpAccount</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_account_get_feature_quark_core"
                version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for representing the core feature of a
         #TpAccount</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_storage"
                c:identifier="tp_account_get_feature_quark_storage"
                version="0.13.2">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for representing the storage interface of a
         #TpAccount</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_account_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpAccount have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="parse_object_path"
                c:identifier="tp_account_parse_object_path"
                version="0.9.0"
                deprecated="1"
                throws="1">
        <doc xml:space="preserve">Validates and parses a Telepathy Account's object path, extracting the
connection manager's name, the protocol, and the account's unique identifier
from the path. This includes replacing underscores with hyphens in the
protocol name, as defined in the Account specification.

Any of the out parameters may be %NULL if not needed. If %TRUE is returned,
the caller is responsible for freeing the strings stored in any non-%NULL
out parameters, using g_free().</doc>
        <doc-deprecated xml:space="preserve">Use tp_account_get_protocol() and
 tp_account_get_connection_manager() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @object_path was successfully parsed; %FALSE and sets
         @error otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">a Telepathy Account's object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cm"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location at which to store the account's
 connection manager's name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="protocol"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location at which to store the account's
 protocol</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="account_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location at which to store the account's
 unique identifier</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <method name="associated_with_uri_scheme"
              c:identifier="tp_account_associated_with_uri_scheme"
              version="0.13.8">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the result of tp_account_get_uri_schemes() would include
 @scheme</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">a URI scheme such as "tel", "sip" or "xmpp"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_connection_status_to_property"
              c:identifier="tp_account_bind_connection_status_to_property"
              version="0.13.16">
        <doc xml:space="preserve">Binds the :connection-status of @self to the boolean property of another
object using a #GBinding such that the @target_property will be set to
%TRUE when @self is connected (and @invert is %FALSE).

@target_property will be synchronised immediately (%G_BINDING_SYNC_CREATE).
@invert can be interpreted as analogous to %G_BINDING_INVERT_BOOLEAN.

For instance, this function can be used to bind the GtkWidget:sensitive
property to only make a widget sensitive when the account is connected.

See g_object_bind_property() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBinding instance representing the binding
  between the @self and the @target. The binding is released whenever the
  #GBinding reference count reaches zero.</doc>
          <type name="GObject.Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="target"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind (must be %G_TYPE_BOOLEAN)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="invert" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if you wish to invert the value of @target_property
  (i.e. %FALSE if connected)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_detailed_error_vardict"
              c:identifier="tp_account_dup_detailed_error_vardict"
              version="0.17.6">
        <doc xml:space="preserve">If the account's connection is not connected, return the D-Bus error name
with which it last disconnected or failed to connect (in particular, this
is %TP_ERROR_STR_CANCELLED if it was disconnected by a user request).
This is the same as #TpAccount:connection-error.

If @details is not %NULL, it will be used to return additional details about
the error (the same as #TpAccount:connection-error-details).

Otherwise, return %NULL, without altering @details.

The returned string and @details may become invalid when the main loop is
re-entered or the account is destroyed.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an account</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
 optionally used to return a variant of type %G_VARIANT_TYPE_VARDICT,
 which must be unreffed by the caller with g_variant_unref()</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_parameters_vardict"
              c:identifier="tp_account_dup_parameters_vardict"
              version="0.17.6">
        <doc xml:space="preserve">Returns the parameters of the account, in a variant of type
%G_VARIANT_TYPE_VARDICT where the keys
are parameter names (account, password, require-encryption etc.).
Use g_variant_lookup() or g_variant_lookup_value() for convenient
access to the values.

The allowed parameters depend on the connection manager, and can be found
via tp_connection_manager_get_protocol() and
tp_connection_manager_protocol_get_param(). Well-known parameters are
listed
&lt;ulink url="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection"&gt;in
the Telepathy D-Bus Interface Specification&lt;/ulink&gt;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the dictionary of
 parameters on @account, of type %G_VARIANT_TYPE_VARDICT</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_storage_identifier_variant"
              c:identifier="tp_account_dup_storage_identifier_variant"
              version="0.13.2">
        <doc xml:space="preserve">Return provider-specific information used to identify this
account. Use g_variant_get_type() to check that the type
is what you expect; for instance, if the
#TpAccount:storage-provider has string-based user identifiers,
this variant should have type %G_VARIANT_TYPE_STRING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same as the
 #TpAccount:storage-identifier-variant property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_storage_specific_information_vardict_async"
              c:identifier="tp_account_dup_storage_specific_information_vardict_async"
              version="0.17.6">
        <doc xml:space="preserve">Makes an asynchronous request of @self's StorageSpecificInformation
property (part of the Account.Interface.Storage interface).

When the operation is finished, @callback will be called. You must then
call tp_account_dup_storage_specific_information_vardict_finish() to get the
result of the request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_storage_specific_information_vardict_finish"
              c:identifier="tp_account_dup_storage_specific_information_vardict_finish"
              version="0.17.6"
              throws="1">
        <doc xml:space="preserve">Retrieve the value of the request begun with
tp_account_dup_storage_specific_information_vardict_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a map from strings to variants,
 of type %G_VARIANT_TYPE_VARDICT</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_connection"
              c:identifier="tp_account_ensure_connection"
              version="0.9.0"
              deprecated="1">
        <doc xml:space="preserve">Set the connection of the account by specifying the connection object path.
This function does not return a new ref and it is not guaranteed that the
returned #TpConnection object is ready.

The use-case for this function is in a HandleChannels callback and you
already know the object path for the connection, so you can let @account
create its #TpConnection and return it for use.</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_simple_client_factory_ensure_connection()
 instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection of the account, or %NULL if either
 the object path @path is invalid or it is the null-value "/"</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to connection object for #TpAccount</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_automatic_presence"
              c:identifier="tp_account_get_automatic_presence"
              version="0.13.8">
        <doc xml:space="preserve">Gets the automatic presence, status and status message of @account. These
values are the same as the #TpAccount:automatic-presence-type,
#TpAccount:automatic-status and #TpAccount:automatic-status-message
properties, and are the values that will be used if the account should
be put online automatically.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:automatic-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an account</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the presence status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the
 user-defined message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_async"
              c:identifier="tp_account_get_avatar_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous get of @account's avatar. When
the operation is finished, @callback will be called. You can then call
tp_account_get_avatar_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_finish"
              c:identifier="tp_account_get_avatar_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async get operation of @account's avatar.

Beware that the returned value is only valid until @result is freed.
Copy it with g_array_ref() if you need to keep it for longer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GArray of #guchar
 containing the bytes of the account's avatar, or %NULL on failure</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_changing_presence"
              c:identifier="tp_account_get_changing_presence"
              version="0.11.6">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:changing-presence property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an account</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cm_name"
              c:identifier="tp_account_get_cm_name"
              version="0.19.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:cm-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connect_automatically"
              c:identifier="tp_account_get_connect_automatically"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:connect-automatically property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tp_account_get_connection"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:connection property</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_manager"
              c:identifier="tp_account_get_connection_manager"
              version="0.9.0"
              deprecated="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Use tp_account_get_cm_name() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:connection-manager property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_status"
              c:identifier="tp_account_get_connection_status"
              version="0.9.0">
        <doc xml:space="preserve">Gets the connection status and reason from @account. The two values
are the same as the #TpAccount:connection-status and
#TpAccount:connection-status-reason properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:connection-status property</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a #TpConnectionStatusReason to fill, or %NULL</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_presence"
              c:identifier="tp_account_get_current_presence"
              version="0.9.0">
        <doc xml:space="preserve">Gets the current presence, status and status message of @account. These
values are the same as the #TpAccount:current-presence-type,
#TpAccount:current-status and #TpAccount:current-status-message properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:current-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the current status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the current
 status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error"
              c:identifier="tp_account_get_detailed_error"
              version="0.11.7"
              introspectable="0">
        <doc xml:space="preserve">If the account's connection is not connected, return the D-Bus error name
with which it last disconnected or failed to connect (in particular, this
is %TP_ERROR_STR_CANCELLED if it was disconnected by a user request).
This is the same as #TpAccount:connection-error.

If @details is not %NULL, it will be used to return additional details about
the error (the same as #TpAccount:connection-error-details).

Otherwise, return %NULL, without altering @details.

The returned string and @details may become invalid when the main loop is
re-entered or the account is destroyed.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an account</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
 optionally used to return a map from string to #GValue, which must not be
 modified, destroyed or unreffed by the caller</doc>
            <type name="GLib.HashTable" c:type="const GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_display_name"
              c:identifier="tp_account_get_display_name"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:display-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_has_been_online"
              c:identifier="tp_account_get_has_been_online"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:has-been-online property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_name"
              c:identifier="tp_account_get_icon_name"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:icon-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nickname"
              c:identifier="tp_account_get_nickname"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:nickname property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_normalized_name"
              c:identifier="tp_account_get_normalized_name"
              version="0.13.8">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:normalized-name
 property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameters"
              c:identifier="tp_account_get_parameters"
              version="0.9.0">
        <doc xml:space="preserve">Returns the parameters of the account, in a hash table where each string
is the parameter name (account, password, require-encryption etc.), and
each value is a #GValue. Using the tp_asv_get family of functions
(tp_asv_get_uint32(), tp_asv_get_string() etc.) to access the parameters is
recommended.

The allowed parameters depend on the connection manager, and can be found
via tp_connection_manager_get_protocol() and
tp_connection_manager_protocol_get_param(). Well-known parameters are
listed
&lt;ulink url="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection"&gt;in
the Telepathy D-Bus Interface Specification&lt;/ulink&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hash table of
 parameters on @account</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path_suffix"
              c:identifier="tp_account_get_path_suffix"
              version="0.13.9">
        <doc xml:space="preserve">Returns the portion of @account's object path after the standard
#TP_ACCOUNT_OBJECT_PATH_BASE prefix, of the form "cm/protocol/acct". This
string uniquely identifies the account.

This function is only intended to be used when printing debug messages or in
tools for developer. For a string suitable for displaying to the user, see
tp_account_get_display_name(). To retrieve the connection manager and
protocol name parts of the object path, see
tp_account_get_connection_manager() and tp_account_get_protocol(). For
persistent identification of the account, use tp_proxy_get_object_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a suffix of @account's object path, for debugging purposes.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol"
              c:identifier="tp_account_get_protocol"
              version="0.9.0"
              deprecated="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Use tp_account_get_cm_name() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:protocol property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol_name"
              c:identifier="tp_account_get_protocol_name"
              version="0.19.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:protocol-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_requested_presence"
              c:identifier="tp_account_get_requested_presence"
              version="0.9.0">
        <doc xml:space="preserve">Gets the requested presence, status and status message of @account. These
values are the same as the #TpAccount:requested-presence-type,
#TpAccount:requested-status and #TpAccount:requested-status-message
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:requested-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the requested status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the requested
 status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="tp_account_get_service"
              version="0.11.9">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:service property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an account</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_storage_identifier"
              c:identifier="tp_account_get_storage_identifier"
              version="0.13.2">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:storage-identifier property</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_storage_provider"
              c:identifier="tp_account_get_storage_provider"
              version="0.13.2">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:storage-provider property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_storage_restrictions"
              c:identifier="tp_account_get_storage_restrictions"
              version="0.13.2">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:storage-restrictions property</doc>
          <type name="StorageRestrictionFlags"
                c:type="TpStorageRestrictionFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_storage_specific_information_async"
              c:identifier="tp_account_get_storage_specific_information_async"
              version="0.13.2">
        <doc xml:space="preserve">Makes an asynchronous request of @self's StorageSpecificInformation
property (part of the Account.Interface.Storage interface).

When the operation is finished, @callback will be called. You must then
call tp_account_get_storage_specific_information_finish() to get the
result of the request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_storage_specific_information_finish"
              c:identifier="tp_account_get_storage_specific_information_finish"
              version="0.13.2"
              throws="1">
        <doc xml:space="preserve">Retrieve the value of the request begun with
tp_account_get_storage_specific_information_async().

Beware that the returned value is only valid until @result is freed.
Copy it with g_hash_table_ref() if you need to keep it for longer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable
 of strings to GValues representing the D-Bus type a{sv}.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supersedes"
              c:identifier="tp_account_get_supersedes"
              version="0.17.5">
        <doc xml:space="preserve">Return the same thing as the #TpAccount:supersedes property, in a way
that may be more convenient for C code.

The returned pointers are not guaranteed to remain valid after the
main loop has been re-entered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:supersedes property</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri_schemes"
              c:identifier="tp_account_get_uri_schemes"
              version="0.13.8">
        <doc xml:space="preserve">Return the #TpAccount:uri-schemes property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpAccount:uri_schemes property</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_enabled"
              c:identifier="tp_account_is_enabled"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:enabled property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_prepared"
              c:identifier="tp_account_is_prepared"
              version="0.9.0"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">since 0.23.0, use tp_proxy_is_prepared() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_valid"
              c:identifier="tp_account_is_valid"
              version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpAccount:valid property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_account_prepare_async"
              version="0.9.0"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Requests an asynchronous preparation of @account with the features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_prepare_finish() to get the result of the
operation.

If @features is %NULL, then @callback will be called when the implied
%TP_ACCOUNT_FEATURE_CORE feature is ready.

If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.

Since 0.11.3, this is equivalent to calling the new function
tp_proxy_prepare_async() with the same arguments.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.6, use tp_proxy_prepare_async() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="const GQuark*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_account_prepare_finish"
              version="0.9.0"
              introspectable="0"
              deprecated="1"
              throws="1">
        <doc xml:space="preserve">Finishes an async preparation of the account @account.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.6, use tp_proxy_prepare_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_async"
              c:identifier="tp_account_reconnect_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous reconnect of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_reconnect_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_finish"
              c:identifier="tp_account_reconnect_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async reconnect of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the reconnect call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_async"
              c:identifier="tp_account_remove_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous removal of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_remove_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_account_remove_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async removal of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_async"
              c:identifier="tp_account_request_presence_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous change of presence on @account. When the
operation is finished, @callback will be called. You can then call
tp_account_request_presence_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_finish"
              c:identifier="tp_account_request_presence_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async presence change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence_async"
              c:identifier="tp_account_set_automatic_presence_async"
              version="0.13.8">
        <doc xml:space="preserve">Requests an asynchronous change of @account's automatic presence. When the
operation is finished, @callback will be called. You can then call
tp_account_set_automatic_presence_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence_finish"
              c:identifier="tp_account_set_automatic_presence_finish"
              version="0.13.8"
              throws="1">
        <doc xml:space="preserve">Finishes an asynchronous request to change the automatic presence of
@account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_async"
              c:identifier="tp_account_set_avatar_async"
              version="0.11.1">
        <doc xml:space="preserve">Requests an asynchronous change of the Avatar parameter on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_avatar_finish() to get the result of the operation.

If @len equals 0, the avatar is cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="avatar"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a new avatar to set; can be %NULL
 only if @len equals 0</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the new avatar</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the MIME type of the new avatar; can be %NULL
 only if @len equals 0</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_finish"
              c:identifier="tp_account_set_avatar_finish"
              version="0.11.1"
              throws="1">
        <doc xml:space="preserve">Finishes an async avatar change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_async"
              c:identifier="tp_account_set_connect_automatically_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous set of the ConnectAutomatically property of
@account. When the operation is finished, @callback will be called. You can
then call tp_account_set_display_name_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="connect_automatically" transfer-ownership="none">
            <doc xml:space="preserve">new value for the parameter</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_finish"
              c:identifier="tp_account_set_connect_automatically_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of the ConnectAutomatically property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async"
              c:identifier="tp_account_set_display_name_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous set of the DisplayName property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_display_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a new display name, or %NULL to unset the display name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish"
              c:identifier="tp_account_set_display_name_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of the DisplayName property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_async"
              c:identifier="tp_account_set_enabled_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous set of the Enabled property of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_set_enabled_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">the new enabled value of @account</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish"
              c:identifier="tp_account_set_enabled_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of the Enabled property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the set was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_async"
              c:identifier="tp_account_set_icon_name_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous set of the Icon property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_icon_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="icon_name" transfer-ownership="none">
            <doc xml:space="preserve">a new icon name, or %NULL to unset the icon name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_finish"
              c:identifier="tp_account_set_icon_name_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of the Icon parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_async"
              c:identifier="tp_account_set_nickname_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous change of the Nickname parameter on @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_nickname_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:space="preserve">a new nickname to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_finish"
              c:identifier="tp_account_set_nickname_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async nickname change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_async"
              c:identifier="tp_account_set_service_async"
              version="0.11.9">
        <doc xml:space="preserve">Requests an asynchronous set of the Service property on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_service_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a new service name, or %NULL or the empty string to unset the
 service name (which will result in the #TpAccount:service property
 becoming the same as #TpAccount:protocol)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_finish"
              c:identifier="tp_account_set_service_finish"
              version="0.11.9"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of the Service parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_scheme_association_async"
              c:identifier="tp_account_set_uri_scheme_association_async"
              version="0.13.8">
        <doc xml:space="preserve">Add @scheme to the list of additional URI schemes that would be returned
by tp_account_get_uri_schemes(), or remove it from that list.

@scheme should not be the primary URI scheme for the account's
protocol (for instance, "xmpp" for XMPP, or "sip" or "sips" for SIP),
since the account should be assumed to be useful for those schemes
regardless of the contents of the list.

Calling this method does not require the %TP_ACCOUNT_FEATURE_ADDRESSING
feature to be enabled, but the change will not be reflected in the result
of tp_account_get_uri_schemes() or tp_account_associated_with_uri_scheme()
unless that feature has been enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">a non-%NULL URI scheme such as "tel"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="associate" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to use this account for @scheme, or %FALSE to not use it</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_scheme_association_finish"
              c:identifier="tp_account_set_uri_scheme_association_finish"
              version="0.13.8"
              throws="1">
        <doc xml:space="preserve">Interpret the result of tp_account_set_uri_scheme_association_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_async"
              c:identifier="tp_account_update_parameters_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous update of parameters of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_update_parameters_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">new
 parameters to set on @account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <doc xml:space="preserve">list of parameters to unset on @account</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_finish"
              c:identifier="tp_account_update_parameters_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async update of the parameters on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request succeeded, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a #GStrv to
 fill with properties that need a reconnect to take effect</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_vardict_async"
              c:identifier="tp_account_update_parameters_vardict_async"
              version="0.17.6">
        <doc xml:space="preserve">Requests an asynchronous update of parameters of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_update_parameters_finish() to get the result of the operation.

If @parameters is a floating reference (see g_variant_ref_sink()),
ownership of @parameters is taken by this function. This means
you can pass the result of g_variant_new() or g_variant_new_parsed()
directly to this function without additional reference-count management.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">a variant of type %G_VARIANT_TYPE_VARDICT
 containing new parameters to set on @account</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <doc xml:space="preserve">list of parameters to unset on @account</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_vardict_finish"
              c:identifier="tp_account_update_parameters_vardict_finish"
              version="0.17.6"
              throws="1">
        <doc xml:space="preserve">Finishes an async update of the parameters on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request succeeded, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a #GStrv to
 fill with properties that need a reconnect to take effect</doc>
            <array c:type="gchar***">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <property name="automatic-presence-type"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's automatic presence type (a #TpConnectionPresenceType).

When the account is put online automatically, for instance to make a
channel request or because network connectivity becomes available,
the automatic presence type, status and message will be copied to
their "requested" counterparts.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="automatic-status"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:space="preserve">The string status name to use in conjunction with the
#TpAccount:automatic-presence-type.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="automatic-status-message"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:space="preserve">The user-defined message to use in conjunction with the
#TpAccount:automatic-presence-type.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="changing-presence"
                version="0.11.6"
                transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if an attempt is currently being made to change the account's
presence (#TpAccount:current-presence-type, #TpAccount:current-status
and #TpAccount:current-status-message) to match its requested presence
(#TpAccount:requested-presence-type, #TpAccount:requested-status
and #TpAccount:requested-status-message).

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="cm-name" version="0.19.3" transfer-ownership="none">
        <doc xml:space="preserve">The account's connection manager name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connect-automatically"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the account should connect automatically or not. To change this
property, use tp_account_set_connect_automatically_async().

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="connection" version="0.9.0" transfer-ownership="none">
        <doc xml:space="preserve">The connection of the account, or %NULL if account is offline.
Note that the returned #TpConnection is not guaranteed to have any
features pre-prepared (not even %TP_CONNECTION_FEATURE_CORE) unless
%TP_ACCOUNT_FEATURE_CONNECTION has been prepared on the account

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. If %TP_ACCOUNT_FEATURE_CONNECTION has been prepared, this signal
will be delayed until the connection is ready.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="connection-error"
                version="0.11.7"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus error name for the last disconnection or connection failure,
(in particular, %TP_ERROR_STR_CANCELLED if it was disconnected by user
request), or %NULL if the account is connected.

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connection-error-details"
                version="0.11.7"
                transfer-ownership="none">
        <doc xml:space="preserve">A map from string to #GValue containing extensible error details
related to #TpAccount:connection-error. Functions like tp_asv_get_string()
can be used to read from this map.

The keys for this map are defined by
&lt;ulink url="http://telepathy.freedesktop.org/spec/"&gt;the Telepathy D-Bus
Interface Specification&lt;/ulink&gt;. They will typically include
&lt;literal&gt;debug-message&lt;/literal&gt;, which is a debugging message in the C
locale, analogous to #GError&lt;!-- --&gt;.message.

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
an empty map.</doc>
        <type name="GLib.HashTable">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="connection-manager"
                version="0.9.0"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's connection manager name.</doc>
        <doc-deprecated xml:space="preserve">Use #TpAccount:cm-name instead.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connection-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's connection status type (a %TpConnectionStatus).

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_DISCONNECTED.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="connection-status-reason"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's connection status reason (a %TpConnectionStatusReason).

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="current-presence-type"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The account connection's current presence type
(a %TpConnectionPresenceType).

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="current-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The current Status string of the account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="current-status-message"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The current status message message of the account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="display-name" version="0.9.0" transfer-ownership="none">
        <doc xml:space="preserve">The account's display name, from the DisplayName property.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="enabled" version="0.9.0" transfer-ownership="none">
        <doc xml:space="preserve">Whether this account is enabled or not.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="has-been-online"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether this account has been online or not.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="icon-name" version="0.9.0" transfer-ownership="none">
        <doc xml:space="preserve">The account's icon name. To change this propery, use
tp_account_set_icon_name_async().

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nickname" version="0.9.0" transfer-ownership="none">
        <doc xml:space="preserve">The nickname that should be set for the user on this account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="normalized-name"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:space="preserve">The normalized form of the user's own unique identifier on this
protocol. For example, on XMPP accounts this is the user's JID; on
ICQ this is the user's UIN; and so on.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol"
                version="0.9.0"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <doc-deprecated xml:space="preserve">Use #TpAccount:protocol-name instead.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol-name"
                version="0.19.3"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="requested-presence-type"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's requested presence type (a #TpConnectionPresenceType).

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="requested-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The requested Status string of the account.

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="requested-status-message"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The requested status message message of the account.

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service" version="0.11.9" transfer-ownership="none">
        <doc xml:space="preserve">A machine-readable name identifying a specific service to which this
account connects, or a copy of #TpAccount:protocol if there is no more
specific service.

Well-known names for various services can be found in the Telepathy D-Bus
Interface Specification.

For instance, accounts for the "jabber" protocol should have the service
names "google-talk", "ovi-chat", "facebook" and "lj-talk" for accounts
that connect to Google Talk, Ovi Chat, Facebook and Livejournal,
respectively, and this property will be "jabber" for accounts that
connect to a generic Jabber server.

To change this property, use
tp_account_set_service_async().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="storage-identifier"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The storage identifier for this account.

A provider-specific variant type used to identify this account with the
provider. This value will be %NULL if #TpAccount:storage-provider is
an empty string.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="GObject.Value"/>
      </property>
      <property name="storage-identifier-variant"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:space="preserve">Provider-specific information used to identify this
account. Use g_variant_get_type() to check that the type
is what you expect. For instance, if you use a
#TpAccount:storage-provider with numeric identifiers for accounts,
this variant might have type %G_VARIANT_TYPE_UINT32;
if the storage provider has string-based identifiers, it should
have type %G_VARIANT_TYPE_STRING.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="storage-provider"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The storage provider for this account.

The name of the account storage implementation. When this
is the empty string the account is internally stored.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="storage-restrictions"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:space="preserve">The storage restrictions for this account.

A bitfield of #TpStorageRestrictionFlags that give the limitations of
this account imposed by the storage provider. This value will be 0
if #TpAccount:storage-provider is an empty string.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is 0.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="supersedes" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">The object paths of previously-active accounts superseded by this one.
For instance, this can be used in a logger to read old logs for an
account that has been migrated from one connection manager to another.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_CORE feature has been prepared; until then,
the value is NULL.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="uri-schemes" version="0.21.0" transfer-ownership="none">
        <doc xml:space="preserve">If the %TP_ACCOUNT_FEATURE_ADDRESSING feature has been prepared
successfully, a list of additional URI schemes for which this
account should be used if possible. Otherwise %NULL.

For instance, a SIP or Skype account might have "tel" in this list if the
user would like to use that account to call phone numbers.

This list should not contain the primary URI scheme(s) for the account's
protocol (for instance, "xmpp" for XMPP, or "sip" or "sips" for SIP),
since it should be assumed to be useful for those schemes in any case.

The notify::uri-schemes signal cannot be relied on if the Account Manager
is Mission Control version 5.14.0 or older.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="valid" version="0.9.0" transfer-ownership="none">
        <doc xml:space="preserve">Whether this account is valid.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountPrivate" c:type="TpAccountPrivate*"/>
      </field>
      <glib:signal name="avatar-changed" when="last" version="0.23.0">
        <doc xml:space="preserve">Emitted when the avatar changes. Call tp_account_get_avatar_async()
to get the new avatar data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="presence-changed" when="last" version="0.9.0">
        <doc xml:space="preserve">Emitted when the presence of the account changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:space="preserve">the new presence</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">the new presence status</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="status_message" transfer-ownership="none">
            <doc xml:space="preserve">the new presence status message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="status-changed" when="last" version="0.9.0">
        <doc xml:space="preserve">Emitted when the connection status on the account changes.

The @dbus_error_name and @details parameters were present, but
non-functional (always %NULL), in older versions. They have been
available with their current behaviour since version 0.11.7.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_status" transfer-ownership="none">
            <doc xml:space="preserve">old #TpAccount:connection-status</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="new_status" transfer-ownership="none">
            <doc xml:space="preserve">new #TpAccount:connection-status</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the #TpAccount:connection-status-reason</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="dbus_error_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #TpAccount:connection-error</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">the
 #TpAccount:connection-error-details</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="AccountChannelRequest"
           c:symbol-prefix="account_channel_request"
           c:type="TpAccountChannelRequest"
           version="0.11.12"
           parent="GObject.Object"
           glib:type-name="TpAccountChannelRequest"
           glib:get-type="tp_account_channel_request_get_type"
           glib:type-struct="AccountChannelRequestClass">
      <doc xml:space="preserve">Data structure representing a #TpAccountChannelRequest object.</doc>
      <constructor name="new"
                   c:identifier="tp_account_channel_request_new"
                   version="0.11.12">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">the requested
 properties of the channel (see #TpAccountChannelRequest:request)</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_audio_call"
                   c:identifier="tp_account_channel_request_new_audio_call"
                   version="0.19.0">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object
which will yield a Call channel, initially carrying audio only.

After creating the request, you will usually also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()

To call a contact, either use
tp_account_channel_request_set_target_contact() or one of the generic
methods that takes a handle type argument. To check whether this
is possible, use tp_capabilities_supports_audio_call() with
@handle_type set to %TP_HANDLE_TYPE_CONTACT.

&lt;!-- reinstate this when we have CMs that actually allow it:
In some protocols it is possible to create a conference call which
takes place in a named chatroom, by calling
tp_account_channel_request_set_target_id() with @handle_type
set to %TP_HANDLE_TYPE_ROOM. To test whether this is possible, use
tp_capabilities_supports_audio_call() with @handle_type set to
%TP_HANDLE_TYPE_ROOM.
--&gt;

In some protocols, it is possible to create a Call channel without
setting a target at all, which will result in a new, empty
conference call. To test whether this is possible, use
tp_capabilities_supports_audio_call() with @handle_type set to
%TP_HANDLE_TYPE_NONE.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_audio_video_call"
                   c:identifier="tp_account_channel_request_new_audio_video_call"
                   version="0.19.0">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object
which will yield a Call channel, initially carrying both audio
and video.

This is the same as tp_account_channel_request_new_audio_call(),
except that the channel will initially carry video as well as audio,
and instead of using tp_capabilities_supports_audio_call()
you should test capabilities with
tp_capabilities_supports_audio_video_call().

See the documentation of tp_account_channel_request_new_audio_call()
for details of how to set the target (contact, chatroom etc.) for the call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_dbus_tube"
                   c:identifier="tp_account_channel_request_new_dbus_tube"
                   version="0.23.2">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object,
which will yield a DBusTube channel.

After creating the request, you will also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="service_name" transfer-ownership="none">
            <doc xml:space="preserve">the service name that will be used over the tube. It should be</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_file_transfer"
                   c:identifier="tp_account_channel_request_new_file_transfer"
                   version="0.19.0">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object,
which will yield a FileTransfer channel to send a file to a contact.

After creating the request, you will also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">a suggested name for the file, which should not contain
 directories or directory separators (for example, if you are sending
a file called /home/user/monkey.pdf, set this to monkey.pdf)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mime_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the MIME type (content-type) of the file;
 a %NULL value is allowed, and is treated as
 "application/octet-stream"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the file's size in bytes</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stream_tube"
                   c:identifier="tp_account_channel_request_new_stream_tube"
                   version="0.23.2">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object,
which will yield a StreamTube channel.

After creating the request, you will also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the service name that will be used over the tube. It should be a
well-known TCP service name as defined by
http://www.iana.org/assignments/port-numbers or
http://www.dns-sd.org/ServiceTypes.html, for instance "rsync" or "daap".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_text"
                   c:identifier="tp_account_channel_request_new_text"
                   version="0.19.0">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object
which will yield a Text channel.

After creating the request, you will also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_vardict"
                   c:identifier="tp_account_channel_request_new_vardict"
                   version="0.19.10">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountChannelRequest object.

If @request is a floating reference, this function will
take ownership of it, much like g_variant_ref_sink(). See documentation of
that function for details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">the requested
 properties of the channel (see #TpAccountChannelRequest:request)
 as a %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time of the user action that caused this request,
 or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME (see
 #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="create_and_handle_channel_async"
              c:identifier="tp_account_channel_request_create_and_handle_channel_async"
              version="0.11.12">
        <doc xml:space="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_create_and_handle_channel_finish() to get the
result of the operation.

(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_create_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)

The caller is responsible for closing the channel with
tp_cli_channel_call_close() when it has finished handling it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_handle_channel_finish"
              c:identifier="tp_account_channel_request_create_and_handle_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_handle_channel_async().

See tp_account_channel_request_ensure_and_handle_channel_finish()
for details of how @context can be used.

The caller is responsible for closing the channel with
tp_cli_channel_call_close() when it has finished handling it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new reference on a #TpChannel if the
channel was successfully created and you are handling it, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer used to return a
 reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_observe_channel_async"
              c:identifier="tp_account_channel_request_create_and_observe_channel_async"
              version="0.13.14">
        <doc xml:space="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation and a #TpChannel representing the channel
which has been created. Note that you are &lt;emphasis&gt;not&lt;/emphasis&gt; handling
this channel and so should interact with the channel as an Observer.
See &lt;ulink url="http://telepathy.freedesktop.org/doc/book/sect.channel-dispatcher.clients.html"&gt;
the Telepathy book&lt;/ulink&gt; for details about how clients should interact
with channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:space="preserve">Either the well-known bus name (starting with
%TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel,
or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_observe_channel_finish"
              c:identifier="tp_account_channel_request_create_and_observe_channel_finish"
              version="0.13.14"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_observe_channel_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #TpChannel if the channel was
successfully created and dispatched, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_async"
              c:identifier="tp_account_channel_request_create_channel_async"
              version="0.11.12">
        <doc xml:space="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:space="preserve">Either the well-known bus name (starting with
%TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel,
or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_finish"
              c:identifier="tp_account_channel_request_create_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel was successfully created and dispatched,
otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_request"
              c:identifier="tp_account_channel_request_dup_request"
              version="0.19.10">
        <doc xml:space="preserve">Return the #TpAccountChannelRequest:request-vardict construct-only
property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of
 #TpAccountChannelRequest:request-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_async"
              c:identifier="tp_account_channel_request_ensure_and_handle_channel_async"
              version="0.11.12">
        <doc xml:space="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_ensure_and_handle_channel_finish() to get the
result of the operation.

If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS. The other handler
will be notified that the channel was requested again (for instance
with #TpAccountChannelRequest::re-handled,
#TpBaseClientClassHandleChannelsImpl or #TpSimpleHandler:callback),
and can move its window to the foreground, if applicable.

(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_ensure_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_finish"
              c:identifier="tp_account_channel_request_ensure_and_handle_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_and_handle_channel_async().

If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS.

@context can be used to obtain extensible information about the channel
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the caller of this method
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new reference on a #TpChannel if the
channel was successfully created and you are handling it, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer used to return a
 reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_observe_channel_async"
              c:identifier="tp_account_channel_request_ensure_and_observe_channel_async"
              version="0.13.14">
        <doc xml:space="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation and a #TpChannel representing the channel
which has been created. Note that you are &lt;emphasis&gt;not&lt;/emphasis&gt; handling
this channel and so should interact with the channel as an Observer.
See &lt;ulink url="http://telepathy.freedesktop.org/doc/book/sect.channel-dispatcher.clients.html"&gt;
the Telepathy book&lt;/ulink&gt; for details about how clients should interact
with channels.

If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback, if it is implemented using Telepathy-GLib),
so that it can re-present the window to the user, for example.
Otherwise, a new channel will be created and dispatched to a handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:space="preserve">Either the well-known bus name (starting with
%TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel,
or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_observe_channel_finish"
              c:identifier="tp_account_channel_request_ensure_and_observe_channel_finish"
              version="0.13.14"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_observe_channel_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #TpChannel if the channel was
successfully ensure and (re-)dispatched, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_async"
              c:identifier="tp_account_channel_request_ensure_channel_async"
              version="0.11.12">
        <doc xml:space="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.

If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback, if it is implemented using Telepathy-GLib),
so that it can re-present the window to the user, for example.
Otherwise, a new channel will be created and dispatched to a handler.

@callback will be called when an existing channel's handler has been
notified, a new channel has been created and dispatched, or the request
has failed.
You can then call tp_account_channel_request_ensure_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:space="preserve">Either the well-known bus name (starting with
%TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel,
or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_finish"
              c:identifier="tp_account_channel_request_ensure_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel was successfully ensured and (re-)dispatched,
otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_account_channel_request_get_account"
              version="0.11.12">
        <doc xml:space="preserve">Return the #TpAccountChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpAccountChannelRequest:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel_request"
              c:identifier="tp_account_channel_request_get_channel_request"
              version="0.13.13">
        <doc xml:space="preserve">Return the #TpAccountChannelRequest:channel-request property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpAccountChannelRequest:channel-request</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request"
              c:identifier="tp_account_channel_request_get_request"
              version="0.11.12">
        <doc xml:space="preserve">Return the #TpAccountChannelRequest:request construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpAccountChannelRequest:request</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_action_time"
              c:identifier="tp_account_channel_request_get_user_action_time"
              version="0.11.12">
        <doc xml:space="preserve">Return the #TpAccountChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpAccountChannelRequest:user-action-time</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_account_channel_request_set_channel_factory"
              version="0.13.2"
              deprecated="1">
        <doc xml:space="preserve">Set @factory as the #TpClientChannelFactory that will be used to
create the channel requested by @self.
By default #TpAutomaticProxyFactory is used.

This function can't be called once @self has been used to request a
channel.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.5. The factory is taken from
 #TpAccountChannelRequest:account.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">a #TpClientChannelFactory</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_conference_initial_channels"
              c:identifier="tp_account_channel_request_set_conference_initial_channels"
              version="0.23.2">
        <doc xml:space="preserve">Indicate that the channel which is going to be requested using @self
is an upgrade of the channels whose object paths is listed in @channels.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">a #NULL-terminated array of channel paths</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegate_to_preferred_handler"
              c:identifier="tp_account_channel_request_set_delegate_to_preferred_handler"
              version="0.15.3">
        <doc xml:space="preserve">If @delegate is %TRUE, asks to the client currently handling the channels to
delegate them to the preferred handler (passed when calling
tp_account_channel_request_ensure_channel_async() for example).

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="delegate" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to request to delegate channels</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegated_channel_callback"
              c:identifier="tp_account_channel_request_set_delegated_channel_callback"
              version="0.15.3">
        <doc xml:space="preserve">Turn on support for
the org.freedesktop.Telepathy.ChannelRequest.DelegateToPreferredHandler
hint.

When receiving a request containing this hint, @self will automatically
delegate the channel to the preferred handler of the request and then call
@callback to inform the client that it is no longer handling this channel.

@callback may be called any time after (and only after) requesting and
handling the channel (i.e. you have called create_and_handle or
ensure_and_handle).

This function can't be called once @self has been used to request a
channel.

See also: tp_base_client_set_delegated_channels_callback()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">function called the channel requested using @self is
delegated, may not be %NULL</doc>
            <type name="AccountChannelRequestDelegatedChannelCb"
                  c:type="TpAccountChannelRequestDelegatedChannelCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with the @user_data as argument, when @self is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_description"
              c:identifier="tp_account_channel_request_set_file_transfer_description"
              version="0.19.0">
        <doc xml:space="preserve">Configure this channel request to provide the recipient of the file
with the given description.

If file descriptions are not supported by the protocol, or if this
method is used on a request that is not actually a file transfer, the
channel request will fail. Use
tp_capabilities_supports_file_transfer_description() to determine
whether outgoing file transfers can have a description.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">a description of the file</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_hash"
              c:identifier="tp_account_channel_request_set_file_transfer_hash"
              version="0.23.2">
        <doc xml:space="preserve">Configure this channel request to accompany the file transfer with
the hash of the file.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="hash_type" transfer-ownership="none">
            <doc xml:space="preserve">a type of @hash</doc>
            <type name="FileHashType" c:type="TpFileHashType"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">hash of the contents of the file transfer</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_initial_offset"
              c:identifier="tp_account_channel_request_set_file_transfer_initial_offset"
              version="0.19.0">
        <doc xml:space="preserve">Configure this channel request to inform the recipient of the file
that this channel will not send the first @offset bytes of the file.
In some protocols, this can be used to resume an interrupted transfer.

If this method is not called, the default is to start from the
beginning of the file (equivalent to @offset = 0).

If offsets greater than 0 are not supported by the protocol, or if this
method is used on a request that is not actually a file transfer, the
channel request will fail. Use
tp_capabilities_supports_file_transfer_initial_offset() to determine
whether offsets greater than 0 are available.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the offset into the file at which the transfer will start</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_timestamp"
              c:identifier="tp_account_channel_request_set_file_transfer_timestamp"
              version="0.19.0">
        <doc xml:space="preserve">Configure this channel request to accompany the file transfer with
the given modification timestamp for the file.

If file timestamps are not supported by the protocol, or if this
method is used on a request that is not actually a file transfer, the
channel request will fail. Use
tp_capabilities_supports_file_transfer_date() to determine
whether outgoing file transfers can have a timestamp.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve">the modification timestamp of the file, in seconds since the
 Unix epoch (the beginning of 1970 in the UTC time zone), as returned
 by g_date_time_to_unix()</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_uri"
              c:identifier="tp_account_channel_request_set_file_transfer_uri"
              version="0.19.0">
        <doc xml:space="preserve">Configure this channel request to provide other local Telepathy
components with the URI of the file being sent. Unlike most
properties on a file transfer channel, this information is not
sent to the recipient of the file; instead, it is signalled on
D-Bus for use by other Telepathy components.

The URI should usually be a &lt;code&gt;file&lt;/code&gt; URI as defined by
&lt;ulink url="http://www.apps.ietf.org/rfc/rfc1738.html#sec-3.10"&gt;RFC 1738
3.10&lt;/ulink&gt; (for instance, &lt;code&gt;file:///path/to/file&lt;/code&gt; or
&lt;code&gt;file://localhost/path/to/file&lt;/code&gt;). If a remote resource
is being transferred to a contact, it may have a different scheme,
such as &lt;code&gt;http&lt;/code&gt;.

Even if this method is used, the connection manager will not read
the file from disk: the handler for the channel is still
responsible for streaming the file. However, providing the URI
allows a local logger to log which file was transferred, for instance.

If this functionality is not supported by the connection manager, or
if this method is used on a request that is not actually a file transfer,
the channel request will fail. Use
tp_capabilities_supports_file_transfer_uri() to determine
whether outgoing file transfers can have a URI.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the source URI for the file</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint"
              c:identifier="tp_account_channel_request_set_hint"
              version="0.19.8">
        <doc xml:space="preserve">Set additional information about the channel request, which will be used
in the resulting request's #TpChannelRequest:hints property.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key used for the hint</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a variant containting the hint value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hints"
              c:identifier="tp_account_channel_request_set_hints"
              version="0.13.14">
        <doc xml:space="preserve">Set additional information about the channel request, which will be used
as the value for the resulting request's #TpChannelRequest:hints property.

This function can't be called once @self has been used to request a
channel.

In high-level language bindings, use tp_account_channel_request_set_hint()
instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">a #TP_HASH_TYPE_STRING_VARIANT_MAP</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_initial_invitee_ids"
              c:identifier="tp_account_channel_request_set_initial_invitee_ids"
              version="0.23.2">
        <doc xml:space="preserve">Indicate that the contacts listed in @ids have to be invited to the
conference represented by the channel which is going to be requested
using @self.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:space="preserve">a #NULL-terminated array of contact ids</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_initial_invitees"
              c:identifier="tp_account_channel_request_set_initial_invitees"
              version="0.23.2">
        <doc xml:space="preserve">Indicate that the contacts listed in @contacts have to be invited to the
conference represented by the channel which is going to be requested
using @self.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">a #GPtrArray of #TpContact</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_request_property"
              c:identifier="tp_account_channel_request_set_request_property"
              version="0.19.0">
        <doc xml:space="preserve">Configure this channel request to include the given property, as
documented in the Telepathy D-Bus API Specification or an
implementation-specific extension.

Using this method is not recommended, but it can be necessary for
experimental or implementation-specific interfaces.

If the property is not supported by the protocol or channel type, the
channel request will fail. Use #TpCapabilities and the Telepathy
D-Bus API Specification to determine which properties are available.

If @value is a floating reference, this method takes ownership of it
by using g_variant_ref_sink(). This allows convenient inline use of
#GVariant constructors:

|[
tp_account_channel_request_set_request_property (acr, "com.example.Int",
    g_variant_new_int32 (17));
tp_account_channel_request_set_request_property (acr, "com.example.String",
    g_variant_new_string ("ferret"));
]|

It is an error to provide a @value which contains types not supported by
D-Bus.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus property name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an arbitrary value for the property</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sms_channel"
              c:identifier="tp_account_channel_request_set_sms_channel"
              version="0.23.2">
        <doc xml:space="preserve">If @is_sms_channel is set to #TRUE, messages sent and received on the
requested channel will be transmitted via SMS.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="is_sms_channel" transfer-ownership="none">
            <doc xml:space="preserve">#TRUE if the channel should use SMS</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_target_contact"
              c:identifier="tp_account_channel_request_set_target_contact"
              version="0.19.0">
        <doc xml:space="preserve">Configure this request to create a peer-to-peer channel with @contact as
the other peer.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">the contact to be contacted</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_target_id"
              c:identifier="tp_account_channel_request_set_target_id"
              version="0.19.0">
        <doc xml:space="preserve">Configure this request to create a channel with @identifier,
an identifier of type @handle_type.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountChannelRequest</doc>
            <type name="AccountChannelRequest"
                  c:type="TpAccountChannelRequest*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of @identifier, typically %TP_HANDLE_TYPE_CONTACT
 or %TP_HANDLE_TYPE_ROOM</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">the unique identifier of the contact, room etc. to be
 contacted</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.12"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpAccount used to request the channel.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channel-request" transfer-ownership="none">
        <doc xml:space="preserve">The #TpChannelRequest used to request the channel, or %NULL if the
channel has not be requested yet.

This can be useful for example to compare with the #TpChannelRequest
objects received from the requests_satisfied argument of
#TpSimpleHandlerHandleChannelsImpl to check if the client is asked to
handle the channel it just requested.

Note that the #TpChannelRequest objects may be different while still
representing the same ChannelRequest on D-Bus. You have to compare
them using their object paths (tp_proxy_get_object_path()).

Since 0.13.13</doc>
        <type name="ChannelRequest"/>
      </property>
      <property name="request"
                version="0.11.12"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The desired D-Bus properties for the channel, represented as a
#GHashTable where the keys are strings and the values are #GValue.

When constructing a new object, one of
#TpAccountChannelRequest:request or
#TpAccountChannelRequest:request-vardict must be set to a non-%NULL
value, and the other must remain unspecified.</doc>
        <type/>
      </property>
      <property name="request-vardict"
                version="0.19.10"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The desired D-Bus properties for the channel.

When constructing a new object, one of
#TpAccountChannelRequest:request or
#TpAccountChannelRequest:request-vardict must be set to a non-%NULL
value, and the other must remain unspecified.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="user-action-time"
                version="0.11.12"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The user action time that will be passed to the channel dispatcher when
requesting the channel.

This may be the time at which user action occurred, or one of the special
values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME.

If %TP_USER_ACTION_TIME_NOT_USER_ACTION, the action doesn't involve any
user action. Clients should avoid stealing focus when presenting the
channel.

If %TP_USER_ACTION_TIME_CURRENT_TIME, clients SHOULD behave as though the
user action happened at the current time, e.g. a client may
request that its window gains focus.

On X11-based systems, GDK 2, GDK 3, Clutter 1.0 etc.,
tp_user_action_time_from_x11() can be used to convert an X11 timestamp to
a Telepathy user action time.

If the channel request succeeds, this user action time will be passed on
to the channel's handler. If the handler is a GUI, it may use
tp_user_action_time_should_present() to decide whether to bring its
window to the foreground.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <glib:signal name="re-handled"
                   when="last"
                   detailed="1"
                   version="0.11.12">
        <doc xml:space="preserve">Emitted when the channel created using @self has been "re-handled".

This means that a Telepathy client has made another request for a
matching channel using an "ensure" API like
tp_account_channel_request_ensure_channel_async(), while the channel
still exists. Instead of creating a new channel, the channel dispatcher
notifies the existing handler of @channel, resulting in this signal.

Most GUI handlers should respond to this signal by checking
@user_action_time, and if appropriate, moving to the foreground.

@context can be used to obtain extensible information about the channel
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the receiver of this signal
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">the #TpChannel being re-handled</doc>
            <type name="Channel"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time at which user action occurred, or one of the
 special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME; see
 #TpAccountChannelRequest:user-action-time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleChannelsContext representing the context of
the HandleChannels() call.</doc>
            <type name="HandleChannelsContext"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountChannelRequestClass"
            c:type="TpAccountChannelRequestClass"
            disguised="1"
            glib:is-gtype-struct-for="AccountChannelRequest"
            version="0.11.12">
      <doc xml:space="preserve">The class of a #TpAccountChannelRequest.</doc>
    </record>
    <callback name="AccountChannelRequestDelegatedChannelCb"
              c:type="TpAccountChannelRequestDelegatedChannelCb"
              version="0.15.3">
      <doc xml:space="preserve">Called when a client asked us to delegate @channel to another Handler.
When this function is called you are no longer handling @channel.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="request" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccountChannelRequest instance</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </parameter>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">a #TpChannel</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">arbitrary user-supplied data passed to
tp_account_channel_request_set_delegated_channel_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AccountChannelRequestPrivate"
            c:type="TpAccountChannelRequestPrivate"
            disguised="1">
    </record>
    <record name="AccountClass"
            c:type="TpAccountClass"
            glib:is-gtype-struct-for="Account">
      <doc xml:space="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountClassPrivate" c:type="TpAccountClassPrivate*"/>
      </field>
    </record>
    <record name="AccountClassPrivate"
            c:type="TpAccountClassPrivate"
            disguised="1">
    </record>
    <class name="AccountManager"
           c:symbol-prefix="account_manager"
           c:type="TpAccountManager"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpAccountManager"
           glib:get-type="tp_account_manager_get_type"
           glib:type-struct="AccountManagerClass">
      <doc xml:space="preserve">The Telepathy Account Manager stores real-time communication accounts and
their configuration, places accounts online on request, and manipulates
accounts' presence, nicknames and avatars.

#TpAccountManager is the "top level" object. Since 0.16 it always has a
non-%NULL #TpProxy:factory, and its #TpProxy:factory will be
propagated to all other objects like #TpAccountManager -&gt; #TpAccount -&gt;
#TpConnection -&gt; #TpContact and #TpChannel. This means that desired features
set on that factory will be prepared on all those objects.
If a #TpProxy:factory is not specified when the #TpAccountManager is
constructed, it will use a #TpAutomaticClientFactory.

&lt;example id="account-manager"&gt;&lt;title&gt;TpAccountManager example&lt;/title&gt;&lt;programlisting&gt;&lt;xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="../../../examples/client/contact-list.c"&gt;&lt;xi:fallback&gt;FIXME: MISSING XINCLUDE CONTENT&lt;/xi:fallback&gt;&lt;/xi:include&gt;&lt;/programlisting&gt;&lt;/example&gt;</doc>
      <constructor name="new" c:identifier="tp_account_manager_new">
        <doc xml:space="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be prepared on return.
Its #TpProxy:factory will be a new #TpAutomaticClientFactory for
@bus_daemon.

Use tp_account_manager_dup() instead if you want an account manager proxy
on the starter or session bus (which is almost always the right thing for
Telepathy).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:space="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_account_manager_new_with_factory">
        <doc xml:space="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be ready on return.

Should be used only by applications having their own #TpSimpleClientFactory
subclass. Usually this should be done at application startup and followed by
a call to tp_account_manager_set_default() to ensure other libraries/plugins
will use this custom factory as well.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="can_set_default"
                c:identifier="tp_account_manager_can_set_default"
                version="0.19.6">
        <doc xml:space="preserve">Check if tp_account_manager_set_default() has already successfully been
called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if tp_account_manager_set_default() has already successfully
been called in this process, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <function name="dup"
                c:identifier="tp_account_manager_dup"
                version="0.9.0">
        <doc xml:space="preserve">Returns an account manager proxy on the D-Bus daemon on which this
process was activated (if it was launched by D-Bus service activation), or
the session bus (otherwise). This account manager will always have
the result of tp_dbus_daemon_dup() as its #TpProxy:dbus-daemon.

The returned #TpAccountManager is cached; the same #TpAccountManager object
will be returned by this function repeatedly, as long as at least one
reference exists. Note that the returned #TpAccountManager is not guaranteed
to be ready on return.

If tp_account_manager_set_default() has been called successfully,
that #TpAccountManager will be returned. Otherwise, a new #TpAccountManager
will be created the first time this function is called, using a new
#TpAutomaticClientFactory as its #TpProxy:factory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an account manager proxy on the starter or session
         bus, or %NULL if it wasn't possible to get a dbus daemon proxy for
         the appropriate bus</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_account_manager_get_feature_quark_core"
                version="0.9.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for representing the core feature of a
         #TpAccountManager</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_account_manager_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpAccountManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="create_account_async"
              c:identifier="tp_account_manager_create_account_async"
              version="0.9.0">
        <doc xml:space="preserve">Requests an asynchronous create of an account on the account manager
@manager. When the operation is finished, @callback will be called. You can
then call tp_account_manager_create_account_finish() to get the result of
the operation.

The #TpAccount returned by tp_account_manager_create_account_finish()
will already have %TP_ACCOUNT_FEATURE_CORE prepared, along with all
features previously passed to
tp_simple_client_factory_add_account_features() for the account
manager's #TpProxy:factory.

It is usually better to use #TpAccountRequest instead, particularly when
using high-level language bindings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="connection_manager" transfer-ownership="none">
            <doc xml:space="preserve">the name of a connection manager</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the name of a protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">the display name for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">parameters
 for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:space="preserve">properties
 for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish"
              c:identifier="tp_account_manager_create_account_finish"
              version="0.9.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async create account operation, and returns a new #TpAccount
object. It has %TP_ACCOUNT_FEATURE_CORE prepared, along with all
features previously passed to
tp_simple_client_factory_add_account_features() for the account
manager's #TpProxy:factory.

The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept beyond the lifetime of @result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #TpAccount which was just created on
 success, otherwise %NULL</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_valid_accounts"
              c:identifier="tp_account_manager_dup_valid_accounts"
              version="0.19.9">
        <doc xml:space="preserve">Returns a newly allocated #GList of reffed valid accounts in @manager.
The list must be freed with g_list_free_full() and g_object_unref() after
used.

The returned #TpAccount&lt;!-- --&gt;s are guaranteed to have
%TP_ACCOUNT_FEATURE_CORE prepared, along with all features previously passed
to tp_simple_client_factory_add_account_features() for the account
manager's #TpProxy:factory.

The list of valid accounts returned is not guaranteed to have been retrieved
until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared
(tp_proxy_prepare_async() has returned). Until this feature has
been prepared, an empty list (%NULL) will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly
 allocated #GList of reffed valid accounts in @manager</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Account"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="enable_restart"
              c:identifier="tp_account_manager_enable_restart">
        <doc xml:space="preserve">Enable autostarting the account manager D-Bus service. This means
that the account manager will be restarted if it disappears from
the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ensure_account"
              c:identifier="tp_account_manager_ensure_account"
              version="0.9.0"
              deprecated="1">
        <doc xml:space="preserve">Lookup an account in the account manager @manager. If the desired account
has already been ensured then the same object will be returned, otherwise
it will create a new #TpAccount and add it to @manager. As a result, if
@manager thinks that the account doesn't exist, this will still add it to
@manager to avoid races.

The account will be constructed via this account manager's #TpProxy:factory
(so it will be of an appropriate #TpAccount subclass if the factory
returns one), but does not necessarily have any features prepared yet.
Use tp_proxy_prepare_async() to prepare features, using
the contents of tp_simple_client_factory_dup_account_features() as a
parameter if you want to prepare the same features that would
normally be used.

The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept.</doc>
        <doc-deprecated xml:space="preserve">New code should call tp_simple_client_factory_ensure_account()
 on this object's #TpProxy:factory instead, which ensures that a new
 reference is returned.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #TpAccount at @path, or %NULL if @path is
 not a valid account path.</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the object path for an account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_most_available_presence"
              c:identifier="tp_account_manager_get_most_available_presence"
              version="0.9.0">
        <doc xml:space="preserve">Gets the most available presence over all accounts in @manager. This
function does not average presences across all accounts, but it merely
finds the "most available" presence. As a result, there is a guarantee
that there exists at least one account in @manager with the returned
presence.

If no accounts are enabled or valid the output will be
(%TP_CONNECTION_PRESENCE_TYPE_OFFLINE, "offline", "").

Since 0.17.5, if the only connected accounts does not implement
%TP_IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE, the output will be
(%TP_CONNECTION_PRESENCE_TYPE_AVAILABLE, "available", "").

The return value of this function is not guaranteed to have been retrieved
until tp_proxy_prepare_async() has finished; until then, the
value will be the same as if no accounts are enabled or valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the most available presence across all accounts</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a string to fill with the actual status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a string to fill with the actual status
 message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_accounts"
              c:identifier="tp_account_manager_get_valid_accounts"
              version="0.9.0"
              deprecated="1">
        <doc xml:space="preserve">Returns a newly allocated #GList of valid accounts in @manager. The list
must be freed with g_list_free() after used. None of the accounts in the
returned list are guaranteed to be ready.

Note that the #TpAccount&lt;!-- --&gt;s in the returned #GList are not reffed
before returning from this function. One could ref every item in the list
like the following example:
|[
GList *accounts;
account = tp_account_manager_get_valid_accounts (manager);
g_list_foreach (accounts, (GFunc) g_object_ref, NULL);
]|

The returned #TpAccount&lt;!-- --&gt;s are guaranteed to have
%TP_ACCOUNT_FEATURE_CORE prepared, along with all features previously passed
to tp_simple_client_factory_add_account_features() for the account
manager's #TpProxy:factory.

The list of valid accounts returned is not guaranteed to have been retrieved
until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared
(tp_proxy_prepare_async() has returned). Until this feature has
been prepared, an empty list (%NULL) will be returned.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_account_manager_dup_valid_accounts() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a newly allocated #GList of valid accounts in @manager</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Account"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_prepared"
              c:identifier="tp_account_manager_is_prepared"
              version="0.9.0"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">since 0.23.0, use tp_proxy_is_prepared() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_account_manager_prepare_async"
              version="0.9.0"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Requests an asynchronous preparation of @manager with
%TP_ACCOUNT_MANAGER_FEATURE_CORE, plus any features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_manager_prepare_finish() to get the result of the
operation.

If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.

In version 0.11.3 or later, this is equivalent to calling
tp_proxy_prepare_async() with the same arguments.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.6, use tp_proxy_prepare_async() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="const GQuark*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_account_manager_prepare_finish"
              version="0.9.0"
              introspectable="0"
              deprecated="1"
              throws="1">
        <doc xml:space="preserve">Finishes an async preparation of the account manager @manager.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.6, use tp_proxy_prepare_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_all_requested_presences"
              c:identifier="tp_account_manager_set_all_requested_presences"
              version="0.9.0">
        <doc xml:space="preserve">Iterates through the accounts in @manager and requests the presence
(@type, @status and @message). Note that the presence requested here is
merely a request, and if might not be satisfiable.

You can find the most available presence across all accounts by calling
tp_account_manager_get_most_available_presence().

Setting a requested presence on all accounts will have no effect
until tp_proxy_prepare_async()
(or the older tp_account_manager_prepare_async()) has finished.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a presence type to request</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">a status to request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a status message to request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default"
              c:identifier="tp_account_manager_set_default"
              version="0.15.5">
        <doc xml:space="preserve">Define the #TpAccountManager singleton that will be returned by
tp_account_manager_dup().

This function may only be called before the first call to
tp_account_manager_dup(), and may not be called more than once. Applications
which use a custom #TpSimpleClientFactory and want the default
#TpAccountManager to use that factory should call this after calling
tp_account_manager_new_with_factory().

Unlike tp_account_manager_dup(), this function will keep an internal
reference to @manager, so it will never be destroyed.

Note that @manager must use the default #TpDBusDaemon as returned by
tp_dbus_daemon_dup()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountManager</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountManagerPrivate" c:type="TpAccountManagerPrivate*"/>
      </field>
      <glib:signal name="account-disabled" when="last" version="0.9.0">
        <doc xml:space="preserve">Emitted when an account from @manager is disabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-enabled" when="last" version="0.9.0">
        <doc xml:space="preserve">Emitted when an account from @manager is enabled.

@account is guaranteed to have %TP_ACCOUNT_FEATURE_CORE prepared, along
with all the features previously passed to the #TpProxy:factory&lt;!-- --&gt;'s
tp_simple_client_factory_add_account_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-removed" when="last" version="0.9.0">
        <doc xml:space="preserve">Emitted when an account is removed from @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-validity-changed" when="last" version="0.9.0">
        <doc xml:space="preserve">Emitted when the validity on @account changes.

This signal is also used to indicate a new account that did not
previously exist has been added (with @valid set to %TRUE).

If @valid is %TRUE,
@account is guaranteed to have %TP_ACCOUNT_FEATURE_CORE prepared, along
with all the features previously passed to the #TpProxy:factory&lt;!-- --&gt;'s
tp_simple_client_factory_add_account_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
          <parameter name="valid" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the account is now valid</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="most-available-presence-changed"
                   when="last"
                   version="0.9.0">
        <doc xml:space="preserve">Emitted when the most available presence on @manager changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:space="preserve">new presence type</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">new status</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">new status message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountManagerClass"
            c:type="TpAccountManagerClass"
            glib:is-gtype-struct-for="AccountManager">
      <doc xml:space="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountManagerClassPrivate"
              c:type="TpAccountManagerClassPrivate*"/>
      </field>
    </record>
    <record name="AccountManagerClassPrivate"
            c:type="TpAccountManagerClassPrivate"
            disguised="1">
    </record>
    <record name="AccountManagerPrivate"
            c:type="TpAccountManagerPrivate"
            disguised="1">
    </record>
    <record name="AccountPrivate" c:type="TpAccountPrivate" disguised="1">
    </record>
    <class name="AccountRequest"
           c:symbol-prefix="account_request"
           c:type="TpAccountRequest"
           version="0.19.1"
           parent="GObject.Object"
           glib:type-name="TpAccountRequest"
           glib:get-type="tp_account_request_get_type"
           glib:type-struct="AccountRequestClass">
      <doc xml:space="preserve">An object for representing a currently non-existent account which
is to be created on a #TpAccountManager.</doc>
      <constructor name="new"
                   c:identifier="tp_account_request_new"
                   version="0.19.1">
        <doc xml:space="preserve">Convenience function to create a new account request object which
will assist in the creation of a new account on @account_manager,
using connection manager @manager, and protocol @protocol.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an account request
  object, or %NULL if any argument is incorrect</doc>
          <type name="AccountRequest" c:type="TpAccountRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:space="preserve">the #TpAccountManager to create the account on</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">the name of the connection manager</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the name of the protocol on @manager</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">the user-visible name of this account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_protocol"
                   c:identifier="tp_account_request_new_from_protocol"
                   version="0.19.1">
        <doc xml:space="preserve">Convenience function to create a new #TpAccountRequest object using
a #TpProtocol instance, instead of specifying connection manager
and protocol name specifically. See tp_account_request_new() for
more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an account request
  object, or %NULL if any argument is incorrect</doc>
          <type name="AccountRequest" c:type="TpAccountRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:space="preserve">the #TpAccountManager to create the account on</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProtocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">the user-visible name of this account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_supersedes"
              c:identifier="tp_account_request_add_supersedes"
              version="0.19.1">
        <doc xml:space="preserve">Add an account object path to the list of superseded accounts which
this new account will supersede. Use the
#TpAccountRequest:supersedes property to read the current list of
superseded accounts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="superseded_path" transfer-ownership="none">
            <doc xml:space="preserve">an account object path to add to the supersedes
  list</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_async"
              c:identifier="tp_account_request_create_account_async"
              version="0.19.1">
        <doc xml:space="preserve">Start an asynchronous operation to create the account @self on the
account manager.

@callback will only be called when the newly created #TpAccount has
the %TP_ACCOUNT_FEATURE_CORE feature ready on it, so when calling
tp_account_request_create_account_finish(), one can guarantee this
feature.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a function to call when the account has been created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish"
              c:identifier="tp_account_request_create_account_finish"
              version="0.19.1"
              throws="1">
        <doc xml:space="preserve">Finishes an asynchronous account creation operation and returns a
new ref to a #TpAccount object. The returned account will have the
features listed in tp_simple_client_factory_dup_account_features()
(with the proxy factory from #TpAccountRequest:account-manager)
prepared on it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new ref to a #TpAccount, or %NULL</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence"
              c:identifier="tp_account_request_set_automatic_presence"
              version="0.19.1">
        <doc xml:space="preserve">Set the automatic presence for the new account, @self, to the type
(@presence, @status), with message @message. Use the
#TpAccountRequest:automatic-presence-type,
#TpAccountRequest:automatic-status, and
#TpAccountRequest:automatic-status-message properties to read the
current automatic presence.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:space="preserve">the automatic presence type</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">the automatic presence status</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the automatic presence message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar"
              c:identifier="tp_account_request_set_avatar"
              version="0.19.1">
        <doc xml:space="preserve">Set the avatar of the account @self to @avatar. Use the
#TpAccountRequest:avatar and #TpAccountRequest:avatar-mime-type
properties to read the current avatar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="avatar"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a new avatar to set; can
  be %NULL only if %len equals 0</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the new avatar</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the MIME type of the new avatar; can be %NULL
 only if @len equals 0</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically"
              c:identifier="tp_account_request_set_connect_automatically"
              version="0.19.1">
        <doc xml:space="preserve">Set the connect automatically property of the account on creation
to @connect_automatically so that the account is brought online to
the automatic presence. Use the
#TpAccountRequest:connect-automatically property to read the current
connect automatically value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="connect_automatically" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the account is to connect automatically</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name"
              c:identifier="tp_account_request_set_display_name"
              version="0.19.1">
        <doc xml:space="preserve">Set the display name for the new account, @self, to @name. Use the
#TpAccountRequest:display-name property to read the current display
name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a display name for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled"
              c:identifier="tp_account_request_set_enabled"
              version="0.19.1">
        <doc xml:space="preserve">Set the enabled property of the account on creation to
@enabled. Use the #TpAccountRequest:enabled property to read the
current enabled value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the account is to be enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name"
              c:identifier="tp_account_request_set_icon_name"
              version="0.19.1">
        <doc xml:space="preserve">Set the icon name for the new account, @self, to @icon. Use the
#TpAccountRequest:icon-name property to read the current icon name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">an icon name for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname"
              c:identifier="tp_account_request_set_nickname"
              version="0.19.1">
        <doc xml:space="preserve">Set the nickname for the new account, @self, to @nickname. Use the
#TpAccountRequest:nickname property to read the current nickname.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:space="preserve">a nickname for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parameter"
              c:identifier="tp_account_request_set_parameter"
              version="0.19.1">
        <doc xml:space="preserve">Set an account parameter, @key, to @value. Use the
#TpAccountRequest:parameters property to read the current list of
set parameters.

Parameters can be unset using tp_account_request_unset_parameter().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the parameter key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a variant containing the parameter value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parameter_string"
              c:identifier="tp_account_request_set_parameter_string"
              version="0.19.1"
              introspectable="0">
        <doc xml:space="preserve">Convenience function to set an account parameter string value. See
tp_account_request_set_parameter() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the parameter key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the parameter value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_requested_presence"
              c:identifier="tp_account_request_set_requested_presence"
              version="0.19.1">
        <doc xml:space="preserve">Set the requested presence for the new account, @self, to the type
(@presence, @status), with message @message. Use the
#TpAccountRequest:requested-presence-type,
#TpAccountRequest:requested-status, and
#TpAccountRequest:requested-status-message properties to read the
current requested presence.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:space="preserve">the requested presence type</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">the requested presence status</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the requested presence message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service"
              c:identifier="tp_account_request_set_service"
              version="0.19.1">
        <doc xml:space="preserve">Set the service property of the account to @service. Use the
#TpAccountRequest:service property to read the current value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the service name for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_storage_provider"
              c:identifier="tp_account_request_set_storage_provider"
              version="0.19.4">
        <doc xml:space="preserve">Set the account storage to use when creating the account. Use the
#TpAccountRequest:storage-provider property to read the current value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="provider" transfer-ownership="none">
            <doc xml:space="preserve">the name of an account storage implementation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset_parameter"
              c:identifier="tp_account_request_unset_parameter"
              version="0.19.1">
        <doc xml:space="preserve">Unset the account parameter @key which has previously been set
using tp_account_request_set_parameter() or another convenience
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccountRequest</doc>
            <type name="AccountRequest" c:type="TpAccountRequest*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the parameter key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account-manager"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpAccountManager to create the account on.</doc>
        <type name="AccountManager"/>
      </property>
      <property name="automatic-presence-type"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's automatic presence type (a
#TpConnectionPresenceType). To change this property use
tp_account_request_set_automatic_presence().

When the account is put online automatically, for instance to
make a channel request or because network connectivity becomes
available, the automatic presence type, status and message will
be copied to their "requested" counterparts.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="automatic-status"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The string status name to use in conjunction with the
#TpAccountRequest:automatic-presence-type. To change this property
use tp_account_request_set_automatic_presence().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="automatic-status-message"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The user-defined message to use in conjunction with the
#TpAccount:automatic-presence-type. To change this property use
tp_account_request_set_automatic_presence().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="avatar" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">The avatar set on the account. The avatar's mime type can be read
in the #TpAccountRequest:avatar-mime-type property. To change this
property, use tp_account_request_set_avatar().</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="avatar-mime-type"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The mime type of the #TpAccountRequest:avatar property. To change
this property, use tp_account_request_set_avatar().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connect-automatically"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether the account should connect automatically or not. To change this
property, use tp_account_request_set_connect_automatically().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="connection-manager"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's connection manager name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="display-name"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's display name. To change this property use
tp_account_request_set_display_name().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="enabled" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the account is enabled or not. To change this property
use tp_account_request_set_enabled().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="icon-name" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">The account's icon name. To change this propery, use
tp_account_request_set_icon_name().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nickname" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">The account's nickname. To change this property use
tp_account_request_set_nickname().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parameters" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">The account's connection parameters. To add a parameter, use
tp_account_request_set_parameter() or another convience function.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="properties" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">The account's properties.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="protocol"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="requested-presence-type"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's requested presence type (a
#TpConnectionPresenceType). To change this property use
tp_account_request_set_requested_presence().</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="requested-status"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The requested Status string of the account. To change this
property use tp_account_request_set_requested_presence().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="requested-status-message"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The requested status message message of the account. To change
this property use tp_account_request_set_requested_presence().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">A string describing the service of the account, which must
consist only of ASCII letters, numbers and hyphen/minus signs,
and start with a letter (matching the requirements for
Protocol). To change this property, use
tp_account_request_set_service().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="storage-provider"
                version="0.19.4"
                transfer-ownership="none">
        <doc xml:space="preserve">The account's storage provider. To change this property use
tp_account_request_set_storage_provider().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="supersedes" version="0.19.1" transfer-ownership="none">
        <doc xml:space="preserve">The object paths of previously-active accounts superseded by this one.
For instance, this can be used in a logger to read old logs for an
account that has been migrated from one connection manager to another.

To add to this property use tp_account_request_add_supersedes().</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountRequestPrivate" c:type="TpAccountRequestPrivate*"/>
      </field>
    </class>
    <record name="AccountRequestClass"
            c:type="TpAccountRequestClass"
            glib:is-gtype-struct-for="AccountRequest">
      <doc xml:space="preserve">The class of a #TpAccountRequest.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="AccountRequestPrivate"
            c:type="TpAccountRequestPrivate"
            disguised="1">
    </record>
    <class name="AddDispatchOperationContext"
           c:symbol-prefix="add_dispatch_operation_context"
           c:type="TpAddDispatchOperationContext"
           version="0.11.5"
           parent="GObject.Object"
           glib:type-name="TpAddDispatchOperationContext"
           glib:get-type="tp_add_dispatch_operation_context_get_type"
           glib:type-struct="AddDispatchOperationContextClass">
      <doc xml:space="preserve">Data structure representing the context of a Approver.AddDispatchOperation()
call.</doc>
      <method name="accept"
              c:identifier="tp_add_dispatch_operation_context_accept"
              version="0.11.5">
        <doc xml:space="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAddDispatchOperationContext</doc>
            <type name="AddDispatchOperationContext"
                  c:type="TpAddDispatchOperationContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delay"
              c:identifier="tp_add_dispatch_operation_context_delay"
              version="0.11.5">
        <doc xml:space="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpAddDispatchOperationContext before calling this function, and
is responsible for calling either
tp_add_dispatch_operation_context_accept() or
tp_add_dispatch_operation_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAddDispatchOperationContext</doc>
            <type name="AddDispatchOperationContext"
                  c:type="TpAddDispatchOperationContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fail"
              c:identifier="tp_add_dispatch_operation_context_fail"
              version="0.11.5">
        <doc xml:space="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAddDispatchOperationContext</doc>
            <type name="AddDispatchOperationContext"
                  c:type="TpAddDispatchOperationContext*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.5"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
AddDispatchOperation call.
Can only be written during construction.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="dispatch-operation"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="ChannelDispatchOperation"/>
      </property>
    </class>
    <record name="AddDispatchOperationContextClass"
            c:type="TpAddDispatchOperationContextClass"
            disguised="1"
            glib:is-gtype-struct-for="AddDispatchOperationContext"
            version="0.11.5">
      <doc xml:space="preserve">The class of a #TpAddDispatchOperationContext.</doc>
    </record>
    <record name="AddDispatchOperationContextPrivate"
            c:type="TpAddDispatchOperationContextPrivate"
            disguised="1">
    </record>
    <bitfield name="AnonymityModeFlags" c:type="TpAnonymityModeFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags for the various types of anonymity modes.  These modes are solely to         inform the CM of the desired anonymous settings.  It is up to the         CM to determine whether the anonymity modes should be handled within         the CM itself, or whether the network that a CM might be talking to         should be enforcing anonymity.          CMs MAY support only a subset of these modes, and specific         connections MAY support none at all.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="client_info"
              value="1"
              c:identifier="TP_ANONYMITY_MODE_CLIENT_INFO">
        <doc xml:space="preserve">&lt;![CDATA[           Obscure any information that provides user identification,           user-agent identification or personal details. Examples of this           information might be GSM CallerID, SIP from address, various           informational email headers, etc.            The CM should scrub/replace any of this information before           passing messages or data onto the network. Note that a CM which           has the option of obscuring the information at the CM or privacy           service level would choose both (anonymity services are opaque           to clients of this interface).            Clients SHOULD NOT set both Client_Info and Show_Client_Info modes.           If they are set, the CM MUST respect Client_Info and ignore           Show_Client_Info.         ]]&gt;</doc>
      </member>
      <member name="show_client_info"
              value="2"
              c:identifier="TP_ANONYMITY_MODE_SHOW_CLIENT_INFO">
        <doc xml:space="preserve">&lt;![CDATA[           Explicitly request showing of client information. In connection           context, this can be used to override service default. In channel           context, this overrides connection anonymity modes.                         In GSM, it's possible to have CLIR enabled by default, and               explicitly suppress CLIR for a single phone call.                       Clients SHOULD NOT set both Client_Info and Show_Client_Info modes.           If they are set, the CM MUST respect Client_Info and ignore           Show_Client_Info. The CM MAY set both Client_Info and Show_Client_Info           in SupportedAnonymityModes to indicate           its support for explicitly hiding and publicising client information.                    ]]&gt;</doc>
      </member>
      <member name="network_info"
              value="4"
              c:identifier="TP_ANONYMITY_MODE_NETWORK_INFO">
        <doc xml:space="preserve">&lt;![CDATA[           Obscure any originating IP address information, contact URIs,           and anonymize all traffic involved with sending/receiving any           media streams or call content.           Examples of this include the "headers" portions of           RFC 3323 as           well as the History-Info (described in           RFC 4244)           for a SIP CM.            This SHOULD have the effect of hiding address information from           the remote contact (ie, the contact cannot know what IP address           the session is originated from). Obviously the network still needs           to be able to route information between contacts, so this provides           no guarantees of what can be seen by intermediaries.         ]]&gt;</doc>
      </member>
    </bitfield>
    <class name="AutomaticClientFactory"
           c:symbol-prefix="automatic_client_factory"
           c:type="TpAutomaticClientFactory"
           version="0.15.5"
           parent="SimpleClientFactory"
           glib:type-name="TpAutomaticClientFactory"
           glib:get-type="tp_automatic_client_factory_get_type"
           glib:type-struct="AutomaticClientFactoryClass">
      <doc xml:space="preserve">Data structure representing a #TpAutomaticClientFactory</doc>
      <constructor name="new"
                   c:identifier="tp_automatic_client_factory_new"
                   version="0.15.5">
        <doc xml:space="preserve">Returns a new #TpAutomaticClientFactory instance. If @dbus is %NULL,
tp_dbus_daemon_dup() will be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAutomaticClientFactory</doc>
          <type name="AutomaticClientFactory"
                c:type="TpAutomaticClientFactory*"/>
        </return-value>
        <parameters>
          <parameter name="dbus"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #TpDBusDaemon, or %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="SimpleClientFactory" c:type="TpSimpleClientFactory"/>
      </field>
    </class>
    <record name="AutomaticClientFactoryClass"
            c:type="TpAutomaticClientFactoryClass"
            glib:is-gtype-struct-for="AutomaticClientFactory"
            version="0.15.5">
      <doc xml:space="preserve">The class of a #TpAutomaticClientFactory.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="SimpleClientFactoryClass"
              c:type="TpSimpleClientFactoryClass"/>
      </field>
    </record>
    <class name="AutomaticProxyFactory"
           c:symbol-prefix="automatic_proxy_factory"
           c:type="TpAutomaticProxyFactory"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpAutomaticProxyFactory"
           glib:get-type="tp_automatic_proxy_factory_get_type"
           glib:type-struct="AutomaticProxyFactoryClass">
      <doc xml:space="preserve">Data structure representing a #TpAutomaticProxyFactory</doc>
      <implements name="ClientChannelFactory"/>
      <constructor name="new"
                   c:identifier="tp_automatic_proxy_factory_new"
                   version="0.13.2"
                   deprecated="1">
        <doc xml:space="preserve">Convenient function to create a new #TpAutomaticProxyFactory instance.</doc>
        <doc-deprecated xml:space="preserve">New code should use #TpAutomaticClientFactory instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpAutomaticProxyFactory</doc>
          <type name="AutomaticProxyFactory"
                c:type="TpAutomaticProxyFactory*"/>
        </return-value>
      </constructor>
      <function name="dup"
                c:identifier="tp_automatic_proxy_factory_dup"
                version="0.13.2"
                deprecated="1">
        <doc xml:space="preserve">Returns a cached #TpAutomaticProxyFactory; the same
#TpAutomaticProxyFactory object will be returned by this function repeatedly,
as long as at least one reference exists.</doc>
        <doc-deprecated xml:space="preserve">New code should use #TpAutomaticClientFactory instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TpAutomaticProxyFactory</doc>
          <type name="AutomaticProxyFactory"
                c:type="TpAutomaticProxyFactory*"/>
        </return-value>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AutomaticProxyFactoryClass"
            c:type="TpAutomaticProxyFactoryClass"
            glib:is-gtype-struct-for="AutomaticProxyFactory"
            version="0.13.2">
      <doc xml:space="preserve">The class of a #TpAutomaticProxyFactory.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="AvatarRequirements"
            c:type="TpAvatarRequirements"
            version="0.11.4"
            glib:type-name="TpAvatarRequirements"
            glib:get-type="tp_avatar_requirements_get_type"
            c:symbol-prefix="avatar_requirements">
      <doc xml:space="preserve">The requirements for setting an avatar on a particular protocol.</doc>
      <field name="supported_mime_types" writable="1">
        <doc xml:space="preserve">An array of supported MIME types (e.g. "image/jpeg")
 Clients MAY assume that the first type in this array is preferred</doc>
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="minimum_width" writable="1">
        <doc xml:space="preserve">The minimum width in pixels of an avatar, which MAY be 0</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="minimum_height" writable="1">
        <doc xml:space="preserve">The minimum height in pixels of an avatar, which MAY be 0</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="recommended_width" writable="1">
        <doc xml:space="preserve">The recommended width in pixels of an avatar, or 0 if
 there is no preferred width.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="recommended_height" writable="1">
        <doc xml:space="preserve">The recommended height in pixels of an avatar, or 0 if
 there is no preferred height</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_width" writable="1">
        <doc xml:space="preserve">The maximum width in pixels of an avatar on this protocol,
 or 0 if there is no limit.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_height" writable="1">
        <doc xml:space="preserve">The maximum height in pixels of an avatar, or 0 if there is
 no limit.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_bytes" writable="1">
        <doc xml:space="preserve">he maximum size in bytes of an avatar, or 0 if there is no
 limit.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_avatar_requirements_new"
                   version="0.11.4">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpAvatarRequirements, free it with
tp_avatar_requirements_destroy()</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <parameter name="supported_mime_types" transfer-ownership="none">
            <doc xml:space="preserve">An array of supported MIME types (e.g. "image/jpeg")
 Clients MAY assume that the first type in this array is preferred</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="minimum_width" transfer-ownership="none">
            <doc xml:space="preserve">The minimum width in pixels of an avatar, which MAY be 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="minimum_height" transfer-ownership="none">
            <doc xml:space="preserve">The minimum height in pixels of an avatar, which MAY be 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_width" transfer-ownership="none">
            <doc xml:space="preserve">The recommended width in pixels of an avatar, or 0 if
 there is no preferred width.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_height" transfer-ownership="none">
            <doc xml:space="preserve">The recommended height in pixels of an avatar, or 0 if
 there is no preferred height</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_width" transfer-ownership="none">
            <doc xml:space="preserve">The maximum width in pixels of an avatar on this protocol,
 or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_height" transfer-ownership="none">
            <doc xml:space="preserve">The maximum height in pixels of an avatar, or 0 if there is
 no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_bytes" transfer-ownership="none">
            <doc xml:space="preserve">he maximum size in bytes of an avatar, or 0 if there is no
 limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="tp_avatar_requirements_copy"
              version="0.11.4"
              introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpAvatarRequirements, free it with
tp_avatar_requirements_destroy()</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAvatarRequirements</doc>
            <type name="AvatarRequirements"
                  c:type="const TpAvatarRequirements*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="tp_avatar_requirements_destroy"
              version="0.11.4"
              introspectable="0">
        <doc xml:space="preserve">Free all memory used by the #TpAvatarRequirements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAvatarRequirements</doc>
            <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="BaseClient"
           c:symbol-prefix="base_client"
           c:type="TpBaseClient"
           version="0.11.5"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TpBaseClient"
           glib:get-type="tp_base_client_get_type"
           glib:type-struct="BaseClientClass">
      <doc xml:space="preserve">Data structure representing a generic #TpSvcClient implementation.</doc>
      <function name="implement_add_dispatch_operation"
                c:identifier="tp_base_client_implement_add_dispatch_operation"
                version="0.11.5"
                introspectable="0">
        <doc xml:space="preserve">Called by subclasses to define the actual implementation of the
AddDispatchOperation() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.add_dispatch_operation function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClientClassAddDispatchOperationImpl function implementing
AddDispatchOperation()</doc>
            <type name="BaseClientClassAddDispatchOperationImpl"
                  c:type="TpBaseClientClassAddDispatchOperationImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_handle_channels"
                c:identifier="tp_base_client_implement_handle_channels"
                version="0.11.6"
                introspectable="0">
        <doc xml:space="preserve">Called by subclasses to define the actual implementation of the
HandleChannels() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.handle_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClientClassHandleChannelsImpl function implementing
HandleCHannels()</doc>
            <type name="BaseClientClassHandleChannelsImpl"
                  c:type="TpBaseClientClassHandleChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_observe_channels"
                c:identifier="tp_base_client_implement_observe_channels"
                version="0.11.5"
                introspectable="0">
        <doc xml:space="preserve">Called by subclasses to define the actual implementation of the
ObserveChannels() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.observe_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClientClassObserveChannelsImpl function implementing
ObserveChannels()</doc>
            <type name="BaseClientClassObserveChannelsImpl"
                  c:type="TpBaseClientClassObserveChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="add_dispatch_operation">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient instance</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other
 features added via tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if
 possible</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE,
 and any other features added via tp_base_client_add_connection_features(),
 or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpChannel,
 each with %TP_CHANNEL_FEATURE_CORE, and any other features added via
 tp_base_client_add_channel_features() or
 tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Channel"/>
            </type>
          </parameter>
          <parameter name="dispatch_operation" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation having
%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE prepared if possible</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext representing the context of this
 D-Bus call</doc>
            <type name="AddDispatchOperationContext"
                  c:type="TpAddDispatchOperationContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_channels">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient instance</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other
 features added via tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if
 possible</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE,
 and any other features added via tp_base_client_add_connection_features(),
 or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpChannel,
 each with %TP_CHANNEL_FEATURE_CORE, and any other features added via
 tp_base_client_add_channel_features() or
 tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Channel"/>
            </type>
          </parameter>
          <parameter name="requests_satisfied" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of
 #TpChannelRequest having their object-path defined but are not guaranteed
 to be prepared.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ChannelRequest"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time at which user action occurred, or one of the
 special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME
 (see #TpAccountChannelRequest:user-action-time for details)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleChannelsContext representing the context of this
 D-Bus call</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="observe_channels">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient instance</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other
 features added via tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if
 possible</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE,
 and any other features added via tp_base_client_add_connection_features(),
 or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpChannel,
 each with %TP_CHANNEL_FEATURE_CORE, and any other features added via
 tp_base_client_add_channel_features() or
 tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Channel"/>
            </type>
          </parameter>
          <parameter name="dispatch_operation"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #TpChannelDispatchOperation or %NULL;
 the dispatch_operation is not guaranteed to be prepared</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of
 #TpChannelRequest having their object-path defined but are not guaranteed
 to be prepared.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ChannelRequest"/>
            </type>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext representing the context of this
 D-Bus call</doc>
            <type name="ObserveChannelsContext"
                  c:type="TpObserveChannelsContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_account_features"
              c:identifier="tp_base_client_add_account_features"
              version="0.11.14"
              deprecated="1">
        <doc xml:space="preserve">Request that the given features are prepared on each #TpAccount (in
addition to %TP_ACCOUNT_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels, or emitting
#TpBaseClient::request-added.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_simple_client_factory_add_account_features() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs"
              c:identifier="tp_base_client_add_account_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">The same as tp_base_client_add_account_features(), but with a more
convenient calling convention from C.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_simple_client_factory_add_account_features_varargs() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with 0</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_approver_filter"
              c:identifier="tp_base_client_add_approver_filter"
              version="0.11.5">
        <doc xml:space="preserve">Register a new channel class as Approver.ApproverChannelFilter.
The #TpBaseClientClass.add_dispatch_operation virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.add_dispatch_operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">
a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_approver_filter_vardict"
              c:identifier="tp_base_client_add_approver_filter_vardict"
              version="0.19.10">
        <doc xml:space="preserve">Register a new channel class as Approver.ApproverChannelFilter.
The #TpBaseClientClass.add_dispatch_operation virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.add_dispatch_operation.

If the variant is floating (see g_variant_ref_sink()), ownership
will be taken. See tp_base_client_add_observer_filter_vardict() for
more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a variant of type %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features"
              c:identifier="tp_base_client_add_channel_features"
              version="0.11.14"
              deprecated="1">
        <doc xml:space="preserve">Request that the given features are prepared on each #TpChannel (in
addition to %TP_CHANNEL_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_simple_client_factory_add_channel_features() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs"
              c:identifier="tp_base_client_add_channel_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">The same as tp_base_client_add_channel_features(), but with a more
convenient calling convention from C.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_simple_client_factory_add_channel_features_varargs() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with 0</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features"
              c:identifier="tp_base_client_add_connection_features"
              version="0.11.14"
              deprecated="1">
        <doc xml:space="preserve">Request that the given features are prepared on each #TpConnection (in
addition to %TP_CONNECTION_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_simple_client_factory_add_connection_features() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs"
              c:identifier="tp_base_client_add_connection_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">The same as tp_base_client_add_connection_features(), but with a more
convenient calling convention from C.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_simple_client_factory_add_connection_features_varargs() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with 0</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities"
              c:identifier="tp_base_client_add_handler_capabilities"
              version="0.11.6">
        <doc xml:space="preserve">Add several capability tokens to this client. These are used to signal
that Telepathy connection managers should advertise certain capabilities
to other contacts, such as the ability to receive audio/video calls using
particular streaming protocols and codecs.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client, which must not have been registered with
 tp_base_client_register() yet</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="tokens" transfer-ownership="none">
            <doc xml:space="preserve">capability
 tokens as defined by the Telepathy D-Bus API Specification</doc>
            <array c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities_varargs"
              c:identifier="tp_base_client_add_handler_capabilities_varargs"
              version="0.11.6"
              introspectable="0">
        <doc xml:space="preserve">Convenience C API equivalent to calling
tp_base_client_add_handler_capability() for each capability token.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client, which must not have been registered with
 tp_base_client_register() yet</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="first_token" transfer-ownership="none">
            <doc xml:space="preserve">a capability token from the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">more tokens, ending with %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capability"
              c:identifier="tp_base_client_add_handler_capability"
              version="0.11.6">
        <doc xml:space="preserve">Add one capability token to this client, as if via
tp_base_client_add_handler_capabilities().

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client, which must not have been registered with
 tp_base_client_register() yet</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a capability token as defined by the Telepathy D-Bus API
 Specification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_filter"
              c:identifier="tp_base_client_add_handler_filter"
              version="0.11.6">
        <doc xml:space="preserve">Register a new channel class as Handler.HandlerChannelFilter.
The #TpBaseClientClass.handle_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">
a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_filter_vardict"
              c:identifier="tp_base_client_add_handler_filter_vardict"
              version="0.19.10">
        <doc xml:space="preserve">Register a new channel class as Handler.HandlerChannelFilter.
The #TpBaseClientClass.handle_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.

If the variant is floating (see g_variant_ref_sink()), ownership
will be taken. See tp_base_client_add_observer_filter_vardict() for
more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a variant of type %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_observer_filter"
              c:identifier="tp_base_client_add_observer_filter"
              version="0.11.5">
        <doc xml:space="preserve">Register a new channel class as Observer.ObserverChannelFilter.
The #TpBaseClientClass.observe_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">
a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_observer_filter_vardict"
              c:identifier="tp_base_client_add_observer_filter_vardict"
              version="0.19.10">
        <doc xml:space="preserve">Register a new channel class as Observer.ObserverChannelFilter.
The #TpBaseClientClass.observe_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.

If the variant is floating (see g_variant_ref_sink()), ownership
will be taken, allowing for uses like this:

|[
tp_base_client_add_observer_filter_vardict (client,
   g_variant_new_parsed ("{ %s: &lt;%s&gt;, %s: &lt;%u&gt;, ... }",
       TP_PROP_CHANNEL_CHANNEL_TYPE, TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, (guint32) TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a variant of type %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="be_a_handler"
              c:identifier="tp_base_client_be_a_handler"
              version="0.11.6">
        <doc xml:space="preserve">Register @self as a Client.Handler with an empty list of filters.
This is useful if you want to create a client that only handle channels
for which it's the PreferredHandler.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delegate_channels_async"
              c:identifier="tp_base_client_delegate_channels_async"
              version="0.15.0">
        <doc xml:space="preserve">Asynchronously calls DelegateChannels on the ChannelDispatcher to try
stopping handling @channels and pass them to another Handler.
You can then call tp_base_client_delegate_channels_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpChannel
handled by @self</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Channel"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time at which user action occurred,
or #TP_USER_ACTION_TIME_NOT_USER_ACTION if this delegation request is
for some reason not involving user action.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:space="preserve">Either the well-known bus name (starting with
%TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channels,
or %NULL to indicate that any handler but @self would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delegate_channels_finish"
              c:identifier="tp_base_client_delegate_channels_finish"
              version="0.15.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async channels delegation request started using
tp_base_client_delegate_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeed, @delegated and @not_delegated
can be used to know the channels that @self is not handling any more,
otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="delegated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:space="preserve">
if not %NULL, used to return a #GPtrArray containing the #TpChannel&lt;!-- --&gt;s
which have been properly delegated</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Channel"/>
            </array>
          </parameter>
          <parameter name="not_delegated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:space="preserve">
if not not %NULL, used to return a #GHashTable mapping #TpChannel&lt;!-- --&gt;s
which have not been delegated to a #GError explaining the reason of
the failure</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="Channel"/>
              <type name="GLib.Error"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dup_handled_channels"
              c:identifier="tp_base_client_dup_handled_channels"
              version="0.19.9">
        <doc xml:space="preserve">Returns the set of channels currently handled by this base client or by any
other #TpBaseClient with which it shares a unique name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the
handled channels</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_pending_requests"
              c:identifier="tp_base_client_dup_pending_requests"
              version="0.19.9">
        <doc xml:space="preserve">Only works if tp_base_client_set_handler_request_notification() has been
called.
Returns the list of requests @self is likely be asked to handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
#GList of #TpChannelRequest</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_account_manager"
              c:identifier="tp_base_client_get_account_manager"
              version="0.11.14"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Return the #TpBaseClient:account-manager construct-only property, which
is the account manager used to look up or create #TpAccount objects.

The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.

It is not guaranteed that any particular features are prepared on this
object; enable and wait for features with tp_proxy_prepare_async().</doc>
        <doc-deprecated xml:space="preserve">New code should not use this function, it may return %NULL in
 the case @self was constructed with a #TpSimpleClientFactory.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpBaseClient:account-manager</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_base_client_get_bus_name"
              version="0.11.5">
        <doc xml:space="preserve">Return the bus name of @self. Note that doesn't mean the client is
actually owning this name; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bus name of the client</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel_factory"
              c:identifier="tp_base_client_get_channel_factory"
              version="0.13.2"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Return the #TpBaseClient:channel-factory property.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.5. The factory is taken from
 #TpBaseClient:account-manager.</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">the value of #TpBaseClient:channel-factory</doc>
          <type name="ClientChannelFactory" c:type="TpClientChannelFactory*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_base_client_get_dbus_daemon"
              version="0.11.11">
        <doc xml:space="preserve">Return the #TpBaseClient:dbus-daemon construct-only property, which
represents the D-Bus connection used to export this client object.

The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpBaseClient:dbus-daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handled_channels"
              c:identifier="tp_base_client_get_handled_channels"
              version="0.11.6"
              deprecated="1">
        <doc xml:space="preserve">Returns the set of channels currently handled by this base client or by any
other #TpBaseClient with which it shares a unique name.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_base_client_dup_handled_channels() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">the
handled channels</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_base_client_get_name"
              version="0.11.11">
        <doc xml:space="preserve">Return the #TpBaseClient:name construct-only property, which is used as
part of the bus name and object path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpBaseClient:name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_path"
              c:identifier="tp_base_client_get_object_path"
              version="0.11.5">
        <doc xml:space="preserve">Return the object path of @self. Note that doesn't mean the client is
actually registered on this path; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object path of the client</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pending_requests"
              c:identifier="tp_base_client_get_pending_requests"
              version="0.11.6"
              deprecated="1">
        <doc xml:space="preserve">Only works if tp_base_client_set_handler_request_notification() has been
called.
Returns the list of requests @self is likely be asked to handle.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_base_client_dup_pending_requests() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
#GList of #TpChannelRequest</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uniquify_name"
              c:identifier="tp_base_client_get_uniquify_name"
              version="0.11.11">
        <doc xml:space="preserve">Return the #TpBaseClient:uniquify-name construct-only property; if this
is true, the bus name and object path will be made unique by appending
a suffix that includes the D-Bus unique name and a per-process counter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpBaseClient:uniquify-name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_handling_channel"
              c:identifier="tp_base_client_is_handling_channel"
              version="0.14.5">
        <doc xml:space="preserve">Check if @self is currently handling @channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @self is handling @channel, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="tp_base_client_register"
              version="0.11.5"
              throws="1">
        <doc xml:space="preserve">Publish @self as an available client. After this method is called, as long
as it continues to exist, it will receive and process whatever events were
requested via the various filters.

Methods that set the filters and other immutable state, such as
tp_base_client_add_observer_filter(), cannot be called after this one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the client was registered successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient, which must not have been registered with
 tp_base_client_register() yet</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_base_client_set_channel_factory"
              version="0.13.2"
              deprecated="1">
        <doc xml:space="preserve">Change the value of the #TpBaseClient:channel-factory property.
It can't be changed once @self has been registered.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.5. The factory is taken from
 #TpBaseClient:account-manager.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">an object implementing the #TpClientChannelFactoryInterface
interface</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegated_channels_callback"
              c:identifier="tp_base_client_set_delegated_channels_callback"
              version="0.15.3">
        <doc xml:space="preserve">Turn on support for
the org.freedesktop.Telepathy.ChannelRequest.DelegateToPreferredHandler
hint.

When receiving a request containing this hint, @self will automatically
delegate the channels to the preferred handler of the request and then call
@callback to inform the client that it is no longer handling those
channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient implementing Handler</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">function called when channels currently handled by @self are
delegated, may not be %NULL</doc>
            <type name="BaseClientDelegatedChannelsCb"
                  c:type="TpBaseClientDelegatedChannelsCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with the @user_data as argument, when @self is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_bypass_approval"
              c:identifier="tp_base_client_set_handler_bypass_approval"
              version="0.11.6">
        <doc xml:space="preserve">Set whether the channels destined for this handler are automatically
handled, without invoking approvers.
(This is implemented by setting the value of its BypassApproval
D-Bus property.)

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Handler.BypassApproval property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_request_notification"
              c:identifier="tp_base_client_set_handler_request_notification"
              version="0.11.6">
        <doc xml:space="preserve">Indicate that @self is a Handler willing to be notified about requests for
channels that it is likely to be asked to handle. This means that the
#TpBaseClient::request-added and #TpBaseClient::request-removed signals will
be fired and tp_base_client_get_pending_requests() will return the list of
pending requests.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_observer_delay_approvers"
              c:identifier="tp_base_client_set_observer_delay_approvers"
              version="0.13.16">
        <doc xml:space="preserve">Set whether the channel dispatcher should wait for
tp_observe_channels_context_accept() or tp_observe_channels_context_fail()
to be called before calling
#TpBaseClientClass.add_dispatch_operation on appropriate Approvers.

This is implemented by setting the value of the DelayApprovers
D-Bus property.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Observer.DelayApprovers property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_observer_recover"
              c:identifier="tp_base_client_set_observer_recover"
              version="0.11.5">
        <doc xml:space="preserve">Set whether the channel dispatcher should attempt to recover
this Observer if it crashes. (This is implemented by setting
the value of its Recover D-Bus property.)

Normally, Observers are only notified when new channels
appear. If an Observer is set to recover, when it registers with
tp_base_client_register(), it will also be told about any channels
that already existed before it started.

For Observers that are activatable as a D-Bus service, if the
Observer exits or crashes while there are any channels that match
its filter, it will automatically be restarted by service-activation.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Observer.Recover property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_approver_filter"
              c:identifier="tp_base_client_take_approver_filter"
              version="0.11.5"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_base_client_add_approver_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_approver_filter (client,
   tp_asv_new (
       TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
           TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
           TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:space="preserve">
a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_handler_filter"
              c:identifier="tp_base_client_take_handler_filter"
              version="0.11.6"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_base_client_add_handler_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_handler_filter (client,
   tp_asv_new (
       TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
           TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
           TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:space="preserve">
a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_observer_filter"
              c:identifier="tp_base_client_take_observer_filter"
              version="0.11.5"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_base_client_add_observer_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_observer_filter (client,
   tp_asv_new (
       TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
           TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
           TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:space="preserve">
a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="unregister"
              c:identifier="tp_base_client_unregister"
              version="0.11.6">
        <doc xml:space="preserve">Remove this client object from D-Bus, if tp_base_client_register()
has already been called.

If the object is not registered, this method may be called, but has
no effect.

Releasing the last reference to the object also has the same effect
as calling this method, but this method should be preferred, as it
has more deterministic behaviour.

If the object still exists, tp_base_client_register() may be used to
attempt to register it again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client, which may already have been registered with
 tp_base_client_register(), or not</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="account-manager"
                version="0.11.14"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Account manager for this base client, used to look up or create
#TpAccount objects. This may be specified in the constructor in order
to get existing #TpAccount objects.

It is not guaranteed that any of its features have been prepared, and
it is not necessary to wait for any features before specifying this
property in the constructor.

Clients that interact with the #TpAccount should usually
set this property instead of #TpBaseClient:dbus-daemon. Doing this
will ensure that each account, connection or contact is represented by
a single #TpAccount, #TpConnection or #TpContact object, shared between
all the cooperating modules that have the same #TpAccountManager.

If the #TpBaseClient:dbus-daemon is set to the result of
tp_dbus_daemon_dup(), then this property defaults to
the result of tp_account_manager_dup().

This property may be %NULL initially, but will always be non-%NULL
after the #TpBaseClient has been constructed.

It is an error to specify both a non-%NULL account manager, and a
non-%NULL #TpBaseClient:dbus-daemon that is not the same as the
account manager's #TpProxy:dbus-daemon.</doc>
        <doc-deprecated xml:space="preserve">New code should not use this property, it may be %NULL in
 the case @self was constructed with a #TpSimpleClientFactory.</doc-deprecated>
        <type name="AccountManager"/>
      </property>
      <property name="channel-factory"
                version="0.13.2"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The object implementing the #TpClientChannelFactoryInterface interface
that will be used to create channel proxies. While
tp_base_client_register() has not yet been called, this property can be
changed using tp_base_client_set_channel_factory().

If no channel factory is specified then #TpAutomaticProxyFactory is used.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.5. The factory is taken from
 #TpBaseClient:account-manager.</doc-deprecated>
        <type name="GObject.Object"/>
      </property>
      <property name="dbus-daemon"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.

This property can't be %NULL after construction.

Since 0.11.14 this property may be %NULL or unspecified in
g_object_new(), but only if #TpBaseClient:account-manager is provided
instead, in which case its #TpProxy:dbus-daemon property will be
used.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="factory"
                version="0.15.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Factory for this base client, used to look up or create
#TpAccount objects.</doc>
        <type name="SimpleClientFactory"/>
      </property>
      <property name="name"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The name of the client. This is used to register the D-Bus service name
and object path of the service.

This property can't be %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uniquify-name"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, tp_base_client_register() will append an unique token to the
service bus name and object path to ensure they are unique.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseClientPrivate" c:type="TpBaseClientPrivate*"/>
      </field>
      <glib:signal name="request-added"
                   when="last"
                   detailed="1"
                   version="0.11.6">
        <doc xml:space="preserve">Emitted when a channels have been requested, and that if the
request is successful, they will probably be handled by this Handler.

This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">the #TpAccount on which the request was made,
 with %TP_ACCOUNT_FEATURE_CORE, and any other features added via
 tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if possible</doc>
            <type name="Account"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelRequest having its object-path defined but
is not guaranteed to be prepared.</doc>
            <type name="ChannelRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-removed"
                   when="last"
                   detailed="1"
                   version="0.11.6">
        <doc xml:space="preserve">Emitted when a request has failed and should be disregarded.

This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">the #TpChannelRequest being removed</doc>
            <type name="ChannelRequest"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the name of the D-Bus error with which the request failed.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">any message supplied with the D-Bus error.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BaseClientClass"
            c:type="TpBaseClientClass"
            glib:is-gtype-struct-for="BaseClient"
            version="0.11.5">
      <doc xml:space="preserve">The class of a #TpBaseClient.

The virtual methods @observe_channels, @add_dispatch_operation and
@handle_channels can be also implemented by calling
tp_base_client_implement_observe_channels(),
tp_base_client_implement_add_dispatch_operation() and
tp_base_client_implement_handle_channels(). This is compatible with
telepathy-glib versions older than 0.11.13.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="observe_channels">
        <doc xml:space="preserve">the function called to observe newly-created channels
 matching this client's observer filter (since 0.11.13)</doc>
        <type name="BaseClientClassObserveChannelsImpl"
              c:type="TpBaseClientClassObserveChannelsImpl"/>
      </field>
      <field name="add_dispatch_operation">
        <doc xml:space="preserve">the function called to request user approval of
 unrequested (incoming) channels matching this client's approver filter
 (since 0.11.13)</doc>
        <type name="BaseClientClassAddDispatchOperationImpl"
              c:type="TpBaseClientClassAddDispatchOperationImpl"/>
      </field>
      <field name="handle_channels">
        <doc xml:space="preserve">the function called to handle channels matching this
 client's handler filter (since 0.11.13)</doc>
        <type name="BaseClientClassHandleChannelsImpl"
              c:type="TpBaseClientClassHandleChannelsImpl"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="dbus_properties_class" readable="0" private="1">
        <type name="DBusPropertiesMixinClass"
              c:type="TpDBusPropertiesMixinClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseClientClassPrivate"
              c:type="TpBaseClientClassPrivate*"/>
      </field>
    </record>
    <callback name="BaseClientClassAddDispatchOperationImpl"
              c:type="TpBaseClientClassAddDispatchOperationImpl"
              version="0.11.5">
      <doc xml:space="preserve">Signature of the implementation of the AddDispatchOperation method.

This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.

The implementation can then use
tp_channel_dispatch_operation_handle_with_async() to approve handling of the
channels, or tp_channel_dispatch_operation_claim_async() to take
responsibility for handling or closing them".</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other
 features added via tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if
 possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE,
 and any other features added via tp_base_client_add_connection_features(),
 or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpChannel,
 each with %TP_CHANNEL_FEATURE_CORE, and any other features added via
 tp_base_client_add_channel_features() or
 tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none">
          <doc xml:space="preserve">a #TpChannelDispatchOperation having
%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE prepared if possible</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #TpObserveChannelsContext representing the context of this
 D-Bus call</doc>
          <type name="AddDispatchOperationContext"
                c:type="TpAddDispatchOperationContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassHandleChannelsImpl"
              c:type="TpBaseClientClassHandleChannelsImpl"
              version="0.11.6">
      <doc xml:space="preserve">Signature of the implementation of the HandleChannels method.

This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other
 features added via tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if
 possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE,
 and any other features added via tp_base_client_add_connection_features(),
 or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpChannel,
 each with %TP_CHANNEL_FEATURE_CORE, and any other features added via
 tp_base_client_add_channel_features() or
 tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
 #TpChannelRequest having their object-path defined but are not guaranteed
 to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:space="preserve">the time at which user action occurred, or one of the
 special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME
 (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #TpHandleChannelsContext representing the context of this
 D-Bus call</doc>
          <type name="HandleChannelsContext"
                c:type="TpHandleChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassObserveChannelsImpl"
              c:type="TpBaseClientClassObserveChannelsImpl"
              version="0.11.5">
      <doc xml:space="preserve">Signature of the implementation of the ObserveChannels method.

This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other
 features added via tp_base_client_add_account_features() or
 tp_simple_client_factory_add_account_features(), prepared if
 possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE,
 and any other features added via tp_base_client_add_connection_features(),
 or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpChannel,
 each with %TP_CHANNEL_FEATURE_CORE, and any other features added via
 tp_base_client_add_channel_features() or
 tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #TpChannelDispatchOperation or %NULL;
 the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
 #TpChannelRequest having their object-path defined but are not guaranteed
 to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #TpObserveChannelsContext representing the context of this
 D-Bus call</doc>
          <type name="ObserveChannelsContext"
                c:type="TpObserveChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientClassPrivate"
            c:type="TpBaseClientClassPrivate"
            disguised="1">
    </record>
    <callback name="BaseClientDelegatedChannelsCb"
              c:type="TpBaseClientDelegatedChannelsCb"
              version="0.15.3">
      <doc xml:space="preserve">Called when a client asked us to delegate @channels to another Handler.
When this function is called @client is not longer handling @channels.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray of #TpChannel</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Channel"/>
          </array>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">arbitrary user-supplied data passed to
tp_base_client_set_delegated_channels_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientPrivate"
            c:type="TpBaseClientPrivate"
            disguised="1">
    </record>
    <class name="BaseConnection"
           c:symbol-prefix="base_connection"
           c:type="TpBaseConnection"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TpBaseConnection"
           glib:get-type="tp_base_connection_get_type"
           glib:type-struct="BaseConnectionClass">
      <doc xml:space="preserve">Data structure representing a generic #TpSvcConnection implementation.

Since 0.19.1, accessing the fields of this structure is deprecated.
Use tp_base_connection_get_bus_name(), tp_base_connection_get_object_path(),
tp_base_connection_get_status(), tp_base_connection_get_self_handle()
instead.</doc>
      <function name="channel_manager_iter_init"
                c:identifier="tp_base_connection_channel_manager_iter_init"
                version="0.7.15"
                introspectable="0">
        <doc xml:space="preserve">Initializes an iterator over the #TpChannelManager objects known to
@self.  It is intended to be used as followed:

&lt;informalexample&gt;&lt;programlisting&gt;
TpChannelManagerIter iter;
TpChannelManager *manager;

tp_base_connection_channel_manager_iter_init (&amp;amp;iter, base_conn);
while (tp_base_connection_channel_manager_iter_next (&amp;amp;iter, &amp;amp;manager))
  {
    ...do something with manager...
  }
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </parameter>
        </parameters>
      </function>
      <function name="channel_manager_iter_next"
                c:identifier="tp_base_connection_channel_manager_iter_next"
                version="0.7.15"
                introspectable="0">
        <doc xml:space="preserve">Advances @iter, and retrieves the #TpChannelManager it now points to.  If
there are no more channel managers, @manager_out is not set and %FALSE is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if there are no more channel managers; else %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="manager_out" transfer-ownership="none">
            <doc xml:space="preserve">a location to store the channel manager, or %NULL.</doc>
            <type c:type="TpChannelManager**"/>
          </parameter>
        </parameters>
      </function>
      <function name="dbus_request_handles"
                c:identifier="tp_base_connection_dbus_request_handles"
                introspectable="0"
                deprecated="1"
                deprecated-version="0.19.0">
        <doc xml:space="preserve">Implements D-Bus method RequestHandles on interface
org.freedesktop.Telepathy.Connection.

This was exported so subclasses could use it as a basis for their
reimplementations, but reimplementing the method is now deprecated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to #TpBaseConnection, cast to a pointer to
 #TpSvcConnection</doc>
            <type c:type="TpSvcConnection*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">The handle type (#TpHandleType) as a guint</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:space="preserve">A strv of handle names</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The dbus-glib method invocation context</doc>
            <type c:type="DBusGMethodInvocation*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="connected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection object</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connecting">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection object</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_channel_factories" introspectable="0">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GPtrArray of objects implementing
 #TpChannelFactoryIface which, between them, implement all channel types
 this Connection supports.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The implementation, a subclass of TpBaseConnection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_channel_managers" introspectable="0">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GPtrArray of objects implementing
 #TpChannelManager which, between them, implement all channel types this
 Connection supports.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The implementation, a subclass of TpBaseConnection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="disconnected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection object</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_interfaces_always_present" introspectable="0">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray of static strings for D-Bus
  interfaces implemented by this client.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseConnection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_unique_connection_name">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a name for this connection which will be unique
 within this connection manager process, as a string which the caller must
 free with #g_free.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The implementation, a subclass of TpBaseConnection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="shut_down">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection object</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_connecting" throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if failure has already occurred, else %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection object</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_client_interest"
              c:identifier="tp_base_connection_add_client_interest">
        <doc xml:space="preserve">Add a "client interest" for @token on behalf of the given client.

This emits #TpBaseConnection::clients-interested if this was the first
time a client expressed an interest in this token.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseConnection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="unique_name" transfer-ownership="none">
            <doc xml:space="preserve">the unique bus name of a D-Bus client</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus interface or a token representing part of an interface,
 added with tp_base_connection_add_possible_client_interest()</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="only_if_uninterested" transfer-ownership="none">
            <doc xml:space="preserve">only add to the interest count if the client is not
 already interested (appropriate for APIs that implicitly subscribe on first
 use if this has not been done already, like Location)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_interfaces"
              c:identifier="tp_base_connection_add_interfaces"
              introspectable="0">
        <doc xml:space="preserve">Add some interfaces to the list supported by this Connection. If you're
going to call this function at all, you must do so before moving to state
CONNECTED (or DISCONNECTED); if you don't call it, only the set of
interfaces always present (@get_interfaces_always_present in
#TpBaseConnectionClass) will be supported.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A TpBaseConnection in state #TP_INTERNAL_CONNECTION_STATUS_NEW
 or #TP_CONNECTION_STATUS_CONNECTING</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:space="preserve">A %NULL-terminated array of D-Bus interface names, which
 must remain valid at least until the connection enters state
 #TP_CONNECTION_STATUS_DISCONNECTED (in practice, you should either
 use static strings, or use strdup'd strings and free them in the dispose
 callback).</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_possible_client_interest"
              c:identifier="tp_base_connection_add_possible_client_interest">
        <doc xml:space="preserve">Add @token to the set of tokens for which this connection will emit
#TpBaseConnection::clients-interested and
#TpBaseConnection::clients-uninterested.

This method must be called from the #GObjectClass&lt;!--
--&gt;.constructed or #GObjectClass&lt;!-- --&gt;.constructor callback
(otherwise, it will run too late to be useful).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a quark corresponding to a D-Bus interface, or a token
 representing part of a D-Bus interface, for which this connection wishes
 to be notified when clients register an interest</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_status"
              c:identifier="tp_base_connection_change_status">
        <doc xml:space="preserve">Change the status of the connection. The allowed state transitions are:

&lt;itemizedlist&gt;
&lt;listitem&gt;#TP_INTERNAL_CONNECTION_STATUS_NEW 
   #TP_CONNECTION_STATUS_CONNECTING&lt;/listitem&gt;
&lt;listitem&gt;#TP_CONNECTION_STATUS_CONNECTING 
   #TP_CONNECTION_STATUS_CONNECTED&lt;/listitem&gt;
&lt;listitem&gt;#TP_INTERNAL_CONNECTION_STATUS_NEW 
   #TP_CONNECTION_STATUS_CONNECTED (exactly equivalent to both of the above
   one after the other; see below)&lt;/listitem&gt;
&lt;listitem&gt;anything except #TP_CONNECTION_STATUS_DISCONNECTED 
   #TP_CONNECTION_STATUS_DISCONNECTED&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Before the transition to #TP_CONNECTION_STATUS_CONNECTED, the implementation
must have discovered the handle for the local user and passed it to
tp_base_connection_set_self_handle().

Changing from NEW to CONNECTED is implemented by doing the transition from
NEW to CONNECTING, followed by the transition from CONNECTING to CONNECTED;
it's exactly equivalent to calling tp_base_connection_change_status for
those two transitions one after the other.

Any other valid transition does the following, in this order:

&lt;itemizedlist&gt;
&lt;listitem&gt;Update #TpBaseConnection&lt;!-- --&gt;.status;&lt;/listitem&gt;
&lt;listitem&gt;If the new state is #TP_CONNECTION_STATUS_DISCONNECTED, call
   tp_channel_factory_iface_close_all() on all channel factories&lt;/listitem&gt;
&lt;listitem&gt;Emit the D-Bus StatusChanged signal;&lt;/listitem&gt;
&lt;listitem&gt;Call #TpBaseConnectionClass.connecting,
   #TpBaseConnectionClass.connected or #TpBaseConnectionClass.disconnected
   as appropriate;&lt;/listitem&gt;
&lt;listitem&gt;Call the channel factories' status change callbacks;&lt;/listitem&gt;
&lt;listitem&gt;If the new state is #TP_CONNECTION_STATUS_DISCONNECTED, call the
   subclass' #TpBaseConnectionClass.shut_down callback.&lt;/listitem&gt;
&lt;/itemizedlist&gt;

To provide more details about what happened when moving to @status
#TP_CONNECTION_STATUS_DISCONNECTED due to an error, consider calling
tp_base_connection_disconnect_with_dbus_error() instead of this function.

Changed in 0.7.35: the @self_handle member of #TpBaseConnection was
previously set to 0 at this stage. It now remains non-zero until the object
is disposed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The new status</doc>
            <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">The reason for the status change</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connected"
              c:identifier="tp_base_connection_check_connected"
              version="0.19.1"
              throws="1">
        <doc xml:space="preserve">Return whether this connection is fully active and connected.
If it is not, raise %TP_ERROR_DISCONNECTED.

This is equivalent to checking whether tp_base_connection_get_status()
returns %TP_CONNECTION_STATUS_CONNECTED; it is provided because methods
on the connection often need to make this check, and return a
#GError if it fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection is connected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="disconnect_with_dbus_error"
              c:identifier="tp_base_connection_disconnect_with_dbus_error"
              version="0.7.24"
              introspectable="0">
        <doc xml:space="preserve">Changes the #TpBaseConnection&lt;!-- --&gt;.status of @self to
%TP_CONNECTION_STATUS_DISCONNECTED, as if by a call to
tp_base_connection_change_status(), but additionally emits the
&lt;code&gt;ConnectionError&lt;/code&gt; D-Bus signal to provide more details about the
error.

Well-known keys for @details are documented in the Telepathy specification's
&lt;ulink url='http://telepathy.freedesktop.org/spec/Connection.html#Signal:ConnectionError'&gt;definition
of the ConnectionError signal&lt;/ulink&gt;, and include:

&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;code&gt;"debug-message"&lt;/code&gt;, whose value should have type
   #G_TYPE_STRING, for debugging information about the
   disconnection which should not be shown to the user&lt;/listitem&gt;
&lt;listitem&gt;&lt;code&gt;"server-message"&lt;/code&gt;, whose value should also have type
   #G_TYPE_STRING, for a human-readable error message from the server (in an
   unspecified language) explaining why the user was
   disconnected.&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus error with which the connection changed status to
             Disconnected</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">Further details of the error, as a hash table where the keys
          are strings as defined in the Telepathy specification, and the
          values are #GValue&lt;!-- --&gt;s. %NULL is allowed, and treated as
          an empty hash table.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">The reason code to use in the StatusChanged signal
         (a less specific, non-extensible version of @error_name)</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_with_dbus_error_vardict"
              c:identifier="tp_base_connection_disconnect_with_dbus_error_vardict"
              version="0.7.24"
              introspectable="0">
        <doc xml:space="preserve">Changes the #TpBaseConnection&lt;!-- --&gt;.status of @self to
%TP_CONNECTION_STATUS_DISCONNECTED, as if by a call to
tp_base_connection_change_status(), but additionally emits the
&lt;code&gt;ConnectionError&lt;/code&gt; D-Bus signal to provide more details about the
error.

Well-known keys for @details are documented in the Telepathy specification's
&lt;ulink url='http://telepathy.freedesktop.org/spec/Connection.html#Signal:ConnectionError'&gt;definition
of the ConnectionError signal&lt;/ulink&gt;, and include:

&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;code&gt;"debug-message"&lt;/code&gt;, whose value should have type
   #G_TYPE_STRING, for debugging information about the
   disconnection which should not be shown to the user&lt;/listitem&gt;
&lt;listitem&gt;&lt;code&gt;"server-message"&lt;/code&gt;, whose value should also have type
   #G_TYPE_STRING, for a human-readable error message from the server (in an
   unspecified language) explaining why the user was
   disconnected.&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus error with which the connection changed status to
             Disconnected</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">Further details of the error, as a variant of
          type %G_VARIANT_TYPE_VARDICT. The keys
          are strings as defined in the Telepathy specification, and the
          values are of type %G_VARIANT_TYPE_VARIANT.
          %NULL is allowed, and treated as an empty dictionary.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">The reason code to use in the StatusChanged signal
         (a less specific, non-extensible version of @error_name)</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_shutdown"
              c:identifier="tp_base_connection_finish_shutdown"
              introspectable="0">
        <doc xml:space="preserve">Tell the connection manager that this Connection has been disconnected,
has emitted StatusChanged and is ready to be removed from D-Bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_account_path_suffix"
              c:identifier="tp_base_connection_get_account_path_suffix"
              version="0.23.2">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same value has the #TpBaseConnection:account-path-suffix
 property.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_base_connection_get_bus_name"
              version="0.19.1">
        <doc xml:space="preserve">Return the bus name starting with %TP_CONN_BUS_NAME_BASE that represents
this connection on D-Bus.

The returned string belongs to the #TpBaseConnection and must be copied
by the caller if it will be kept.

If this connection has never been present on D-Bus
(tp_base_connection_register() has never been called), return %NULL
instead.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the bus name of this connection,
 or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_base_connection_get_dbus_daemon"
              version="0.11.3"
              introspectable="0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the
 #TpBaseConnectionManager:dbus-daemon property. The caller must reference
 the returned object with g_object_ref() if it will be kept.</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection manager</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handles" c:identifier="tp_base_connection_get_handles">
        <doc xml:space="preserve">&lt;!----&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handle repository corresponding to the given
handle type, or #NULL if it's unsupported or invalid.</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">The handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object_path"
              c:identifier="tp_base_connection_get_object_path"
              version="0.19.1">
        <doc xml:space="preserve">Return the object path starting with %TP_CONN_OBJECT_PATH_BASE that
represents this connection on D-Bus.

The returned string belongs to the #TpBaseConnection and must be copied
by the caller if it will be kept.

If this connection has never been present on D-Bus
(tp_base_connection_register() has never been called), return %NULL
instead.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the object path of this connection,
 or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_self_handle"
              c:identifier="tp_base_connection_get_self_handle"
              version="0.7.15"
              introspectable="0">
        <doc xml:space="preserve">Returns the #TpBaseConnection:self-handle property, which is guaranteed not
to be 0 once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current self handle of the connection.</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status"
              c:identifier="tp_base_connection_get_status"
              version="0.19.1">
        <doc xml:space="preserve">Return the status of this connection, as set by
tp_base_connection_change_status() or similar functions like
tp_base_connection_disconnect_with_dbus_error().

Like the corresponding D-Bus property, this method returns
%TP_CONNECTION_STATUS_DISCONNECTED in two situations:
either the connection is newly-created (and has never emitted
#TpSvcConnection::status-changed), or D-Bus clients have already been
told that it has been destroyed (by the Disconnect D-Bus method,
a failed attempt to connect, or loss of an established connection).
Use tp_base_connection_is_destroyed() to distinguish between the two.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpBaseConnection:dbus-status</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_destroyed"
              c:identifier="tp_base_connection_is_destroyed"
              version="0.19.1">
        <doc xml:space="preserve">Return whether this connection has already emitted the D-Bus signal
indicating that it has been destroyed.

In particular, this can be used to distinguish between the two reasons
why tp_base_connection_get_status() would return
%TP_CONNECTION_STATUS_DISCONNECTED: it will return %FALSE if the
connection is newly-created, and %TRUE if the Disconnect D-Bus method
has been called, an attempt to connect has failed, or an established
connection has encountered an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection is disappearing from D-Bus</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="tp_base_connection_register"
              throws="1">
        <doc xml:space="preserve">Make the connection object appear on the bus, returning the bus
name and object path used. If %TRUE is returned, the connection owns the
bus name, and will release it when destroyed.

Since 0.11.11, @bus_name and @object_path may be %NULL if the
strings are not needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the connection manager in the Telepathy protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="bus_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Used to return the bus name corresponding to the connection
 if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="object_path"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Used to return the object path of the connection if
 %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_with_contacts_mixin"
              c:identifier="tp_base_connection_register_with_contacts_mixin"
              introspectable="0">
        <doc xml:space="preserve">Register the Connection interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">An instance of the #TpBaseConnections that uses the Contacts
mixin</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_self_handle"
              c:identifier="tp_base_connection_set_self_handle"
              version="0.7.15">
        <doc xml:space="preserve">Sets the #TpBaseConnection:self-handle property.  self_handle may not be 0
once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </instance-parameter>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:space="preserve">The new self handle for the connection.</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <property name="account-path-suffix"
                version="0.23.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The suffix of the account object path such as
"gabble/jabber/chris_40example_2ecom0" for the account whose object path is
%TP_ACCOUNT_OBJECT_PATH_BASE + "gabble/jabber/chris_40example_2ecom0".
The same as returned by tp_account_get_path_suffix().

It is given by the AccountManager in the connection parameters. Or %NULL if
the ConnectionManager or the AccountManager are too old.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dbus-daemon"
                version="0.11.3"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.

If this property is %NULL or omitted during construction, the object will
automatically attempt to connect to the starter or session bus with
tp_dbus_daemon_dup() just after it is constructed; if this fails, this
property will remain %NULL, and tp_base_connection_register() will fail.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="dbus-status"
                version="0.11.3"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">The Connection.Status as visible on D-Bus, which is the same as
#TpBaseConnection&lt;!-- --&gt;.status except that
%TP_INTERNAL_CONNECTION_STATUS_NEW is replaced by
%TP_CONNECTION_STATUS_DISCONNECTED.

The #GObject::notify signal is not currently emitted for this property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="has-immortal-handles"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:space="preserve">This property is not useful to use directly. Its value is %TRUE, to
indicate that this version of telepathy-glib never unreferences handles
until the connection becomes disconnected.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="interfaces"
                version="0.11.3"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">The set of D-Bus interfaces available on this Connection, other than
Connection itself.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="protocol"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Identifier used in the Telepathy protocol when this connection's protocol
name is required.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="self-handle"
                version="0.7.15"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The handle of type %TP_HANDLE_TYPE_CONTACT representing the local user.
Must be set nonzero by the subclass before moving to state CONNECTED.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="self-id"
                version="0.21.2"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">The identifier representing the local user. This is the result of
inspecting #TpBaseConnection:self-handle.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="bus_name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="status" readable="0" private="1">
        <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
      </field>
      <field name="self_handle" readable="0" private="1">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseConnectionPrivate" c:type="TpBaseConnectionPrivate*"/>
      </field>
      <glib:signal name="clients-interested" when="last" detailed="1">
        <doc xml:space="preserve">Emitted when a client becomes interested in any token that was added with
tp_base_connection_add_possible_client_interest().

The "signal detail" is a GQuark representing @token. Modules implementing
an interface (Location, say) should typically connect to a detailed signal
like
"clients-interested::org.freedesktop.Telepathy.Connection.Interface.Location"
rather than receiving all emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">the interface or part of an interface in which clients are newly
 interested</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="clients-uninterested" when="last" detailed="1">
        <doc xml:space="preserve">Emitted when no more clients are interested in an interface added with
tp_base_connection_add_possible_client_interest(), for which
#TpBaseConnection::clients-interested was previously emitted.

As with #TpBaseConnection::clients-interested, the "signal detail" is a
GQuark representing @token. Modules implementing an interface (Location,
say) should typically connect to a detailed signal like
"clients-uninterested::org.freedesktop.Telepathy.Connection.Interface.Location"
rather than receiving all emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">the interface or part of an interface in which clients are no
 longer interested</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="shutdown-finished"
                   when="last"
                   detailed="1"
                   introspectable="0">
        <doc xml:space="preserve">Emitted by tp_base_connection_finish_shutdown() when the underlying
network connection has been closed; #TpBaseConnectionManager listens
for this signal and removes connections from its table of active
connections when it is received.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="BaseConnectionClass"
            c:type="TpBaseConnectionClass"
            glib:is-gtype-struct-for="BaseConnection">
      <doc xml:space="preserve">The class of a #TpBaseConnection. Many members are virtual methods etc.
to be filled in in the subclass' class_init function.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The superclass' structure</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_internal_create_handle_repos" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="create_channel_factories" introspectable="0">
        <doc xml:space="preserve">Create an array of channel factories for this
 Connection. At least one of this or @create_channel_managers must be set by
 subclasses to a non-%NULL value; in new code, setting this to %NULL and
 using channel managers exclusively is recommended.</doc>
        <type name="BaseConnectionCreateChannelFactoriesImpl"
              c:type="TpBaseConnectionCreateChannelFactoriesImpl"/>
      </field>
      <field name="get_unique_connection_name">
        <doc xml:space="preserve">Construct a unique name for this connection
 (for example using the protocol's format for usernames). If %NULL (the
 default), a unique name will be generated. Subclasses should usually
 override this to get more obvious names, to aid debugging and prevent
 multiple connections to the same account.</doc>
        <type name="BaseConnectionGetUniqueConnectionNameImpl"
              c:type="TpBaseConnectionGetUniqueConnectionNameImpl"/>
      </field>
      <field name="connecting">
        <doc xml:space="preserve">If set by subclasses, will be called just after the state
 changes to CONNECTING. May be %NULL if nothing special needs to happen.</doc>
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="connected">
        <doc xml:space="preserve">If set by subclasses, will be called just after the state
 changes to CONNECTED. May be %NULL if nothing special needs to happen.</doc>
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="disconnected">
        <doc xml:space="preserve">If set by subclasses, will be called just after the state
 changes to DISCONNECTED. May be %NULL if nothing special needs to happen.</doc>
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="shut_down">
        <doc xml:space="preserve">Called after disconnected() is called, to clean up the
 connection. Must start the shutdown process for the underlying
 network connection, and arrange for tp_base_connection_finish_shutdown()
 to be called after the underlying connection has been closed. May not
 be left as %NULL.</doc>
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="start_connecting">
        <doc xml:space="preserve">Asynchronously start connecting - called to implement
 the Connect D-Bus method. See #TpBaseConnectionStartConnectingImpl for
 details. May not be left as %NULL.</doc>
        <type name="BaseConnectionStartConnectingImpl"
              c:type="TpBaseConnectionStartConnectingImpl"/>
      </field>
      <field name="interfaces_always_present" readable="0" private="1">
        <type name="utf8" c:type="const gchar**"/>
      </field>
      <field name="create_channel_managers" introspectable="0">
        <doc xml:space="preserve">Create an array of channel managers for this
 Connection. At least one of this or @create_channel_factories must be set
 by subclasses to a non-%NULL value. Since: 0.7.15</doc>
        <type name="BaseConnectionCreateChannelManagersImpl"
              c:type="TpBaseConnectionCreateChannelManagersImpl"/>
      </field>
      <field name="get_interfaces_always_present" introspectable="0">
        <doc xml:space="preserve">Returns a #GPtrArray of extra D-Bus
 interfaces which are always implemented by instances of this class,
 which may be filled in by subclasses. The default is to list no
 additional interfaces. Individual instances may detect which
 additional interfaces they support and signal them before going
 to state CONNECTED by calling tp_base_connection_add_interfaces().</doc>
        <type name="BaseConnectionGetInterfacesImpl"
              c:type="TpBaseConnectionGetInterfacesImpl"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="BaseConnectionCreateChannelFactoriesImpl"
              c:type="TpBaseConnectionCreateChannelFactoriesImpl"
              introspectable="0">
      <doc xml:space="preserve">Signature of an implementation of the create_channel_factories method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a GPtrArray of objects implementing
 #TpChannelFactoryIface which, between them, implement all channel types
 this Connection supports.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateChannelManagersImpl"
              c:type="TpBaseConnectionCreateChannelManagersImpl"
              introspectable="0">
      <doc xml:space="preserve">Signature of an implementation of the create_channel_managers method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a GPtrArray of objects implementing
 #TpChannelManager which, between them, implement all channel types this
 Connection supports.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateHandleReposImpl"
              c:type="TpBaseConnectionCreateHandleReposImpl"
              introspectable="0">
      <doc xml:space="preserve">Signature of an implementation of the create_handle_repos method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:space="preserve">An array of pointers to be filled in; the implementation
        may assume all are initially NULL.</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface**"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionGetInterfacesImpl"
              c:type="TpBaseConnectionGetInterfacesImpl"
              version="0.19.4"
              introspectable="0">
      <doc xml:space="preserve">Signature of an implementation of
#TpBaseConnectionClass.get_interfaces_always_present virtual
function.

Implementation must first chainup on parent class implementation and then
add extra interfaces into the #GPtrArray.

|[
static GPtrArray *
my_connection_get_interfaces_always_present (TpBaseConnection *self)
{
  GPtrArray *interfaces;

  interfaces = TP_BASE_CONNECTION_CLASS (
      my_connection_parent_class)-&gt;get_interfaces_always_present (self);

  g_ptr_array_add (interfaces, TP_IFACE_BADGERS);

  return interfaces;
}
]|</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a #GPtrArray of static strings for D-Bus
  interfaces implemented by this client.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionGetUniqueConnectionNameImpl"
              c:type="TpBaseConnectionGetUniqueConnectionNameImpl">
      <doc xml:space="preserve">Signature of the @get_unique_connection_name virtual method
on #TpBaseConnection.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a name for this connection which will be unique
 within this connection manager process, as a string which the caller must
 free with #g_free.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseConnectionPrivate"
            c:type="TpBaseConnectionPrivate"
            disguised="1">
    </record>
    <callback name="BaseConnectionProc" c:type="TpBaseConnectionProc">
      <doc xml:space="preserve">Signature of a virtual method on #TpBaseConnection that takes no
additional parameters and returns nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionStartConnectingImpl"
              c:type="TpBaseConnectionStartConnectingImpl"
              throws="1">
      <doc xml:space="preserve">Signature of an implementation of the start_connecting method
of #TpBaseConnection.

On entry, the implementation may assume that it is in state NEW.

If %TRUE is returned, the Connect D-Bus method succeeds; the
implementation must either have already set the status to CONNECTED by
calling tp_base_connection_change_status(), or have arranged for a
status change to either state DISCONNECTED or CONNECTED to be signalled by
calling tp_base_connection_change_status() at some later time.
If the status is still NEW after returning %TRUE, #TpBaseConnection will
automatically change it to CONNECTING for reason REQUESTED.

If %FALSE is returned, the error will be raised from Connect as an
exception. If the status is not DISCONNECTED after %FALSE is returned,
#TpBaseConnection will automatically change it to DISCONNECTED
with a reason appropriate to the error; NetworkError results in
NETWORK_ERROR, PermissionDenied results in AUTHENTICATION_FAILED, and all
other errors currently result in NONE_SPECIFIED.

All except the simplest connection managers are expected to implement this
asynchronously, returning %TRUE in most cases and changing the status
to CONNECTED or DISCONNECTED later.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if failure has already occurred, else %TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="BasicProxyFactory"
           c:symbol-prefix="basic_proxy_factory"
           c:type="TpBasicProxyFactory"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpBasicProxyFactory"
           glib:get-type="tp_basic_proxy_factory_get_type"
           glib:type-struct="BasicProxyFactoryClass">
      <doc xml:space="preserve">Data structure representing a #TpBasicProxyFactory</doc>
      <implements name="ClientChannelFactory"/>
      <constructor name="new"
                   c:identifier="tp_basic_proxy_factory_new"
                   version="0.13.2"
                   deprecated="1">
        <doc xml:space="preserve">Convenient function to create a new #TpBasicProxyFactory instance.</doc>
        <doc-deprecated xml:space="preserve">New code should use #TpSimpleClientFactory instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpBasicProxyFactory</doc>
          <type name="BasicProxyFactory" c:type="TpBasicProxyFactory*"/>
        </return-value>
      </constructor>
      <function name="dup"
                c:identifier="tp_basic_proxy_factory_dup"
                version="0.13.2"
                deprecated="1">
        <doc xml:space="preserve">Returns a cached #TpBasicProxyFactory; the same #TpBasicProxyFactory object
will be returned by this function repeatedly, as long as at least one
reference exists.</doc>
        <doc-deprecated xml:space="preserve">New code should use #TpSimpleClientFactory instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TpBasicProxyFactory</doc>
          <type name="BasicProxyFactory" c:type="TpBasicProxyFactory*"/>
        </return-value>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="BasicProxyFactoryClass"
            c:type="TpBasicProxyFactoryClass"
            glib:is-gtype-struct-for="BasicProxyFactory"
            version="0.13.2">
      <doc xml:space="preserve">The class of a #TpBasicProxyFactory.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <constant name="CHANNEL_DISPATCHER_BUS_NAME"
              value="org.freedesktop.Telepathy.ChannelDispatcher"
              c:type="TP_CHANNEL_DISPATCHER_BUS_NAME">
      <doc xml:space="preserve">The channel dispatcher's well-known bus name</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CHANNEL_DISPATCHER_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/ChannelDispatcher"
              c:type="TP_CHANNEL_DISPATCHER_OBJECT_PATH">
      <doc xml:space="preserve">The channel dispatcher's standard object path</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.Client."
              c:type="TP_CLIENT_BUS_NAME_BASE">
      <doc xml:space="preserve">The common prefix of the well-known bus name for any Telepathy Client.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Client/"
              c:type="TP_CLIENT_OBJECT_PATH_BASE">
      <doc xml:space="preserve">The common prefix of the well-known object path for any Telepathy Client.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="CMInfoSource" version="0.7.1" c:type="TpCMInfoSource">
      <doc xml:space="preserve">Describes possible sources of information on connection managers'
supported protocols.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CM_INFO_SOURCE.</doc>
      <member name="none" value="0" c:identifier="TP_CM_INFO_SOURCE_NONE">
        <doc xml:space="preserve">no information available</doc>
      </member>
      <member name="file" value="1" c:identifier="TP_CM_INFO_SOURCE_FILE">
        <doc xml:space="preserve">information came from a .manager file</doc>
      </member>
      <member name="live" value="2" c:identifier="TP_CM_INFO_SOURCE_LIVE">
        <doc xml:space="preserve">information came from the connection manager</doc>
      </member>
    </enumeration>
    <constant name="CM_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.ConnectionManager."
              c:type="TP_CM_BUS_NAME_BASE">
      <doc xml:space="preserve">The prefix for a connection manager's bus name, to which the CM's name
(e.g. "gabble") should be appended.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CM_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/ConnectionManager/"
              c:type="TP_CM_OBJECT_PATH_BASE">
      <doc xml:space="preserve">The prefix for a connection manager's object path, to which the CM's name
(e.g. "gabble") should be appended.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONN_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.Connection."
              c:type="TP_CONN_BUS_NAME_BASE">
      <doc xml:space="preserve">The prefix for a connection's bus name, to which the CM's name
(e.g. "gabble"), the protocol (e.g. "jabber") and an element or sequence
of elements representing the account should be appended.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONN_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Connection/"
              c:type="TP_CONN_OBJECT_PATH_BASE">
      <doc xml:space="preserve">The prefix for a connection's object path, to which the CM's name
(e.g. "gabble"), the protocol (e.g. "jabber") and an element or sequence
of elements representing the account should be appended.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONTACT_FEATURE_INVALID"
              value="-1"
              c:type="TP_CONTACT_FEATURE_INVALID"
              version="0.15.5"
              introspectable="0">
      <doc xml:space="preserve">An invalid TpContactFeature. Used as list termination. See for example
tp_simple_client_factory_add_contact_features_varargs().</doc>
      <type name="ContactFeature" c:type="TpContactFeature"/>
    </constant>
    <class name="CallChannel"
           c:symbol-prefix="call_channel"
           c:type="TpCallChannel"
           version="0.17.5"
           parent="Channel"
           glib:type-name="TpCallChannel"
           glib:get-type="tp_call_channel_get_type"
           glib:type-struct="CallChannelClass">
      <doc xml:space="preserve">Data structure representing a #TpCallChannel.</doc>
      <function name="get_feature_quark_core"
                c:identifier="tp_call_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_async"
              c:identifier="tp_call_channel_accept_async"
              version="0.17.5">
        <doc xml:space="preserve">For incoming calls with #TpCallChannel:state set to
%TP_CALL_STATE_INITIALISED, accept the incoming call. This changes
#TpCallChannel:state to %TP_CALL_STATE_ACCEPTED.

For outgoing calls with #TpCallChannel:state set to
%TP_CALL_STATE_PENDING_INITIATOR, actually call the remote contact; this
changes #TpCallChannel:state to
%TP_CALL_STATE_INITIALISING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_call_channel_accept_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_accept_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_content_async"
              c:identifier="tp_call_channel_add_content_async"
              version="0.17.5">
        <doc xml:space="preserve">Request that a new Content of type @type is added to @self. Callers should
check the value of the #TpCallChannel:mutable-contents property before trying
to add another content as it might not be allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the suggested name of the content to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the media stream type of the content to be added to the call, from
 #TpMediaStreamType</doc>
            <type name="MediaStreamType" c:type="TpMediaStreamType"/>
          </parameter>
          <parameter name="initial_direction" transfer-ownership="none">
            <doc xml:space="preserve">The initial direction of the content</doc>
            <type name="MediaStreamDirection" c:type="TpMediaStreamDirection"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_content_finish"
              c:identifier="tp_call_channel_add_content_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_add_content_async().

The returned #TpCallContent is NOT guaranteed to have
%TP_CALL_CONTENT_FEATURE_CORE prepared.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">reference to the new #TpCallContent.</doc>
          <type name="CallContent" c:type="TpCallContent*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contents"
              c:identifier="tp_call_channel_get_contents"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
 the value of #TpCallChannel:contents</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="CallContent"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_members"
              c:identifier="tp_call_channel_get_members"
              version="0.17.5">
        <doc xml:space="preserve">Get the members of this call.

The #TpContact objects are guaranteed to have all of the features
previously passed to tp_simple_client_factory_add_contact_features()
prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
 #GHashTable mapping #TpContact to its new #TpCallMemberFlags</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Contact"/>
            <type name="guint"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="tp_call_channel_get_state"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallChannel:state</doc>
          <type name="CallState" c:type="TpCallState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a place to set the value of
 #TpCallChannel:flags</doc>
            <type name="CallFlags" c:type="TpCallFlags*"/>
          </parameter>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a place to set the value of
 #TpCallChannel:state-details</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a place to set the value of
 #TpCallChannel:state-reason</doc>
            <type name="CallStateReason" c:type="TpCallStateReason**"/>
          </parameter>
        </parameters>
      </method>
      <method name="hangup_async"
              c:identifier="tp_call_channel_hangup_async"
              version="0.17.5">
        <doc xml:space="preserve">Request that the call is ended. All contents will be removed from @self so
that the #TpCallChannel:contents property will be the empty list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">a TpCallStateChangeReason</doc>
            <type name="CallStateChangeReason"
                  c:type="TpCallStateChangeReason"/>
          </parameter>
          <parameter name="detailed_reason" transfer-ownership="none">
            <doc xml:space="preserve">a more specific reason for the call hangup, if one is
 available, or an empty or %NULL string otherwise</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a human-readable message to be sent to the remote contact(s)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="hangup_finish"
              c:identifier="tp_call_channel_hangup_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_hangup_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_dtmf"
              c:identifier="tp_call_channel_has_dtmf"
              version="0.17.5">
        <doc xml:space="preserve">Whether or not @self can send DTMF tones using
tp_call_channel_send_tones_async(). To be able to send DTMF tones, at least
one of @self's #TpCallChannel:contents must implement
%TP_IFACE_CALL_CONTENT_INTERFACE_DTMF interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @self can send DTMF tones.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_hardware_streaming"
              c:identifier="tp_call_channel_has_hardware_streaming"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallChannel:hardware-streaming</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_hold"
              c:identifier="tp_call_channel_has_hold"
              version="0.17.6">
        <doc xml:space="preserve">Whether or not @self has the %TP_IFACE_CHANNEL_INTERFACE_HOLD
interfaces</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @self supports Hold</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_initial_audio"
              c:identifier="tp_call_channel_has_initial_audio"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallChannel:initial-audio</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="initial_audio_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a place to set the
 value of #TpCallChannel:initial-audio-name</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_initial_video"
              c:identifier="tp_call_channel_has_initial_video"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallChannel:initial-video</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="initial_video_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a place to set the
 value of #TpCallChannel:initial-video-name</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_mutable_contents"
              c:identifier="tp_call_channel_has_mutable_contents"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallChannel:mutable-contents</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="request_hold_async"
              c:identifier="tp_call_channel_request_hold_async"
              version="0.17.6">
        <doc xml:space="preserve">Requests that the connection manager holds or unholds the call. Watch
#TpCallChannel:hold-state property to know when the channel goes on
hold or is unheld. Unholding may fail if the streaming implementation
can not obtain all the resources needed to restart the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:space="preserve">Whether to request a hold or a unhold</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_hold_finish"
              c:identifier="tp_call_channel_request_hold_finish"
              version="0.17.6"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_request_hold_async</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_async"
              c:identifier="tp_call_channel_send_tones_async"
              version="0.17.5">
        <doc xml:space="preserve">Send @tones on every of @self's contents which have the
%TP_IFACE_CALL_CONTENT_INTERFACE_DTMF interface.

For more details, see tp_call_content_send_tones_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="tones" transfer-ownership="none">
            <doc xml:space="preserve">a string representation of one or more DTMF events.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_finish"
              c:identifier="tp_call_channel_send_tones_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_send_tones_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_queued_async"
              c:identifier="tp_call_channel_set_queued_async"
              version="0.17.5">
        <doc xml:space="preserve">Notifies the CM that the local user is already in a call, so this call has
been put in a call-waiting style queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_queued_finish"
              c:identifier="tp_call_channel_set_queued_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_set_queued_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ringing_async"
              c:identifier="tp_call_channel_set_ringing_async"
              version="0.17.5">
        <doc xml:space="preserve">Indicate that the local user has been alerted about the incoming call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ringing_finish"
              c:identifier="tp_call_channel_set_ringing_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_channel_set_ringing_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallChannel</doc>
            <type name="CallChannel" c:type="TpCallChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="contents" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">#GPtrArray of #TpCallContent objects. The list of content objects that are
part of this call.

It is NOT guaranteed that %TP_CALL_CONTENT_FEATURE_CORE is prepared on
those objects.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="flags" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">A #TpCallFlags specifying the flags of the call state.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hardware-streaming"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the streaming is done by dedicated hardware.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hold-state" version="0.17.6" transfer-ownership="none">
        <doc xml:space="preserve">A #TpLocalHoldState specifying if the Call is currently held</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hold-state-reason"
                version="0.17.6"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpLocalHoldStateReason specifying why the Call is currently held.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="initial-audio"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the Call was started with audio.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="initial-audio-name"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">If #TpCallChannel:initial-audio is set to %TRUE, then this property will
is the name of the intial audio content, %NULL otherwise.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="initial-video"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the Call was started with video.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="initial-video-name"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">If #TpCallChannel:initial-video is set to %TRUE, then this property will
is the name of the intial video content, %NULL otherwise.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mutable-contents"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not call contents can be added or removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="state" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">A #TpCallState specifying the state of the call.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="state-details"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">Detailed infoermation about #TpCallChannel:state. It is a #GHashTable
mapping gchar*-&gt;GValue, it can be accessed using the tp_asv_* functions.</doc>
        <type name="GLib.HashTable">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="state-reason" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">Reason why #TpCallChannel:state last changed.</doc>
        <type name="CallStateReason"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CallChannelPrivate" c:type="TpCallChannelPrivate*"/>
      </field>
      <glib:signal name="content-added" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::content-added signal is emitted whenever a
#TpCallContent is added to @self.

It is NOT guaranteed that %TP_CALL_CONTENT_FEATURE_CORE is prepared on
@content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="content" transfer-ownership="none">
            <doc xml:space="preserve">the newly added #TpCallContent</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="content-removed" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::content-removed signal is emitted whenever a
#TpCallContent is removed from @self.

It is NOT guaranteed that %TP_CALL_CONTENT_FEATURE_CORE is prepared on
@content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="content" transfer-ownership="none">
            <doc xml:space="preserve">the newly removed #TpCallContent</doc>
            <type name="GObject.Object"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStateReason</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="members-changed" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::members-changed signal is emitted whenever the call's members
changes.

The #TpContact objects are guaranteed to have all of the features
previously passed to tp_simple_client_factory_add_contact_features()
prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="updates" transfer-ownership="none">
            <doc xml:space="preserve">
  #GHashTable mapping #TpContact to its new #TpCallMemberFlags</doc>
            <type name="GLib.HashTable">
              <type name="Contact"/>
              <type name="guint"/>
            </type>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">
 #GPtrArray of #TpContact removed from the call members</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="state-changed" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::state-changed signal is emitted whenever the
call state changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new #TpCallState</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the new #TpCallFlags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">additional details as a
  #GHashTable readable using the tp_asv_* functions.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="CallChannelClass"
            c:type="TpCallChannelClass"
            glib:is-gtype-struct-for="CallChannel"
            version="0.17.5">
      <doc xml:space="preserve">The class of a #TpCallChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="CallChannelPrivate"
            c:type="TpCallChannelPrivate"
            disguised="1">
    </record>
    <class name="CallContent"
           c:symbol-prefix="call_content"
           c:type="TpCallContent"
           version="0.17.5"
           parent="Proxy"
           glib:type-name="TpCallContent"
           glib:get-type="tp_call_content_get_type"
           glib:type-struct="CallContentClass">
      <doc xml:space="preserve">Data structure representing a #TpCallContent.</doc>
      <function name="get_feature_quark_core"
                c:identifier="tp_call_content_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_call_content_init_known_interfaces"
                version="0.17.5">
        <doc xml:space="preserve">Ensure that the known interfaces for #TpCallContent have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CALL_CONTENT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_disposition"
              c:identifier="tp_call_content_get_disposition"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallContent:disposition</doc>
          <type name="CallContentDisposition"
                c:type="TpCallContentDisposition"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_media_type"
              c:identifier="tp_call_content_get_media_type"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallContent:name</doc>
          <type name="MediaStreamType" c:type="TpMediaStreamType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_call_content_get_name"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallContent:name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_streams"
              c:identifier="tp_call_content_get_streams"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
 the value of #TpCallContent:streams</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="CallStream"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_async"
              c:identifier="tp_call_content_remove_async"
              version="0.17.5">
        <doc xml:space="preserve">Remove the content from the call. This will cause #TpCallContent::removed
to be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_call_content_remove_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_content_remove_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_async"
              c:identifier="tp_call_content_send_tones_async"
              version="0.17.5">
        <doc xml:space="preserve">Send @tones DTMF code on @self content. @self must have the
%TP_IFACE_CALL_CONTENT_INTERFACE_DTMF interface.

If DTMF tones are already being played, this request is queued.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
          <parameter name="tones" transfer-ownership="none">
            <doc xml:space="preserve">a string representation of one or more DTMF events.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_finish"
              c:identifier="tp_call_content_send_tones_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_content_send_tones_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallContent</doc>
            <type name="CallContent" c:type="TpCallContent*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel"
                version="0.17.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The parent #TpCallChannel of the content.</doc>
        <type name="CallChannel"/>
      </property>
      <property name="connection"
                version="0.17.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpConnection of the call.</doc>
        <type name="Connection"/>
      </property>
      <property name="disposition" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">The disposition of this content, from #TpCallContentDisposition.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="media-type" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">The media type of this content, from #TpMediaStreamType.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="name" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">The name of this content.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="streams" version="0.17.5" transfer-ownership="none">
        <doc xml:space="preserve">#GPtrArray of #TpCallStream objects. The list of stream objects that are
part of this content.

It is NOT guaranteed that %TP_CALL_STREAM_FEATURE_CORE is prepared on
those objects.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CallContentPrivate" c:type="TpCallContentPrivate*"/>
      </field>
      <glib:signal name="removed" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::removed signal is emitted when @self is removed from
a #TpCallChannel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="streams-added" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::streams-added signal is emitted whenever
#TpCallStream are added to @self.

It is NOT guaranteed that %TP_CALL_STREAM_FEATURE_CORE is prepared on
stream objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="streams" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of newly added #TpCallStream</doc>
            <array name="GLib.PtrArray">
              <type name="CallStream"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="streams-removed" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::streams-removed signal is emitted whenever
#TpCallStreams are removed from @self.

It is NOT guaranteed that %TP_CALL_STREAM_FEATURE_CORE is prepared on
stream objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="streams" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of newly removed #TpCallStream</doc>
            <array name="GLib.PtrArray">
              <type name="CallStream"/>
            </array>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStateReason</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="CallContentClass"
            c:type="TpCallContentClass"
            glib:is-gtype-struct-for="CallContent"
            version="0.17.5">
      <doc xml:space="preserve">The class of a #TpCallContent.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <enumeration name="CallContentDisposition"
                 c:type="TpCallContentDisposition">
      <doc xml:space="preserve">&lt;![CDATA[         The disposition of this content, which defines whether to         automatically start sending data on the streams when         Accept is         called on the channel.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CALL_CONTENT_DISPOSITION_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           The content has no specific disposition.         ]]&gt;</doc>
      </member>
      <member name="initial"
              value="1"
              c:identifier="TP_CALL_CONTENT_DISPOSITION_INITIAL">
        <doc xml:space="preserve">&lt;![CDATA[           The content was initially part of the call. When           Accept           is called on the channel, all streams of this content with           LocalSendingState           set to Pending_Send will be           moved to Sending as if           SetSending           (True) had been called.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="CallContentPacketizationType"
                 c:type="TpCallContentPacketizationType">
      <doc xml:space="preserve">&lt;![CDATA[         A packetization method that can be used for a content.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="rtp"
              value="0"
              c:identifier="TP_CALL_CONTENT_PACKETIZATION_TYPE_RTP">
        <doc xml:space="preserve">&lt;![CDATA[           Real-time Transport Protocol, as documented by RFC 3550.         ]]&gt;</doc>
      </member>
      <member name="raw"
              value="1"
              c:identifier="TP_CALL_CONTENT_PACKETIZATION_TYPE_RAW">
        <doc xml:space="preserve">&lt;![CDATA[           Raw media.         ]]&gt;</doc>
      </member>
      <member name="msn_webcam"
              value="2"
              c:identifier="TP_CALL_CONTENT_PACKETIZATION_TYPE_MSN_WEBCAM">
        <doc xml:space="preserve">&lt;![CDATA[           MSN webcam. This is the video-only one-way type which was           used in earlier versions of WLM. Although no longer used,           modern WLM clients still support the MSN webcam protocol.         ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="CallContentPrivate"
            c:type="TpCallContentPrivate"
            disguised="1">
    </record>
    <bitfield name="CallFlags" c:type="TpCallFlags">
      <doc xml:space="preserve">&lt;![CDATA[         A set of flags representing additional information than is available         in CallState. Many of these flags only make         sense in a particular (or may explain why a call is in a specific         state).       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="locally_held"
              value="1"
              c:identifier="TP_CALL_FLAG_LOCALLY_HELD">
        <doc xml:space="preserve">&lt;![CDATA[           The call has been put on hold by the local user, e.g. using           the Hold interface. This flag SHOULD only be set           if there is at least one Content, and all Contents are           locally held.                         Otherwise, in transient situations where some but not all contents             are on hold, UIs would falsely indicate that the call as a whole             is on hold, which could lead to the user saying something they'll             regret, while under the impression that the other contacts can't             hear them!              This flag exists as a simplified proxy for HoldStateChanged,             to reduce the number of signals that need to be             listened to by a simple UI.                    ]]&gt;</doc>
      </member>
      <member name="locally_ringing"
              value="2"
              c:identifier="TP_CALL_FLAG_LOCALLY_RINGING">
        <doc xml:space="preserve">&lt;![CDATA[           This flag exists for observability of the           SetRinging method (e.g. so that           loggers can tell whether the call got as far as alerting the user,           or whether something went wrong before then). It should be set when           the SetRinging is called, and unset when the call leaves           Initialised.         ]]&gt;</doc>
      </member>
      <member name="locally_queued"
              value="4"
              c:identifier="TP_CALL_FLAG_LOCALLY_QUEUED">
        <doc xml:space="preserve">&lt;![CDATA[           This flag exists for observability of the           SetQueued method. It should be set           when the SetQueued is called, and unset when the call leaves           Initialising or           Initialised.         ]]&gt;</doc>
      </member>
      <member name="forwarded" value="8" c:identifier="TP_CALL_FLAG_FORWARDED">
        <doc xml:space="preserve">&lt;![CDATA[           The initiator of the call originally called a contact other than the           current recipient of the call, but the call was then forwarded or           diverted. This flag only makes sense on outgoing calls. It SHOULD be           set or unset according to informational messages from other           contacts.         ]]&gt;</doc>
      </member>
      <member name="clearing" value="16" c:identifier="TP_CALL_FLAG_CLEARING">
        <doc xml:space="preserve">&lt;![CDATA[           This flag only occurs when the CallState is Ended. The call with           this flag set has ended, but not all resources corresponding to the           call have been freed yet.            Depending on the protocol there might be some audible feedback while           the clearing flag is set.                         In calls following the ITU-T Q.931 standard there is a period of             time between the call ending and the underlying channel being             completely free for re-use.                    ]]&gt;</doc>
      </member>
    </bitfield>
    <bitfield name="CallMemberFlags" c:type="TpCallMemberFlags">
      <doc xml:space="preserve">&lt;![CDATA[         A set of flags representing the status of a remote contact in a           call.          It is protocol- and client-specific whether a particular contact           will ever have a particular flag set on them, and Telepathy clients           SHOULD NOT assume that a flag will ever be set.                     180 Ringing in SIP, and its equivalent in XMPP, are optional             informational messages, and implementations are not required             to send them. The same applies to the messages used to indicate             hold state.                ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="ringing"
              value="1"
              c:identifier="TP_CALL_MEMBER_FLAG_RINGING">
        <doc xml:space="preserve">&lt;![CDATA[           The remote contact's client has told us that the contact has been             alerted about the call but has not responded.                         This is a flag per member, not a flag for the call as a whole,               because in Muji conference calls, you could invite someone and               have their state be "ringing" for a while.                    ]]&gt;</doc>
      </member>
      <member name="held" value="2" c:identifier="TP_CALL_MEMBER_FLAG_HELD">
        <doc xml:space="preserve">&lt;![CDATA[           The call member has put this call on hold.                         This is a flag per member, not a flag for the call as a whole,               because in conference calls, any member could put the conference               on hold.                    ]]&gt;</doc>
      </member>
      <member name="conference_host"
              value="4"
              c:identifier="TP_CALL_MEMBER_FLAG_CONFERENCE_HOST">
        <doc xml:space="preserve">&lt;![CDATA[           This contact has merged this call into a conference. Note that GSM           provides a notification when the remote party merges a call into a           conference, but not when it is split out again; thus, this flag can           only indicate that the call has been part of a conference at some           point. If a GSM connection manager receives a notification that a           call has been merged into a conference a second time, it SHOULD           represent this by clearing and immediately re-setting this flag on           the remote contact.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="CallState" c:type="TpCallState">
      <doc xml:space="preserve">&lt;![CDATA[         The state of a call, as a whole.          The allowed transitions are:                     Pending_Initiator  Initialising (for outgoing calls,             when Accept is called)           Initialising  Initialised (for outgoing calls, when             the remote client indicates that the user has been notified about             the call. If the network is known not to provide feedback about whether             the remote side is ringing, then the call should immediately be             set to Initialised.           Initialising  Initialised (for incoming calls, when e.g. the             implementation has been initialised far enough that it is sensible             to notify the user about the call (to reduce the probability that             the user will pick up the call and have it immediately fail).             The UI should then alert the user about the call, and call             SetRinging)           Initialised  Accepted (for outgoing calls to a contact,             when the remote contact accepts the call; for incoming calls, when             Accept is called.)           Accepted  Active (when the local user successfully             joins the call/conference, and media is known to be flowing             successfully; also, when temporary connection problems are             resolved (See below)). If the network is known not to provide             feedback about when the call is properly connected, the call             should immediately be set to Active.           Active  Accepted (when there are temporary connection problems             that the CM is aware of and able to recover from)           any state  Ended (when the call is terminated             normally, or when an error occurs that the CM is unable to recover             from)                   Clients MAY consider unknown values from this enum to be an           error - additional values will not be defined after the Call           specification is declared to be stable.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown" value="0" c:identifier="TP_CALL_STATE_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           The call state is not known. This call state MUST NOT appear as a           value of the CallState property, but           MAY be used by client code to represent calls whose state is as yet           unknown.         ]]&gt;</doc>
      </member>
      <member name="pending_initiator"
              value="1"
              c:identifier="TP_CALL_STATE_PENDING_INITIATOR">
        <doc xml:space="preserve">&lt;![CDATA[           The initiator of the call hasn't accepted the call yet. This state           only makes sense for outgoing calls, where it means that the local           user has not yet sent any signalling messages to the remote user(s),           and will not do so until Accept is           called.         ]]&gt;</doc>
      </member>
      <member name="initialising"
              value="2"
              c:identifier="TP_CALL_STATE_INITIALISING">
        <doc xml:space="preserve">&lt;![CDATA[           Progress has been made in placing the call, but the           contact has not been made aware of the call yet. This corresponds to SIP's           status code 183 Session Progress, and should be used for the period           where the CM is waiting for the streaming implementation to           initialise (before sending the initial INVITE or equivalent) and when the           outgoing call has reached a gateway or ICE negotiation is pending.           UIs should not produce a dialtone or start ringing if the call is in           this state.         ]]&gt;</doc>
      </member>
      <member name="initialised"
              value="3"
              c:identifier="TP_CALL_STATE_INITIALISED">
        <doc xml:space="preserve">&lt;![CDATA[           In the outgoing case: at least one called user has been alerted           about the call (a SIP 180 (Ringing) packet or equivalent has been           received) but none have answered, so the call cannot go to Accepted           (use Ringing to determine which           members have been informed and which haven't, if you care). UIs           SHOULD produce a dialtone for outgoing calls in this state.            In the incoming case, the local user should be informed of the call           as soon as the call reaches this state (and           SetRinging should be called           to inform the CM that this has happened, so that it can relay this           fact to the caller using a SIP 180 (Ringing) packet or equivalent).         ]]&gt;</doc>
      </member>
      <member name="accepted" value="4" c:identifier="TP_CALL_STATE_ACCEPTED">
        <doc xml:space="preserve">&lt;![CDATA[           The contact being called has accepted the call, but the call is not           in the Active state (The most common reason for this is that the           streaming implementation hasn't connected yet).         ]]&gt;</doc>
      </member>
      <member name="active" value="5" c:identifier="TP_CALL_STATE_ACTIVE">
        <doc xml:space="preserve">&lt;![CDATA[           The contact being called has accepted the call, and discourse between           at least two parties should now be possible.         ]]&gt;</doc>
      </member>
      <member name="ended" value="6" c:identifier="TP_CALL_STATE_ENDED">
        <doc xml:space="preserve">&lt;![CDATA[           The call has ended, either via normal termination or an error.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="CallStateChangeReason" c:type="TpCallStateChangeReason">
      <doc xml:space="preserve">&lt;![CDATA[         A simple representation of the reason for a change in the call's         state, which may be used by simple clients, or used as a fallback         when the DBus_Reason member of a Call_State_Reason         struct is not understood.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           We just don't know. Unknown values of this enum SHOULD also be           treated like this.         ]]&gt;</doc>
      </member>
      <member name="progress_made"
              value="1"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_PROGRESS_MADE">
        <doc xml:space="preserve">&lt;![CDATA[           Situation normal. Progress has been made in the setup/teardown of           the call (and it didn't require any user interaction).         ]]&gt;</doc>
      </member>
      <member name="user_requested"
              value="2"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_USER_REQUESTED">
        <doc xml:space="preserve">&lt;![CDATA[           The change was requested by the contact indicated by the Actor             member of a Call_State_Reason struct.            The DBus_Reason SHOULD be the empty string if the call             was terminated normally, but MAY be a non-empty error name             to indicate error-like call termination reasons (kicked from             a conference by a moderator, etc.).         ]]&gt;</doc>
      </member>
      <member name="forwarded"
              value="3"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_FORWARDED">
        <doc xml:space="preserve">&lt;![CDATA[           The call was forwarded. If known, the handle of the           contact the call was forwarded to will be indicated by the           "forwarded-to" member of a           CallStateDetails dictionnary           in the CallStateChanged           signal.         ]]&gt;</doc>
      </member>
      <member name="rejected"
              value="4"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_REJECTED">
        <doc xml:space="preserve">&lt;![CDATA[           The CallState changed from             Initialised or             Ended (or a content's direction             changed) because it was rejected by the remote user.           Corresponds to Rejected         ]]&gt;</doc>
      </member>
      <member name="no_answer"
              value="5"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_NO_ANSWER">
        <doc xml:space="preserve">&lt;![CDATA[           The CallState changed from             Initialised or             Ended because the initiator             ended the call before the receiver accepted it. With an             incoming call this state change reason signifies a missed             call, or one that was picked up elsewhere before it was             picked up here.           Corresponds to NoAnswer or             PickedUpElsewhere         ]]&gt;</doc>
      </member>
      <member name="invalid_contact"
              value="6"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_INVALID_CONTACT">
        <doc xml:space="preserve">&lt;![CDATA[           The CallState changed because one             of the addresses does not exist on the network.           Corresponds to DoesNotExist         ]]&gt;</doc>
      </member>
      <member name="permission_denied"
              value="7"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_PERMISSION_DENIED">
        <doc xml:space="preserve">&lt;![CDATA[           The CallState changed because the           local user is not authorised.           Corresponds to PermissionDenied or             InsufficientBalance                      ]]&gt;</doc>
      </member>
      <member name="busy"
              value="8"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_BUSY">
        <doc xml:space="preserve">&lt;![CDATA[           The CallState changed from             Initialised             Ended because the receiver is busy             (e.g. is already engaged in another call, and has not placed the             initiator in a call-waiting queue).           Corresponds to Busy         ]]&gt;</doc>
      </member>
      <member name="internal_error"
              value="9"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_INTERNAL_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There has been an unexpected error in either the CM or some other             local component.           Corresponds to Confused or           Media.StreamingError                    ]]&gt;</doc>
      </member>
      <member name="service_error"
              value="10"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_SERVICE_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There has been an unexpected error in the server or some other             remote component.           Corresponds to             ServiceConfused                    ]]&gt;</doc>
      </member>
      <member name="network_error"
              value="11"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_NETWORK_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There has been a network error related to the CM or the             signalling part of the call (compare and contrast:             Streaming_Error).           Corresponds to             NetworkError         ]]&gt;</doc>
      </member>
      <member name="media_error"
              value="12"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_MEDIA_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           Some aspect of the content is unsupported so has to be             removed from the call.           Corresponds to Media.UnsupportedType             or Media.CodecsIncompatible                    ]]&gt;</doc>
      </member>
      <member name="connectivity_error"
              value="13"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_CONNECTIVITY_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           It was not possible for the streaming implementation to connect             to any of the users participating in this call or content.           Corresponds to ConnectionFailed or             ConnectionLost         ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="CallStateReason"
            c:type="TpCallStateReason"
            version="0.17.5"
            glib:type-name="TpCallStateReason"
            glib:get-type="tp_call_state_reason_get_type"
            c:symbol-prefix="call_state_reason">
      <doc xml:space="preserve">Data structure representing the reason for a call state change.</doc>
      <field name="actor" writable="1">
        <doc xml:space="preserve">the contact responsible for the change, or 0 if no contact was
 responsible</doc>
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="reason" writable="1">
        <doc xml:space="preserve">the reason for the change. If
 #TP_CALL_STATE_CHANGE_REASON_USER_REQUESTED then the @actor member will
 dictate whether it was the local user or a remote contact responsible</doc>
        <type name="CallStateChangeReason" c:type="TpCallStateChangeReason"/>
      </field>
      <field name="dbus_reason" writable="1">
        <doc xml:space="preserve">A specific reason for the change, which may be a D-Bus error in
 the Telepathy namespace, a D-Bus error in any other namespace
 (for implementation-specific errors), or the empty string to indicate that
 the state change was not an error</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="message" writable="1">
        <doc xml:space="preserve">A developer readable debug message giving the reason for the state
 change.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <class name="CallStream"
           c:symbol-prefix="call_stream"
           c:type="TpCallStream"
           version="0.17.5"
           parent="Proxy"
           glib:type-name="TpCallStream"
           glib:get-type="tp_call_stream_get_type"
           glib:type-struct="CallStreamClass">
      <doc xml:space="preserve">Data structure representing a #TpCallStream.</doc>
      <function name="get_feature_quark_core"
                c:identifier="tp_call_stream_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_call_stream_init_known_interfaces"
                version="0.17.5">
        <doc xml:space="preserve">Ensure that the known interfaces for #TpCallStream have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CALL_STREAM.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="can_request_receiving"
              c:identifier="tp_call_stream_can_request_receiving"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallStream:can-request-receiving</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_sending_state"
              c:identifier="tp_call_stream_get_local_sending_state"
              version="0.17.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpCallStream:local-sending-state</doc>
          <type name="SendingState" c:type="TpSendingState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_members"
              c:identifier="tp_call_stream_get_remote_members"
              version="0.17.5">
        <doc xml:space="preserve">Get the remote contacts to who this stream is connected, mapped to their
sending state.

It is NOT guaranteed that #TpContact objects have any feature prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
 #GHashTable mapping #TpContact to its new #TpSendingState</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Contact"/>
            <type name="guint"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="request_receiving_async"
              c:identifier="tp_call_stream_request_receiving_async"
              version="0.17.5">
        <doc xml:space="preserve">Request that a remote contact stops or starts sending on this stream.

The #TpCallStream:can-request-receiving property defines whether the protocol
allows the local user to request the other side start sending on this stream.

If @receive is %TRUE, request that the given contact starts to send media.
If @receive is %FALSE, request that the given contact stops sending media.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">contact from which sending is requested</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
          <parameter name="receive" transfer-ownership="none">
            <doc xml:space="preserve">the requested receiving state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_receiving_finish"
              c:identifier="tp_call_stream_request_receiving_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_stream_request_receiving_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sending_async"
              c:identifier="tp_call_stream_set_sending_async"
              version="0.17.5">
        <doc xml:space="preserve">Set the stream to start or stop sending media from the local user to other
contacts.

If @send is %TRUE, #TpCallStream:local-sending-state should change to
%TP_SENDING_STATE_SENDING, if it isn't already.
If @send is %FALSE, #TpCallStream:local-sending-state should change to
%TP_SENDING_STATE_NONE, if it isn't already.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
          <parameter name="send" transfer-ownership="none">
            <doc xml:space="preserve">the requested sending state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sending_finish"
              c:identifier="tp_call_stream_set_sending_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_call_stream_set_sending_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCallStream</doc>
            <type name="CallStream" c:type="TpCallStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="can-request-receiving"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the user can request that a remote contact starts sending on this
stream.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="connection"
                version="0.17.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpConnection of the call.</doc>
        <type name="Connection"/>
      </property>
      <property name="content"
                version="0.17.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Content that this streams belongs to</doc>
        <type name="CallContent"/>
      </property>
      <property name="local-sending-state"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:space="preserve">The local user's sending state, from #TpSendingState.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CallStreamPrivate" c:type="TpCallStreamPrivate*"/>
      </field>
      <glib:signal name="local-sending-state-changed"
                   when="last"
                   version="0.17.5">
        <doc xml:space="preserve">The ::local-sending-state-changed signal is emitted whenever the
stream sending state changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new #TpSendingState</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remote-members-changed" when="last" version="0.17.5">
        <doc xml:space="preserve">The ::remote-members-changed signal is emitted whenever the
stream's remote members changes.

It is NOT guaranteed that #TpContact objects have any feature prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="updates" transfer-ownership="none">
            <doc xml:space="preserve">
  #GHashTable mapping #TpContact to its new #TpSendingState</doc>
            <type name="GLib.HashTable">
              <type name="Contact"/>
              <type name="guint"/>
            </type>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">
 #GPtrArray of #TpContact removed from remote contacts</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="CallStreamCandidateType"
                 c:type="TpCallStreamCandidateType">
      <doc xml:space="preserve">&lt;![CDATA[         The network topology that an IP candidate represents. This can         sometimes be used to infer what kind of performance characteristics         (latency, bandwith, etc) can be expected of connections made to this         candidate.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           This is not an IP candidate. This is a reserved value, and should           not be seen on the bus.         ]]&gt;</doc>
      </member>
      <member name="host"
              value="1"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_HOST">
        <doc xml:space="preserve">&lt;![CDATA[           This candidate represents a direct connection to the host, as its           address is taken directly the host's IP stack.         ]]&gt;</doc>
      </member>
      <member name="server_reflexive"
              value="2"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_SERVER_REFLEXIVE">
        <doc xml:space="preserve">&lt;![CDATA[           This candidate probably represents a connection to the host through           a NAT device, as its address was discovered by sending a binding           request to a STUN server or similar.         ]]&gt;</doc>
      </member>
      <member name="peer_reflexive"
              value="3"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_PEER_REFLEXIVE">
        <doc xml:space="preserve">&lt;![CDATA[           This candidate probably represents a good route between the host and           its peer, as its address was discovered by sending a STUN binding           request to one of the candidates advertised by the peer.         ]]&gt;</doc>
      </member>
      <member name="relay"
              value="4"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_RELAY">
        <doc xml:space="preserve">&lt;![CDATA[           This candidate represents the address of a relay server (usually           somewhere on the public internet). This candidate is the most likely           to work, but all media will go via a relay server, so latency is           likely to be higher than other types of candidate.         ]]&gt;</doc>
      </member>
      <member name="multicast"
              value="5"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_MULTICAST">
        <doc xml:space="preserve">&lt;![CDATA[           This candidate represents a Multicast group. This value should only           appear if the Stream's Transport is           set to Multicast.         ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="CallStreamClass"
            c:type="TpCallStreamClass"
            glib:is-gtype-struct-for="CallStream"
            version="0.17.5">
      <doc xml:space="preserve">The class of a #TpCallStream.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="CallStreamPrivate"
            c:type="TpCallStreamPrivate"
            disguised="1">
    </record>
    <class name="Capabilities"
           c:symbol-prefix="capabilities"
           c:type="TpCapabilities"
           version="0.11.3"
           parent="GObject.Object"
           glib:type-name="TpCapabilities"
           glib:get-type="tp_capabilities_get_type"
           glib:type-struct="CapabilitiesClass">
      <doc xml:space="preserve">An object representing capabilities a #TpConnection or #TpContact supports.</doc>
      <method name="dup_channel_classes_variant"
              c:identifier="tp_capabilities_dup_channel_classes_variant"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpCapabilities:channel-classes-variant property</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of the
#TpCapabilities:channel-classes-variant property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel_classes"
              c:identifier="tp_capabilities_get_channel_classes"
              version="0.11.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same #GPtrArray as
the #TpCapabilities:channel-classes property</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_specific_to_contact"
              c:identifier="tp_capabilities_is_specific_to_contact"
              version="0.11.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same #gboolean as the #TpCapabilities:contact-specific property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_audio_call"
              c:identifier="tp_capabilities_supports_audio_call"
              version="0.17.6">
        <doc xml:space="preserve">Return whether audio calls can be established, for instance by calling
tp_account_channel_request_new_audio_call(), followed by
tp_account_channel_request_set_target_id() with @handle_type.

To check whether requests using
tp_account_channel_request_set_target_contact() would work, set
@handle_type to %TP_HANDLE_TYPE_CONTACT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing Call as ChannelType,
@handle_type as TargetHandleType, a True value for InitialAudio and an
identifier of the appropriate type can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type of the call; #TP_HANDLE_TYPE_CONTACT for
 private, #TP_HANDLE_TYPE_ROOM or #TP_HANDLE_TYPE_NONE for conference
 (depending on the protocol)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_audio_video_call"
              c:identifier="tp_capabilities_supports_audio_video_call"
              version="0.17.6">
        <doc xml:space="preserve">Return whether audio/video calls can be established, for instance by calling
tp_account_channel_request_new_audio_video_call(), followed by
tp_account_channel_request_set_target_id() with @handle_type.

To check whether requests using
tp_account_channel_request_set_target_contact() would work, set
@handle_type to %TP_HANDLE_TYPE_CONTACT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing Call as ChannelType,
@handle_type as TargetHandleType, a True value for
InitialAudio/InitialVideo and an identifier of the appropriate type can be
expected to work,
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type of the call; #TP_HANDLE_TYPE_CONTACT for
 private, #TP_HANDLE_TYPE_ROOM or #TP_HANDLE_TYPE_NONE for conference
 (depending on the protocol)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_contact_search"
              c:identifier="tp_capabilities_supports_contact_search"
              version="0.13.11">
        <doc xml:space="preserve">Return whether this protocol or connection can perform contact
searches. Optionally, also return whether a limited number of
results can be specified, and whether alternative servers can be
searched.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if #TpContactSearch can be used.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
          <parameter name="with_limit"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL, used to return %TRUE if the limit
parameter to tp_contact_search_new_async() and
tp_contact_search_reset_async() can be nonzero</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="with_server"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL, used to return %TRUE if the server
parameter to tp_contact_search_new_async() and
tp_contact_search_reset_async() can be non-%NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_dbus_tubes"
              c:identifier="tp_capabilities_supports_dbus_tubes"
              version="0.13.0">
        <doc xml:space="preserve">If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
D-Bus tubes with @handle_type as TargetHandleType.
If @service_name is not %NULL, it also checks if it supports stream tubes
with @service as #TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME.

If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if the connection supports requesting D-Bus tube channels with
@handle_type as ChannelType. The @service_name argument is unused in
this case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the contact or connection supports this type of D-Bus
tubes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type of the tube (either #TP_HANDLE_TYPE_CONTACT
or #TP_HANDLE_TYPE_ROOM)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="service_name" transfer-ownership="none">
            <doc xml:space="preserve">the service name of the tube, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_file_transfer"
              c:identifier="tp_capabilities_supports_file_transfer"
              version="0.17.6">
        <doc xml:space="preserve">Return whether private file transfer can be established by providing
a contact identifier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing FileTransfer as ChannelType,
HandleTypeContact as TargetHandleType and a contact identifier can be
expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_file_transfer_description"
              c:identifier="tp_capabilities_supports_file_transfer_description"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if requests as described for
 tp_capabilities_supports_file_transfer() can also specify the outgoing
 file's description</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_file_transfer_initial_offset"
              c:identifier="tp_capabilities_supports_file_transfer_initial_offset"
              version="0.19.0">
        <doc xml:space="preserve">Return whether an initial offset other than 0 can be specified on
outgoing file transfers. This can be used to resume partial transfers,
by omitting the part that has already been sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if requests as described for
 tp_capabilities_supports_file_transfer() can also specify an
 initial offset greater than 0</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_file_transfer_timestamp"
              c:identifier="tp_capabilities_supports_file_transfer_timestamp"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if requests as described for
 tp_capabilities_supports_file_transfer() can also specify the outgoing
 file's timestamp</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_file_transfer_uri"
              c:identifier="tp_capabilities_supports_file_transfer_uri"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if requests as described for
 tp_capabilities_supports_file_transfer() can also specify the outgoing
 file's URI</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_room_list"
              c:identifier="tp_capabilities_supports_room_list"
              version="0.13.14">
        <doc xml:space="preserve">Discovers whether this protocol or connection supports listing rooms.
Specifically, if this function returns %TRUE, a room list channel can be
requested as follows:
|[
GHashTable *request;
TpAccountChannelRequest *req;

request = tp_asv_new (
    TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
      TP_IFACE_CHANNEL_TYPE_ROOM_LIST,
    TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_NONE,
    NULL);

req = tp_account_channel_request_new (account, request,
   TP_USER_ACTION_TIME_CURRENT_TIME);

tp_account_channel_request_create_and_handle_channel_async (req, NULL,
    create_channel_cb, NULL);

g_object_unref (req);
g_hash_table_unref (request);
]|

If @with_server is set to %TRUE, a list of rooms on a particular server can
be requested as follows:
|[
/\* Same code as above but with request defined using: *\/
request = tp_asv_new (
    TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
      TP_IFACE_CHANNEL_TYPE_ROOM_LIST,
    TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_NONE,
    TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER, G_TYPE_STRING,
      "characters.shakespeare.lit",
    NULL);
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing RoomList as ChannelType,
HandleTypeNone as TargetHandleType can be expected to work,
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
          <parameter name="with_server"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL, used to return %TRUE if the
#TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER property can be defined when
requesting a RoomList channel.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_sms"
              c:identifier="tp_capabilities_supports_sms"
              version="0.19.0">
        <doc xml:space="preserve">If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if SMS text channels can be requested with the connection associated
with this #TpCapabilities.

If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
SMS text channels.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing Text as ChannelType,
HandleTypeContact as TargetHandleType, a channel identifier and
#TP_PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL set to %TRUE can be
expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_stream_tubes"
              c:identifier="tp_capabilities_supports_stream_tubes"
              version="0.13.0">
        <doc xml:space="preserve">If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
stream tubes with @handle_type as TargetHandleType.
If @service is not %NULL, it also checks if it supports stream tubes
with @service as #TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE.

If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if the connection supports requesting stream tube channels with
@handle_type as ChannelType. The @service argument is unused in this case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the contact or connection supports this type of stream
tubes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type of the tube (either #TP_HANDLE_TYPE_CONTACT
or #TP_HANDLE_TYPE_ROOM)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the service of the tube, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_text_chatrooms"
              c:identifier="tp_capabilities_supports_text_chatrooms"
              version="0.11.3">
        <doc xml:space="preserve">If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if named text chatrooms can be joined by providing a chatroom
identifier, for instance by calling
tp_account_channel_request_new_text() followed by
tp_account_channel_request_set_target_id() with %TP_HANDLE_TYPE_ROOM.

If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities can be invited
to named text chatrooms.

If the protocol is such that chatrooms can be joined or contacts can be
invited, but only via a more elaborate D-Bus API than normal
(because more information is needed), then this method will return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing Text as ChannelType,
HandleTypeRoom as TargetHandleType and a channel identifier can be
expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_text_chats"
              c:identifier="tp_capabilities_supports_text_chats"
              version="0.11.3">
        <doc xml:space="preserve">Return whether private text channels can be established by providing
a contact identifier, for instance by calling
tp_account_channel_request_new_text() followed by
tp_account_channel_request_set_target_contact().

If the protocol is such that text chats can be established, but only via a
more elaborate D-Bus API than normal (because more information is needed),
then this method will return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a channel request containing Text as ChannelType,
HandleTypeContact as TargetHandleType and a contact identifier can be
expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCapabilities object</doc>
            <type name="Capabilities" c:type="TpCapabilities*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="channel-classes"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The underlying data structure used by Telepathy to represent the
requests that can succeed.

This can be used by advanced clients to determine whether an unusually
complex request would succeed. See the Telepathy D-Bus API Specification
for details of how to interpret the returned #GPtrArray of
#TP_STRUCT_TYPE_REQUESTABLE_CHANNEL_CLASS.

The higher-level methods like
tp_capabilities_supports_text_chats() are likely to be more useful to
the majority of clients.</doc>
        <type/>
      </property>
      <property name="channel-classes-variant"
                version="0.19.0"
                transfer-ownership="none">
        <doc xml:space="preserve">The underlying data structure used by Telepathy to represent the
requests that can succeed.

This can be used by advanced clients to determine whether an unusually
complex request would succeed. See the Telepathy D-Bus API Specification
for details of how to interpret the returned #GVariant of type
a(a{sv}as).

The higher-level methods like
tp_capabilities_supports_text_chats() are likely to be more useful to
the majority of clients.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="contact-specific"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether this object accurately describes the capabilities of a particular
contact, or if it's only a guess based on the capabilities of the
underlying connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <record name="CapabilitiesClass"
            c:type="TpCapabilitiesClass"
            disguised="1"
            glib:is-gtype-struct-for="Capabilities">
    </record>
    <record name="CapabilitiesPrivate"
            c:type="TpCapabilitiesPrivate"
            disguised="1">
    </record>
    <enumeration name="CaptchaCancelReason" c:type="TpCaptchaCancelReason">
      <doc xml:space="preserve">&lt;![CDATA[         A reason why captcha authentication was aborted by the client.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="user_cancelled"
              value="0"
              c:identifier="TP_CAPTCHA_CANCEL_REASON_USER_CANCELLED">
        <doc xml:space="preserve">&lt;![CDATA[           The user aborted the authentication. If this is used, the           CaptchaError SHOULD be set to           Cancelled         ]]&gt;</doc>
      </member>
      <member name="not_supported"
              value="1"
              c:identifier="TP_CAPTCHA_CANCEL_REASON_NOT_SUPPORTED">
        <doc xml:space="preserve">&lt;![CDATA[           The Handler doesn't support the given/required captcha types.           If this is used, the CaptchaError           SHOULD be set to CaptchaNotSupported.           This SHOULD also be used if           Close is called           before CancelCaptcha.                        If no Handler supports captcha channels,             the ChannelDispatcher will just call             Close,             because it has no knowledge of specific channel types.                    ]]&gt;</doc>
      </member>
      <member name="service_confused"
              value="2"
              c:identifier="TP_CAPTCHA_CANCEL_REASON_SERVICE_CONFUSED">
        <doc xml:space="preserve">&lt;![CDATA[           The Handler doesn't understand the captcha data received. The           challenger may be sending gibberish.           If this is used, the CaptchaError           SHOULD be set to ServiceConfused.         ]]&gt;</doc>
      </member>
    </enumeration>
    <bitfield name="CaptchaFlags" c:type="TpCaptchaFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Extra flags to include with Captcha information       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="captcha_flags_required"
              value="1"
              c:identifier="TP_CAPTCHA_FLAGS_REQUIRED">
        <doc xml:space="preserve">&lt;![CDATA[           This captcha mechanism is required to be successfully           answered in order to pass this captcha challenge.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="CaptchaStatus" c:type="TpCaptchaStatus">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_pending"
              value="0"
              c:identifier="TP_CAPTCHA_STATUS_LOCAL_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The challenge/response exchange is in progress and waiting for           a local action. Call AnswerCaptchas           to go to the Remote_Pending state, or call           CancelCaptcha followed by            Close           to give up.         ]]&gt;</doc>
      </member>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_CAPTCHA_STATUS_REMOTE_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The challenge/response exchange is in progress and waiting for           a response from the server. Wait for a reply from the server,           which will result in the Succeeded, Try_Again, or Failed state,           or call CancelCaptcha followed by           Close           to give up.         ]]&gt;</doc>
      </member>
      <member name="succeeded"
              value="2"
              c:identifier="TP_CAPTCHA_STATUS_SUCCEEDED">
        <doc xml:space="preserve">&lt;![CDATA[           Everyone is happy. Connection to the server will proceed as soon as           this state is reached. There is nothing useful to do in this state           except to call Close           to close the channel.         ]]&gt;</doc>
      </member>
      <member name="try_again"
              value="3"
              c:identifier="TP_CAPTCHA_STATUS_TRY_AGAIN">
        <doc xml:space="preserve">&lt;![CDATA[           The server has indicated an authentication failure.           Call GetCaptchas again to get           a new captcha, or           CancelCaptcha followed by           Close           to give up.         ]]&gt;</doc>
      </member>
      <member name="failed" value="4" c:identifier="TP_CAPTCHA_STATUS_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           Authentication has failed in some way. There is nothing           useful to do in this state except to close the channel with           Close.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="Channel"
           c:symbol-prefix="channel"
           c:type="TpChannel"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpChannel"
           glib:get-type="tp_channel_get_type"
           glib:type-struct="ChannelClass">
      <doc xml:space="preserve">A proxy object for a Telepathy channel.
A proxy object for a Telepathy channel. There are no interesting
public struct fields.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new"
                   c:identifier="tp_channel_new"
                   version="0.7.1"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_channel() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new channel proxy, or %NULL on invalid arguments.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="optional_channel_type" transfer-ownership="none">
            <doc xml:space="preserve">the channel type if already known, or %NULL if not</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="optional_handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type if already known, or
 %TP_UNKNOWN_HANDLE_TYPE if not</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="optional_handle" transfer-ownership="none">
            <doc xml:space="preserve">the handle if already known, or 0 if not
 (if @optional_handle_type is %TP_UNKNOWN_HANDLE_TYPE or
 %TP_HANDLE_TYPE_NONE, this must be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_properties"
                   c:identifier="tp_channel_new_from_properties"
                   version="0.7.19"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_channel() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the channel,
 as signalled by the NewChannel D-Bus signal or returned by the
 CreateChannel and EnsureChannel D-Bus methods: a mapping from
 strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_chat_states"
                c:identifier="tp_channel_get_feature_quark_chat_states">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contacts"
                c:identifier="tp_channel_get_feature_quark_contacts">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_group"
                c:identifier="tp_channel_get_feature_quark_group">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_password"
                c:identifier="tp_channel_get_feature_quark_password">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_init_known_interfaces"
                version="0.7.6">
        <doc xml:space="preserve">Ensure that the known interfaces for TpChannel have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_connection"
              c:identifier="tp_channel_borrow_connection"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with g_object_ref() if needed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_channel_get_connection() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="borrow_immutable_properties"
              c:identifier="tp_channel_borrow_immutable_properties"
              deprecated="1">
        <doc xml:space="preserve">Returns the immutable D-Bus properties of this channel, the same as
#TpChannel:channel-properties.

The returned hash table should not be altered, and is not necessarily
valid after the main loop is next re-entered. Copy it with
g_boxed_copy() (its type is %TP_HASH_TYPE_QUALIFIED_PROPERTY_VALUE_MAP)
if a copy that remains valid must be kept.

If the #TpChannel:channel-properties property was not set during
construction (e.g. by calling tp_channel_new_from_properties()), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until the %TP_CHANNEL_FEATURE_CORE
feature is prepared.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_channel_dup_immutable_properties() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable
 where the keys are strings,
 D-Bus interface name + "." + property name, and the values are #GValue
 instances</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_channel_call_when_ready"
              version="0.7.7"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.17.6">
        <doc xml:space="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.

This is a less general form of tp_proxy_prepare_async(), which should be
used in new code. (One important difference is that this function can call
@callback before it has returned, whereas tp_proxy_prepare_async() always
calls @callback from the main loop.)</doc>
        <doc-deprecated xml:space="preserve">Use tp_proxy_prepare_async()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">called when the channel becomes ready or invalidated, whichever
 happens first</doc>
            <type name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async"
              c:identifier="tp_channel_close_async"
              version="0.13.10">
        <doc xml:space="preserve">Close channel @self. In most cases, it's generally cleaner to use
tp_channel_leave_async() instead to properly leave and close the channel.

When the channel has been closed, @callback will be called.
You can then call tp_channel_close_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when we closed the channel, or %NULL
 to ignore any reply</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="tp_channel_close_finish"
              version="0.13.10"
              throws="1">
        <doc xml:space="preserve">Finishes a call to tp_channel_leave_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel has been closed; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_channel_close_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_async"
              c:identifier="tp_channel_destroy_async"
              version="0.15.2">
        <doc xml:space="preserve">Destroy channel @self.
If @self doesn't implement #TP_IFACE_QUARK_CHANNEL_INTERFACE_DESTROYABLE
or if for any reason we can't destroy the channel, we close it.

When the channel has been destroyed or closed, @callback will be called.
You can then call tp_channel_destroy_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when we left the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_finish"
              c:identifier="tp_channel_destroy_finish"
              version="0.15.2"
              throws="1">
        <doc xml:space="preserve">Completes a call to tp_channel_destroy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel has been destroyed or closed; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_channel_destroy_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_immutable_properties"
              c:identifier="tp_channel_dup_immutable_properties"
              version="0.19.9">
        <doc xml:space="preserve">Returns the immutable D-Bus properties of this channel, in a variant of type
%G_VARIANT_TYPE_VARDICT where the keys are strings,
D-Bus interface name + "." + property name. Use g_variant_lookup() or
g_variant_lookup_value() for convenient access to the values.

If the #TpChannel:channel-properties property was not set during
construction (e.g. by calling tp_channel_new_from_properties()), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until the %TP_CHANNEL_FEATURE_CORE
feature is prepared.

This function should be used only by #TpChannel subclasses, otherwise it is
recommended to use individual property getters instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a dictionary where the keys are strings,
 D-Bus interface name + "." + property name.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel_type"
              c:identifier="tp_channel_get_channel_type"
              version="0.7.12">
        <doc xml:space="preserve">Get the D-Bus interface name representing this channel's type,
if it has been discovered.

This is the same as the #TpChannelIface:channel-type property; it isn't
guaranteed to be non-%NULL until the %TP_CHANNEL_FEATURE_CORE feature has
been prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the channel type, if the channel is ready; either the channel
 type or %NULL, if the channel is not yet ready.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel_type_id"
              c:identifier="tp_channel_get_channel_type_id"
              version="0.7.12">
        <doc xml:space="preserve">Get the D-Bus interface name representing this channel's type, as a GQuark,
if it has been discovered.

This is the same as the #TpChannelIface:channel-type property, except that it
is a GQuark rather than a string. It isn't guaranteed to be nonzero until
the %TP_CHANNEL_FEATURE_CORE property is ready.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the channel type, if the channel is ready; either the channel
 type or 0, if the channel is not yet ready.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_chat_state"
              c:identifier="tp_channel_get_chat_state"
              version="0.11.3"
              deprecated="1">
        <doc xml:space="preserve">Return the chat state for the given contact. If tp_proxy_is_prepared()
would return %FALSE for the feature %TP_CHANNEL_FEATURE_CHAT_STATES,
the result will always be %TP_CHANNEL_CHAT_STATE_INACTIVE.</doc>
        <doc-deprecated xml:space="preserve">Use tp_text_channel_get_chat_state() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the chat state for @contact, or %TP_CHANNEL_CHAT_STATE_INACTIVE
 if their chat state is not known</doc>
          <type name="ChannelChatState" c:type="TpChannelChatState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">a contact handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tp_channel_get_connection"
              version="0.19.9">
        <doc xml:space="preserve">Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handle"
              c:identifier="tp_channel_get_handle"
              version="0.7.12">
        <doc xml:space="preserve">Get the handle representing the contact, chatroom, etc. with which this
channel communicates for its whole lifetime, or 0 if there is no such
handle or it has not yet been discovered.

This is the same as the #TpChannelIface:handle property. It isn't
guaranteed to have its final value until the %TP_CHANNEL_FEATURE_CORE
feature is ready.

If @handle_type is not %NULL, the type of handle is written into it.
This will be %TP_UNKNOWN_HANDLE_TYPE if the handle has not yet been
discovered, or %TP_HANDLE_TYPE_NONE if there is no handle with which this
channel will always communicate. This is the same as the
#TpChannelIface:handle-type property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="handle_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL, used to return the type of this handle</doc>
            <type name="HandleType" c:type="TpHandleType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier"
              c:identifier="tp_channel_get_identifier"
              version="0.7.21">
        <doc xml:space="preserve">This channel's associated identifier, or the empty string if no identifier
or unknown.

This is the same as the #TpChannel:identifier property, and isn't guaranteed
to be set until the %TP_CHANNEL_FEATURE_CORE property is ready.

Changed in 0.11.4: as with #TpChannel:identifier, this could
previously either be %NULL or the empty string if there was no suitable
value. It is now non-%NULL in all cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_initiator_contact"
              c:identifier="tp_channel_get_initiator_contact"
              version="0.15.6">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:initiator-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_initiator_handle"
              c:identifier="tp_channel_get_initiator_handle"
              version="0.11.15"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Return the #TpChannel:initiator-handle property</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_channel_get_initiator_contact() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:initiator-handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_initiator_identifier"
              c:identifier="tp_channel_get_initiator_identifier"
              version="0.11.15"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Return the #TpChannel:initiator-identifier property</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_channel_get_initiator_contact() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:initiator-identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_requested"
              c:identifier="tp_channel_get_requested"
              version="0.11.15">
        <doc xml:space="preserve">Return the #TpChannel:requested property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:requested</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_target_contact"
              c:identifier="tp_channel_get_target_contact"
              version="0.15.6">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:target-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_dup_local_pending_contacts"
              c:identifier="tp_channel_group_dup_local_pending_contacts"
              version="0.15.6">
        <doc xml:space="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its local-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of local-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_dup_members_contacts"
              c:identifier="tp_channel_group_dup_members_contacts"
              version="0.15.6">
        <doc xml:space="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_dup_remote_pending_contacts"
              c:identifier="tp_channel_group_dup_remote_pending_contacts"
              version="0.15.6">
        <doc xml:space="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its remote-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of remote-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_get_contact_owner"
              c:identifier="tp_channel_group_get_contact_owner"
              version="0.15.6">
        <doc xml:space="preserve">Synopsis (see below for further explanation):

- if @self is not a group or @contact is not a member of this channel,
  result is undefined;
- if %TP_CHANNEL_FEATURE_CONTACTS has not yet been prepared, result is
  undefined;
- if @self does not have flags that include
  %TP_CHANNEL_GROUP_FLAG_PROPERTIES,
  result is undefined;
- if @contact is channel-specific and its globally valid "owner" is known,
  return that owner;
- if @contact is channel-specific and its globally valid "owner" is unknown,
  return %NULL;
- if @contact is globally valid, return @contact itself

Some channels (those with flags that include
%TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES) have a concept of
"channel-specific contacts". These are contacts that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.

Depending on the protocol and configuration, it might be possible to find
out what globally valid contact (i.e. a contact that you could add to
your contact list) "owns" a channel-specific contact. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.

This is further complicated by the fact that channels with channel-specific
contacts can sometimes have members with globally valid contacts (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the contact representing that JID in the
Group's remote-pending set).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the global contact that owns the given contact,
 or %NULL.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">a contact which is a member of this channel</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_flags"
              c:identifier="tp_channel_group_get_flags"
              version="0.7.12">
        <doc xml:space="preserve">Return the #TpChannel:group-flags property (see the description
of that property for notes on validity).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the group flags, or 0</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_get_handle_owner"
              c:identifier="tp_channel_group_get_handle_owner"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">Synopsis (see below for further explanation):

- if @self is not a group or @handle is not a member of this channel,
  result is undefined;
- if %TP_CHANNEL_FEATURE_GROUP has not yet been prepared, result is
  undefined;
- if @self does not have flags that include
  %TP_CHANNEL_GROUP_FLAG_PROPERTIES,
  result is undefined;
- if @handle is channel-specific and its globally valid "owner" is known,
  return that owner;
- if @handle is channel-specific and its globally valid "owner" is unknown,
  return zero;
- if @handle is globally valid, return @handle itself

Some channels (those with flags that include
%TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES) have a concept of
"channel-specific handles". These are handles that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.

Depending on the protocol and configuration, it might be possible to find
out what globally valid handle (i.e. an identifier that you could add to
your contact list) "owns" a channel-specific handle. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.

This is further complicated by the fact that channels with channel-specific
handles can sometimes have members with globally valid handles (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the handle representing that JID in the
Group's remote-pending set).

This function's result is undefined unless the channel is ready
and its flags include %TP_CHANNEL_GROUP_FLAG_PROPERTIES (an implementation
without extra D-Bus round trips is not possible using the older API).</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_channel_group_get_contact_owner() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the global handle that owns the given handle, or 0</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a handle which is a member of this channel</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending"
              c:identifier="tp_channel_group_get_local_pending"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its local-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of local-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_channel_group_dup_local_pending_contacts()
 instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the local-pending members, or %NULL</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending_contact_info"
              c:identifier="tp_channel_group_get_local_pending_contact_info"
              version="0.15.6">
        <doc xml:space="preserve">If @local_pending is actually a local-pending contact,
write additional information into @actor, @reason and @message and return
%TRUE. The contact and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.

If @local_pending is not the handle of a local-pending contact,
write %NULL into @actor, %TP_CHANNEL_GROUP_CHANGE_REASON_NONE into @reason
and "" into @message, and return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the contact is in fact local-pending</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:space="preserve">the #TpContact of a local-pending contact about whom more
 information is needed</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
          <parameter name="actor"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">either %NULL or a location to
 return the contact who requested the change</doc>
            <type name="Contact" c:type="TpContact**"/>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">either %NULL or a location to return the reason
 for the change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">either %NULL or a location to
 return the
 user-supplied message</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending_info"
              c:identifier="tp_channel_group_get_local_pending_info"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">If @local_pending is actually the handle of a local-pending contact,
write additional information into @actor, @reason and @message and return
%TRUE. The handle and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.

If @local_pending is not the handle of a local-pending contact,
write 0 into @actor, %TP_CHANNEL_GROUP_CHANGE_REASON_NONE into @reason
and "" into @message, and return %FALSE.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_channel_group_get_local_pending_contact_info() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the contact is in fact local-pending</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:space="preserve">the handle of a local-pending contact about whom more
 information is needed</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="actor"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">either %NULL or a location to return the contact
who requested the change</doc>
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">either %NULL or a location to return the reason
for the change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">either %NULL or a location to
return the user-supplied message</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_members"
              c:identifier="tp_channel_group_get_members"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_channel_group_dup_members_contacts()
 instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the members, or %NULL</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_get_remote_pending"
              c:identifier="tp_channel_group_get_remote_pending"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its remote-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of remote-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <doc-deprecated xml:space="preserve">New code should use
 tp_channel_group_dup_remote_pending_contacts() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote-pending members, or %NULL</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_get_self_contact"
              c:identifier="tp_channel_group_get_self_contact"
              version="0.15.6">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:group-self-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="group_get_self_handle"
              c:identifier="tp_channel_group_get_self_handle"
              version="0.7.12"
              deprecated="1">
        <doc xml:space="preserve">Return the #TpChannel:group-self-handle property (see the description
of that property for notes on validity).</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_channel_group_get_self_contact() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handle representing the user, or 0</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_channel_is_ready"
              version="0.7.12"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.17.6">
        <doc xml:space="preserve">Returns the same thing as the #TpChannel:channel-ready property.

New code should use tp_proxy_is_prepared(), which is a more general form of
this method.

For group channels, this method is equivalent to checking for the
combination of %TP_CHANNEL_FEATURE_CORE and %TP_CHANNEL_FEATURE_GROUP; for
non-group channels, it's equivalent to checking for
%TP_CHANNEL_FEATURE_CORE.

One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.</doc>
        <doc-deprecated xml:space="preserve">use tp_proxy_is_prepared() with
 %TP_CHANNEL_FEATURE_CORE</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if introspection has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="join_async"
              c:identifier="tp_channel_join_async"
              version="0.15.5">
        <doc xml:space="preserve">Join channel @self with @message as join message.

When we joined the channel, @callback will be called.
You can then call tp_channel_join_finish() to get the result of
the operation.

Note that unlike tp_channel_leave_async(), %TP_CHANNEL_FEATURE_GROUP feature
must be prepared before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the join message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when we joined the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="join_finish"
              c:identifier="tp_channel_join_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Completes a call to tp_channel_join_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel was successfully joined; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_channel_join_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_async"
              c:identifier="tp_channel_leave_async"
              version="0.13.10">
        <doc xml:space="preserve">Leave channel @self with @reason as reason and @message as leave message.
If @self doesn't implement #TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP or if
for any reason we can't properly leave the channel, we close it.

When we left the channel, @callback will be called.
You can then call tp_channel_leave_finish() to get the result of
the operation.

Note that unlike tp_channel_join_async(), %TP_CHANNEL_FEATURE_GROUP feature
does not have to be prepared and will be prepared for you. But this is a
deprecated behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the leave reason</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the leave message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when we left the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_finish"
              c:identifier="tp_channel_leave_finish"
              version="0.13.10"
              throws="1">
        <doc xml:space="preserve">Completes a call to tp_channel_leave_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel has been left; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_channel_leave_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="password_needed"
              c:identifier="tp_channel_password_needed"
              version="0.15.2">
        <doc xml:space="preserve">Return the #TpChannel:password-needed property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannel:password-needed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="provide_password_async"
              c:identifier="tp_channel_provide_password_async"
              version="0.15.2">
        <doc xml:space="preserve">Provide @password so that @self can be joined.
This function must be called with the correct password in order for
channel joining to proceed if the TpChannel:password-needed property
is set.

Once the password has been provided, @callback will be
called. You can then call tp_channel_provide_password_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when @password has been provided</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_password_finish"
              c:identifier="tp_channel_provide_password_finish"
              version="0.15.2"
              throws="1">
        <doc xml:space="preserve">Completes a call to tp_channel_provide_password_async().
If the password was rejected, the operation
fails with #TP_ERROR_AUTHENTICATION_FAILED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the password has been provided and accepted,
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for
 tp_channel_provide_password_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_until_ready"
              c:identifier="tp_channel_run_until_ready"
              version="0.7.1"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.11.0">
        <doc xml:space="preserve">If @self is ready for use (introspection has finished, etc.), return
immediately. Otherwise, re-enter the main loop until the channel either
becomes invalid or becomes ready for use, or until the main loop stored
via @loop is cancelled.</doc>
        <doc-deprecated xml:space="preserve">Use tp_proxy_prepare_async() and re-enter the main
 loop yourself, or restructure your program in such a way as to avoid
 re-entering the main loop.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel has been introspected and is ready for use,
 %FALSE if the channel has become invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, a #GMainLoop is placed here while it is being run
 (so calling code can call g_main_loop_quit() to abort), and %NULL is
 placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel-properties"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The immutable D-Bus properties of this channel, represented by a
#GHashTable where the keys are D-Bus interface name + "." + property
name, and the values are #GValue instances.

Read-only except during construction. If this is not provided
during construction, a reasonable (but possibly incomplete) version
will be made up from the values of individual properties; reading this
property repeatedly may yield progressively more complete values until
tp_proxy_prepare_async() has finished preparing %TP_CHANNEL_FEATURE_CORE.</doc>
        <type/>
      </property>
      <property name="channel-ready"
                deprecated="1"
                deprecated-version="0.17.6"
                transfer-ownership="none">
        <doc xml:space="preserve">Initially %FALSE; changes to %TRUE when tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE, and if the channel is a
group, %TP_CHANNEL_FEATURE_GROUP.

This is a less general form of tp_proxy_is_prepared(), which should be
used in new code.

One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.

Change notification is via notify::channel-ready.</doc>
        <doc-deprecated xml:space="preserve">use tp_proxy_is_prepared() with
 %TP_CHANNEL_FEATURE_CORE for checks, or tp_proxy_prepare_async() for
 notification</doc-deprecated>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpConnection to which this #TpChannel belongs. Used for e.g.
handle manipulation.</doc>
        <type name="Connection"/>
      </property>
      <property name="group-flags" version="0.7.12" transfer-ownership="none">
        <doc xml:space="preserve">If the %TP_CHANNEL_FEATURE_GROUP feature has been prepared successfully,
#TpChannelGroupFlags indicating the capabilities and behaviour of that
group.

Otherwise, this may be 0.

Change notification is via notify::group-flags or
TpChannel::group-flags-changed.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="group-self-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:space="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_CONTACTS has been
prepared, and the user is a member of the group, the #TpContact
representing them in this group.

Otherwise, the result may be either a contact representing the user,
or %NULL.

Change notification is via notify::group-self-contact.</doc>
        <type name="Contact"/>
      </property>
      <property name="group-self-handle"
                version="0.7.12"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_GROUP has been
prepared, and the user is a member of the group, the #TpHandle
representing them in this group.

Otherwise, the result may be either a handle representing the user, or 0.

Change notification is via notify::group-self-handle.</doc>
        <doc-deprecated xml:space="preserve">Use #TpChannel:group-self-contact instead.</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:space="preserve">This channel's associated identifier, or the empty string if it has
handle type %TP_HANDLE_TYPE_NONE.

For channels where #TpChannelIface:handle is non-zero, this is the result
of inspecting #TpChannelIface:handle.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.

Changed in 0.11.4: this property is never %NULL. Previously,
it was %NULL before an identifier was known, or when a channel
with no TargetID D-Bus property had TargetHandleType %TP_HANDLE_TYPE_NONE.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="initiator-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpContact of the initiator of this channel, or %NULL if there is no
particular initiator.

If the channel was initiated by a remote contact, this represents
that contact, and #TpChannel:requested will be %FALSE. For instance,
for an incoming call this property indicates the caller, and for a
chatroom invitation this property indicates who sent the invitation.

If the channel was requested by the local user, #TpChannel:requested
will be %TRUE, and this property may be the #TpChannel:group-self-contact
or #TpConnection:self-contact.

If the channel appeared for some other reason (for instance as a
side-effect of connecting to the server), this property may be %NULL.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
%NULL.</doc>
        <type name="Contact"/>
      </property>
      <property name="initiator-handle"
                version="0.11.15"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The %TP_HANDLE_TYPE_CONTACT #TpHandle of the initiator of this
channel, or 0 if there is no particular initiator.

If the channel was initiated by a remote contact, this handle represents
that contact, and #TpChannel:requested will be %FALSE. For instance,
for an incoming call this property indicates the caller, and for a
chatroom invitation this property indicates who sent the invitation.

If the channel was requested by the local user, #TpChannel:requested
will be %TRUE, and this property may be the #TpChannel:group-self-handle
or #TpConnection:self-handle.

If the channel appeared for some other reason (for instance as a
side-effect of connecting to the server), this property may be 0.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be 0.</doc>
        <doc-deprecated xml:space="preserve">Use #TpChannel:initiator-contact instead.</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="initiator-identifier"
                version="0.11.15"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If #TpChannel:initiator-handle is 0, this will always be "".
Otherwise, this will be the #TpContact:identifier of the contact
with that handle.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.</doc>
        <doc-deprecated xml:space="preserve">Use #TpChannel:initiator-contact instead.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-needed"
                version="0.15.2"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, tp_channel_provide_password_async() has to be called
to be able to join the channel.

This is not guaranteed to be meaningful until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_PASSWORD; until then, it may return
%FALSE even if the channel is actually protected by a password.
Preparing %TP_CHANNEL_FEATURE_PASSWORD also ensures that the
notify::password-needed signal will be fired when this property changes.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="requested" version="0.11.15" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if this channel was created in response to a local request, such
as a call to tp_account_channel_request_create_channel_async(). %FALSE
if this channel was initiated by a remote contact
(the #TpChannel:initiator-handle), or if it appeared as a side-effect
of some other action.

For instance, this is %FALSE on incoming calls and file transfers,
remotely-initiated 1-1 text conversations, and invitations to chatrooms,
and %TRUE on outgoing calls and file transfers, locally-initiated 1-1
text conversations, and chatrooms joined by local user action.

This is not guaranteed to be meaningful until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may return
%FALSE even if the channel was actually requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="target-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:space="preserve">If this channel is for communication with a single contact (that is,
#TpChannelIface:handle-type is %TP_HANDLE_TYPE_CONTACT), then a #TpContact
representing the remote contact. For chat rooms, contact search channels and
other channels without a single remote contact, %NULL.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
%NULL.</doc>
        <type name="Contact"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelPrivate" c:type="TpChannelPrivate*"/>
      </field>
      <glib:signal name="chat-state-changed"
                   when="last"
                   detailed="1"
                   version="0.11.3"
                   deprecated="1">
        <doc xml:space="preserve">Emitted when a contact's chat state changes after tp_proxy_prepare_async()
has finished preparing the feature %TP_CHANNEL_FEATURE_CHAT_STATES.</doc>
        <doc-deprecated xml:space="preserve">Use #TpTextChannel::contact-chat-state-changed instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">a contact handle for the local user or another contact</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new #TpChannelChatState for the contact</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-contacts-changed"
                   when="last"
                   detailed="1"
                   version="0.15.6">
        <doc xml:space="preserve">Emitted when the group members change in a Group channel.

This is not guaranteed to be emitted until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
omitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact containing the full members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact containing the members (full, local-pending or
 remote-pending) removed</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact containing the local-pending members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact containing the remote-pending members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact for the "actor" handle in @details</doc>
            <type name="Contact"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GHashTable mapping (gchar *) to #GValue containing details
 about the change, as described in the specification of the
 MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-flags-changed"
                   when="last"
                   detailed="1"
                   version="0.7.12">
        <doc xml:space="preserve">Emitted when the #TpChannel:group-flags property changes while the
channel is ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">#TpChannelGroupFlags which are newly set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">#TpChannelGroupFlags which are no longer set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed"
                   when="last"
                   detailed="1"
                   version="0.7.12"
                   introspectable="0"
                   deprecated="1">
        <doc xml:space="preserve">Emitted when the group members change in a Group channel that is ready.</doc>
        <doc-deprecated xml:space="preserve">Use #TpChannel::group-contacts-changed instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">an optional textual message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of #guint containing the full members added</doc>
            <type/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of #guint containing the members (full,
 local-pending or remote-pending) removed</doc>
            <type/>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of #guint containing the local-pending
 members added</doc>
            <type/>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of #guint containing the remote-pending
 members added</doc>
            <type/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">the #TpHandle of the contact causing the change, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the reason for the change as a #TpChannelGroupChangeReason</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed-detailed"
                   when="last"
                   detailed="1"
                   version="0.7.21"
                   deprecated="1">
        <doc xml:space="preserve">Emitted when the group members change in a Group channel that is ready.
Contains a superset of the information in the
TpChannel::group-members-changed signal, and is emitted at the same time;
applications can connect to this signal and ignore the other.</doc>
        <doc-deprecated xml:space="preserve">Use #TpChannel::group-contacts-changed instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of #guint
 containing the full members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of #guint
 containing the members (full, local-pending or remote-pending) removed</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of
 #guint containing the local-pending members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:space="preserve">a #GArray of
 #guint containing the remote-pending members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GHashTable mapping (gchar *) to #GValue containing details
 about the change, as described in the specification of the
 MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ChannelCallStateFlags" c:type="TpChannelCallStateFlags">
      <doc xml:space="preserve">&lt;![CDATA[         A set of flags representing call states.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="ringing"
              value="1"
              c:identifier="TP_CHANNEL_CALL_STATE_RINGING">
        <doc xml:space="preserve">&lt;![CDATA[           The contact has been alerted about the call but has not responded           (e.g. 180 Ringing in SIP).         ]]&gt;</doc>
      </member>
      <member name="queued"
              value="2"
              c:identifier="TP_CHANNEL_CALL_STATE_QUEUED">
        <doc xml:space="preserve">&lt;![CDATA[           The contact is temporarily unavailable, and the call has been placed           in a queue (e.g. 182 Queued in SIP, or call-waiting in telephony).         ]]&gt;</doc>
      </member>
      <member name="held" value="4" c:identifier="TP_CHANNEL_CALL_STATE_HELD">
        <doc xml:space="preserve">&lt;![CDATA[           The contact has placed the call on hold, and will not receive           media from the local user or any other participants until they           unhold the call again.         ]]&gt;</doc>
      </member>
      <member name="forwarded"
              value="8"
              c:identifier="TP_CHANNEL_CALL_STATE_FORWARDED">
        <doc xml:space="preserve">&lt;![CDATA[           The initiator of the call originally called a contact other than the           current recipient of the call, but the call was then forwarded or           diverted.         ]]&gt;</doc>
      </member>
      <member name="in_progress"
              value="16"
              c:identifier="TP_CHANNEL_CALL_STATE_IN_PROGRESS">
        <doc xml:space="preserve">&lt;![CDATA[           Progress has been made in placing the outgoing call, but the           destination contact may not have been made aware of the call yet           (so the Ringing state is not appropriate). This corresponds to SIP's           status code 183 Session Progress, and could be used when the           outgoing call has reached a gateway, for instance.         ]]&gt;</doc>
      </member>
      <member name="conference_host"
              value="32"
              c:identifier="TP_CHANNEL_CALL_STATE_CONFERENCE_HOST">
        <doc xml:space="preserve">&lt;![CDATA[           This contact has merged this call into a conference. Note that GSM           provides a notification when the remote party merges a call into a           conference, but not when it is split out again; thus, this flag can           only indicate that the call has been part of a conference at some           point. If a GSM connection manager receives a notification that a           call has been merged into a conference a second time, it SHOULD           represent this by clearing and immediately re-setting this flag on           the remote contact.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="ChannelChatState" c:type="TpChannelChatState">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="gone" value="0" c:identifier="TP_CHANNEL_CHAT_STATE_GONE">
        <doc xml:space="preserve">&lt;![CDATA[         The contact has effectively ceased participating in the chat.         ]]&gt;</doc>
      </member>
      <member name="inactive"
              value="1"
              c:identifier="TP_CHANNEL_CHAT_STATE_INACTIVE">
        <doc xml:space="preserve">&lt;![CDATA[         The contact has not been active for some time.         ]]&gt;</doc>
      </member>
      <member name="active"
              value="2"
              c:identifier="TP_CHANNEL_CHAT_STATE_ACTIVE">
        <doc xml:space="preserve">&lt;![CDATA[         The contact is actively participating in the chat.         ]]&gt;</doc>
      </member>
      <member name="paused"
              value="3"
              c:identifier="TP_CHANNEL_CHAT_STATE_PAUSED">
        <doc xml:space="preserve">&lt;![CDATA[         The contact has paused composing a message.         ]]&gt;</doc>
      </member>
      <member name="composing"
              value="4"
              c:identifier="TP_CHANNEL_CHAT_STATE_COMPOSING">
        <doc xml:space="preserve">&lt;![CDATA[         The contact is composing a message to be sent to the chat.         ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="ChannelClass"
            c:type="TpChannelClass"
            glib:is-gtype-struct-for="Channel"
            version="0.7.1">
      <doc xml:space="preserve">The class of a #TpChannel. In addition to @parent_class there are four
pointers reserved for possible future use.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent class</doc>
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <enumeration name="ChannelContactSearchState"
                 c:type="TpChannelContactSearchState">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="not_started"
              value="0"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_NOT_STARTED">
        <doc xml:space="preserve">&lt;![CDATA[The search has not started]]&gt;</doc>
      </member>
      <member name="in_progress"
              value="1"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_IN_PROGRESS">
        <doc xml:space="preserve">&lt;![CDATA[The search is in progress]]&gt;</doc>
      </member>
      <member name="more_available"
              value="2"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_MORE_AVAILABLE">
        <doc xml:space="preserve">&lt;![CDATA[The search has paused, but more results can be retrieved           by calling More.]]&gt;</doc>
      </member>
      <member name="completed"
              value="3"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_COMPLETED">
        <doc xml:space="preserve">&lt;![CDATA[The search has been completed]]&gt;</doc>
      </member>
      <member name="failed"
              value="4"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[The search has failed]]&gt;</doc>
      </member>
    </enumeration>
    <class name="ChannelDispatchOperation"
           c:symbol-prefix="channel_dispatch_operation"
           c:type="TpChannelDispatchOperation"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelDispatchOperation"
           glib:get-type="tp_channel_dispatch_operation_get_type"
           glib:type-struct="ChannelDispatchOperationClass">
      <doc xml:space="preserve">One of the channel dispatcher's functions is to offer incoming channels to
Approver clients for approval. An approver should generally ask the user
whether they want to participate in the requested communication channels
(join the chat or chatroom, answer the call, accept the file transfer, or
whatever is appropriate). A collection of channels offered in this way
is represented by a ChannelDispatchOperation object.

If the user wishes to accept the communication channels, the approver
should call tp_cli_channel_dispatch_operation_call_handle_with() to
indicate the user's or approver's preferred handler for the channels (the
empty string indicates no particular preference, and will cause any
suitable handler to be used).

If the user wishes to reject the communication channels, or if the user
accepts the channels and the approver will handle them itself, the approver
should call tp_cli_channel_dispatch_operation_call_claim(). If this method
succeeds, the approver immediately has control over the channels as their
primary handler, and may do anything with them (in particular, it may close
them in whatever way seems most appropriate).

There are various situations in which the channel dispatch operation will
be closed, causing the #TpProxy::invalidated signal to be emitted. If this
happens, the approver should stop prompting the user.

Because all approvers are launched simultaneously, the user might respond
to another approver; if this happens, the #TpProxy::invalidated signal
will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

If a channel closes, the #TpChannelDispatchOperation::channel-lost signal
is emitted. If all channels
close, there is nothing more to dispatch, so the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST. In a high-quality implementation, the
dispatcher should be restarted, at which point it will create new
channel dispatch operations for any undispatched channels, and the approver
will be notified again.

Creating a #TpChannelDispatchOperation directly is deprecated: it
should only be created via a #TpBaseClient.

Since 0.16, #TpChannelDispatchOperation always has a non-%NULL
#TpProxy:factory, which will be propagated to the #TpAccount,
#TpConnection and #TpChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_channel_dispatch_operation_new"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">Convenience function to create a new channel dispatch operation proxy.

The @immutable_properties argument is not yet used.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should get
 #TpChannelDispatchOperation objects from a #TpBaseClient</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an channel dispatch operation proxy, or %NULL if
   @object_path is not syntactically valid or the channel dispatcher is not
   running</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:space="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The non-NULL object path of this channel dispatch operation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">As many as are known of the immutable D-Bus
 properties of this channel dispatch operation, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_channel_dispatch_operation_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_dispatch_operation_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpChannelDispatchOperation have been
set up. This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCH_OPERATION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_account"
              c:identifier="tp_channel_dispatch_operation_borrow_account"
              version="0.11.5"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Returns the #TpAccount of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_channel_dispatch_operation_get_account() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelDispatchOperation:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="borrow_channels"
              c:identifier="tp_channel_dispatch_operation_borrow_channels"
              version="0.11.5"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Returns a #GPtrArray containing the #TpChannel of this
ChannelDispatchOperation.
The returned array and its #TpChannel are only valid while @self is
valid - copy array and reference channels with g_object_ref() if needed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_channel_dispatch_operation_get_channels() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelDispatchOperation:channels</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="borrow_connection"
              c:identifier="tp_channel_dispatch_operation_borrow_connection"
              version="0.11.5"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Returns the #TpConnection of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_channel_dispatch_operation_get_connection() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelDispatchOperation:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="borrow_immutable_properties"
              c:identifier="tp_channel_dispatch_operation_borrow_immutable_properties"
              version="0.11.5"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Returns the immutable D-Bus properties of this channel.
The returned hash table is only valid while @self is valid - reference
it with g_hash_table_ref() if needed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use individual property
 getters like tp_channel_dispatch_operation_get_connection(),
 tp_channel_dispatch_operation_get_account(),
 tp_channel_dispatch_operation_get_channels(), or
 tp_channel_dispatch_operation_get_possible_handlers() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpChannelDispatchOperation:cdo-properties</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="borrow_possible_handlers"
              c:identifier="tp_channel_dispatch_operation_borrow_possible_handlers"
              version="0.11.5"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Returns a #GStrv containing the possible handlers of this
ChannelDispatchOperation.
The returned array and its strings are only valid while @self is
valid - copy it with g_strdupv if needed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_channel_dispatch_operation_get_possible_handlers() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpChannelDispatchOperation:possible-handlers</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="claim_async"
              c:identifier="tp_channel_dispatch_operation_claim_async"
              version="0.11.5"
              deprecated="1">
        <doc xml:space="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.0. Use
tp_channel_dispatch_operation_claim_with_async()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_finish"
              c:identifier="tp_channel_dispatch_operation_claim_finish"
              version="0.11.5"
              deprecated="1"
              throws="1">
        <doc xml:space="preserve">Finishes an async call to Claim().</doc>
        <doc-deprecated xml:space="preserve">since 0.15.0. Use
tp_channel_dispatch_operation_claim_with_finish()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_with_async"
              c:identifier="tp_channel_dispatch_operation_claim_with_async"
              version="0.15.0">
        <doc xml:space="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.

This is an improved version of tp_channel_dispatch_operation_claim_async()
as it tells @client about the new channels being handled.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the #TpBaseClient claiming @self</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_with_finish"
              c:identifier="tp_channel_dispatch_operation_claim_with_finish"
              version="0.15.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async call to Claim() initiated using
tp_channel_dispatch_operation_claim_with_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_channels_async"
              c:identifier="tp_channel_dispatch_operation_close_channels_async"
              version="0.15.1">
        <doc xml:space="preserve">Called by an approver to claim channels and close them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_close_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_channels_finish"
              c:identifier="tp_channel_dispatch_operation_close_channels_finish"
              version="0.15.1"
              throws="1">
        <doc xml:space="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_close_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the Claim() call was successful and
Close() has at least been attempted on all the channels, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_channels_async"
              c:identifier="tp_channel_dispatch_operation_destroy_channels_async"
              version="0.15.2">
        <doc xml:space="preserve">Called by an approver to claim channels and destroy them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_destroy_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_channels_finish"
              c:identifier="tp_channel_dispatch_operation_destroy_channels_finish"
              version="0.15.2"
              throws="1">
        <doc xml:space="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_destroy_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the Claim() call was successful and
tp_channel_destroy_async() has at least been attempted on all the
channels, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_channel_dispatch_operation_get_account"
              version="0.19.9"
              introspectable="0">
        <doc xml:space="preserve">Returns the #TpAccount of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelDispatchOperation:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channels"
              c:identifier="tp_channel_dispatch_operation_get_channels"
              version="0.19.9">
        <doc xml:space="preserve">Returns a #GPtrArray containing the #TpChannel of this
ChannelDispatchOperation.
The returned array and its #TpChannel are only valid while @self is
valid - copy array and reference channels with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value
 of #TpChannelDispatchOperation:channels</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Channel"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tp_channel_dispatch_operation_get_connection"
              version="0.19.9"
              introspectable="0">
        <doc xml:space="preserve">Returns the #TpConnection of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelDispatchOperation:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_possible_handlers"
              c:identifier="tp_channel_dispatch_operation_get_possible_handlers"
              version="0.19.9"
              introspectable="0">
        <doc xml:space="preserve">Returns a #GStrv containing the possible handlers of this
ChannelDispatchOperation.
The returned array and its strings are only valid while @self is
valid - copy it with g_strdupv if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpChannelDispatchOperation:possible-handlers</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="handle_with_async"
              c:identifier="tp_channel_dispatch_operation_handle_with_async"
              version="0.11.5">
        <doc xml:space="preserve">Called by an approver to accept a channel bundle and request that the
given handler be used to handle it.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted with the TP_DBUS_ERROR_OBJECT_REMOVED error code.

However, this method may fail because the dispatch has already been
completed and the object has already gone. If this occurs, it indicates
that another approver has asked for the bundle to be handled by a
particular handler. The approver MUST NOT attempt to interact with
the channels further in this case, unless it is separately
invoked as the handler.

Approvers which are also channel handlers SHOULD use
tp_channel_dispatch_operation_claim_async() instead
of tp_channel_dispatch_operation_handle_with_async() to request
that they can handle a channel bundle themselves.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The well-known bus name (starting with
#TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the
channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_finish"
              c:identifier="tp_channel_dispatch_operation_handle_with_finish"
              version="0.11.5"
              throws="1">
        <doc xml:space="preserve">Finishes an async call to HandleWith().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the HandleWith() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_async"
              c:identifier="tp_channel_dispatch_operation_handle_with_time_async"
              version="0.11.7">
        <doc xml:space="preserve">A variant of tp_channel_dispatch_operation_handle_with_async()
allowing the approver to pass an user action time.
This timestamp will be passed to the Handler when HandleChannels is called.

If an X server timestamp for the user action causing this method call is
available, @user_action_time should be this timestamp (for instance, the
result of gdk_event_get_time() if it is not %GDK_CURRENT_TIME). Otherwise, it
may be %TP_USER_ACTION_TIME_NOT_USER_ACTION to behave as if there was no
user action or it happened a long time ago, or
%TP_USER_ACTION_TIME_CURRENT_TIME to have the Handler behave as though the
user action had just happened (resembling, but not numerically equal to,
%GDK_CURRENT_TIME).

This method has been introduced in telepathy-mission-control 5.5.0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The well-known bus name (starting with
#TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the
channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time at which user action occurred, or one of the
 special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_finish"
              c:identifier="tp_channel_dispatch_operation_handle_with_time_finish"
              version="0.11.7"
              throws="1">
        <doc xml:space="preserve">Finishes an async call to HandleWithTime().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the HandleWithTime() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_channels_async"
              c:identifier="tp_channel_dispatch_operation_leave_channels_async"
              version="0.15.2">
        <doc xml:space="preserve">Called by an approver to claim channels and leave them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_leave_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the leave reason</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the leave message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_channels_finish"
              c:identifier="tp_channel_dispatch_operation_leave_channels_finish"
              version="0.15.2"
              throws="1">
        <doc xml:space="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_leave_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the Claim() call was successful and
tp_channel_leave_async() has at least been attempted on all the
channels, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatchOperation</doc>
            <type name="ChannelDispatchOperation"
                  c:type="TpChannelDispatchOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpAccount with which the connection and channels are associated.

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Account"/>
      </property>
      <property name="cdo-properties"
                version="0.11.5"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The immutable D-Bus properties of this ChannelDispatchOperation,
represented by a #GHashTable where the keys are D-Bus
interface name + "." + property name, and the values are #GValue instances.

Read-only except during construction. If this is not provided
during construction, it is not guaranteed to be set until
tp_proxy_prepare_async() has finished preparing
%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing the #TpChannel to be dispatched.

Read-only.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpConnection with which the channels are associated.

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Connection"/>
      </property>
      <property name="possible-handlers"
                version="0.11.5"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GStrv containing the well known bus names (starting
with TP_CLIENT_BUS_NAME_BASE) of the possible Handlers for
the channels

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatchOperationPrivate"
              c:type="TpChannelDispatchOperationPrivate*"/>
      </field>
      <glib:signal name="channel-lost"
                   when="last"
                   detailed="1"
                   version="0.11.5">
        <doc xml:space="preserve">Emitted when a channel has closed before it could be claimed or handled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">the #TpChannel that closed</doc>
            <type name="Channel"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">domain of a #GError indicating why the channel has been closed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">error code of a #GError indicating why the channel has been closed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a message associated with the error</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelDispatchOperationClass"
            c:type="TpChannelDispatchOperationClass"
            glib:is-gtype-struct-for="ChannelDispatchOperation">
      <doc xml:space="preserve">The class of a #TpChannelDispatchOperation.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatchOperationClassPrivate"
              c:type="TpChannelDispatchOperationClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatchOperationClassPrivate"
            c:type="TpChannelDispatchOperationClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelDispatchOperationPrivate"
            c:type="TpChannelDispatchOperationPrivate"
            disguised="1">
    </record>
    <class name="ChannelDispatcher"
           c:symbol-prefix="channel_dispatcher"
           c:type="TpChannelDispatcher"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelDispatcher"
           glib:get-type="tp_channel_dispatcher_get_type"
           glib:type-struct="ChannelDispatcherClass">
      <doc xml:space="preserve">The Channel Dispatcher's main D-Bus API is used to request channels,
which is done by calling tp_cli_channel_dispatcher_call_create_channel() or
tp_cli_channel_dispatcher_call_ensure_channel() as appropriate.

The Telepathy Channel Dispatcher is also responsible for responding to new
channels and launching client processes to handle them. However, clients
that can work with incoming channels do not have to call methods
on the channel dispatcher: instead, they must register with the channel
dispatcher passively, by taking a bus name starting with
%TP_CLIENT_BUS_NAME_BASE and implementing the #TpSvcClient interface.
See the Telepathy D-Bus Interface Specification for details.

This proxy is usable but incomplete: convenience methods will be added in
a later version of telepathy-glib, along with a mechanism similar to
tp_connection_call_when_ready().</doc>
      <constructor name="new" c:identifier="tp_channel_dispatcher_new">
        <doc xml:space="preserve">Convenience function to create a new channel dispatcher proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to a channel dispatcher proxy</doc>
          <type name="ChannelDispatcher" c:type="TpChannelDispatcher*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:space="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_dispatcher_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpChannelDispatcher have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCHER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="present_channel_async"
              c:identifier="tp_channel_dispatcher_present_channel_async"
              version="0.15.0">
        <doc xml:space="preserve">Asynchronously calls PresentChannel on the ChannelDispatcher to ask
to the handler of @channel to re-present it to the user.
You can then call tp_channel_dispatcher_present_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelDispatcher</doc>
            <type name="ChannelDispatcher" c:type="TpChannelDispatcher*"/>
          </instance-parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:space="preserve">the time at which user action occurred,
or #TP_USER_ACTION_TIME_NOT_USER_ACTION if this presentation request is
for some reason not involving user action.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="present_channel_finish"
              c:identifier="tp_channel_dispatcher_present_channel_finish"
              version="0.15.0"
              throws="1">
        <doc xml:space="preserve">Finishes an async channel presentation request started using
tp_channel_dispatcher_present_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call succeeded, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpBaseClient</doc>
            <type name="ChannelDispatcher" c:type="TpChannelDispatcher*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatcherPrivate"
              c:type="TpChannelDispatcherPrivate*"/>
      </field>
    </class>
    <record name="ChannelDispatcherClass"
            c:type="TpChannelDispatcherClass"
            glib:is-gtype-struct-for="ChannelDispatcher">
      <doc xml:space="preserve">The class of a #TpChannelDispatcher.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatcherClassPrivate"
              c:type="TpChannelDispatcherClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatcherClassPrivate"
            c:type="TpChannelDispatcherClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelDispatcherPrivate"
            c:type="TpChannelDispatcherPrivate"
            disguised="1">
    </record>
    <enumeration name="ChannelGroupChangeReason"
                 c:type="TpChannelGroupChangeReason">
      <doc xml:space="preserve">&lt;![CDATA[         The reason for a set of handles to move to one of           Members,           LocalPendingMembers or           RemotePendingMembers, or to be removed           from the group. A client may supply a reason when attempting to           remove members from a group with           RemoveMembersWithReason, and reasons           are supplied by the CM when emitting           MembersChanged and           MembersChangedDetailed. Some reason           codes have different meanings depending on the Actor in a           MembersChanged signal.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           No reason was provided for this change.            In particular, this reason SHOULD be used when representing             users joining a named chatroom in the usual way, users leaving             a chatroom by their own request, and normal termination of a             StreamedMedia call by the remote user.            If the SelfHandle is removed from             a group for this reason and the actor is not the SelfHandle, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Terminated.            If the SelfHandle is removed from a group for this reason and             the actor is also the SelfHandle, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cancelled.         ]]&gt;</doc>
      </member>
      <member name="offline"
              value="1"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE">
        <doc xml:space="preserve">&lt;![CDATA[           The change is due to a user going offline. Also used when             user is already offline, but this wasn't known previously.            If a one-to-one StreamedMedia             call fails because the contact being called is offline, the             connection manager SHOULD indicate this by removing both the             SelfHandle and the other contact's             handle from the Group interface with reason Offline.                         For 1-1 calls, the call terminates as a result of removing the             remote contact, so the SelfHandle should be removed at the same             time as the remote contact and for the same reason.                       If a handle is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Offline.         ]]&gt;</doc>
      </member>
      <member name="kicked"
              value="2"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_KICKED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is due to a kick operation.            If the SelfHandle is removed             from a group for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Channel.Kicked.                    ]]&gt;</doc>
      </member>
      <member name="busy"
              value="3"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BUSY">
        <doc xml:space="preserve">&lt;![CDATA[           The change is due to a busy indication.            If a one-to-one StreamedMedia             call fails because the contact being called is busy, the             connection manager SHOULD indicate this by removing both the             SelfHandle and the other contact's             handle from the Group interface with reason Busy.                         For 1-1 calls, the call terminates as a result of removing the             remote contact, so the SelfHandle should be removed at the same             time as the remote contact and for the same reason.                       If the SelfHandle is removed             from a group for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Busy.                    ]]&gt;</doc>
      </member>
      <member name="invited"
              value="4"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVITED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is due to an invitation. This reason SHOULD only be used           when contacts are added to the remote-pending set (to indicate that           the contact has been invited) or to the members (to indicate that           the contact has accepted the invitation).                         Otherwise, what would it mean?                    ]]&gt;</doc>
      </member>
      <member name="banned"
              value="5"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BANNED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is due to a kick+ban operation.            If the SelfHandle is removed             from a group for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Channel.Banned.                    ]]&gt;</doc>
      </member>
      <member name="error"
              value="6"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[             The change is due to an error occurring.         ]]&gt;</doc>
      </member>
      <member name="invalid_contact"
              value="7"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT">
        <doc xml:space="preserve">&lt;![CDATA[           The change is because the requested contact does not exist.            For instance, if the user invites a nonexistent contact to a             chatroom or attempts to call a nonexistent contact, this could             be indicated by the CM adding that contact's handle to             remote-pending for reason None or Invited, then removing it for             reason Invalid_Contact. In the case of a 1-1 StreamedMedia             call, the CM SHOULD remove the self handle from the Group             in the same signal.                         For 1-1 calls, the call terminates as a result of removing the             remote contact, so the SelfHandle should be removed at the same             time as the remote contact and for the same reason.                       If a contact is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.DoesNotExist.                    ]]&gt;</doc>
      </member>
      <member name="no_answer"
              value="8"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER">
        <doc xml:space="preserve">&lt;![CDATA[           The change is because the requested contact did not respond.            If a one-to-one StreamedMedia             call fails because the contact being called did not respond, or the             local user did not respond to an incoming call, the             connection manager SHOULD indicate this by removing both the             SelfHandle and the other contact's             handle from the Group interface with reason No_Answer.                         Documenting existing practice.                       If a contact is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.NoAnswer.                    ]]&gt;</doc>
      </member>
      <member name="renamed"
              value="9"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is because a contact's unique identifier changed.           There must be exactly one handle in the removed set and exactly           one handle in one of the added sets. The Renamed           signal on the           Renaming           interface will have been emitted for the same handles,           shortly before this MembersChanged signal is emitted.         ]]&gt;</doc>
      </member>
      <member name="permission_denied"
              value="10"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is because there was no permission to contact the             requested handle.            If a contact is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.PermissionDenied.                    ]]&gt;</doc>
      </member>
      <member name="separated"
              value="11"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED">
        <doc xml:space="preserve">&lt;![CDATA[           If members are removed with this reason code, the change is             because the group has split into unconnected parts which can only             communicate within themselves (e.g. netsplits on IRC use this             reason code).                                   If members are added with this reason code, the change is because             unconnected parts of the group have rejoined. If this channel             carries messages (e.g. Text             or Tubes             channels) applications must             assume that the contacts being added are likely to have missed some             messages as a result of the separation, and that the contacts             in the group are likely to have missed some messages from the             contacts being added.                      Note that from the added contacts' perspective, they have been             in the group all along, and the contacts we indicate to be in             the group (including the local user) have just rejoined             the group with reason Separated. Application protocols in Tubes             should be prepared to cope with this situation.                       The SelfHandle SHOULD NOT be             removed from channels with this reason.         ]]&gt;</doc>
      </member>
    </enumeration>
    <bitfield name="ChannelGroupFlags" c:type="TpChannelGroupFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="can_add"
              value="1"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_ADD">
        <doc xml:space="preserve">&lt;![CDATA[             The AddMembers method can be used to             add or invite members who are             not already in the local pending list (which is always valid).         ]]&gt;</doc>
      </member>
      <member name="can_remove"
              value="2"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_REMOVE">
        <doc xml:space="preserve">&lt;![CDATA[             The RemoveMembers method can be used             to remove channel members             (removing those on the pending local list is always valid).         ]]&gt;</doc>
      </member>
      <member name="can_rescind"
              value="4"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_RESCIND">
        <doc xml:space="preserve">&lt;![CDATA[             The RemoveMembers method can be used             on people on the remote             pending list.         ]]&gt;</doc>
      </member>
      <member name="message_add"
              value="8"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD">
        <doc xml:space="preserve">&lt;![CDATA[             A message may be sent to the server when calling             AddMembers on             contacts who are not currently pending members.         ]]&gt;</doc>
      </member>
      <member name="message_remove"
              value="16"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE">
        <doc xml:space="preserve">&lt;![CDATA[             A message may be sent to the server when calling             RemoveMembers on             contacts who are currently channel members.         ]]&gt;</doc>
      </member>
      <member name="message_accept"
              value="32"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT">
        <doc xml:space="preserve">&lt;![CDATA[             A message may be sent to the server when calling             AddMembers on             contacts who are locally pending.         ]]&gt;</doc>
      </member>
      <member name="message_reject"
              value="64"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT">
        <doc xml:space="preserve">&lt;![CDATA[             A message may be sent to the server when calling             RemoveMembers on             contacts who are locally pending.         ]]&gt;</doc>
      </member>
      <member name="message_rescind"
              value="128"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND">
        <doc xml:space="preserve">&lt;![CDATA[             A message may be sent to the server when calling             RemoveMembers on             contacts who are remote pending.         ]]&gt;</doc>
      </member>
      <member name="channel_specific_handles"
              value="256"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES">
        <doc xml:space="preserve">&lt;![CDATA[                        The members of this group have handles which are specific to             this channel, and are not valid as general-purpose handles on             the connection. Depending on the channel, it may be possible to             check the HandleOwners property or             call GetHandleOwners to find the             owners of these handles, which should be done if you wish to (e.g.)             subscribe to the contact's presence.                                    Connection managers must ensure that any given handle is not             simultaneously a general-purpose handle and a channel-specific             handle.                    ]]&gt;</doc>
      </member>
      <member name="only_one_group"
              value="512"
              c:identifier="TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP">
        <doc xml:space="preserve">&lt;![CDATA[             Placing a contact in multiple groups of this type is not allowed             and will raise NotAvailable (on services where contacts may only             be in one user-defined group, user-defined groups will have             this flag).         ]]&gt;</doc>
      </member>
      <member name="handle_owners_not_available"
              value="1024"
              c:identifier="TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE">
        <doc xml:space="preserve">&lt;![CDATA[           In rooms with channel specific handles (ie Channel_Specific_Handles           flag is set), this flag indicates that no handle owners are           available, apart from the owner of the           SelfHandle.                         This used to be an important optimization to avoid repeated             GetHandleOwners calls, before we introduced the             HandleOwners property and             HandleOwnersChanged signal.                    ]]&gt;</doc>
      </member>
      <member name="properties"
              value="2048"
              c:identifier="TP_CHANNEL_GROUP_FLAG_PROPERTIES">
        <doc xml:space="preserve">&lt;![CDATA[           This flag indicates that all the properties introduced in           specification 0.17.6 are fully supported.         ]]&gt;</doc>
      </member>
      <member name="members_changed_detailed"
              value="4096"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED">
        <doc xml:space="preserve">&lt;![CDATA[           Indicates that MembersChangedDetailed           will be emitted for changes to this group's members in addition to           MembersChanged.           Clients can then connect to the former and ignore emission of the           latter. This flag's state MUST NOT change over the lifetime of a           channel.                         If it were allowed to change, client bindings would have to always             connect to MembersChanged just in case the flag ever went away (and             generally be unnecessarily complicated), which would mostly negate             the point of having this flag in the first place.                    ]]&gt;</doc>
      </member>
      <member name="message_depart"
              value="8192"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART">
        <doc xml:space="preserve">&lt;![CDATA[           A message may be sent to the server when calling           RemoveMembers on           the SelfHandle.                         This would be set for XMPP Multi-User Chat or IRC channels,             but not for a typical implementation of streamed media calls.                    ]]&gt;</doc>
      </member>
    </bitfield>
    <record name="ChannelManagerIter"
            c:type="TpChannelManagerIter"
            version="0.7.15"
            introspectable="0">
      <doc xml:space="preserve">An iterator over the #TpChannelManager objects known to a #TpBaseConnection.
It has no public fields.

Use tp_base_connection_channel_manager_iter_init() to start iteration and
tp_base_connection_channel_manager_iter_next() to continue.</doc>
      <field name="self" readable="0" private="1">
        <type name="BaseConnection" c:type="TpBaseConnection*"/>
      </field>
      <field name="index" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_future" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ChannelMediaCapabilities"
              c:type="TpChannelMediaCapabilities">
      <doc xml:space="preserve">&lt;![CDATA[         The channel-type-specific capability flags used for         Channel.Type.StreamedMedia in the Connection.Interface.Capabilities         interface. See the InitialAudio         property for details of the mechanisms that will replace this.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="audio"
              value="1"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_AUDIO">
        <doc xml:space="preserve">&lt;![CDATA[           The handle is capable of using audio streams within a media channel.         ]]&gt;</doc>
      </member>
      <member name="video"
              value="2"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_VIDEO">
        <doc xml:space="preserve">&lt;![CDATA[           The handle is capable of using video streams within a media channel.         ]]&gt;</doc>
      </member>
      <member name="nat_traversal_stun"
              value="4"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN">
        <doc xml:space="preserve">&lt;![CDATA[           The handle is capable of performing STUN to traverse NATs.         ]]&gt;</doc>
      </member>
      <member name="nat_traversal_gtalk_p2p"
              value="8"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P">
        <doc xml:space="preserve">&lt;![CDATA[           The handle is capable of establishing Google Talk peer-to-peer           connections (as implemented in libjingle 0.3) to traverse NATs.         ]]&gt;</doc>
      </member>
      <member name="nat_traversal_ice_udp"
              value="16"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP">
        <doc xml:space="preserve">&lt;![CDATA[           The handle is capable of establishing ICE UDP peer-to-peer           connections (as defined by the IETF MMUSIC working group) to traverse           NATs.         ]]&gt;</doc>
      </member>
      <member name="immutable_streams"
              value="32"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS">
        <doc xml:space="preserve">&lt;![CDATA[           Channels whose target handle is this contact will have           ImmutableStreams = True.         ]]&gt;</doc>
      </member>
    </bitfield>
    <bitfield name="ChannelPasswordFlags" c:type="TpChannelPasswordFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="provide"
              value="8"
              c:identifier="TP_CHANNEL_PASSWORD_FLAG_PROVIDE">
        <doc xml:space="preserve">&lt;![CDATA[           The ProvidePassword method must be           called now for the user to join the channel         ]]&gt;</doc>
      </member>
      <member name="hint"
              value="4"
              c:identifier="TP_CHANNEL_PASSWORD_FLAG_HINT">
        <doc xml:space="preserve">&lt;![CDATA[           The RoomConfig1.PasswordHint           contains a hint for the password.         ]]&gt;</doc>
      </member>
    </bitfield>
    <record name="ChannelPrivate" c:type="TpChannelPrivate" disguised="1">
    </record>
    <class name="ChannelRequest"
           c:symbol-prefix="channel_request"
           c:type="TpChannelRequest"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelRequest"
           glib:get-type="tp_channel_request_get_type"
           glib:type-struct="ChannelRequestClass">
      <doc xml:space="preserve">Requesting a channel from the channel dispatcher can take some time, so an
object is created in the channel dispatcher to represent each request. This
proxy represents one of those objects.

Any client can call tp_cli_channel_request_call_cancel() at any time to
attempt to cancel the request.

On success, the #TpChannelRequest::succeeded signal will be emitted.
Immediately after that, the #TpProxy::invalidated signal will be emitted,
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED (this is not an error condition, it merely
indicates that the channel request no longer exists).

On failure, the #TpProxy::invalidated signal will be emitted with some
other suitable error, usually from the %TP_ERROR domain.

If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST.

Creating a #TpChannelRequest directly is deprecated: it
should only be created via a #TpAccountChannelRequest
or a #TpBaseClient.

Since 0.16, #TpChannelRequest always has a non-%NULL #TpProxy:factory,
and its #TpProxy:factory will be propagated to the #TpAccount,
#TpConnection and #TpChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_channel_request_new"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">Convenience function to create a new channel request proxy.

If the channel request was newly created, the client making the request
is responsible for calling tp_cli_channel_request_call_proceed() when it
is ready for the channel request to proceed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should get #TpChannelRequest objects
 from a #TpBaseClient</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to an channel request proxy, or %NULL if
   @object_path is not syntactically valid or the channel dispatcher is
   not running</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:space="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The non-NULL object path of this channel request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">As many as are known of the immutable D-Bus
 properties of this channel request, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_request_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpChannelRequest have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_REQUEST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="dup_hints"
              c:identifier="tp_channel_request_dup_hints"
              version="0.19.10">
        <doc xml:space="preserve">Return the #TpChannelRequest:hints-vardict property</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of #TpChannelRequest:hints-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelRequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_immutable_properties"
              c:identifier="tp_channel_request_dup_immutable_properties"
              version="0.19.10">
        <doc xml:space="preserve">Return the #TpChannelRequest:immutable-properties-vardict property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of
#TpChannelRequest:immutable-properties-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelRequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_channel_request_get_account"
              version="0.15.3">
        <doc xml:space="preserve">Return the value of the #TpChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelRequest:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #tpchannelrequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hints"
              c:identifier="tp_channel_request_get_hints"
              version="0.13.14">
        <doc xml:space="preserve">Return the #TpChannelRequest:hints property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpChannelRequest:hints</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelRequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_immutable_properties"
              c:identifier="tp_channel_request_get_immutable_properties"
              version="0.13.14">
        <doc xml:space="preserve">Return the #TpChannelRequest:immutable-properties construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpChannelRequest:immutable-properties</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelRequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_preferred_handler"
              c:identifier="tp_channel_request_get_preferred_handler"
              version="0.15.3">
        <doc xml:space="preserve">return the #TpChannelRequest:preferred-handler construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelRequest:preferred-handler</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #tpchannelrequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_action_time"
              c:identifier="tp_channel_request_get_user_action_time"
              version="0.15.3">
        <doc xml:space="preserve">return the #TpChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpChannelRequest:user-action-time</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #tpchannelrequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_channel_request_set_channel_factory"
              version="0.13.14"
              deprecated="1">
        <doc xml:space="preserve">Change the value of the #TpChannelRequest:channel-factory property.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.5. Use #TpProxy:factory instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelRequest</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest*"/>
          </instance-parameter>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">an object implementing the #TpClientChannelFactoryInterface
interface</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account" version="0.15.3" transfer-ownership="none">
        <doc xml:space="preserve">The #TpAccount on which this request was made, not guaranteed
to be prepared.

Read-only.</doc>
        <type name="Account"/>
      </property>
      <property name="channel-factory"
                version="0.13.14"
                deprecated="1"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The object implementing the #TpClientChannelFactoryInterface interface
that will be used to create channel proxies when the
#TpChannelRequest::succeeded-with-channel signal is fired.
This property can be changed using
tp_channel_request_set_channel_factory().

If no channel factory is specified then #TpAutomaticProxyFactory is used.</doc>
        <doc-deprecated xml:space="preserve">since 0.15.5. Use #TpProxy:factory instead.</doc-deprecated>
        <type name="GObject.Object"/>
      </property>
      <property name="hints"
                version="0.13.14"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TP_HASH_TYPE_STRING_VARIANT_MAP of metadata provided by
the channel requester; or %NULL if #TpChannelRequest:immutable-properties
is not defined or if no hints has been defined.

Read-only.</doc>
        <type/>
      </property>
      <property name="hints-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:space="preserve">A %G_VARIANT_TYPE_VARDICT of metadata provided by
the channel requester; or %NULL if #TpChannelRequest:immutable-properties
is not defined or if no hints have been defined.

Read-only.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="immutable-properties"
                version="0.13.14"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The immutable D-Bus properties of this channel request, represented by a
#GHashTable where the keys are D-Bus interface name + "." + property
name, and the values are #GValue instances.

Note that this property is set only if the immutable properties have been
set during the construction of the #TpChannelRequest.

Read-only except during construction.</doc>
        <type/>
      </property>
      <property name="immutable-properties-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:space="preserve">The immutable D-Bus properties of this channel request, represented by a
%G_VARIANT_TYPE_VARDICT where the keys are
D-Bus interface name + "." + property name.

Note that this property is set only if the immutable properties have been
set during the construction of the #TpChannelRequest.

Read-only except during construction.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="preferred-handler"
                version="0.15.3"
                transfer-ownership="none">
        <doc xml:space="preserve">Either the well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE)
of the preferred handler for this channel request,
or %NULL to indicate that any handler would be acceptable.

Read-only.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="user-action-time"
                version="0.15.3"
                transfer-ownership="none">
        <doc xml:space="preserve">The time at which user action occurred, or
#TP_USER_ACTION_TIME_NOT_USER_ACTION if this channel request is
for some reason not involving user action.

Read-only.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelRequestPrivate" c:type="TpChannelRequestPrivate*"/>
      </field>
      <glib:signal name="succeeded" when="last" detailed="1" deprecated="1">
        <doc xml:space="preserve">Emitted when the channel request succeeds.</doc>
        <doc-deprecated xml:space="preserve">since 0.13.14. Use
#TpChannelRequest::succeeded-with-channel, which provides the resulting
channel, instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="succeeded-with-channel"
                   when="last"
                   detailed="1"
                   version="0.13.14">
        <doc xml:space="preserve">Emitted when the channel request succeeds.

With telepathy-mission-control version 5.7.1 and earlier, @connection and
@channel will be %NULL. When using newer versions, they will be correctly
set to the newly-created channel, and the connection which owns it.

The #TpChannel is created using #TpChannelRequest:channel-factory or
#TpProxy:factory but the features of the factory are NOT prepared.
It's up to the user to prepare the features returned by
tp_simple_client_factory_dup_channel_features() himself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #TpConnection of @channel, or %NULL</doc>
            <type name="Connection"/>
          </parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">the #TpChannel created, or %NULL</doc>
            <type name="Channel"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelRequestClass"
            c:type="TpChannelRequestClass"
            glib:is-gtype-struct-for="ChannelRequest">
      <doc xml:space="preserve">The class of a #TpChannelRequest.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelRequestClassPrivate"
              c:type="TpChannelRequestClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelRequestClassPrivate"
            c:type="TpChannelRequestClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelRequestPrivate"
            c:type="TpChannelRequestPrivate"
            disguised="1">
    </record>
    <bitfield name="ChannelTextMessageFlags"
              c:type="TpChannelTextMessageFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="truncated"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED">
        <doc xml:space="preserve">&lt;![CDATA[         The incoming message was truncated to a shorter length by the         server or the connection manager.         ]]&gt;</doc>
      </member>
      <member name="non_text_content"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT">
        <doc xml:space="preserve">&lt;![CDATA[           The incoming message contained non-text content which cannot be             represented by this interface, but has been signalled             in the Messages             interface.            Connection managers SHOULD only set this flag if the non-text             content appears to be relatively significant (exactly how             significant is up to the implementor). The intention is that             if this flag is set, clients using this interface SHOULD inform             the user that part of the message was not understood.         ]]&gt;</doc>
      </member>
      <member name="scrollback"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK">
        <doc xml:space="preserve">&lt;![CDATA[           The incoming message was part of a replay of message history.                         In XMPP multi-user chat, a few past messages are replayed               when you join a chatroom. A sufficiently capable IRC connection               manager could also set this flag on historical messages when               connected to a proxy like bip or irssi-proxy. The existence               of this flag allows loggers and UIs to use better heuristics               when eliminating duplicates (a simple implementation made               possible by this flag would be to avoid logging scrollback               at all).                    ]]&gt;</doc>
      </member>
      <member name="rescued"
              value="8"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED">
        <doc xml:space="preserve">&lt;![CDATA[           The incoming message has been seen in a previous channel during             the lifetime of the Connection, but             had not been acknowledged             when that channel closed, causing an identical channel (the             channel in which the message now appears) to open.                         This means that a logger (which should already have seen the               message in the previous channel) is able to recognise and ignore               these replayed messages.                    ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="ChannelTextMessageType"
                 c:type="TpChannelTextMessageType">
      <doc xml:space="preserve">&lt;![CDATA[         The type of message.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="normal"
              value="0"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL">
        <doc xml:space="preserve">&lt;![CDATA[         An ordinary chat message. Unknown types SHOULD be treated like this.         ]]&gt;</doc>
      </member>
      <member name="action"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION">
        <doc xml:space="preserve">&lt;![CDATA[         An action which might be presented to the user as         "* &lt;sender&gt; &lt;action&gt;", such as an IRC CTCP         ACTION (typically selected by the "/me" command). For example, the         text of the message might be "drinks more coffee".         ]]&gt;</doc>
      </member>
      <member name="notice"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE">
        <doc xml:space="preserve">&lt;![CDATA[         A one-off or automated message not necessarily expecting a reply         ]]&gt;</doc>
      </member>
      <member name="auto_reply"
              value="3"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY">
        <doc xml:space="preserve">&lt;![CDATA[         An automatically-generated reply message.         ]]&gt;</doc>
      </member>
      <member name="delivery_report"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT">
        <doc xml:space="preserve">&lt;![CDATA[           A delivery report. This message type MUST NOT appear unless the           channel supports the Messages           interface; see Message_Part for the format that           delivery reports must take.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="ChannelTextSendError" c:type="TpChannelTextSendError">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[         An unknown error occurred         ]]&gt;</doc>
      </member>
      <member name="offline"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE">
        <doc xml:space="preserve">&lt;![CDATA[         The requested contact was offline         ]]&gt;</doc>
      </member>
      <member name="invalid_contact"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT">
        <doc xml:space="preserve">&lt;![CDATA[         The requested contact is not valid         ]]&gt;</doc>
      </member>
      <member name="permission_denied"
              value="3"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED">
        <doc xml:space="preserve">&lt;![CDATA[         The user does not have permission to speak on this channel         ]]&gt;</doc>
      </member>
      <member name="too_long"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG">
        <doc xml:space="preserve">&lt;![CDATA[         The outgoing message was too long and was rejected by the server         ]]&gt;</doc>
      </member>
      <member name="not_implemented"
              value="5"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED">
        <doc xml:space="preserve">&lt;![CDATA[         The channel doesn't support sending text messages to the requested         contact         ]]&gt;</doc>
      </member>
    </enumeration>
    <callback name="ChannelWhenReadyCb"
              c:type="TpChannelWhenReadyCb"
              deprecated="1"
              deprecated-version="0.17.6">
      <doc xml:space="preserve">Signature of a callback passed to tp_channel_call_when_ready(), which
will be called exactly once, when the channel becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">the channel (which may be in the middle of being disposed,
 if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is
 TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL if the channel is ready for use, or the error with which
 it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">whatever was passed to tp_channel_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="ClientChannelFactory"
               c:symbol-prefix="client_channel_factory"
               c:type="TpClientChannelFactory"
               version="0.13.6"
               glib:type-name="TpClientChannelFactory"
               glib:get-type="tp_client_channel_factory_get_type"
               glib:type-struct="ClientChannelFactoryInterface">
      <doc xml:space="preserve">Opaque typedef representing a #GObject that implements
the %TP_TYPE_CLIENT_CHANNEL_FACTORY interface.</doc>
      <virtual-method name="obj_create_channel" introspectable="0" throws="1">
        <return-value>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="obj_dup_channel_features" introspectable="0">
        <return-value>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </instance-parameter>
          <parameter name="channel" transfer-ownership="none">
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_channel"
              c:identifier="tp_client_channel_factory_create_channel"
              version="0.13.2"
              throws="1">
        <doc xml:space="preserve">Function called when a channel need to be created.
Implementation can return a subclass of #TpChannel if they need to.

Changed in 0.13.6: the function's signature was previously wrong;
it expected an object instance as its first parameter, but the type of the
parameter was the type of the interface vtable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client channel factory</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the channel</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:space="preserve">
the immutable properties of the channel</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dup_channel_features"
              c:identifier="tp_client_channel_factory_dup_channel_features"
              version="0.13.3">
        <doc xml:space="preserve">Return a zero terminated #GArray containing the #TpChannel features that
should be prepared on @channel.

Changed in 0.13.6: the function's signature was previously wrong;
it expected an object instance as its first parameter, but the type of the
parameter was the type of the interface vtable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a client channel factory</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </instance-parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ClientChannelFactoryInterface"
            c:type="TpClientChannelFactoryInterface"
            glib:is-gtype-struct-for="ClientChannelFactory"
            version="0.13.2">
      <doc xml:space="preserve">Interface for a channel factory</doc>
      <field name="parent">
        <doc xml:space="preserve">the parent</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="create_channel" introspectable="0">
        <callback name="create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactoryInterface"
                    c:type="TpClientChannelFactoryInterface*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_channel_features" introspectable="0">
        <callback name="dup_channel_features" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactoryInterface"
                    c:type="TpClientChannelFactoryInterface*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="obj_create_channel" introspectable="0">
        <callback name="obj_create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactory"
                    c:type="TpClientChannelFactory*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="obj_dup_channel_features" introspectable="0">
        <callback name="obj_dup_channel_features" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactory"
                    c:type="TpClientChannelFactory*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ClientMessage"
           c:symbol-prefix="client_message"
           c:type="TpClientMessage"
           version="0.13.9"
           parent="Message"
           glib:type-name="TpClientMessage"
           glib:get-type="tp_client_message_get_type"
           glib:type-struct="ClientMessageClass">
      <doc xml:space="preserve">Opaque structure representing a message in the Telepathy messages interface
(client side).</doc>
      <constructor name="new"
                   c:identifier="tp_client_message_new"
                   version="0.13.9">
        <doc xml:space="preserve">A convenient function to create a new #TpClientMessage</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpClientMessage having only
the header part.</doc>
          <type name="Message" c:type="TpMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_text"
                   c:identifier="tp_client_message_new_text"
                   version="0.13.9">
        <doc xml:space="preserve">A convenient function to create a new #TpClientMessage having
'text/plain' as 'content-type', @type as 'message-type' and
@text as 'content'.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpClientMessage</doc>
          <type name="Message" c:type="TpMessage*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of message</doc>
            <type name="ChannelTextMessageType"
                  c:type="TpChannelTextMessageType"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">content of the messsage</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="ClientMessageClass"
            c:type="TpClientMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="ClientMessage">
    </record>
    <bitfield name="ConnMgrParamFlags" c:type="TpConnMgrParamFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="required"
              value="1"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_REQUIRED">
        <doc xml:space="preserve">&lt;![CDATA[           This parameter is required for connecting to the server.         ]]&gt;</doc>
      </member>
      <member name="register"
              value="2"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_REGISTER">
        <doc xml:space="preserve">&lt;![CDATA[           This parameter is required for registering an account on the           server.         ]]&gt;</doc>
      </member>
      <member name="has_default"
              value="4"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT">
        <doc xml:space="preserve">&lt;![CDATA[           This parameter has a default value, which is returned in           GetParameters; not providing this parameter is equivalent to           providing the default.         ]]&gt;</doc>
      </member>
      <member name="secret"
              value="8"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_SECRET">
        <doc xml:space="preserve">&lt;![CDATA[           This parameter should be considered private or secret; for             instance, clients should store it in a "password safe" like             gnome-keyring or kwallet, omit it from debug logs, and use a             text input widget that hides the value of the parameter.            (Clients that support older connection managers may also treat             any parameter whose name contains "password" as though it had this             flag.)         ]]&gt;</doc>
      </member>
      <member name="dbus_property"
              value="16"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY">
        <doc xml:space="preserve">&lt;![CDATA[           This parameter is also a D-Bus property on the resulting             Connection; a             parameter named com.example.Duck.Macaroni with this             flag corresponds to the Macaroni property on the             com.example.Duck interface.  Its value can be queried             and possibly changed on an existing Connection using methods on the             org.freedesktop.DBus.Properties interface.            When a new value for a parameter with this flag is passed to             Account.UpdateParameters,             the account manager will attempt to update its value on any running             connections. Similarly, if the parameter also has the             Has_Default flag, and is passed in the second argument             to UpdateParameters, the default value will be applied             to any running             connections. Thus, clients generally do not need to directly access             or update the connection property; instead, they SHOULD manipulate             Account.Parameters.                         This allows runtime-configurable options to be stored and               maintained by the AccountManager, without needing to               invent a separate account preference for properties that should               be set on the connection as soon as it is created. It was               originally invented to manage Cellular               preferences.                    ]]&gt;</doc>
      </member>
    </bitfield>
    <class name="Connection"
           c:symbol-prefix="connection"
           c:type="TpConnection"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpConnection"
           glib:get-type="tp_connection_get_type"
           glib:type-struct="ConnectionClass">
      <doc xml:space="preserve">A proxy object for a Telepathy connection. There are no interesting
public struct fields.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new"
                   c:identifier="tp_connection_new"
                   version="0.7.1"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_connection() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new connection proxy, or %NULL if unique-name resolution
 fails or on invalid arguments</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bus_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the well-known or unique name of the connection
 process; if well-known, this function will make a blocking call to the bus
 daemon to resolve the unique name. May be %NULL if @object_path is not, in
 which case a well-known name will be derived from @object_path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the object path of the connection process.
 May be %NULL if @bus_name is a well-known name, in which case the object
 path will be derived from @bus_name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_aliasing"
                c:identifier="tp_connection_get_feature_quark_aliasing">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_avatar_requirements"
                c:identifier="tp_connection_get_feature_quark_avatar_requirements">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_balance"
                c:identifier="tp_connection_get_feature_quark_balance">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_capabilities"
                c:identifier="tp_connection_get_feature_quark_capabilities">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connected"
                c:identifier="tp_connection_get_feature_quark_connected">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_blocking"
                c:identifier="tp_connection_get_feature_quark_contact_blocking">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_groups"
                c:identifier="tp_connection_get_feature_quark_contact_groups">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_info"
                c:identifier="tp_connection_get_feature_quark_contact_info">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_list"
                c:identifier="tp_connection_get_feature_quark_contact_list">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_list_properties"
                c:identifier="tp_connection_get_feature_quark_contact_list_properties">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_connection_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_connection_init_known_interfaces"
                version="0.7.6">
        <doc xml:space="preserve">Ensure that the known interfaces for TpConnection have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="presence_type_cmp_availability"
                c:identifier="tp_connection_presence_type_cmp_availability"
                version="0.7.16">
        <doc xml:space="preserve">Compares @p1 and @p2 like strcmp(). @p1 &gt; @p2 means @p1 is more available
than @p2.

The order used is: available &gt; busy &gt; away &gt; xa &gt; hidden &gt; offline &gt; error &gt;
unknown &gt; unset</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1, 0 or 1, if @p1 is &lt;, == or &gt; than @p2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_client_interest"
              c:identifier="tp_connection_add_client_interest"
              version="0.11.3">
        <doc xml:space="preserve">Subscribe to any opt-in change notifications for @interested_in.

For contact information, use #TpContact instead, which will call this
automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="interested_in" transfer-ownership="none">
            <doc xml:space="preserve">a string identifying an interface or part of an interface
 to which this connection will subscribe</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_client_interest_by_id"
              c:identifier="tp_connection_add_client_interest_by_id"
              version="0.11.3"
              introspectable="0">
        <doc xml:space="preserve">Subscribe to any opt-in change notifications for @interested_in.

Equivalent to, but a little more efficient than, calling
tp_connection_add_client_interest() for the string value of @interested_in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="interested_in" transfer-ownership="none">
            <doc xml:space="preserve">a quark identifying an interface or part of an interface
 to which this connection will subscribe</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_async"
              c:identifier="tp_connection_add_to_group_async"
              version="0.15.5">
        <doc xml:space="preserve">Add the given @contacts to the given @group, creating it if necessary.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 include in the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_finish"
              c:identifier="tp_connection_add_to_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_add_to_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_async"
              c:identifier="tp_connection_authorize_publication_async"
              version="0.15.5">
        <doc xml:space="preserve">For each of the given @contacts, request that the local user's presence is
sent to that contact, i.e. that their #TpContact:publish-state property
becomes %TP_SUBSCRIPTION_STATE_YES.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 authorize</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_finish"
              c:identifier="tp_connection_authorize_publication_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_authorize_publication_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_connection_status_to_property"
              c:identifier="tp_connection_bind_connection_status_to_property"
              version="0.13.16">
        <doc xml:space="preserve">Binds the :status of @self to the boolean property of another
object using a #GBinding such that the @target_property will be set to
%TRUE when @self is connected (and @invert is %FALSE).

@target_property will be synchronised immediately (%G_BINDING_SYNC_CREATE).
@invert can be interpreted as analogous to %G_BINDING_INVERT_BOOLEAN.

For instance, this function can be used to bind the GtkWidget:sensitive
property to only make a widget sensitive when the account is connected.

See g_object_bind_property() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBinding instance representing the binding
  between the @self and the @target. The binding is released whenever the
  #GBinding reference count reaches zero.</doc>
          <type name="GObject.Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="target"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind (must be %G_TYPE_BOOLEAN)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="invert" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if you wish to invert the value of @target_property
  (i.e. %FALSE if connected)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_contacts_async"
              c:identifier="tp_connection_block_contacts_async"
              version="0.17.0">
        <doc xml:space="preserve">Direct the server to block @contacts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">the number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 block</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="report_abusive" transfer-ownership="none">
            <doc xml:space="preserve">If %TRUE, report these contacts as abusive to the
server administrators as well as blocking them. See
#TpConnection:can-report-abusive to discover whether reporting abuse is
supported. If #TpConnection:can-report-abusive is %FALSE, this parameter will
be ignored.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_contacts_finish"
              c:identifier="tp_connection_block_contacts_finish"
              version="0.17.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_block_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_connection_call_when_ready"
              version="0.7.7"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.17.6">
        <doc xml:space="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.

Note that if the connection is not in state CONNECTED, the callback will
not be called until the connection either goes to state CONNECTED
or is invalidated (e.g. by going to state DISCONNECTED or by becoming
unreferenced). In particular, this method does not call Connect().
Call tp_cli_connection_call_connect() too, if you want to do that.</doc>
        <doc-deprecated xml:space="preserve">Use tp_proxy_prepare_async()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">called when the connection becomes ready or invalidated,
 whichever happens first</doc>
            <type name="ConnectionWhenReadyCb"
                  c:type="TpConnectionWhenReadyCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_report_abusive"
              c:identifier="tp_connection_can_report_abusive"
              version="0.17.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:can-report-abusive</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_set_contact_alias"
              c:identifier="tp_connection_can_set_contact_alias">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="disconnect_async"
              c:identifier="tp_connection_disconnect_async"
              version="0.17.5">
        <doc xml:space="preserve">Disconnect the connection.

This method is intended for use by AccountManager implementations,
such as Mission Control. To disconnect a connection managed by an
AccountManager, either use tp_account_request_presence_async()
or tp_account_set_enabled_async(), depending whether the intention is
to put the account offline temporarily, or disable it longer-term.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_finish"
              c:identifier="tp_connection_disconnect_finish"
              version="0.17.5"
              throws="1">
        <doc xml:space="preserve">Interpret the result of tp_connection_disconnect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_by_id_async"
              c:identifier="tp_connection_dup_contact_by_id_async"
              version="0.19.0">
        <doc xml:space="preserve">Create a #TpContact object and make any asynchronous method calls necessary
to ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection, which must have the %TP_CONNECTION_FEATURE_CONNECTED
 feature prepared</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">A strings representing the desired contact by its
 identifier in the IM protocol (an XMPP JID, SIP URI, MSN Passport,
 AOL screen-name etc.)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:space="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of features
 that must be ready for use (if supported)
 before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="1"
                   zero-terminated="0"
                   c:type="const TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">A user callback to call when the contact is ready</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_by_id_finish"
              c:identifier="tp_connection_dup_contact_by_id_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_dup_contact_by_id_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TpContact or %NULL on error.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_if_possible"
              c:identifier="tp_connection_dup_contact_if_possible"
              version="0.13.9">
        <doc xml:space="preserve">Try to return an existing contact object or create a new contact object
immediately.

If tp_connection_has_immortal_handles() would return %TRUE and
@identifier is non-%NULL, this function always succeeds.

On connections without immortal handles, it is not possible to guarantee
that @handle remains valid without making asynchronous D-Bus calls, so
it might be necessary to delay processing of messages or other events
until a #TpContact can be constructed asynchronously, for instance by using
tp_connection_get_contacts_by_id().

Similarly, if @identifier is %NULL, it might not be possible to find the
identifier for @handle without making asynchronous D-Bus calls, so
it might be necessary to delay processing of messages or other events
until a #TpContact can be constructed asynchronously, for instance by using
tp_connection_get_contacts_by_handle().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a contact or %NULL</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a handle of type %TP_HANDLE_TYPE_CONTACT</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">the normalized identifier (XMPP JID, etc.)
 corresponding to @handle, or %NULL if not known</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_info_supported_fields"
              c:identifier="tp_connection_dup_contact_info_supported_fields"
              version="0.19.9">
        <doc xml:space="preserve">Returns a newly allocated #GList of supported contact info fields for this
connection. The list must be freed with tp_contact_info_spec_list_free().

To wait for valid supported fields, call tp_proxy_prepare_async() with the
feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a #GList of #TpContactInfoFieldSpec struct, or %NULL if the feature is not
 yet prepared or the connection doesn't have the necessary properties.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoFieldSpec"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_contact_list"
              c:identifier="tp_connection_dup_contact_list"
              version="0.15.5">
        <doc xml:space="preserve">Retrieves the user's contact list. In general, blocked contacts are not
included in this list. The #TpContact objects returned are guaranteed to
have all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.

Before calling this method, you must first call tp_proxy_prepare_async() with
the %TP_CONNECTION_FEATURE_CONTACT_LIST feature, and verify that
#TpConnection:contact-list-state is set to %TP_CONTACT_LIST_STATE_SUCCESS.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a new #GPtrArray of #TpContact. Use g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_detailed_error_vardict"
              c:identifier="tp_connection_dup_detailed_error_vardict"
              version="0.19.0">
        <doc xml:space="preserve">If the connection has disconnected, return the D-Bus error name with which
it disconnected (in particular, this is %TP_ERROR_STR_CANCELLED if it was
disconnected by a user request).

Otherwise, return %NULL, without altering @details.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
 optionally used to return a %G_VARIANT_TYPE_VARDICT with details
 of the error</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_connection_get_account"
              version="0.15.5">
        <doc xml:space="preserve">Return the the #TpAccount associated with this connection. Will return %NULL
if @self was not acquired from a #TpAccount via tp_account_get_connection(),
or if the account object got finalized in the meantime (#TpConnection does
not keep a strong ref on its #TpAccount).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the account associated with this connection, or
%NULL.</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_avatar_requirements"
              c:identifier="tp_connection_get_avatar_requirements"
              version="0.11.4">
        <doc xml:space="preserve">To wait for valid avatar requirements, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_AVATAR_REQUIREMENTS.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #TpAvatarRequirements struct, or %NULL if the
 feature is not yet prepared or the connection doesn't have the necessary
 properties.</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_balance"
              c:identifier="tp_connection_get_balance"
              version="0.15.1">
        <doc xml:space="preserve">If @self has a valid account balance, returns %TRUE and sets the variables
pointed to by @balance, @scale and @currency to the appropriate fields
of the Balance.AccountBalance property.

The monetary value of the balance is expressed as a fixed-point number,
@balance, with a decimal scale defined by @scale; for instance a @balance
of 1234 with @scale of 2 represents a value of "12.34" in the currency
represented by @currency.

Requires %TP_CONNECTION_FEATURE_BALANCE to be prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the balance is valid (and the values set), %FALSE if the
  balance is invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="balance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a pointer to store the account balance (or %NULL)</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="scale"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a pointer to store the balance scale (or %NULL)</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="currency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">a pointer to store the balance
  currency (or %NULL)</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_balance_uri"
              c:identifier="tp_connection_get_balance_uri"
              version="0.15.1">
        <doc xml:space="preserve">The value of Balance.ManageCreditURI.

Requires %TP_CONNECTION_FEATURE_BALANCE to be prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #TpConnection:balance-uri property.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blocked_contacts"
              c:identifier="tp_connection_get_blocked_contacts"
              version="0.17.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
#TpConnection:blocked-contacts</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_can_change_contact_list"
              c:identifier="tp_connection_get_can_change_contact_list"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:can-change-contact-list property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_connection_get_capabilities"
              version="0.11.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same #TpCapabilities as the
#TpConnection:capabilities property</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cm_name"
              c:identifier="tp_connection_get_cm_name"
              version="0.19.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpConnection:cm-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_manager_name"
              c:identifier="tp_connection_get_connection_manager_name"
              version="0.13.16"
              deprecated="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Use tp_connection_get_cm_name() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpConnection:connection-manager-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_attributes"
              c:identifier="tp_connection_get_contact_attributes"
              deprecated="1">
        <doc xml:space="preserve">Return (via a callback) any number of attributes of the given handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, if @hold
was %TRUE, the callback would hold a reference to them which could be
released with tp_connection_unref_handles().

This is a thin wrapper around the GetContactAttributes D-Bus method, and
should be used in preference to
tp_cli_connection_interface_contacts_call_get_contact_attributes(); mixing this
function, tp_connection_hold_handles(), tp_connection_unref_handles(), and
#TpContact with direct use of the RequestHandles, HoldHandles and
GetContactAttributes D-Bus methods is unwise, as #TpConnection and
#TpContact perform client-side reference counting of handles.
The #TpContact API provides a higher-level abstraction which should
usually be used instead.

@callback will later be called with the attributes of those of the given
handles that were valid. Invalid handles are simply omitted from the
parameter to the callback.

If @hold is %TRUE, the @callback is given one reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_contact() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:space="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:space="preserve">an array of handles</doc>
            <array length="1" zero-terminated="0" c:type="const TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrv of interfaces</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, the callback will hold one reference to each valid handle</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:space="preserve">called on success or
 failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback"
                  c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called to destroy @user_data after calling @callback, or when
 @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, an object to be weakly referenced: if it is
 destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_groups"
              c:identifier="tp_connection_get_contact_groups"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of
 #TpConnection:contact-groups</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_info_flags"
              c:identifier="tp_connection_get_contact_info_flags"
              version="0.11.7">
        <doc xml:space="preserve">Returns the flags describing how contact info (vCards) behaves on this
connection

To wait for valid contact info flags, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a set of #TpContactInfoFlags</doc>
          <type name="ContactInfoFlags" c:type="TpContactInfoFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_info_supported_fields"
              c:identifier="tp_connection_get_contact_info_supported_fields"
              version="0.11.7"
              deprecated="1">
        <doc xml:space="preserve">Returns a newly allocated #GList of supported contact info fields for this
connection. The list must be freed with g_list_free() after used.

Note that the #TpContactInfoFieldSpec&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_spec_copy().

To wait for valid supported fields, call tp_proxy_prepare_async() with the
feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_connection_dup_contact_info_supported_fields() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a #GList of #TpContactInfoFieldSpec struct, or %NULL if the feature is not
 yet prepared or the connection doesn't have the necessary properties.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoFieldSpec"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_list_attributes"
              c:identifier="tp_connection_get_contact_list_attributes"
              deprecated="1">
        <doc xml:space="preserve">Return (via a callback) the contacts on the contact list and any number of
their attributes.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, if @hold
was %TRUE, the callback would hold a reference to them which could be
released with tp_connection_unref_handles().

This is a thin wrapper around the RequestContactList D-Bus method,
and should be used in preference to lower-level functions; it is similar
to tp_connection_get_contact_attributes().

The #TpContact API provides a higher-level abstraction which should
usually be used instead.

If @hold is %TRUE, the @callback is given a reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <doc-deprecated xml:space="preserve">Use tp_connection_dup_contact_list() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds (using a large timeout is
 recommended)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrv of interfaces</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, the callback will hold one reference to each handle it
 receives</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:space="preserve">called on success or
 failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback"
                  c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called to destroy @user_data after calling @callback, or when
 @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, an object to be weakly referenced: if it is
 destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_list_persists"
              c:identifier="tp_connection_get_contact_list_persists"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:contact-list-persists property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_list_state"
              c:identifier="tp_connection_get_contact_list_state"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:contact-list-state property</doc>
          <type name="ContactListState" c:type="TpContactListState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contacts_by_handle"
              c:identifier="tp_connection_get_contacts_by_handle"
              version="0.7.18"
              deprecated="1">
        <doc xml:space="preserve">Create a number of #TpContact objects and make asynchronous method calls
to hold their handles and ensure that all the features specified in
@features are ready for use (if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_contact() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection, which must have the %TP_CONNECTION_FEATURE_CONNECTED
 feature prepared</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:space="preserve">The number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:space="preserve">An array of handles
 of type %TP_HANDLE_TYPE_CONTACT representing the desired contacts</doc>
            <array length="0" zero-terminated="0" c:type="const TpHandle*">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:space="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of features that
 must be ready for use (if supported) before the callback is called (may
 be %NULL if @n_features is 0)</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const TpContactFeature*">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByHandleCb"
                  c:type="TpConnectionContactsByHandleCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">Called to destroy @user_data either after @callback has been
 called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An object to pass to the callback, which will be
 weakly referenced; if this object is destroyed, the operation will be
 cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contacts_by_id"
              c:identifier="tp_connection_get_contacts_by_id"
              version="0.7.18"
              deprecated="1">
        <doc xml:space="preserve">Create a number of #TpContact objects and make asynchronous method calls
to obtain their handles and ensure that all the features specified in
@features are ready for use (if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <doc-deprecated xml:space="preserve">Use tp_connection_dup_contact_by_id_async() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection, which must have the %TP_CONNECTION_FEATURE_CONNECTED
 feature prepared</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_ids" transfer-ownership="none">
            <doc xml:space="preserve">The number of IDs in @ids (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:space="preserve">An array of strings representing
 the desired contacts by their
 identifiers in the IM protocol (XMPP JIDs, SIP URIs, MSN Passports,
 AOL screen-names etc.)</doc>
            <array length="0" zero-terminated="0" c:type="const gchar* const*">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:space="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of features
 that must be ready for use (if supported)
 before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByIdCb"
                  c:type="TpConnectionContactsByIdCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">Called to destroy @user_data either after @callback has been
 called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An object to pass to the callback, which will
 be weakly referenced; if this object is destroyed, the operation will be
 cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error"
              c:identifier="tp_connection_get_detailed_error"
              version="0.11.4">
        <doc xml:space="preserve">If the connection has disconnected, return the D-Bus error name with which
it disconnected (in particular, this is %TP_ERROR_STR_CANCELLED if it was
disconnected by a user request).

Otherwise, return %NULL, without altering @details.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
 optionally used to return a map from string to #GValue, which must not be
 modified or destroyed by the caller</doc>
            <type name="GLib.HashTable" c:type="const GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_disjoint_groups"
              c:identifier="tp_connection_get_disjoint_groups"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:disjoint-groups</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_group_storage"
              c:identifier="tp_connection_get_group_storage"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:group-storage</doc>
          <type name="ContactMetadataStorageType"
                c:type="TpContactMetadataStorageType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol_name"
              c:identifier="tp_connection_get_protocol_name"
              version="0.13.16">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same as the #TpConnection:protocol-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_uses_message"
              c:identifier="tp_connection_get_request_uses_message"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpConnection:request-uses-message property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_self_contact"
              c:identifier="tp_connection_get_self_contact"
              version="0.13.9">
        <doc xml:space="preserve">Return a #TpContact representing the local user on this connection.

The returned object is not necessarily valid after the main loop is
re-entered; ref it with g_object_ref() if you want to keep it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the TpConnection:self-contact
 property, which may be %NULL</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_self_handle"
              c:identifier="tp_connection_get_self_handle"
              version="0.7.26"
              deprecated="1">
        <doc xml:space="preserve">Return the %TP_HANDLE_TYPE_CONTACT handle of the local user on this
connection, or 0 if the self-handle is not known yet or the connection
has become invalid (the TpProxy::invalidated signal).

The returned handle is not necessarily valid forever (the
notify::self-handle signal will be emitted if it changes, which can happen
on protocols such as IRC). Construct a #TpContact object if you want to
track the local user's identifier in the protocol, or other information
like their presence status, over time.</doc>
        <doc-deprecated xml:space="preserve">Use tp_connection_get_self_contact() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the TpConnection:self-handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status"
              c:identifier="tp_connection_get_status"
              version="0.7.14">
        <doc xml:space="preserve">If @reason is not %NULL it is set to the reason why "status" changed to its
current value, or %TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we
don't know yet.</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a TpConnectionStatusReason, or %NULL</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_immortal_handles"
              c:identifier="tp_connection_has_immortal_handles">
        <doc xml:space="preserve">Return %TRUE if this connection is known to not destroy handles
(#TpHandle) until it disconnects.

On such connections, if you know that a handle maps to a particular
identifier now, then you can rely on that handle mapping to that
identifier for the whole lifetime of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if handles last as long as the connection itself</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hold_handles"
              c:identifier="tp_connection_hold_handles"
              deprecated="1">
        <doc xml:space="preserve">Hold (ensure a reference to) the given handles, if they are valid.

If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.

This function, along with tp_connection_unref_handles(),
tp_connection_get_contact_attributes() and #TpContact, keeps a client-side
reference count of handles; you should not use the RequestHandles,
HoldHandles and GetContactAttributes D-Bus methods directly as well as these
functions.</doc>
        <doc-deprecated xml:space="preserve">Holding handles is not needed with Connection Managers having
 immortal handles (any Connection Manager using telepathy-glib &gt;= 0.13.8).
 Other Connection Managers are considered deprecated, clients wanting to
 still support them should continue using this deprecated function.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:space="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:space="preserve">an array of handles</doc>
            <array length="2" zero-terminated="0" c:type="const TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">called on success or failure (unless @weak_object has become
 unreferenced)</doc>
            <type name="ConnectionHoldHandlesCb"
                  c:type="TpConnectionHoldHandlesCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called to destroy @user_data after calling @callback, or when
 @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, an object to be weakly referenced: if it is
 destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_connection_is_ready"
              version="0.7.17"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.17.6">
        <doc xml:space="preserve">Returns the same thing as the #TpConnection:connection-ready property.</doc>
        <doc-deprecated xml:space="preserve">use tp_proxy_is_prepared() with
 %TP_CONNECTION_FEATURE_CONNECTED</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if introspection has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_object_path"
              c:identifier="tp_connection_parse_object_path"
              version="0.7.27"
              deprecated="1">
        <doc xml:space="preserve">If the object path of @connection is in the correct form, set
@protocol and @cm_name, return TRUE. Otherwise leave them unchanged and
return FALSE.</doc>
        <doc-deprecated xml:space="preserve">Use tp_connection_get_protocol_name() and
 tp_connection_get_connection_manager_name() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the object path was correctly parsed, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="protocol"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">If not NULL, used to return the protocol
 of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="cm_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">If not NULL, used to return the connection
 manager name of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_contact_info"
              c:identifier="tp_connection_refresh_contact_info"
              version="0.11.7">
        <doc xml:space="preserve">Requests to refresh the #TpContact:contact-info property on each contact from
@contacts, requesting it from the network if an up-to-date version is not
cached locally. "notify::contact-info" will be emitted when the contact's
information are updated.

If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on a contact, it will be
set before its property gets updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects
 associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="remove_contacts_async"
              c:identifier="tp_connection_remove_contacts_async"
              version="0.15.5">
        <doc xml:space="preserve">Remove the given @contacts from the contact list entirely. It is
protocol-dependent whether this works, and under which circumstances.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_contacts_finish"
              c:identifier="tp_connection_remove_contacts_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_remove_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_async"
              c:identifier="tp_connection_remove_from_group_async"
              version="0.15.5">
        <doc xml:space="preserve">Remove the given @contacts from the given @group. If there are no members
left in the group afterwards, the group MAY itself be removed.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 remove from the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_finish"
              c:identifier="tp_connection_remove_from_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_remove_from_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_async"
              c:identifier="tp_connection_remove_group_async"
              version="0.15.5">
        <doc xml:space="preserve">Remove all members from the given group, then remove the group itself.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group to remove.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_finish"
              c:identifier="tp_connection_remove_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_remove_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_group_async"
              c:identifier="tp_connection_rename_group_async"
              version="0.15.5">
        <doc xml:space="preserve">Rename the given @old_name.

On protocols where groups behave like tags, this is an API short-cut for
adding all of the group's members to a group with the new name, then removing
the old group.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the group to rename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">the new name for the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_group_finish"
              c:identifier="tp_connection_rename_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_rename_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_handles"
              c:identifier="tp_connection_request_handles"
              deprecated="1">
        <doc xml:space="preserve">Request the handles corresponding to the given identifiers, and if they
are valid, hold (ensure a reference to) the corresponding handles.

If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.</doc>
        <doc-deprecated xml:space="preserve">If @handle_type is TP_HANDLE_TYPE_CONTACT, use
 tp_connection_dup_contact_by_id_async() instead. For channel requests,
 use tp_account_channel_request_set_target_id() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:space="preserve">an array of string identifiers for which
 handles are required, terminated by %NULL (must not be %NULL or empty)</doc>
            <array c:type="const gchar* const*">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:space="preserve">called on success or failure (unless @weak_object has become
 unreferenced)</doc>
            <type name="ConnectionRequestHandlesCb"
                  c:type="TpConnectionRequestHandlesCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called to destroy @user_data after calling @callback, or when
 @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, an object to be weakly referenced: if it is
 destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_async"
              c:identifier="tp_connection_request_subscription_async"
              version="0.15.5">
        <doc xml:space="preserve">Request that the given @contacts allow the local user to subscribe to their
presence, i.e. that their #TpContact:subscribe-state property becomes
%TP_SUBSCRIPTION_STATE_YES.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to whom
 requests are to be sent.</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">an optional plain-text message from the user, to send to those
 @contacts with the subscription request.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_finish"
              c:identifier="tp_connection_request_subscription_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_request_subscription_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_until_ready"
              c:identifier="tp_connection_run_until_ready"
              version="0.7.1"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.11.0">
        <doc xml:space="preserve">If @self is connected and ready for use, return immediately. Otherwise,
call Connect() (unless @connect is %FALSE) and re-enter the main loop
until the connection becomes invalid, the connection connects successfully
and is introspected, or the main loop stored via @loop is cancelled.</doc>
        <doc-deprecated xml:space="preserve">Use tp_proxy_prepare_async() and re-enter the main
 loop yourself, or restructure your program in such a way as to avoid
 re-entering the main loop.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is now connected and ready for use,
 %FALSE if the connection has become invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="connect" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, call Connect() if it appears to be necessary;
 if %FALSE, rely on Connect() to be called by another client</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, a #GMainLoop is placed here while it is being run
 (so calling code can call g_main_loop_quit() to abort), and %NULL is
 placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_async"
              c:identifier="tp_connection_set_contact_info_async"
              version="0.11.7">
        <doc xml:space="preserve">Requests an asynchronous set of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_connection_set_contact_info_finish() to get the result of the operation.

This method should not be expected to succeed if the result of
tp_connection_get_contact_info_flags() does not include
%TP_CONTACT_INFO_FLAG_CAN_SET.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of
 #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ContactInfoField"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_finish"
              c:identifier="tp_connection_set_contact_info_finish"
              version="0.11.7"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of @self info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group_members_async"
              c:identifier="tp_connection_set_group_members_async"
              version="0.15.5">
        <doc xml:space="preserve">Add the given @contacts to the given @group (creating it if necessary), and
remove all other members.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects members
 for the group. If this set is empty, this method MAY remove the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group_members_finish"
              c:identifier="tp_connection_set_group_members_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_set_group_members_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_contacts_async"
              c:identifier="tp_connection_unblock_contacts_async"
              version="0.17.0">
        <doc xml:space="preserve">Direct the server to unblock @contacts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">the number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 block</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_contacts_finish"
              c:identifier="tp_connection_unblock_contacts_finish"
              version="0.17.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_unblock_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_async"
              c:identifier="tp_connection_unpublish_async"
              version="0.15.5">
        <doc xml:space="preserve">Attempt to set the given @contacts' #TpContact:publish-state property to
%TP_SUBSCRIPTION_STATE_NO, i.e. stop sending presence to them.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_finish"
              c:identifier="tp_connection_unpublish_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_unpublish_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_handles"
              c:identifier="tp_connection_unref_handles"
              deprecated="1">
        <doc xml:space="preserve">Do nothing. In versions of telepathy-glib prior to 0.13.8,
this released a reference to the handles in @handles.</doc>
        <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:space="preserve">the number of handles in @handles</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:space="preserve">an array of @n_handles handles</doc>
            <array length="1" zero-terminated="0" c:type="const TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_async"
              c:identifier="tp_connection_unsubscribe_async"
              version="0.15.5">
        <doc xml:space="preserve">Attempt to set the given @contacts' #TpContact:subscribe-state property to
%TP_SUBSCRIPTION_STATE_NO, i.e. stop receiving their presence.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects to
 remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_finish"
              c:identifier="tp_connection_unsubscribe_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_unsubscribe_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts"
              c:identifier="tp_connection_upgrade_contacts"
              version="0.7.18"
              deprecated="1">
        <doc xml:space="preserve">Given several #TpContact objects, make asynchronous method calls
ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <doc-deprecated xml:space="preserve">Use tp_connection_upgrade_contacts_async() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection, which must have the %TP_CONNECTION_FEATURE_CONNECTED
 feature prepared</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects
 associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:space="preserve">The number of features in @features (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">An array of features that must be
 ready for use (if supported) before the callback is called</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionUpgradeContactsCb"
                  c:type="TpConnectionUpgradeContactsCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">Called to destroy @user_data either after @callback has been
 called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An object to pass to the callback, which will be
 weakly referenced; if this object is destroyed, the operation will be
 cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_async"
              c:identifier="tp_connection_upgrade_contacts_async"
              version="0.19.0">
        <doc xml:space="preserve">Given several #TpContact objects, make asynchronous method calls
ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A connection, which must have the %TP_CONNECTION_FEATURE_CONNECTED
 feature prepared</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects
 associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:space="preserve">The number of features in @features (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:space="preserve">An array of features that must be
 ready for use (if supported) before the callback is called</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">A user callback to call when the contacts are ready</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_finish"
              c:identifier="tp_connection_upgrade_contacts_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_connection_upgrade_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contacts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
 a location to set a #GPtrArray of upgraded #TpContact, or %NULL.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <property name="balance" transfer-ownership="none">
        <doc xml:space="preserve">The Amount field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="balance-currency" transfer-ownership="none">
        <doc xml:space="preserve">The Currency field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="balance-scale" transfer-ownership="none">
        <doc xml:space="preserve">The Scale field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="balance-uri" transfer-ownership="none">
        <doc xml:space="preserve">The Balance.ManageCreditURI property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="blocked-contacts"
                version="0.17.0"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray of blocked #TpContact. Changes are notified using the
#TpConnection::blocked-contacts-changed signal.

These TpContact objects have been prepared with the desired features.
See tp_simple_client_factory_add_contact_features() to define which
features needs to be prepared on them.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="can-change-contact-list"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">If true, presence subscription and publication can be changed using the
RequestSubscription, AuthorizePublication and RemoveContacts methods.

Rational: link-local XMPP, presence is implicitly published to everyone in
the local subnet, so the user cannot control their presence publication.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="can-report-abusive"
                version="0.17.0"
                transfer-ownership="none">
        <doc xml:space="preserve">If this property is %TRUE, contacts may be reported as abusive to the
server administrators by setting report_abusive to %TRUE when calling
tp_connection_block_contacts_async().

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The %TpCapabilities object representing the capabilities of this
connection, or NULL if we don't know yet.

To wait for valid capability information, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="cm-name" version="0.19.3" transfer-ownership="none">
        <doc xml:space="preserve">This connection's connection manager name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connection-manager-name"
                version="0.13.16"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">This connection's connection manager name.</doc>
        <doc-deprecated xml:space="preserve">Use #TpConnection:cm-name instead.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connection-ready"
                deprecated="1"
                deprecated-version="0.17.6"
                transfer-ownership="none">
        <doc xml:space="preserve">Initially %FALSE; changes to %TRUE when the connection has gone to
CONNECTED status, introspection has finished and it's ready for use.

By the time this property becomes %TRUE, any extra interfaces will
have been set up and the #TpProxy:interfaces property will have been
populated.

This is similar to %TP_CONNECTION_FEATURE_CONNECTED, except that once
it has changed to %TRUE, it remains %TRUE even if the connection has
been invalidated.</doc>
        <doc-deprecated xml:space="preserve">use tp_proxy_is_prepared() with
 %TP_CHANNEL_FEATURE_CONNECTED for checks, or tp_proxy_prepare_async() for
 notification</doc-deprecated>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="contact-groups"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">The names of all groups that currently exist. This may be a larger set than
the union of all #TpContact:contact-groups properties, if the connection
allows groups to be empty.

This property's value is not meaningful until the
#TpConnection:contact-list-state property has become
%TP_CONTACT_LIST_STATE_SUCCESS.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="contact-list-persists"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">If true, presence subscriptions (in both directions) on this connection are
stored by the server or other infrastructure.

If false, presence subscriptions on this connection are not stored.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="contact-list-state"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">The progress made in retrieving the contact list.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="disjoint-groups"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">True if each contact can be in at most one group; false if each contact
can be in many groups.

This property cannot change after the connection has moved to the
%TP_CONNECTION_STATUS_CONNECTED state. Until then, its value is undefined,
and it may change at any time, without notification.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="group-storage"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">Indicates the extent to which contacts' groups can be set and stored.

This property cannot change after the connection has moved to the
%TP_CONNECTION_STATUS_CONNECTED state. Until then, its value is undefined,
and it may change at any time, without notification.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="protocol-name"
                version="0.13.16"
                transfer-ownership="none">
        <doc xml:space="preserve">The connection's machine-readable protocol name, such as "jabber",
"msn" or "local-xmpp". Recommended names for most protocols can be
found in the Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="request-uses-message"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">If true, the Message parameter to RequestSubscription is likely to be
significant, and user interfaces SHOULD prompt the user for a message to
send with the request; a message such as "I would like to add you to my
contact list", translated into the local user's language, might make a
suitable default.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="self-contact" version="0.13.9" transfer-ownership="none">
        <doc xml:space="preserve">A #TpContact representing the local user on this connection,
or %NULL if not yet available.

If the local user's unique identifier changes (for instance by using
/nick on IRC), this property will change to a different #TpContact object
representing the new identifier, and #GObject::notify will be emitted.

The #TpContact object is guaranteed to have all of the features previously
passed to tp_simple_client_factory_add_contact_features() prepared.

To wait for a non-%NULL self-contact (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <type name="Contact"/>
      </property>
      <property name="self-handle" deprecated="1" transfer-ownership="none">
        <doc xml:space="preserve">The %TP_HANDLE_TYPE_CONTACT handle of the local user on this connection,
or 0 if we don't know yet or if the connection has become invalid.

This may change if the local user's unique identifier changes (for
instance by using /nick on IRC), in which case #GObject::notify will be
emitted.

To wait for a valid self-handle (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <doc-deprecated xml:space="preserve">Use #TpConnection:self-contact instead.</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="status" transfer-ownership="none">
        <doc xml:space="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we don't
know yet.

To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.

Since version 0.11.3, the change to status
%TP_CONNECTION_STATUS_CONNECTED is delayed slightly, until introspection
of the connection has finished.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="status-reason" transfer-ownership="none">
        <doc xml:space="preserve">To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.

The reason why #TpConnection:status changed to its current value,
or TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.
know yet.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConnectionPrivate" c:type="TpConnectionPrivate*"/>
      </field>
      <glib:signal name="balance-changed"
                   when="last"
                   detailed="1"
                   version="0.15.1">
        <doc xml:space="preserve">Emitted when at least one of the #TpConnection:balance,
#TpConnection:balance-scale or #TpConnection:balance-currency
property is changed.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="balance" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpConnection:balance property</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="balance_scale" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpConnection:balance-scale property</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="balance_currency" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpConnection:balance-currency property</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="blocked-contacts-changed"
                   when="last"
                   version="0.17.0">
        <doc xml:space="preserve">Notify of changes in #TpConnection:blocked-contacts.
 It is guaranteed that all contacts have desired features prepared. See
tp_simple_client_factory_add_contact_features() to define which features
needs to be prepared.

This signal is also emitted for the initial set of blocked contacts once
retrieved.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact which have been blocked</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact which are no longer blocked</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="contact-list-changed" when="last" version="0.15.5">
        <doc xml:space="preserve">Notify of changes in the list of contacts as returned by
tp_connection_dup_contact_list(). It is guaranteed that all contacts have
desired features prepared. See
tp_simple_client_factory_add_contact_features() to define which features
needs to be prepared.

This signal is also emitted for the initial set of contacts once retrieved.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact added to contacts list</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">
 a #GPtrArray of #TpContact removed from contacts list</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-renamed" when="last" version="0.15.5">
        <doc xml:space="preserve">Emitted when a group is renamed, in protocols where this can be
distinguished from group creation, removal and membership changes.

Immediately after this signal is emitted, #TpConnection::groups-created
signal the creation of a group with the new name, and
#TpConnection::groups-removed signal the removal of a group with the old
name.
If the group was not empty, immediately after those signals are emitted,
#TpContact::contact-groups-changed signal that the members of that group
were removed from the old name and added to the new name.

When this signal is emitted, #TpConnection:contact-groups property is
already updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the old name of the group.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">the new name of the group.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="groups-created" when="last" version="0.15.5">
        <doc xml:space="preserve">Emitted when new, empty groups are created. This will often be followed by
#TpContact::contact-groups-changed signals that add some members. When this
signal is emitted, #TpConnection:contact-groups property is already
updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrv with the names of the new groups.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="groups-removed" when="last" version="0.15.5">
        <doc xml:space="preserve">Emitted when one or more groups are removed. If they had members at the
time that they were removed, then immediately after this signal is emitted,
#TpContact::contact-groups-changed signals that their members were removed.
When this signal is emitted, #TpConnection:contact-groups property is
already updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">A #GStrv with the names of the groups.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ConnectionAliasFlags" c:type="TpConnectionAliasFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="connection_alias_flag_user_set"
              value="1"
              c:identifier="TP_CONNECTION_ALIAS_FLAG_USER_SET">
        <doc xml:space="preserve">&lt;![CDATA[           The aliases of contacts on this connection may be changed by the             user of the service, not just by the contacts themselves. This is             the case on Jabber, for instance.           It is possible that aliases can be changed by the contacts too -             which alias takes precedence is not defined by this             specification, and depends on the server and/or connection manager             implementation.           This flag only applies to the aliases of "globally valid" contact             handles. At this time, clients should not expect to be able to             change the aliases corresponding to any channel-specific             handles. If this becomes possible in future, a new flag will             be defined.         ]]&gt;</doc>
      </member>
    </bitfield>
    <bitfield name="ConnectionCapabilityFlags"
              c:type="TpConnectionCapabilityFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="create"
              value="1"
              c:identifier="TP_CONNECTION_CAPABILITY_FLAG_CREATE">
        <doc xml:space="preserve">&lt;![CDATA[           The given channel type and handle can be given to RequestChannel           to create a new channel of this type.         ]]&gt;</doc>
      </member>
      <member name="invite"
              value="2"
              c:identifier="TP_CONNECTION_CAPABILITY_FLAG_INVITE">
        <doc xml:space="preserve">&lt;![CDATA[           The given contact can be invited to an existing channel of this type.         ]]&gt;</doc>
      </member>
    </bitfield>
    <record name="ConnectionClass"
            c:type="TpConnectionClass"
            glib:is-gtype-struct-for="Connection"
            version="0.7.1">
      <doc xml:space="preserve">The class of a #TpConnection. In addition to @parent_class there are four
pointers reserved for possible future use.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="ConnectionContactsByHandleCb"
              c:type="TpConnectionContactsByHandleCb"
              version="0.7.18">
      <doc xml:space="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_handle().

If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts or
invalid handles are returned.

If some or even all of the @handles passed to
tp_connection_get_contacts_by_handle() were not valid, this is not
considered to be a failure. @error will be %NULL in this situation,
@contacts will contain contact objects for those handles that were
valid (possibly none of them), and @invalid will contain the handles
that were not valid.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:space="preserve">The number of TpContact objects successfully created
 (one per valid handle), or 0 on unrecoverable errors</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">An array of @n_contacts TpContact
 objects (this callback is not given a reference to any of these objects,
 and must call g_object_ref() on any that it will keep), or %NULL on
 unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="TpContact* const*">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="n_failed" transfer-ownership="none">
          <doc xml:space="preserve">The number of invalid handles that were passed to
 tp_connection_get_contacts_by_handle() (or on unrecoverable errors,
 the total number of handles that were given)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="failed" transfer-ownership="none">
          <doc xml:space="preserve">An array of @n_failed handles that were
 passed to tp_connection_get_contacts_by_handle() but turned out to be
 invalid (or on unrecoverable errors, all the handles that were given)</doc>
          <array length="3" zero-terminated="0" c:type="const TpHandle*">
            <type name="Handle" c:type="TpHandle"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or an unrecoverable error that caused everything
 to fail</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="6">
          <doc xml:space="preserve">the @user_data that was passed to
 tp_connection_get_contacts_by_handle()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the @weak_object that was passed to
 tp_connection_get_contacts_by_handle()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionContactsByIdCb"
              c:type="TpConnectionContactsByIdCb"
              version="0.7.18">
      <doc xml:space="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_id().

@requested_ids contains the IDs that were converted to handles successfully.
The normalized form of requested_ids[i] is
tp_contact_get_identifier (contacts[i]).

If some or even all of the @ids passed to
tp_connection_get_contacts_by_id() were not valid, this is not
considered to be a fatal error. @error will be %NULL in this situation,
@contacts will contain contact objects for those IDs that were
valid (it may be empty), and @failed_id_errors will map the IDs
that were not valid to a corresponding #GError (if the connection manager
complies with the Telepathy spec, it will have domain %TP_ERROR and code
%TP_ERROR_INVALID_HANDLE).

If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts
or requested IDs are returned. @failed_id_errors will contain all the IDs
that were requested, mapped to a corresponding #GError (either one
indicating that the ID was invalid, if that was determined before the
fatal error occurred, or a copy of @error).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:space="preserve">The number of TpContact objects successfully created
 (one per valid ID), or 0 on unrecoverable errors</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">An array of @n_contacts TpContact
 objects (this callback is
 not given a reference to any of these objects, and must call
 g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="TpContact* const*">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="requested_ids" transfer-ownership="none">
          <doc xml:space="preserve">An array of @n_contacts valid IDs
 (JIDs, SIP URIs etc.)
 that were passed to tp_connection_get_contacts_by_id(), in an order
 corresponding to @contacts, or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="failed_id_errors" transfer-ownership="none">
          <doc xml:space="preserve">A hash table in which
 the keys are IDs and the values are errors (#GError)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.Error"/>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or an unrecoverable error that caused everything
 to fail</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="6">
          <doc xml:space="preserve">the @user_data that was passed to
 tp_connection_get_contacts_by_id()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the @weak_object that was passed to
 tp_connection_get_contacts_by_id()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionHoldHandlesCb"
              c:type="TpConnectionHoldHandlesCb"
              deprecated="1">
      <doc xml:space="preserve">Signature of the callback called when tp_connection_hold_handles() succeeds
or fails.

On success, the caller has a reference to each handle in @handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, they could be
released with tp_connection_unref_handles().

For convenience, the handle type and handles requested by the caller are
passed through to this callback on success, so the caller does not have to
include them in @user_data.</doc>
      <doc-deprecated xml:space="preserve">See tp_connection_hold_handles().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:space="preserve">the handle type that was passed to
 tp_connection_hold_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:space="preserve">the number of handles that were passed to
 tp_connection_hold_handles() on success, or 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">a copy of the array of @n_handles handles that was passed to
 tp_connection_hold_handles() on success, or %NULL on failure</doc>
          <type name="Handle" c:type="const TpHandle*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="5">
          <doc xml:space="preserve">the same arbitrary pointer that was passed to
 tp_connection_hold_handles()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the same object that was passed to
 tp_connection_hold_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ConnectionManager"
           c:symbol-prefix="connection_manager"
           c:type="TpConnectionManager"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpConnectionManager"
           glib:get-type="tp_connection_manager_get_type"
           glib:type-struct="ConnectionManagerClass">
      <doc xml:space="preserve">A proxy object for a Telepathy connection manager.

This might represent a connection manager which is currently running
(in which case it can be introspected) or not (in which case its
capabilities can be read from .manager files in the filesystem).
Accordingly, this object never emits #TpProxy::invalidated unless all
references to it are discarded.

Various fields and methods on this object do not work until
%TP_CONNECTION_MANAGER_FEATURE_CORE is prepared. Use
tp_proxy_prepare_async() to wait for this to happen.

Since 0.19.1, accessing the fields of this struct is deprecated,
and they are no longer documented here.
Use the accessors tp_connection_manager_get_name(),
tp_connection_manager_is_running(),
tp_connection_manager_dup_protocols(),
tp_connection_manager_get_info_source()
and the #TpConnectionManager:always-introspect property instead.</doc>
      <constructor name="new"
                   c:identifier="tp_connection_manager_new"
                   throws="1">
        <doc xml:space="preserve">Convenience function to create a new connection manager proxy. If
its protocol and parameter information are required, you should call
tp_proxy_prepare_async() on the result.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to a connection manager proxy, or %NULL if @error
         is set.</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="manager_filename"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The #TpConnectionManager:manager-file
 property, which may (and generally should) be %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="check_valid_name"
                c:identifier="tp_connection_manager_check_valid_name"
                version="0.7.1"
                throws="1">
        <doc xml:space="preserve">Check that the given string is a valid connection manager name, i.e. that
it consists entirely of ASCII letters, digits and underscores, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a possible connection manager name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="check_valid_protocol_name"
                c:identifier="tp_connection_manager_check_valid_protocol_name"
                version="0.7.1"
                throws="1">
        <doc xml:space="preserve">Check that the given string is a valid protocol name, i.e. that
it consists entirely of ASCII letters, digits and hyphen/minus, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a possible protocol name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_connection_manager_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_connection_manager_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpConnectionManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="activate"
              c:identifier="tp_connection_manager_activate"
              version="0.7.1"
              introspectable="0">
        <doc xml:space="preserve">Attempt to run and introspect the connection manager, asynchronously.
Since 0.7.26 this function is not generally very useful, since
the connection manager will now be activated automatically if necessary.

If the CM was already running, do nothing and return %FALSE.

On success, emit #TpConnectionManager::activated when the CM appears
on the bus, and #TpConnectionManager::got-info when its capabilities
have been (re-)discovered.

On failure, emit #TpConnectionManager::exited without first emitting
activated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if activation was needed and is now in progress, %FALSE
 if the connection manager was already running and no additional signals
 will be emitted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager proxy</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_connection_manager_call_when_ready"
              version="0.7.26"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Call the @callback from the main loop when information about @cm's
supported protocols and parameters has been retrieved.</doc>
        <doc-deprecated xml:space="preserve">since 0.17.6, use tp_proxy_prepare_async() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">callback to call when information has been retrieved or on
           error</doc>
            <type name="ConnectionManagerWhenReadyCb"
                  c:type="TpConnectionManagerWhenReadyCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called to destroy @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">object to reference weakly; if it is destroyed, @callback
              will not be called, but @destroy will still be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_protocol_names"
              c:identifier="tp_connection_manager_dup_protocol_names"
              version="0.7.26">
        <doc xml:space="preserve">Returns a list of protocol names supported by this connection manager.
These are the internal protocol names used by the Telepathy specification
(e.g. "jabber" and "msn"), rather than user-visible names in any particular
locale.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_proxy_prepare_async() to wait for this.

The result is copied and must be freed by the caller, but it is not
necessarily still true after the main loop is re-entered.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GStrv of protocol names</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_protocols"
              c:identifier="tp_connection_manager_dup_protocols"
              version="0.17.6">
        <doc xml:space="preserve">Return objects representing all protocols supported by this connection
manager.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use tp_proxy_prepare_async()
to wait for this.

The caller must free the list, for instance with
&lt;literal&gt;g_list_free_full (l, g_object_unref)&lt;/literal&gt;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list
 of #TpProtocol objects representing the protocols supported by @self,
 owned by the caller</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Protocol"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info_source"
              c:identifier="tp_connection_manager_get_info_source"
              version="0.7.26">
        <doc xml:space="preserve">If protocol and parameter information has been obtained from the connection
manager, return %TP_CM_INFO_SOURCE_LIVE; if it has been obtained from the
cache in the .manager file, return %TP_CM_INFO_SOURCE_FILE. If this
information has not yet been obtained, or obtaining it failed, return
%TP_CM_INFO_SOURCE_NONE.

This may increase at any time that the main loop is running; the
#GObject::notify signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpConnectionManager:info-source property</doc>
          <type name="CMInfoSource" c:type="TpCMInfoSource"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_connection_manager_get_name"
              version="0.7.26">
        <doc xml:space="preserve">Return the internal name of this connection manager in the Telepathy
D-Bus API, e.g. "gabble" or "haze". This is often the name of the binary
without the "telepathy-" prefix.

The returned string is valid as long as @self is. Copy it with g_strdup()
if a longer lifetime is required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #TpConnectionManager:cm-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol"
              c:identifier="tp_connection_manager_get_protocol"
              version="0.7.26"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">Returns a structure representing a protocol, or %NULL if this connection
manager does not support the specified protocol.

Since 0.11.11, you can get a #GObject version with more
functionality by calling tp_connection_manager_get_protocol_object().

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_proxy_prepare_async() to wait for this.

The result is not necessarily valid after the main loop is re-entered.
Since 0.11.3, it can be copied with tp_connection_manager_protocol_copy()
if a permanently-valid copy is needed.</doc>
        <doc-deprecated xml:space="preserve">, use tp_connection_manager_get_protocol_object()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a structure representing the protocol</doc>
          <type name="ConnectionManagerProtocol"
                c:type="const TpConnectionManagerProtocol*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the name of a protocol as defined in the Telepathy D-Bus API,
           e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol_object"
              c:identifier="tp_connection_manager_get_protocol_object"
              version="0.11.11">
        <doc xml:space="preserve">Returns an object representing a protocol, or %NULL if this connection
manager does not support the specified protocol.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use tp_proxy_prepare_async()
to wait for this.

The result should be referenced with g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an object representing the protocol, or %NULL</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the name of a protocol as defined in the Telepathy D-Bus API,
           e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_protocol"
              c:identifier="tp_connection_manager_has_protocol"
              version="0.7.26">
        <doc xml:space="preserve">Return whether @protocol is supported by this connection manager.

If this function is called before the connection manager information has
been obtained, the result is always %FALSE. Use tp_proxy_prepare_async()
to wait for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection manager supports @protocol</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the name of a protocol as defined in the Telepathy D-Bus API,
           e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_connection_manager_is_ready"
              version="0.7.26"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">If protocol and parameter information has been obtained from the connection
manager or the cache in the .manager file, return %TRUE. Otherwise,
return %FALSE.

This may change from %FALSE to %TRUE at any time that the main loop is
running; the #GObject::notify signal is emitted for the
#TpConnectionManager:info-source property.</doc>
        <doc-deprecated xml:space="preserve">since 0.17.6, use tp_proxy_is_prepared()
 with %TP_CONNECTION_MANAGER_FEATURE_CORE instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, unless the #TpConnectionManager:info-source property is
         %TP_CM_INFO_SOURCE_NONE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_running"
              c:identifier="tp_connection_manager_is_running"
              version="0.7.26">
        <doc xml:space="preserve">Return %TRUE if this connection manager currently appears to be running.
This may change at any time that the main loop is running; the
#TpConnectionManager::activated and #TpConnectionManager::exited signals
are emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the connection manager is currently running</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a connection manager</doc>
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="always-introspect"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, always introspect the connection manager as it comes online,
even if we already have its info from a .manager file. Default %FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="cm-name" version="0.19.3" transfer-ownership="none">
        <doc xml:space="preserve">The name of the connection manager, e.g. "gabble" (read-only).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="connection-manager"
                deprecated="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The name of the connection manager, e.g. "gabble" (read-only).</doc>
        <doc-deprecated xml:space="preserve">Use #TpConnectionManager:cm-name instead.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="info-source" transfer-ownership="none">
        <doc xml:space="preserve">Where we got the current information on supported protocols
(a #TpCMInfoSource).

Since 0.7.26, the #GObject::notify signal is emitted for this
property.

(Note that this is of type %G_TYPE_UINT, not %TP_TYPE_CM_INFO_SOURCE,
for historical reasons.)</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="manager-file"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The absolute path of the .manager file. If set to %NULL (the default),
the XDG data directories will be searched for a .manager file of the
correct name.

If set to the empty string, no .manager file will be read.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="protocols" readable="0" private="1">
        <type name="ConnectionManagerProtocol"
              c:type="const TpConnectionManagerProtocol* const*"/>
      </field>
      <field name="running" readable="0" bits="1" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="always_introspect" readable="0" bits="1" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="info_source" readable="0" bits="2" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="reserved_flags" readable="0" bits="28" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConnectionManagerPrivate"
              c:type="TpConnectionManagerPrivate*"/>
      </field>
      <glib:signal name="activated" when="last" detailed="1">
        <doc xml:space="preserve">Emitted when the connection manager's well-known name appears on the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="exited" when="last" detailed="1">
        <doc xml:space="preserve">Emitted when the connection manager's well-known name disappears from
the bus or when activation fails.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-info" when="last" detailed="1">
        <doc xml:space="preserve">Emitted when the connection manager's capabilities have been discovered.

This signal is not very helpful. Using
tp_proxy_prepare_async() instead is recommended.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCMInfoSource</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionManagerClass"
            c:type="TpConnectionManagerClass"
            glib:is-gtype-struct-for="ConnectionManager"
            version="0.7.1">
      <doc xml:space="preserve">The class of a #TpConnectionManager.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
    </record>
    <callback name="ConnectionManagerListCb"
              c:type="TpConnectionManagerListCb"
              version="0.7.1">
      <doc xml:space="preserve">Signature of the callback supplied to tp_list_connection_managers().

Since 0.11.3, tp_list_connection_managers() will
wait for %TP_CONNECTION_MANAGER_FEATURE_CORE to be prepared on each
connection manager passed to @callback, unless an error occurred while
launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated array of
  #TpConnectionManager (the objects will
  be unreferenced and the array will be freed after the callback returns,
  so the callback must reference any CMs it stores a pointer to),
  or %NULL on error</doc>
          <array c:type="TpConnectionManager* const*">
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </array>
        </parameter>
        <parameter name="n_cms" transfer-ownership="none">
          <doc xml:space="preserve">number of connection managers in @cms (not including the final
 %NULL)</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">user-supplied data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ConnectionManagerParam"
            c:type="TpConnectionManagerParam"
            version="0.7.1"
            glib:type-name="TpConnectionManagerParam"
            glib:get-type="tp_connection_manager_param_get_type"
            c:symbol-prefix="connection_manager_param">
      <doc xml:space="preserve">Structure representing a connection manager parameter.

Since 0.19.1, accessing the fields of this struct is deprecated,
and they are no longer documented here.
Use the accessors tp_connection_manager_param_get_name(),
tp_connection_manager_param_get_dbus_signature(),
tp_connection_manager_param_is_required(),
tp_connection_manager_param_is_required_for_registration(),
tp_connection_manager_param_is_secret(),
tp_connection_manager_param_is_dbus_property(),
tp_connection_manager_param_get_default(),
tp_connection_manager_param_dup_default_variant() instead.</doc>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dbus_signature" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="default_value" readable="0" private="1">
        <type name="GObject.Value" c:type="GValue"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="tp_connection_manager_param_copy"
              version="0.11.3">
        <doc xml:space="preserve">&lt;!-- Returns: says it all --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly (slice) allocated #TpConnectionManagerParam, free with
 tp_connection_manager_param_free()</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">the #TpConnectionManagerParam to copy</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_default_variant"
              c:identifier="tp_connection_manager_param_dup_default_variant"
              version="0.19.0">
        <doc xml:space="preserve">Get the default value for this parameter.

Use g_variant_get_type() to check that the type is what you expect.
For instance, a string parameter should have type
%G_VARIANT_TYPE_STRING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default value, or %NULL if there is no default</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_variant_type"
              c:identifier="tp_connection_manager_param_dup_variant_type"
              version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GVariantType of the parameter</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="tp_connection_manager_param_free"
              version="0.11.3">
        <doc xml:space="preserve">Frees @param, which was copied with tp_connection_manager_param_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">the #TpConnectionManagerParam to free</doc>
            <type name="ConnectionManagerParam"
                  c:type="TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_signature"
              c:identifier="tp_connection_manager_param_get_dbus_signature"
              version="0.7.26">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the D-Bus signature of the parameter</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default"
              c:identifier="tp_connection_manager_param_get_default"
              version="0.7.26">
        <doc xml:space="preserve">Get the default value for this parameter, if there is one. If %FALSE is
returned, @value is left uninitialized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if there is a default value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">pointer to an unset (all zeroes) #GValue into which the default's
        type and value are written</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_connection_manager_param_get_name"
              version="0.7.26">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the parameter</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_dbus_property"
              c:identifier="tp_connection_manager_param_is_dbus_property"
              version="0.7.26">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the parameter represents a D-Bus property of the same name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_required"
              c:identifier="tp_connection_manager_param_is_required"
              version="0.7.26">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the parameter is normally required</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_required_for_registration"
              c:identifier="tp_connection_manager_param_is_required_for_registration"
              version="0.7.26">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the parameter is required when registering a new account
         (by setting the special "register" parameter to %TRUE)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_secret"
              c:identifier="tp_connection_manager_param_is_secret"
              version="0.7.26">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the parameter's value is a password or other secret</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerParam"
                  c:type="const TpConnectionManagerParam*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="ConnectionManagerPrivate"
            c:type="TpConnectionManagerPrivate"
            disguised="1">
    </record>
    <record name="ConnectionManagerProtocol"
            c:type="TpConnectionManagerProtocol"
            version="0.7.1"
            deprecated="1"
            deprecated-version="0.19.1"
            glib:type-name="TpConnectionManagerProtocol"
            glib:get-type="tp_connection_manager_protocol_get_type"
            c:symbol-prefix="connection_manager_protocol">
      <doc xml:space="preserve">Structure representing a protocol supported by a connection manager.
Note that the size of this structure may change, so its size must not be
relied on.</doc>
      <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of this connection manager</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <doc xml:space="preserve">Array of #TpConnectionManagerParam structures, terminated by
 a structure whose @name is %NULL</doc>
        <type name="ConnectionManagerParam"
              c:type="TpConnectionManagerParam*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="can_register"
              c:identifier="tp_connection_manager_protocol_can_register"
              version="0.7.26"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">structure representing a supported protocol</doc>
            <type name="ConnectionManagerProtocol"
                  c:type="const TpConnectionManagerProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="tp_connection_manager_protocol_copy"
              version="0.11.3"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">&lt;!-- Returns: says it all --&gt;</doc>
        <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly (slice) allocated #TpConnectionManagerProtocol, free with
 tp_connection_manager_protocol_free()</doc>
          <type name="ConnectionManagerProtocol"
                c:type="TpConnectionManagerProtocol*"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">the #TpConnectionManagerProtocol to copy</doc>
            <type name="ConnectionManagerProtocol"
                  c:type="const TpConnectionManagerProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_param_names"
              c:identifier="tp_connection_manager_protocol_dup_param_names"
              version="0.7.26"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.

The result is copied and must be freed by the caller with g_strfreev().</doc>
        <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GStrv of protocol names</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">a protocol supported by a #TpConnectionManager</doc>
            <type name="ConnectionManagerProtocol"
                  c:type="const TpConnectionManagerProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="tp_connection_manager_protocol_free"
              version="0.11.3"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">Frees @proto, which was copied with tp_connection_manager_protocol_copy().</doc>
        <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">the #TpConnectionManagerProtocol to free</doc>
            <type name="ConnectionManagerProtocol"
                  c:type="TpConnectionManagerProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_param"
              c:identifier="tp_connection_manager_protocol_get_param"
              version="0.7.26"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">&lt;!-- no more to say --&gt;</doc>
        <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a structure representing the parameter @param, or %NULL if not
         supported</doc>
          <type name="ConnectionManagerParam"
                c:type="const TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">structure representing a supported protocol</doc>
            <type name="ConnectionManagerProtocol"
                  c:type="const TpConnectionManagerProtocol*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_param"
              c:identifier="tp_connection_manager_protocol_has_param"
              version="0.7.26"
              deprecated="1"
              deprecated-version="0.19.1">
        <doc xml:space="preserve">&lt;!-- no more to say --&gt;</doc>
        <doc-deprecated xml:space="preserve">, use #TpProtocol objects instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @protocol supports the parameter @param.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">structure representing a supported protocol</doc>
            <type name="ConnectionManagerProtocol"
                  c:type="const TpConnectionManagerProtocol*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ConnectionManagerWhenReadyCb"
              c:type="TpConnectionManagerWhenReadyCb"
              deprecated="1">
      <doc xml:space="preserve">Called as the result of tp_connection_manager_call_when_ready(). If the
connection manager's protocol and parameter information could be retrieved,
@error is %NULL and @cm is considered to be ready. Otherwise, @error is
non-%NULL and @cm is not ready.</doc>
      <doc-deprecated xml:space="preserve">since 0.17.6, use tp_proxy_prepare_async() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cm" transfer-ownership="none">
          <doc xml:space="preserve">a connection manager</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or the reason why tp_connection_manager_is_ready()
        would return %FALSE</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">the @user_data passed to tp_connection_manager_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the @weak_object passed to
              tp_connection_manager_call_when_ready()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionNameListCb"
              c:type="TpConnectionNameListCb"
              version="0.7.1">
      <doc xml:space="preserve">Signature of the callback supplied to tp_list_connection_names().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="names" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated array of @n
 connection bus names, or %NULL on error</doc>
          <array c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of names (not including the final %NULL), or 0 on error</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated array of @n
 connection manager names (e.g. "gabble") in the same order as @names, or
 %NULL on error</doc>
          <array c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="protocols" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated array of
 @n protocol names as defined in the Telepathy spec (e.g. "jabber") in the
 same order as @names, or %NULL on error</doc>
          <array c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="5">
          <doc xml:space="preserve">user-supplied data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionPresenceType"
                 c:type="TpConnectionPresenceType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unset"
              value="0"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNSET">
        <doc xml:space="preserve">&lt;![CDATA[           An invalid presence type used as a null value. This value MUST NOT           appear in the Statuses property,           or in the result of GetStatuses           on the deprecated Presence           interface.         ]]&gt;</doc>
      </member>
      <member name="offline"
              value="1"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_OFFLINE">
        <doc xml:space="preserve">&lt;![CDATA[           Offline         ]]&gt;</doc>
      </member>
      <member name="available"
              value="2"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_AVAILABLE">
        <doc xml:space="preserve">&lt;![CDATA[           Available         ]]&gt;</doc>
      </member>
      <member name="away"
              value="3"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_AWAY">
        <doc xml:space="preserve">&lt;![CDATA[           Away         ]]&gt;</doc>
      </member>
      <member name="extended_away"
              value="4"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY">
        <doc xml:space="preserve">&lt;![CDATA[           Away for an extended time         ]]&gt;</doc>
      </member>
      <member name="hidden"
              value="5"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_HIDDEN">
        <doc xml:space="preserve">&lt;![CDATA[           Hidden (invisible)         ]]&gt;</doc>
      </member>
      <member name="busy"
              value="6"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_BUSY">
        <doc xml:space="preserve">&lt;![CDATA[           Busy, Do Not Disturb.         ]]&gt;</doc>
      </member>
      <member name="unknown"
              value="7"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           Unknown, unable to determine presence for this contact, for example           if the protocol only allows presence of subscribed contacts.         ]]&gt;</doc>
      </member>
      <member name="error"
              value="8"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           Error, an error occurred while trying to determine presence.  The           message, if set, is an error from the server.         ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="ConnectionPrivate"
            c:type="TpConnectionPrivate"
            disguised="1">
    </record>
    <callback name="ConnectionRequestHandlesCb"
              c:type="TpConnectionRequestHandlesCb"
              deprecated="1">
      <doc xml:space="preserve">Signature of the callback called when tp_connection_request_handles()
succeeds or fails.

On success, the caller has a reference to each handle in @handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, they could be
released with tp_connection_unref_handles().

For convenience, the handle type and IDs requested by the caller are
passed through to this callback, so the caller does not have to include
them in @user_data.</doc>
      <doc-deprecated xml:space="preserve">See tp_connection_request_handles().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:space="preserve">the handle type that was passed to
 tp_connection_request_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:space="preserve">the number of IDs that were passed to
 tp_connection_request_handles() on success, or 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">the @n_handles
 handles corresponding to @ids, in the same order, or %NULL on failure</doc>
          <array length="2" zero-terminated="0" c:type="const TpHandle*">
            <type name="guint"/>
          </array>
        </parameter>
        <parameter name="ids" transfer-ownership="none">
          <doc xml:space="preserve">a copy of the array of
 @n_handles IDs that was passed to tp_connection_request_handles() on
 success, or %NULL on failure</doc>
          <array length="2" zero-terminated="0" c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="6">
          <doc xml:space="preserve">the same arbitrary pointer that was passed to
 tp_connection_request_handles()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the same object that was passed to
 tp_connection_request_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionStatus" c:type="TpConnectionStatus">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="connected"
              value="0"
              c:identifier="TP_CONNECTION_STATUS_CONNECTED">
        <doc xml:space="preserve">&lt;![CDATA[           The connection is fully connected and all methods are available.         ]]&gt;</doc>
      </member>
      <member name="connecting"
              value="1"
              c:identifier="TP_CONNECTION_STATUS_CONNECTING">
        <doc xml:space="preserve">&lt;![CDATA[           Connect has been called but the           connection has not yet been established. Some methods may fail           until the connection has been established.         ]]&gt;</doc>
      </member>
      <member name="disconnected"
              value="2"
              c:identifier="TP_CONNECTION_STATUS_DISCONNECTED">
        <doc xml:space="preserve">&lt;![CDATA[           If this is retrieved from GetStatus or           Status, it indicates that connection           has not yet been attempted. If seen in a           StatusChanged signal, it indicates           that the connection has failed; the Connection object SHOULD be           removed from D-Bus immediately, and all subsequent method calls           SHOULD fail.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="ConnectionStatusReason"
                 c:type="TpConnectionStatusReason">
      <doc xml:space="preserve">&lt;![CDATA[         A reason why the status of the connection changed. Apart from           Requested, the values of this enumeration only make sense as           reasons why the status changed to Disconnected.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none_specified"
              value="0"
              c:identifier="TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED">
        <doc xml:space="preserve">&lt;![CDATA[           There is no reason set for this state change. Unknown status             reasons SHOULD be treated like this reason.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Disconnected.         ]]&gt;</doc>
      </member>
      <member name="requested"
              value="1"
              c:identifier="TP_CONNECTION_STATUS_REASON_REQUESTED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is in response to a user request. Changes to the             Connecting or Connected status SHOULD always indicate this reason;             changes to the Disconnected status SHOULD indicate this reason             if and only if the disconnection was requested by the user.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cancelled.         ]]&gt;</doc>
      </member>
      <member name="network_error"
              value="2"
              c:identifier="TP_CONNECTION_STATUS_REASON_NETWORK_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There was an error sending or receiving on the network socket.            When the status changes from Connecting to Disconnected for this             reason, the equivalent D-Bus error is either             org.freedesktop.Telepathy.Error.NetworkError,             org.freedesktop.Telepathy.Error.ConnectionRefused,             org.freedesktop.Telepathy.Error.ConnectionFailed             or some more specific error.            When the status changes from Connected to Disconnected for this             reason, the equivalent D-Bus error is either             org.freedesktop.Telepathy.Error.NetworkError,             org.freedesktop.Telepathy.Error.ConnectionLost             or some more specific error.         ]]&gt;</doc>
      </member>
      <member name="authentication_failed"
              value="3"
              c:identifier="TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           The username or password was invalid.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.AuthenticationFailed.                    ]]&gt;</doc>
      </member>
      <member name="encryption_error"
              value="4"
              c:identifier="TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There was an error negotiating SSL on this connection, or             encryption was unavailable and require-encryption was set when the             connection was created.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.EncryptionNotAvailable             if encryption was not available at all, or             org.freedesktop.Telepathy.Error.EncryptionError             if encryption failed.         ]]&gt;</doc>
      </member>
      <member name="name_in_use"
              value="5"
              c:identifier="TP_CONNECTION_STATUS_REASON_NAME_IN_USE">
        <doc xml:space="preserve">&lt;![CDATA[           In general, this reason indicates that the requested account             name or other identification could not be used due to conflict             with another connection. It can be divided into three cases:                         If the status change is from Connecting to Disconnected               and the 'register' parameter to RequestConnection was present               and true, the requested account could not be created on the               server because it already exists.               The equivalent D-Bus error is               org.freedesktop.Telepathy.Error.RegistrationExists.                           If the status change is from Connecting to Disconnected               but the 'register' parameter is absent or false, the connection               manager could not connect to the specified account because               a connection to that account already exists.               The equivalent D-Bus error is               org.freedesktop.Telepathy.Error.AlreadyConnected.                                 In some protocols, like XMPP (when connecting with the same                 JID and resource as an existing connection), the existing                 connection "wins" and the new one fails to connect.                                          If the status change is from Connected to Disconnected,               the existing connection was automatically disconnected because               a new connection to the same account (perhaps from a different               client or location) was established.               The equivalent D-Bus error is               org.freedesktop.Telepathy.Error.ConnectionReplaced.                                 In some protocols, like MSNP (when connecting twice with the                 same Passport), the new connection "wins" and the                 existing one is automatically disconnected.                                                ]]&gt;</doc>
      </member>
      <member name="cert_not_provided"
              value="6"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED">
        <doc xml:space="preserve">&lt;![CDATA[           The server did not provide a SSL certificate.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.NotProvided.                    ]]&gt;</doc>
      </member>
      <member name="cert_untrusted"
              value="7"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate is signed by an untrusted certifying             authority. This error SHOULD NOT be used to represent a self-signed             certificate: use the more specific Cert_Self_Signed reason for             that.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Untrusted.                    ]]&gt;</doc>
      </member>
      <member name="cert_expired"
              value="8"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_EXPIRED">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate has expired.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Expired.                    ]]&gt;</doc>
      </member>
      <member name="cert_not_activated"
              value="9"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate is not yet valid.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.NotActivated.                    ]]&gt;</doc>
      </member>
      <member name="cert_hostname_mismatch"
              value="10"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate did not match its hostname.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.HostnameMismatch.                    ]]&gt;</doc>
      </member>
      <member name="cert_fingerprint_mismatch"
              value="11"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate does not have the expected             fingerprint.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.FingerprintMismatch.                    ]]&gt;</doc>
      </member>
      <member name="cert_self_signed"
              value="12"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate is self-signed.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.SelfSigned.                    ]]&gt;</doc>
      </member>
      <member name="cert_other_error"
              value="13"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There was some other error validating the server's SSL             certificate.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Invalid.                    ]]&gt;</doc>
      </member>
      <member name="cert_revoked"
              value="14"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_REVOKED">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate has been revoked.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Revoked.                    ]]&gt;</doc>
      </member>
      <member name="cert_insecure"
              value="15"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_INSECURE">
        <doc xml:space="preserve">&lt;![CDATA[           The server's SSL certificate uses an insecure algorithm, 	  or is cryptographically weak.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Insecure.                    ]]&gt;</doc>
      </member>
      <member name="cert_limit_exceeded"
              value="16"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_LIMIT_EXCEEDED">
        <doc xml:space="preserve">&lt;![CDATA[ 	  The length in bytes of the server certificate, or the depth of the 	  sever certificate chain exceed the limits imposed by the crypto 	  library.  	  When disconnected for this reason, the equivalent D-Bus error is 	    org.freedesktop.Telepathy.Error.Cert.LimitExceeded 	   	]]&gt;</doc>
      </member>
    </enumeration>
    <callback name="ConnectionUpgradeContactsCb"
              c:type="TpConnectionUpgradeContactsCb"
              version="0.7.18">
      <doc xml:space="preserve">Signature of a callback used to receive the result of
tp_connection_upgrade_contacts().

If an unrecoverable error occurs (for instance, if @connection becomes
disconnected) it is indicated by @error, but the contacts in @contacts
are still provided.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:space="preserve">The number of TpContact objects for which an upgrade was
 requested</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">An array of @n_contacts TpContact
 objects (this callback is
 not given an extra reference to any of these objects, and must call
 g_object_ref() on any that it will keep)</doc>
          <array length="1" zero-terminated="0" c:type="TpContact* const*">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">An unrecoverable error, or %NULL if the connection remains valid</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="4">
          <doc xml:space="preserve">the @user_data that was passed to
 tp_connection_upgrade_contacts()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the @weak_object that was passed to
 tp_connection_upgrade_contacts()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionWhenReadyCb"
              c:type="TpConnectionWhenReadyCb"
              deprecated="1"
              deprecated-version="0.17.6">
      <doc xml:space="preserve">Signature of a callback passed to tp_connection_call_when_ready(), which
will be called exactly once, when the connection becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection (which may be in the middle of being disposed,
 if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is
 TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%NULL if the connection is ready for use, or the error with which
 it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">whatever was passed to tp_connection_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Contact"
           c:symbol-prefix="contact"
           c:type="TpContact"
           version="0.7.18"
           parent="GObject.Object"
           glib:type-name="TpContact"
           glib:get-type="tp_contact_get_type"
           glib:type-struct="ContactClass">
      <doc xml:space="preserve">An object representing a contact on a #TpConnection.

Contact objects support tracking a number of attributes of contacts, as
described by the #TpContactFeature flags. Features can be specified when
instantiating contact objects (with tp_connection_get_contacts_by_id() or
tp_connection_get_contacts_by_handle()), or added to an existing contact
object with tp_connection_upgrade_contacts(). For example, a client wishing
to keep track of a contact's alias would set #TP_CONTACT_FEATURE_ALIAS, and
then listen for the "notify::alias" signal, emitted whenever the
#TpContact:alias property changes.

Note that releasing a #TpContact object might release handle references
held by calling tp_cli_connection_call_request_handles(),
tp_cli_connection_run_request_handles(),
tp_cli_connection_call_hold_handles(),
tp_cli_connection_run_hold_handles(),
tp_cli_connection_interface_contacts_call_get_contact_attributes() or
tp_cli_connection_interface_contacts_run_get_contact_attributes() directly.
Those functions should be avoided in favour of using #TpContact,
tp_connection_hold_handles(), tp_connection_request_handles() and
tp_connection_get_contact_attributes().</doc>
      <method name="add_to_group_async"
              c:identifier="tp_contact_add_to_group_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_add_to_group_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_finish"
              c:identifier="tp_contact_add_to_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_add_to_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_async"
              c:identifier="tp_contact_authorize_publication_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_authorize_publication_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_finish"
              c:identifier="tp_contact_authorize_publication_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_authorize_publication_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_async"
              c:identifier="tp_contact_block_async"
              version="0.17.0">
        <doc xml:space="preserve">Block communications with a contact, optionally reporting the contact as
abusive to the server administrators. To block more than one contact at once,
see tp_connection_block_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="report_abusive" transfer-ownership="none">
            <doc xml:space="preserve">If %TRUE, report this contact as abusive to the
server administrators as well as blocking him. See
#TpConnection:can-report-abusive to discover whether reporting abuse is
supported. If #TpConnection:can-report-abusive is %FALSE, this parameter will
be ignored.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_finish"
              c:identifier="tp_contact_block_finish"
              version="0.17.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_block_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_info"
              c:identifier="tp_contact_dup_contact_info"
              version="0.19.9">
        <doc xml:space="preserve">Returns a newly allocated #GList of contact's vCard fields. The list must be
freed with tp_contact_info_list_free() after used.

Same as the #TpContact:contact-info property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a #GList of #TpContactInfoField, or %NULL if the feature is not yet
 prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_location"
              c:identifier="tp_contact_dup_location"
              version="0.19.10">
        <doc xml:space="preserve">Return the contact's user-defined location, or %NULL if the location is
unspecified.

This function returns the same information as tp_contact_get_location(),
but in a different format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a variant of type %G_VARIANT_TYPE_VARDICT, the same as
 the #TpContact:location-vardict property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_contact_get_account"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpAccount of @self's #TpContact:connection.
See tp_connection_get_account() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a borrowed reference to @self's account
 (it must be referenced with g_object_ref if it must remain valid
 longer than the contact)</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alias"
              c:identifier="tp_contact_get_alias"
              version="0.7.18">
        <doc xml:space="preserve">Return the contact's alias. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same non-%NULL alias as the #TpContact:alias</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_avatar_file"
              c:identifier="tp_contact_get_avatar_file"
              version="0.11.6">
        <doc xml:space="preserve">Return the contact's avatar file. This remains valid until the main loop
is re-entered; if the caller requires a #GFile that will persist for
longer than that, it must be reffed with g_object_ref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same #GFile as the #TpContact:avatar-file property
 (possibly %NULL)</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_avatar_mime_type"
              c:identifier="tp_contact_get_avatar_mime_type"
              version="0.11.6">
        <doc xml:space="preserve">Return the contact's avatar MIME type. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same MIME type as the #TpContact:avatar-mime-type property
 (possibly %NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_avatar_token"
              c:identifier="tp_contact_get_avatar_token"
              version="0.7.18">
        <doc xml:space="preserve">Return the contact's avatar token. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same token as the #TpContact:avatar-token property
 (possibly %NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_contact_get_capabilities"
              version="0.11.3">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same #TpCapabilities (or %NULL) as the
#TpContact:capabilities property</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_types"
              c:identifier="tp_contact_get_client_types"
              version="0.13.1">
        <doc xml:space="preserve">Return the contact's client types or %NULL if the client types are
unspecified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same
 #GStrv as the #TpContact:client-types property</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tp_contact_get_connection"
              version="0.7.18">
        <doc xml:space="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a borrowed reference to the #TpContact:connection
 (it must be referenced with g_object_ref if it must remain valid
 longer than the contact)</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_groups"
              c:identifier="tp_contact_get_contact_groups"
              version="0.13.14">
        <doc xml:space="preserve">Return names of groups of which a contact is a member. It is incorrect to
call this method before %TP_CONTACT_FEATURE_CONTACT_GROUPS has been
prepared. This remains valid until the main loop is re-entered; if the caller
requires a #GStrv that will persist for longer than that, it must be copied
with g_strdupv().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same
 #GStrv as the #TpContact:contact-groups property</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact_info"
              c:identifier="tp_contact_get_contact_info"
              version="0.11.7"
              deprecated="1">
        <doc xml:space="preserve">Returns a newly allocated #GList of contact's vCard fields. The list must be
freed with g_list_free() after used.

Note that the #TpContactInfoField&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_copy().

Same as the #TpContact:contact-info property.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_contact_dup_contact_info() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a #GList of #TpContactInfoField, or %NULL if the feature is not yet
 prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handle"
              c:identifier="tp_contact_get_handle"
              version="0.7.18">
        <doc xml:space="preserve">Return the contact's handle, which is of type %TP_HANDLE_TYPE_CONTACT,
or 0 if the #TpContact:connection has become invalid.

This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as @self exists and the
#TpContact:connection remains valid.

However, the caller of this function does not gain an additional reference
to the handle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same handle as the #TpContact:handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_identifier"
              c:identifier="tp_contact_get_identifier"
              version="0.7.18">
        <doc xml:space="preserve">Return the contact's identifier. This remains valid for as long as @self
exists; if the caller requires a string that will persist for longer than
that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same non-%NULL identifier as the #TpContact:identifier property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_location"
              c:identifier="tp_contact_get_location"
              version="0.11.1">
        <doc xml:space="preserve">Return the contact's user-defined location or %NULL if the location is
unspecified.
This remains valid until the main loop is re-entered; if the caller
requires a hash table that will persist for longer than that, it must be
reffed with g_hash_table_ref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same
 #GHashTable (or %NULL) as the #TpContact:location property</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presence_message"
              c:identifier="tp_contact_get_presence_message"
              version="0.7.18">
        <doc xml:space="preserve">Return the contact's user-defined status message, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same non-%NULL message as the #TpContact:presence-message
 property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presence_status"
              c:identifier="tp_contact_get_presence_status"
              version="0.7.18">
        <doc xml:space="preserve">Return the name of the contact's presence status, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same non-%NULL status name as the #TpContact:presence-status
 property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presence_type"
              c:identifier="tp_contact_get_presence_type"
              version="0.7.18">
        <doc xml:space="preserve">If this object has been set up to track %TP_CONTACT_FEATURE_PRESENCE
and the underlying connection supports either the Presence or
SimplePresence interfaces, return the type of the contact's presence.

Otherwise, return %TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same presence type as the #TpContact:presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_publish_request"
              c:identifier="tp_contact_get_publish_request"
              version="0.13.12">
        <doc xml:space="preserve">If #TpContact:publish-state is set to %TP_SUBSCRIPTION_STATE_ASK, return the
message that this remote contact sent when they requested permission to see
the local user's presence, an empty string ("") otherwise. This remains valid
until the main loop is re-entered; if the caller requires a string that will
persist for longer than that, it must be copied with g_strdup().

This is set to %NULL until %TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been
prepared, and it is guaranteed to be non-%NULL afterward.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpContact:publish-request.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_publish_state"
              c:identifier="tp_contact_get_publish_state"
              version="0.13.12">
        <doc xml:space="preserve">Return the state of this remote contact's subscription to the local user's
presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpContact:publish-state.</doc>
          <type name="SubscriptionState" c:type="TpSubscriptionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subscribe_state"
              c:identifier="tp_contact_get_subscribe_state"
              version="0.13.12">
        <doc xml:space="preserve">Return the state of the local user's subscription to this remote contact's
presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpContact:subscribe-state.</doc>
          <type name="SubscriptionState" c:type="TpSubscriptionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_feature"
              c:identifier="tp_contact_has_feature"
              version="0.7.18">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @self has been set up to track the feature @feature</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a desired feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_blocked"
              c:identifier="tp_contact_is_blocked"
              version="0.17.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpContact:is-blocked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_async"
              c:identifier="tp_contact_remove_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_remove_contacts_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_contact_remove_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_remove_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_async"
              c:identifier="tp_contact_remove_from_group_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_remove_from_group_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_finish"
              c:identifier="tp_contact_remove_from_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_remove_from_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_async"
              c:identifier="tp_contact_request_contact_info_async"
              version="0.11.7">
        <doc xml:space="preserve">Requests an asynchronous request of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_contact_request_contact_info_finish() to get the result of the operation.

If the operation is successful, the #TpContact:contact-info property will be
updated (emitting "notify::contact-info" signal) before @callback is called.
That means you can call tp_contact_get_contact_info() to get the new vCard
inside @callback.

Note that requesting the vCard from the network can take significant time, so
a bigger timeout is set on the underlying D-Bus call. @cancellable can be
cancelled to free resources used in the D-Bus call if the caller is no longer
interested in the vCard.

If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on @self, it will be
set before its property gets updated and @callback is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_finish"
              c:identifier="tp_contact_request_contact_info_finish"
              version="0.11.7"
              throws="1">
        <doc xml:space="preserve">Finishes an async request of @self info. If the operation was successful,
the contact's vCard can be accessed using tp_contact_get_contact_info().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_async"
              c:identifier="tp_contact_request_subscription_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_request_subscription_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">an optional message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_finish"
              c:identifier="tp_contact_request_subscription_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_request_subscription_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_groups_async"
              c:identifier="tp_contact_set_contact_groups_async"
              version="0.13.14">
        <doc xml:space="preserve">Add @self to the given groups (creating new groups if necessary), and remove
it from all other groups. If the user is removed from a group of which they
were the only member, the group MAY be removed automatically. You can then
call tp_contact_set_contact_groups_finish() to get the result of the
operation.

If the operation is successful and %TP_CONTACT_FEATURE_CONTACT_GROUPS is
prepared, the #TpContact:contact-groups property will be
updated (emitting "notify::contact-groups" signal) and
#TpContact::contact-groups-changed signal will be emitted before @callback
is called. That means you can call tp_contact_get_contact_groups() to get the
new contact groups inside @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="n_groups" transfer-ownership="none">
            <doc xml:space="preserve">the number of groups, or -1 if @groups is %NULL-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="groups"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the set of
 groups which the contact should be in (may be %NULL if @n_groups is 0)</doc>
            <array length="0" zero-terminated="0" c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_groups_finish"
              c:identifier="tp_contact_set_contact_groups_finish"
              version="0.13.14"
              throws="1">
        <doc xml:space="preserve">Finishes an async set of @self contact groups.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_async"
              c:identifier="tp_contact_unblock_async"
              version="0.17.0">
        <doc xml:space="preserve">Unblock communications with a contact. To unblock more than one contact
at once, see tp_connection_unblock_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_finish"
              c:identifier="tp_contact_unblock_finish"
              version="0.17.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_unblock_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_async"
              c:identifier="tp_contact_unpublish_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_unpublish_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_finish"
              c:identifier="tp_contact_unpublish_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_unpublish_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_async"
              c:identifier="tp_contact_unsubscribe_async"
              version="0.15.5">
        <doc xml:space="preserve">Convenience wrapper for tp_connection_unsubscribe_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_finish"
              c:identifier="tp_contact_unsubscribe_finish"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Finishes tp_contact_unsubscribe_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="alias" transfer-ownership="none">
        <doc xml:space="preserve">The contact's alias if available, falling back to their
#TpContact:identifier if no alias is available or if the #TpContact has
not been set up to track %TP_CONTACT_FEATURE_ALIAS.

This alias may have been supplied by the contact themselves, or by the
local user, so it does not necessarily unambiguously identify the contact.
However, it is suitable for use as a main "display name" for the contact.

This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="avatar-file" version="0.11.6" transfer-ownership="none">
        <doc xml:space="preserve">#GFile to the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.

When #TpContact:avatar-token changes, this property is not updated
immediately, but will be updated when the new avatar data is retrieved and
stored in cache. Until then, the file will keep its old value of the latest
cached avatar image.

This is set to %NULL if %TP_CONTACT_FEATURE_AVATAR_DATA is not set on this
contact. Note that setting %TP_CONTACT_FEATURE_AVATAR_DATA will also
implicitly set %TP_CONTACT_FEATURE_AVATAR_TOKEN.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="avatar-mime-type"
                version="0.11.6"
                transfer-ownership="none">
        <doc xml:space="preserve">MIME type of the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.

This is always the MIME type of the image given by #TpContact:avatar-file.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="avatar-token" transfer-ownership="none">
        <doc xml:space="preserve">An opaque string representing state of the contact's avatar (depending on
the protocol, this might be a hash, a timestamp or something else), or
an empty string if there is no avatar.

This may be %NULL if it is not known whether this contact has an avatar
or not (either for network protocol reasons, or because this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_AVATAR_TOKEN).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="capabilities" version="0.11.3" transfer-ownership="none">
        <doc xml:space="preserve">The capabilities supported by this contact. If the underlying Connection
doesn't support the ContactCapabilities interface, this property will
contain the capabilities supported by the connection.
Use tp_capabilities_is_specific_to_contact() to check if the capabilities
are specific to this #TpContact or not.

This may be %NULL if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="client-types" version="0.13.1" transfer-ownership="none">
        <doc xml:space="preserve">A #GStrv containing the client types of this contact.

This is set to %NULL if %TP_CONTACT_FEATURE_CLIENT_TYPES is not
set on this contact; it may also be %NULL if that feature is prepared, but
the contact's client types are unknown.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="connection" transfer-ownership="none">
        <doc xml:space="preserve">The #TpConnection to which this contact belongs.</doc>
        <type name="Connection"/>
      </property>
      <property name="contact-groups"
                version="0.13.14"
                transfer-ownership="none">
        <doc xml:space="preserve">a #GStrv with names of groups of which a contact is a member.

This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_GROUPS is not prepared
on this contact, or if the connection does not implement ContactGroups
interface.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="contact-info" version="0.11.7" transfer-ownership="none">
        <doc xml:space="preserve">A #GList of #TpContactInfoField representing the vCard of this contact.

This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_INFO is not set on this
contact.</doc>
        <type name="ContactInfoList"/>
      </property>
      <property name="handle" transfer-ownership="none">
        <doc xml:space="preserve">The contact's handle in the Telepathy D-Bus API, a handle of type
%TP_HANDLE_TYPE_CONTACT representing the string
given by #TpContact:identifier.

This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as the #TpContact exists and the
#TpContact:connection remains valid.

However, getting this property does not cause an additional reference
to the handle to be held.

If the #TpContact:connection becomes invalid, this property is no longer
meaningful and will be set to 0.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:space="preserve">The contact's identifier in the instant messaging protocol (e.g.
XMPP JID, SIP URI, AOL screenname or IRC nick - whatever the underlying
protocol uses to identify a user).

This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="is-blocked" version="0.17.0" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the contact has been blocked.

This is set to %FALSE if %TP_CONTACT_FEATURE_CONTACT_BLOCKING is not
prepared on this contact, or if the connection does not implement
ContactBlocking interface.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="location"
                version="0.11.1"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">If this contact has set a user-defined location, a string to
#GValue * hash table containing his location. If not, %NULL.
tp_asv_get_string() and similar functions can be used to access
the contents.

This may be %NULL even if the contact has set a location,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_LOCATION.</doc>
        <type/>
      </property>
      <property name="location-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:space="preserve">If this contact has set a user-defined location, a string to
variant map containing his location. If not, %NULL.
tp_vardict_get_string() and similar functions can be used to access
the contents.

This may be %NULL even if the contact has set a location,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_LOCATION.

This property contains the same information as #TpContact:location,
in a different format.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="presence-message" transfer-ownership="none">
        <doc xml:space="preserve">If this contact has set a user-defined status message, that message;
if not, an empty string (which user interfaces may replace with a
localized form of the #TpContact:presence-status or
#TpContact:presence-type).

This may be an empty string even if the contact has set a message,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="presence-status" transfer-ownership="none">
        <doc xml:space="preserve">A string representing the presence status of this contact. This may be
a well-known string from the Telepathy specification, like "available",
or a connection-manager-specific string, like "out-to-lunch".

This may be an empty string if this #TpContact object has not been set up
to track %TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="presence-type" transfer-ownership="none">
        <doc xml:space="preserve">The #TpConnectionPresenceType representing the type of presence status
for this contact.

This is provided so even unknown values for #TpContact:presence-status
can be classified into their fundamental types.

This may be %TP_CONNECTION_PRESENCE_TYPE_UNSET if this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_PRESENCE.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="publish-request"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:space="preserve">The message that contact sent when they requested permission to see the
local user's presence, if #TpContact:publish-state is
%TP_SUBSCRIPTION_STATE_ASK, an empty string ("") otherwise.

This is set to %NULL until %TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been
prepared, and it is guaranteed to be non-%NULL afterward.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="publish-state"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpSubscriptionState indicating the state of this contact's subscription
to the local user's presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="subscribe-state"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpSubscriptionState indicating the state of the local user's
subscription to this contact's presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <glib:signal name="contact-groups-changed" when="last" version="0.13.14">
        <doc xml:space="preserve">Emitted when this contact's groups changes. When this signal is emitted,
#TpContact:contact-groups property is already updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">A #GStrv with added contact groups</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">A #GStrv with removed contact groups</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="presence-changed" when="last" version="0.11.7">
        <doc xml:space="preserve">Emitted when this contact's presence changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The new value of #TpContact:presence-type</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The new value of #TpContact:presence-status</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The new value of #TpContact:presence-message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="subscription-states-changed"
                   when="last"
                   version="0.13.12">
        <doc xml:space="preserve">Emitted when this contact's subscription states changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="subscribe" transfer-ownership="none">
            <doc xml:space="preserve">the new value of #TpContact:subscribe-state</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="publish" transfer-ownership="none">
            <doc xml:space="preserve">the new value of #TpContact:publish-state</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="publish_request" transfer-ownership="none">
            <doc xml:space="preserve">the new value of #TpContact:publish-request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ContactBlockingCapabilities"
              c:type="TpContactBlockingCapabilities">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="contact_blocking_capability_can_report_abusive"
              value="1"
              c:identifier="TP_CONTACT_BLOCKING_CAPABILITY_CAN_REPORT_ABUSIVE">
        <doc xml:space="preserve">&lt;![CDATA[           When calling BlockContacts, the           contacts may be reporting as abusive to the server administrators by           setting Report_Abusive to True.         ]]&gt;</doc>
      </member>
    </bitfield>
    <record name="ContactClass"
            c:type="TpContactClass"
            disguised="1"
            glib:is-gtype-struct-for="Contact">
    </record>
    <enumeration name="ContactFeature"
                 version="0.7.18"
                 c:type="TpContactFeature">
      <doc xml:space="preserve">Enumeration representing the features a #TpContact can optionally support.
When requesting a #TpContact, library users specify the desired features;
the #TpContact code will only initialize state for those features, to
avoid unwanted D-Bus round-trips and signal connections.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CONTACT_FEATURE.</doc>
      <member name="alias" value="0" c:identifier="TP_CONTACT_FEATURE_ALIAS">
        <doc xml:space="preserve">#TpContact:alias</doc>
      </member>
      <member name="avatar_token"
              value="1"
              c:identifier="TP_CONTACT_FEATURE_AVATAR_TOKEN">
        <doc xml:space="preserve">#TpContact:avatar-token</doc>
      </member>
      <member name="presence"
              value="2"
              c:identifier="TP_CONTACT_FEATURE_PRESENCE">
        <doc xml:space="preserve">#TpContact:presence-type,
 #TpContact:presence-status and #TpContact:presence-message</doc>
      </member>
      <member name="location"
              value="3"
              c:identifier="TP_CONTACT_FEATURE_LOCATION">
        <doc xml:space="preserve">#TpContact:location (available since 0.11.1)
 and #TpContact:location-vardict (since 0.19.10)</doc>
      </member>
      <member name="capabilities"
              value="4"
              c:identifier="TP_CONTACT_FEATURE_CAPABILITIES">
        <doc xml:space="preserve">#TpContact:capabilities
 (available since 0.11.3)</doc>
      </member>
      <member name="avatar_data"
              value="5"
              c:identifier="TP_CONTACT_FEATURE_AVATAR_DATA">
        <doc xml:space="preserve">#TpContact:avatar-file and
 #TpContact:avatar-mime-type. Implies %TP_CONTACT_FEATURE_AVATAR_TOKEN
 (available since 0.11.6)</doc>
      </member>
      <member name="contact_info"
              value="6"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_INFO">
        <doc xml:space="preserve">#TpContact:contact-info
 (available since 0.11.7)</doc>
      </member>
      <member name="client_types"
              value="7"
              c:identifier="TP_CONTACT_FEATURE_CLIENT_TYPES">
        <doc xml:space="preserve">#TpContact:client-types
 (available since 0.13.1)</doc>
      </member>
      <member name="subscription_states"
              value="8"
              c:identifier="TP_CONTACT_FEATURE_SUBSCRIPTION_STATES">
        <doc xml:space="preserve">#TpContact:subscribe-state,
 #TpContact:publish-state and #TpContact:publish-request. Require a
 Connection implementing the %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST
 interface. (available since 0.13.12)</doc>
      </member>
      <member name="contact_groups"
              value="9"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_GROUPS">
        <doc xml:space="preserve">#TpContact:contact-groups
 (available since 0.13.14)</doc>
      </member>
      <member name="contact_blocking"
              value="10"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_BLOCKING">
        <doc xml:space="preserve">#TpContact:is-blocked. Require
 Connection implementing the %TP_IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING
 interface. (available since 0.17.0)</doc>
      </member>
    </enumeration>
    <record name="ContactInfoField"
            c:type="TpContactInfoField"
            version="0.11.7"
            glib:type-name="TpContactInfoField"
            glib:get-type="tp_contact_info_field_get_type"
            c:symbol-prefix="contact_info_field">
      <doc xml:space="preserve">A structure representing an information about a contact. Similar to a vCard
field.</doc>
      <field name="field_name" writable="1">
        <doc xml:space="preserve">The name of the field; this is the lowercased name of a vCard
 field. For example, a field representing a contact's address would be named
 "adr".</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <doc xml:space="preserve">A list of vCard type parameters applicable to this field,
 with their values. The type parameter names, and any values that are
 case-insensitive in vCard, MUST be in lower case. For example, a contact's
 preferred home address would have parameters 'type=home' and 'type=pref'.</doc>
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="field_value" writable="1">
        <doc xml:space="preserve">For unstructured vCard fields (such as 'fn', a formatted name
 field), a single-element array containing the field's value. For structured
 fields (such as 'adr', an address field), an array corresponding to the
 semicolon-separated elements of the field (with empty strings for empty
 elements).</doc>
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_contact_info_field_new"
                   version="0.11.7">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpContactInfoField, free it with
tp_contact_info_field_free()</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the field; this is the lowercased name of a vCard
 field. For example, a field representing a contact's address would be named
 "adr".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">A list of vCard type parameters applicable to this field,
 with their values. The type parameter names, and any values that are
 case-insensitive in vCard, MUST be in lower case. For example, a contact's
 preferred home address would have parameters 'type=home' and 'type=pref'.</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="field_value" transfer-ownership="none">
            <doc xml:space="preserve">For unstructured vCard fields (such as 'fn', a formatted name
 field), a single-element array containing the field's value. For structured
 fields (such as 'adr', an address field), an array corresponding to the
 semicolon-separated elements of the field (with empty strings for empty
 elements).</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="tp_contact_info_field_copy"
              version="0.11.7"
              introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpContactInfoField, free it with
 tp_contact_info_field_free()</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactInfoField</doc>
            <type name="ContactInfoField" c:type="const TpContactInfoField*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="tp_contact_info_field_free"
              version="0.11.7"
              introspectable="0">
        <doc xml:space="preserve">Free all memory used by the #TpContactInfoField.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactInfoField</doc>
            <type name="ContactInfoField" c:type="TpContactInfoField*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags describing the behaviour of a vCard field.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="parameters_exact"
              value="1"
              c:identifier="TP_CONTACT_INFO_FIELD_FLAG_PARAMETERS_EXACT">
        <doc xml:space="preserve">&lt;![CDATA[           If present, exactly the parameters indicated must be set on this             field; in the case of an empty list of parameters, this implies that             parameters may not be used.            If absent, and the list of allowed parameters is non-empty,             any (possibly empty) subset of that list may be             used.            If absent, and the list of allowed parameters is empty,             any parameters may be used.         ]]&gt;</doc>
      </member>
      <member name="overwritten_by_nickname"
              value="2"
              c:identifier="TP_CONTACT_INFO_FIELD_FLAG_OVERWRITTEN_BY_NICKNAME">
        <doc xml:space="preserve">&lt;![CDATA[           Indicates that this field will be overwritten when the user's alias             is changed with SetAliases             or when the Account's Nickname             is updated.  Clients that allow the editing of the Alias and the             ContactInfo in the same location should hide fields with this flag.                        If a client allowed the user to edit both the nickname and the               ContactInfo field at the same time, the user could set them to two               different values even though they map to the same property.  This               would result in surprising behavior where the second value would               win over the first.                      In addition to hiding this field when editing ContactInfo together             with the user's nickname, it is recommended that clients call             SetContactInfo before setting the             user's nickname.                        This ensures that if the user changes the nickname, the correct               value will get set even if the stale nickname is mistakenly sent               along with SetContactInfo.                      If used, this flag typically appears on either the 'nickname' or             'fn' field.         ]]&gt;</doc>
      </member>
    </bitfield>
    <record name="ContactInfoFieldSpec"
            c:type="TpContactInfoFieldSpec"
            version="0.11.7"
            glib:type-name="TpContactInfoFieldSpec"
            glib:get-type="tp_contact_info_field_spec_get_type"
            c:symbol-prefix="contact_info_field_spec">
      <doc xml:space="preserve">A struct describing a vCard field.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the field; this is the lowercased name of a vCard
 field. For example, a field representing a contact's address would be named
 "adr".</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <doc xml:space="preserve">The set of vCard type parameters which may be set on this field.
 If this list is empty and the #TP_CONTACT_INFO_FIELD_FLAG_PARAMETERS_EXACT
 flag is not set, any vCard type parameters may be used. The type parameter
 names, and any values that are case-insensitive in vCard, MUST be in lower
 case. For example, a contact's preferred home address would have parameters
 'type=home' and 'type=pref'.</doc>
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Flags describing the behaviour of this field.</doc>
        <type name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags"/>
      </field>
      <field name="max" writable="1">
        <doc xml:space="preserve">Maximum number of instances of this field which may be set.
 #G_MAXUINT32 is used to indicate that there is no limit.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="tp_contact_info_field_spec_copy"
              version="0.11.7"
              introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TpContactInfoFieldSpec, free it with
 tp_contact_info_field_spec_free()</doc>
          <type name="ContactInfoFieldSpec" c:type="TpContactInfoFieldSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactInfoFieldSpec</doc>
            <type name="ContactInfoFieldSpec"
                  c:type="const TpContactInfoFieldSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="tp_contact_info_field_spec_free"
              version="0.11.7"
              introspectable="0">
        <doc xml:space="preserve">Free all memory used by the #TpContactInfoFieldSpec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactInfoFieldSpec</doc>
            <type name="ContactInfoFieldSpec"
                  c:type="TpContactInfoFieldSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="ContactInfoFlags" c:type="TpContactInfoFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags defining the behaviour of contact information on this protocol.         Some protocols provide no information on contacts without an explicit         request; others always push information to the connection manager as         and when it changes.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="can_set"
              value="1"
              c:identifier="TP_CONTACT_INFO_FLAG_CAN_SET">
        <doc xml:space="preserve">&lt;![CDATA[           Indicates that SetContactInfo is           supported on this connection.         ]]&gt;</doc>
      </member>
      <member name="push" value="2" c:identifier="TP_CONTACT_INFO_FLAG_PUSH">
        <doc xml:space="preserve">&lt;![CDATA[           Indicates that the protocol pushes all contacts' information to the           connection manager without prompting. If set,           ContactInfoChanged will be emitted           whenever contacts' information changes.         ]]&gt;</doc>
      </member>
    </bitfield>
    <glib:boxed glib:name="ContactInfoList"
                c:symbol-prefix="contact_info_list"
                glib:type-name="TpContactInfoList"
                glib:get-type="tp_contact_info_list_get_type">
      <function name="copy"
                c:identifier="tp_contact_info_list_copy"
                version="0.11.7"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value>
          <doc xml:space="preserve">a new #GList of newly allocated #TpContactInfoField, free it with
 tp_contact_info_list_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free"
                c:identifier="tp_contact_info_list_free"
                version="0.11.7"
                introspectable="0">
        <doc xml:space="preserve">Free all memory used by the #GList and its elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <glib:boxed glib:name="ContactInfoSpecList"
                c:symbol-prefix="contact_info_spec_list"
                glib:type-name="TpContactInfoSpecList"
                glib:get-type="tp_contact_info_spec_list_get_type">
      <function name="copy"
                c:identifier="tp_contact_info_spec_list_copy"
                version="0.11.7"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value>
          <doc xml:space="preserve">a new #GList of newly allocated #TpContactInfoFieldSpec,
 free it with tp_contact_info_spec_list_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpContactInfoFieldSpec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free"
                c:identifier="tp_contact_info_spec_list_free"
                version="0.11.7"
                introspectable="0">
        <doc xml:space="preserve">Free all memory used by the #GList and its elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #TpContactInfoFieldSpec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <enumeration name="ContactListState" c:type="TpContactListState">
      <doc xml:space="preserve">&lt;![CDATA[         The progress made in retrieving the contact list.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_CONTACT_LIST_STATE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[The connection has not started to retrieve the contact           list. If GetContactListAttributes is           called in this state, it will raise NotYet.]]&gt;</doc>
      </member>
      <member name="waiting"
              value="1"
              c:identifier="TP_CONTACT_LIST_STATE_WAITING">
        <doc xml:space="preserve">&lt;![CDATA[The connection has started to retrieve the contact           list, but has not yet succeeded or failed.           If GetContactListAttributes is called           in this state, it will raise NotYet.]]&gt;</doc>
      </member>
      <member name="failure"
              value="2"
              c:identifier="TP_CONTACT_LIST_STATE_FAILURE">
        <doc xml:space="preserve">&lt;![CDATA[           The connection has tried and failed to retrieve the contact             list. If GetContactListAttributes             is called in this state, it will immediately raise an error             indicating the reason for failure.            The connection manager SHOULD try again to obtain the contact             list, if appropriate for the protocol. If it succeeds later,             the ContactListState MUST advance             to Success.         ]]&gt;</doc>
      </member>
      <member name="success"
              value="3"
              c:identifier="TP_CONTACT_LIST_STATE_SUCCESS">
        <doc xml:space="preserve">&lt;![CDATA[The connection has successfully retrieved the contact           list. If GetContactListAttributes           is called in this state, it will return successfully.]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="ContactMetadataStorageType"
                 c:type="TpContactMetadataStorageType">
      <doc xml:space="preserve">&lt;![CDATA[         Values of this enumeration indicate the extent to which metadata           such as aliases and group memberships can be stored for the contacts           on a particular connection.          On some protocols, certain metadata (for instance, contact aliases)           can only be stored for contacts on the contact list, or contacts           with a particular contact list state.          To make it easier to deal with such protocols, if clients set           metadata on a contact who is not in the required state, the           Connection MUST cache the metadata for the duration of the session.           If clients request the attributes of that contact after the           appropriate "set" method has returned successfully, the Connection           MUST return the new (cached) value.          If the contact is later placed in the required state to store           metadata (for instance, if subscription to the contact's presence           is requested, on a protocol like MSN where the alias has storage type           Subscribed_Or_Pending), the connection MUST store the cached           metadata at that time.                     If the Connection didn't cache changes in this way, a client             intending to change the alias on MSN would have to wait until             the server acknowledged the subscription request; in the meantime,             other clients would still display the old alias.                   The only exception to that general rule is that if the Connection           cannot store particular metadata at all (i.e. the           storage type is None), it MUST reject attempts to set it.                     If the implementation knows that metadata can't be stored at             all, it's useful to report that, which can be done             synchronously. In general, user interfaces should detect             storage type None and not display editing controls at all.                ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           This connection cannot store this type of metadata at all, and             attempting to do so will fail with NotImplemented.                         Link-local XMPP can't store aliases or group memberships at               all, and subscription and presence states are implicit (all               contacts on the local network have subscribe = publish = Yes               and no other contacts exist).              As of April 2010, the XMPP server for Facebook Chat provides a               read-only view of the user's Facebook contacts, so it could also               usefully have this storage type.                    ]]&gt;</doc>
      </member>
      <member name="subscribed_or_pending"
              value="1"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_SUBSCRIBED_OR_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           This type of metadata can only be stored permanently for contacts             whose subscribe attribute is Ask or Yes.                         Contact aliases and groups on MSN have this behaviour.                    ]]&gt;</doc>
      </member>
      <member name="subscribed"
              value="2"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_SUBSCRIBED">
        <doc xml:space="preserve">&lt;![CDATA[           This type of metadata can only be stored permanently for contacts             whose subscribe attribute is Yes.                         No service with this behaviour is currently known, but it's a               stricter form of Subscribed_Or_Pending.                    ]]&gt;</doc>
      </member>
      <member name="anyone"
              value="3"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_ANYONE">
        <doc xml:space="preserve">&lt;![CDATA[           The user can set this metadata for any valid contact identifier,             whether or not they have any presence subscription relationship             to it, and it will be stored on their contact list.                         Contact aliases and groups on XMPP have this behaviour; it               is possible to put a contact in a group, or assign an alias               to them, without requesting that presence be shared.                    ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="ContactPrivate" c:type="TpContactPrivate" disguised="1">
    </record>
    <class name="ContactSearch"
           c:symbol-prefix="contact_search"
           c:type="TpContactSearch"
           version="0.13.11"
           parent="GObject.Object"
           glib:type-name="TpContactSearch"
           glib:get-type="tp_contact_search_get_type"
           glib:type-struct="ContactSearchClass">
      <doc xml:space="preserve">An object for Telepathy contact searches.
There are no interesting public struct fields.</doc>
      <implements name="Gio.AsyncInitable"/>
      <constructor name="new_finish"
                   c:identifier="tp_contact_search_new_finish"
                   version="0.13.11"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new contact search object, or %NULL
in case of error.</doc>
          <type name="ContactSearch" c:type="TpContactSearch*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async"
                c:identifier="tp_contact_search_new_async"
                version="0.13.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">an account for the contact search</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">the server on which to search for contacts, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:space="preserve">The maximum number of results the server should return,
or 0 for the server default.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization
is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_account"
              c:identifier="tp_contact_search_get_account"
              version="0.13.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The TpContactSearch:account property</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact search object</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limit"
              c:identifier="tp_contact_search_get_limit"
              version="0.13.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The TpContactSearch:limit property</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact search object</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_search_keys"
              c:identifier="tp_contact_search_get_search_keys"
              version="0.13.11">
        <doc xml:space="preserve">Get the search keys for a contact search.
The keys are vCard field names in lower case, except when
they're one of the special cases from telepathy-spec like
"tel;cell" or "x-n-given". See the
&lt;ulink url="http://telepathy.freedesktop.org/spec/Channel_Type_Contact_Search.html"&gt;
Channel.Type.ContactSearch interface&lt;/ulink&gt;
for a list of the special cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new search keys, or %NULL.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the contact search object to get the keys from</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_server"
              c:identifier="tp_contact_search_get_server"
              version="0.13.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The TpContactSearch:server property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a contact search object</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset_async"
              c:identifier="tp_contact_search_reset_async"
              version="0.13.11">
        <doc xml:space="preserve">Resets the contact search object so a new search can be performed.
If another tp_contact_search_reset_async() call is in progress,
it will be cancelled and tp_contact_search_reset_finish() will
return an appropriate error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #TpContactSearch to reset</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">the server on which to search for contacts, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:space="preserve">The maximum number of results the server should return,
or 0 for the server default.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization
is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_finish"
              c:identifier="tp_contact_search_reset_finish"
              version="0.13.11"
              throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new search keys, or %NULL
in case of error.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #TpContactSearch that is being reset</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start"
              c:identifier="tp_contact_search_start"
              version="0.13.11">
        <doc xml:space="preserve">Starts a search for the keys specified in @criteria. Connect
to the #TpContactSearch::search-results-received signal
before calling this function.

Before searching again on the same #TpContactSearch, you must
call tp_contact_search_reset_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactSearch</doc>
            <type name="ContactSearch" c:type="TpContactSearch*"/>
          </instance-parameter>
          <parameter name="criteria" transfer-ownership="none">
            <doc xml:space="preserve">a map
from keys returned by tp_contact_search_get_search_keys()
to values to search for</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.13.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">This search's account.</doc>
        <type name="Account"/>
      </property>
      <property name="limit"
                version="0.13.11"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The maximum number of results that the server should return.
This is only supported by some protocols; use
tp_capabilities_supports_contact_search() to check if it's
supported.

To change the limit after the object has been constructed,
use tp_contact_search_reset_async().</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="server"
                version="0.13.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The search server. This is only supported by some protocols;
use tp_capabilities_supports_contact_search() to check if it's
supported.

To change the server after the object has been constructed,
use tp_contact_search_reset_async().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" version="0.13.11" transfer-ownership="none">
        <doc xml:space="preserve">This search's state, as a %TpChannelContactSearchState.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContactSearchPrivate" c:type="TpContactSearchPrivate*"/>
      </field>
      <glib:signal name="search-results-received"
                   when="last"
                   version="0.13.11">
        <doc xml:space="preserve">Emitted when search results are received. Note that this signal may
be emitted multiple times for the same search.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="results" transfer-ownership="none">
            <doc xml:space="preserve">
a #GList with the search results</doc>
            <type name="GLib.List" c:type="gpointer">
              <type name="ContactSearchResult"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ContactSearchClass"
            c:type="TpContactSearchClass"
            glib:is-gtype-struct-for="ContactSearch"
            version="0.13.11">
      <doc xml:space="preserve">The class of a #TpContactSearch.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="ContactSearchPrivate"
            c:type="TpContactSearchPrivate"
            disguised="1">
    </record>
    <class name="ContactSearchResult"
           c:symbol-prefix="contact_search_result"
           c:type="TpContactSearchResult"
           version="0.13.11"
           parent="GObject.Object"
           glib:type-name="TpContactSearchResult"
           glib:get-type="tp_contact_search_result_get_type"
           glib:type-struct="ContactSearchResultClass">
      <doc xml:space="preserve">An object representing the results of a Telepathy contact
search channel.
There are no interesting public struct fields.</doc>
      <method name="dup_fields"
              c:identifier="tp_contact_search_result_dup_fields"
              version="0.19.9">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a #GList of #TpContactInfoField for the specified contact. You should free
 it when you're done with tp_contact_info_list_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a search result</doc>
            <type name="ContactSearchResult" c:type="TpContactSearchResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_field"
              c:identifier="tp_contact_search_result_get_field"
              version="0.13.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the specified field, or %NULL if the
result doesn't have it.</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactSearchResult</doc>
            <type name="ContactSearchResult" c:type="TpContactSearchResult*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the name of the field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fields"
              c:identifier="tp_contact_search_result_get_fields"
              deprecated="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_contact_search_result_dup_fields() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
 a #GList of #TpContactInfoField for the specified contact. You should free
 it when you're done with g_list_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a search result</doc>
            <type name="ContactSearchResult" c:type="TpContactSearchResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_identifier"
              c:identifier="tp_contact_search_result_get_identifier"
              version="0.13.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the contact identifier.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContactSearchResult</doc>
            <type name="ContactSearchResult" c:type="TpContactSearchResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="identifier"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContactSearchResultPrivate"
              c:type="TpContactSearchResultPrivate*"/>
      </field>
    </class>
    <record name="ContactSearchResultClass"
            c:type="TpContactSearchResultClass"
            glib:is-gtype-struct-for="ContactSearchResult"
            version="0.13.11">
      <doc xml:space="preserve">The class of a #TpContactSearchResult.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="ContactSearchResultPrivate"
            c:type="TpContactSearchResultPrivate"
            disguised="1">
    </record>
    <record name="ContactsMixin" c:type="TpContactsMixin">
      <doc xml:space="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="ContactsMixinPrivate" c:type="TpContactsMixinPrivate*"/>
      </field>
      <function name="add_contact_attributes_iface"
                c:identifier="tp_contacts_mixin_add_contact_attributes_iface"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">Name of the interface that has ContactAttributes</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fill_contact_attributes" transfer-ownership="none">
            <doc xml:space="preserve">Contact attribute filler function</doc>
            <type name="ContactsMixinFillContactAttributesFunc"
                  c:type="TpContactsMixinFillContactAttributesFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_contacts_mixin_finalize"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">Free resources held by the contacts mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object with this mixin.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_contact_attributes"
                c:identifier="tp_contacts_mixin_get_contact_attributes"
                introspectable="0">
        <doc xml:space="preserve">Get contact attributes for the given contacts. Provide attributes for all requested
interfaces. If contact attributes are not immediately known, the behaviour is defined
by the interface; the attribute should either be omitted from the result or replaced
with a default value.</doc>
        <return-value>
          <doc xml:space="preserve">A dictionary mapping the contact handles to contact attributes.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">A connection instance that uses this mixin. The connection must be connected.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:space="preserve">List of handles to retrieve contacts for. Any invalid handles will be
dropped from the returned mapping.</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:space="preserve">A list of interfaces to retrieve attributes from.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="assumed_interfaces" transfer-ownership="none">
            <doc xml:space="preserve">A list of additional interfaces to retrieve attributes
 from. This can be used for interfaces documented as automatically included,
 like %TP_IFACE_CONNECTION for GetContactAttributes,
 or %TP_IFACE_CONNECTION and %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST for
 GetContactListAttributes.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="sender" transfer-ownership="none">
            <doc xml:space="preserve">The DBus client's unique name. If this is not NULL, the requested handles
will be held on behalf of this client.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_contacts_mixin_get_offset_quark"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="iface_init"
                c:identifier="tp_contacts_mixin_iface_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object
class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_contacts_mixin_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
                    G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_contact_attribute"
                c:identifier="tp_contacts_mixin_set_contact_attribute"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact_attributes" transfer-ownership="none">
            <doc xml:space="preserve">contacts attribute hash as passed to
  TpContactsMixinFillContactAttributesFunc</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">Handle to set the attribute on</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">attribute name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">slice allocated GValue containing the value of the attribute, for
instance with tp_g_value_slice_new. Ownership of the GValue is taken over by
the mixin</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContactsMixinClass" c:type="TpContactsMixinClass">
      <doc xml:space="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_class_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="ContactsMixinClassPrivate"
              c:type="TpContactsMixinClassPrivate*"/>
      </field>
      <function name="get_offset_quark"
                c:identifier="tp_contacts_mixin_class_get_offset_quark"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_contacts_mixin_class_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:space="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
                         G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of the implementation that uses this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The byte offset of the TpContactsMixinClass within the class
         structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContactsMixinClassPrivate"
            c:type="TpContactsMixinClassPrivate"
            disguised="1">
    </record>
    <callback name="ContactsMixinFillContactAttributesFunc"
              c:type="TpContactsMixinFillContactAttributesFunc"
              introspectable="0">
      <doc xml:space="preserve">This function is called to supply contact attributes pertaining to
a particular interface, for a list of contacts.
All the handles in @contacts are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the Contacts interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">The contact handles for which attributes are requested</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="attributes_hash" transfer-ownership="none">
          <doc xml:space="preserve">hash of handle =&gt; hash of attributes, containing all the
contacts in the contacts array</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </callback>
    <record name="ContactsMixinPrivate"
            c:type="TpContactsMixinPrivate"
            disguised="1">
    </record>
    <class name="DBusDaemon"
           c:symbol-prefix="dbus_daemon"
           c:type="TpDBusDaemon"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpDBusDaemon"
           glib:get-type="tp_dbus_daemon_get_type"
           glib:type-struct="DBusDaemonClass">
      <doc xml:space="preserve">A subclass of #TpProxy that represents the D-Bus daemon. It mainly provides
functionality to manage well-known names on the bus.</doc>
      <constructor name="new"
                   c:identifier="tp_dbus_daemon_new"
                   version="0.7.1"
                   introspectable="0">
        <doc xml:space="preserve">Returns a proxy for signals and method calls on a particular bus
connection.

Use tp_dbus_daemon_dup() instead if you just want a connection to the
starter or session bus (which is almost always the right thing for
Telepathy).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new proxy for signals and method calls on the bus daemon
 to which @connection is connected</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a connection to D-Bus</doc>
            <type c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dup"
                c:identifier="tp_dbus_daemon_dup"
                version="0.7.26"
                throws="1">
        <doc xml:space="preserve">Returns a proxy for signals and method calls on the D-Bus daemon on which
this process was activated (if it was launched by D-Bus service
activation), or the session bus (otherwise).

If it is not possible to connect to the appropriate bus, raise an error
and return %NULL.

The returned #TpDBusDaemon is cached; the same #TpDBusDaemon object will
be returned by this function repeatedly, as long as at least one reference
exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to a proxy for signals and method
 calls on the bus daemon, or %NULL</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_dbus_daemon_init_known_interfaces"
                version="0.7.32">
        <doc xml:space="preserve">Ensure that the known interfaces for TpDBusDaemon have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_DBUS_DAEMON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="cancel_name_owner_watch"
              c:identifier="tp_dbus_daemon_cancel_name_owner_watch"
              version="0.7.1"
              introspectable="0">
        <doc xml:space="preserve">If there was a previous call to tp_dbus_daemon_watch_name_owner()
with exactly the given @name, @callback and @user_data, remove it.

If more than one watch matching the details provided was active, remove
only the most recently added one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if there was such a watch, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name that was being watched</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">the callback that was called</doc>
            <type name="DBusDaemonNameOwnerChangedCb"
                  c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the user data that was provided</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unique_name"
              c:identifier="tp_dbus_daemon_get_unique_name"
              version="0.7.35">
        <doc xml:space="preserve">&lt;!-- Returns: is enough --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the unique name of this connection to the bus, which is valid for
 as long as this #TpDBusDaemon is</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">object representing a connection to a bus</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_activatable_names"
              c:identifier="tp_dbus_daemon_list_activatable_names"
              version="0.7.35">
        <doc xml:space="preserve">Call the ListActivatableNames method on the bus daemon, asynchronously.
The @callback will be called from the main loop with a list of all the
well-known names that are available for service-activation on the bus.

In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_activatable_names(), since
that function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">object representing a connection to a bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:space="preserve">timeout for the call</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb"
                  c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">if not %NULL, called with @user_data as argument after the call
 has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, a GObject which will be weakly referenced; if
 it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_names"
              c:identifier="tp_dbus_daemon_list_names"
              version="0.7.35">
        <doc xml:space="preserve">Call the ListNames method on the bus daemon, asynchronously. The @callback
will be called from the main loop with a list of all the names (either
unique or well-known) that exist on the bus.

In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_names(), since that
function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">object representing a connection to a bus</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:space="preserve">timeout for the call</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb"
                  c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">if not %NULL, called with @user_data as argument after the call
 has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:space="preserve">if not %NULL, a GObject which will be weakly referenced; if
 it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_object"
              c:identifier="tp_dbus_daemon_register_object"
              version="0.11.3">
        <doc xml:space="preserve">Export @object at @object_path. This is a convenience wrapper around
dbus_g_connection_register_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">object representing a connection to a bus</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">an object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object to export</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_name"
              c:identifier="tp_dbus_daemon_release_name"
              version="0.7.30"
              throws="1">
        <doc xml:space="preserve">Release the given well-known name. This makes a synchronous call to the bus
daemon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @well_known_name was released, or %FALSE and sets @error
         if an error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TpDBusDaemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:space="preserve">a well-known name owned by this process to release</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_name"
              c:identifier="tp_dbus_daemon_request_name"
              version="0.7.30"
              throws="1">
        <doc xml:space="preserve">Claim the given well-known name without queueing, allowing replacement
or replacing an existing name-owner. This makes a synchronous call to the
bus daemon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @well_known_name was claimed, or %FALSE and sets @error if
         an error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TpDBusDaemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:space="preserve">a well-known name to acquire</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="idempotent" transfer-ownership="none">
            <doc xml:space="preserve">whether to consider it to be a success if this process
             already owns the name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_object"
              c:identifier="tp_dbus_daemon_unregister_object"
              version="0.11.3">
        <doc xml:space="preserve">Stop exporting @object on D-Bus. This is a convenience wrapper around
dbus_g_connection_unregister_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">object representing a connection to a bus</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object previously exported
with tp_dbus_daemon_register_object()</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="watch_name_owner"
              c:identifier="tp_dbus_daemon_watch_name_owner"
              version="0.7.1">
        <doc xml:space="preserve">Arrange for @callback to be called with the owner of @name as soon as
possible (which might even be before this function returns!), then
again every time the ownership of @name changes.

If multiple watches are registered for the same @name, they will be called
in the order they were registered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name whose ownership is to be watched</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">Callback to call when the ownership is discovered or changes</doc>
            <type name="DBusDaemonNameOwnerChangedCb"
                  c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Arbitrary data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">Called to destroy @user_data when the name owner watch is
 cancelled due to tp_dbus_daemon_cancel_name_owner_watch()</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusDaemonClass"
            c:type="TpDBusDaemonClass"
            disguised="1"
            glib:is-gtype-struct-for="DBusDaemon"
            version="0.7.1">
      <doc xml:space="preserve">The class of #TpDBusDaemon.</doc>
    </record>
    <callback name="DBusDaemonListNamesCb"
              c:type="TpDBusDaemonListNamesCb"
              version="0.7.35">
      <doc xml:space="preserve">Signature of a callback for functions that list bus names.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:space="preserve">object representing a connection to a bus</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="names" transfer-ownership="none">
          <doc xml:space="preserve">constant %NULL-terminated array of constant strings representing
 bus names, or %NULL on error</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">the error that occurred, or %NULL on success</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">the same user data that was passed to
 tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:space="preserve">the same object that was passed to
 tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusDaemonNameOwnerChangedCb"
              c:type="TpDBusDaemonNameOwnerChangedCb"
              version="0.7.1">
      <doc xml:space="preserve">The signature of the callback called by tp_dbus_daemon_watch_name_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:space="preserve">The D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name whose ownership has changed or been discovered</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="new_owner" transfer-ownership="none">
          <doc xml:space="preserve">The unique name that now owns @name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">Arbitrary user-supplied data as passed to
 tp_dbus_daemon_watch_name_owner()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusDaemonPrivate"
            c:type="TpDBusDaemonPrivate"
            disguised="1">
    </record>
    <enumeration name="DBusError" version="0.7.1" c:type="TpDBusError">
      <doc xml:space="preserve">#GError codes for use with the %TP_DBUS_ERRORS domain.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_DBUS_ERROR.</doc>
      <member name="unknown_remote_error"
              value="0"
              c:identifier="TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR">
        <doc xml:space="preserve">Raised if the error raised by
 a remote D-Bus object is not recognised</doc>
      </member>
      <member name="proxy_unreferenced"
              value="1"
              c:identifier="TP_DBUS_ERROR_PROXY_UNREFERENCED">
        <doc xml:space="preserve">Emitted in #TpProxy::invalidated
 when the #TpProxy has lost its last reference</doc>
      </member>
      <member name="no_interface"
              value="2"
              c:identifier="TP_DBUS_ERROR_NO_INTERFACE">
        <doc xml:space="preserve">Raised by #TpProxy methods if the remote
 object does not appear to have the required interface</doc>
      </member>
      <member name="name_owner_lost"
              value="3"
              c:identifier="TP_DBUS_ERROR_NAME_OWNER_LOST">
        <doc xml:space="preserve">Emitted in #TpProxy::invalidated if the
 remote process loses ownership of its bus name, and raised by
 any #TpProxy methods that have not had a reply at that time or are called
 after the proxy becomes invalid in this way (usually meaning it crashed)</doc>
      </member>
      <member name="invalid_bus_name"
              value="4"
              c:identifier="TP_DBUS_ERROR_INVALID_BUS_NAME">
        <doc xml:space="preserve">Raised if a D-Bus bus name given is not
 valid, or is of an unacceptable type (e.g. well-known vs. unique)</doc>
      </member>
      <member name="invalid_interface_name"
              value="5"
              c:identifier="TP_DBUS_ERROR_INVALID_INTERFACE_NAME">
        <doc xml:space="preserve">Raised if a D-Bus interface or
 error name given is not valid</doc>
      </member>
      <member name="invalid_object_path"
              value="6"
              c:identifier="TP_DBUS_ERROR_INVALID_OBJECT_PATH">
        <doc xml:space="preserve">Raised if a D-Bus object path
 given is not valid</doc>
      </member>
      <member name="invalid_member_name"
              value="7"
              c:identifier="TP_DBUS_ERROR_INVALID_MEMBER_NAME">
        <doc xml:space="preserve">Raised if a D-Bus method or signal
 name given is not valid</doc>
      </member>
      <member name="object_removed"
              value="8"
              c:identifier="TP_DBUS_ERROR_OBJECT_REMOVED">
        <doc xml:space="preserve">A generic error which can be used with
 #TpProxy::invalidated to indicate an application-specific indication
 that the remote object no longer exists, if no more specific error
 is available.</doc>
      </member>
      <member name="cancelled"
              value="9"
              c:identifier="TP_DBUS_ERROR_CANCELLED">
        <doc xml:space="preserve">Raised from calls that re-enter the main
 loop (*_run_*) if they are cancelled</doc>
      </member>
      <member name="inconsistent"
              value="10"
              c:identifier="TP_DBUS_ERROR_INCONSISTENT">
        <doc xml:space="preserve">Raised if information received from a remote
 object is inconsistent or otherwise obviously wrong (added in 0.7.17).
 See also %TP_ERROR_CONFUSED.</doc>
      </member>
    </enumeration>
    <bitfield name="DBusNameType" version="0.7.1" c:type="TpDBusNameType">
      <doc xml:space="preserve">A set of flags indicating which D-Bus bus names are acceptable.
They can be combined with the bitwise-or operator to accept multiple
types. %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON and %TP_DBUS_NAME_TYPE_ANY are
the bitwise-or of other appropriate types, for convenience.

Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_NAME_TYPE.</doc>
      <member name="unique" value="1" c:identifier="TP_DBUS_NAME_TYPE_UNIQUE">
        <doc xml:space="preserve">accept unique names like :1.123
 (not including the name of the bus daemon itself)</doc>
      </member>
      <member name="well_known"
              value="2"
              c:identifier="TP_DBUS_NAME_TYPE_WELL_KNOWN">
        <doc xml:space="preserve">accept well-known names like
 com.example.Service (not including the name of the bus daemon itself)</doc>
      </member>
      <member name="bus_daemon"
              value="4"
              c:identifier="TP_DBUS_NAME_TYPE_BUS_DAEMON">
        <doc xml:space="preserve">accept the name of the bus daemon
 itself, which has the syntax of a well-known name, but behaves like a
 unique name</doc>
      </member>
      <member name="not_bus_daemon"
              value="3"
              c:identifier="TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON">
        <doc xml:space="preserve">accept either unique or well-known
 names, but not the bus daemon</doc>
      </member>
      <member name="any" value="7" c:identifier="TP_DBUS_NAME_TYPE_ANY">
        <doc xml:space="preserve">accept any of the above</doc>
      </member>
    </bitfield>
    <record name="DBusPropertiesMixinClass"
            c:type="TpDBusPropertiesMixinClass"
            version="0.7.3">
      <doc xml:space="preserve">Structure representing all of a class's property implementations. One of
these structures may be placed in the layout of an object class structure.

In addition to the documented fields, there are 7 pointers reserved for
future use, which must be initialized to %NULL.</doc>
      <field name="interfaces" writable="1">
        <doc xml:space="preserve">An array of interface implementations, terminated by one with
 @name equal to %NULL</doc>
        <type name="DBusPropertiesMixinIfaceImpl"
              c:type="TpDBusPropertiesMixinIfaceImpl*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <function name="init"
                c:identifier="tp_dbus_properties_mixin_class_init"
                version="0.7.3">
        <doc xml:space="preserve">Initialize the class @cls to use the D-Bus Properties mixin.
The given struct member, of size sizeof(TpDBusPropertiesMixinClass),
will be used to store property implementation information.

Each property and each interface must have been declared as a member of
a GInterface implemented by @cls, using
tp_svc_interface_set_dbus_properties_info().

Before calling this function, the array @interfaces must have been
placed in the #TpDBusPropertiesMixinClass structure; if it would be empty,
it may instead be %NULL.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Changed in 0.7.9: TpDBusPropertiesMixinClass::interfaces may now be %NULL,
which means that only interfaces whose properties are set up using
tp_dbus_properties_mixin_implement_interface() will be used.

Changed in 0.7.15: @offset may now be 0, in which case the
#TpDBusPropertiesMixinClass can be omitted from @cls.  It is treated as if
it were present, but with all fields (including
TpDBusPropertiesMixinClass::interfaces) being %NULL, so only interfaces
whose properties are set using
tp_dbus_properties_mixin_implement_interface() will be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:space="preserve">a subclass of #GObjectClass</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the offset within @cls of a TpDBusPropertiesMixinClass structure</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="DBusPropertiesMixinFlags"
              version="0.7.3"
              c:type="TpDBusPropertiesMixinFlags">
      <doc xml:space="preserve">Bitfield representing allowed access to a property. At most one of
%TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_CHANGED and
%TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_INVALIDATED may be specified for a
property.

Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_PROPERTIES_MIXIN_FLAGS.</doc>
      <member name="read"
              value="1"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_READ">
        <doc xml:space="preserve">The property can be read using Get and
 GetAll</doc>
      </member>
      <member name="write"
              value="2"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_WRITE">
        <doc xml:space="preserve">The property can be written using Set</doc>
      </member>
      <member name="emits_changed"
              value="4"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_CHANGED">
        <doc xml:space="preserve">The property's new value is
 included in emissions of PropertiesChanged</doc>
      </member>
      <member name="emits_invalidated"
              value="8"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_INVALIDATED">
        <doc xml:space="preserve">The property is announced
 as invalidated, without its value, in emissions of PropertiesChanged</doc>
      </member>
    </bitfield>
    <callback name="DBusPropertiesMixinGetter"
              c:type="TpDBusPropertiesMixinGetter">
      <doc xml:space="preserve">Signature of a callback used to get the value of a property.

For simplicity, in this mixin we don't allow getting a property to fail;
implementations must always be prepared to return *something*.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A GValue pre-initialized to the right type, into which to put
 the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusPropertiesMixinIfaceImpl"
            c:type="TpDBusPropertiesMixinIfaceImpl"
            version="0.7.3">
      <doc xml:space="preserve">Structure representing an implementation of an interface's properties.

In addition to the documented fields, there are four pointers which must
be initialized to %NULL.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the interface</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="getter" writable="1">
        <doc xml:space="preserve">A callback to get the current value of the property, to which
 the @getter_data from each property implementation will be passed</doc>
        <type name="DBusPropertiesMixinGetter"
              c:type="TpDBusPropertiesMixinGetter"/>
      </field>
      <field name="setter" writable="1">
        <doc xml:space="preserve">A callback to set a new value for the property, to which
 the @setter_data from each property implementation will be passed</doc>
        <type name="DBusPropertiesMixinSetter"
              c:type="TpDBusPropertiesMixinSetter"/>
      </field>
      <field name="props" writable="1">
        <doc xml:space="preserve">An array of property implementations, terminated by one with
 @name equal to %NULL</doc>
        <type name="DBusPropertiesMixinPropImpl"
              c:type="TpDBusPropertiesMixinPropImpl*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_next" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="mixin_priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinIfaceInfo"
            c:type="TpDBusPropertiesMixinIfaceInfo"
            version="0.7.3">
      <doc xml:space="preserve">Semi-abstract description of an interface. Each service GInterface that
has properties must have one of these attached to it via
tp_svc_interface_set_dbus_properties_info() in its base_init function;
service GInterfaces that do not have properties may have one of these
with no properties.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.

In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="dbus_interface" writable="1">
        <doc xml:space="preserve">Quark representing the interface's name</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="props" writable="1">
        <doc xml:space="preserve">Array of property descriptions, terminated by one with
 @name == %NULL</doc>
        <type name="DBusPropertiesMixinPropInfo"
              c:type="TpDBusPropertiesMixinPropInfo*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropImpl"
            c:type="TpDBusPropertiesMixinPropImpl"
            version="0.7.3">
      <doc xml:space="preserve">Structure representing an implementation of a property.

In addition to the documented fields, there are three pointers which must
be initialized to %NULL.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the property as it appears on D-Bus</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="getter_data" writable="1">
        <doc xml:space="preserve">Arbitrary user-supplied data for the getter function</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="setter_data" writable="1">
        <doc xml:space="preserve">Arbitrary user-supplied data for the setter function</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropInfo"
            c:type="TpDBusPropertiesMixinPropInfo"
            version="0.7.3">
      <doc xml:space="preserve">Semi-abstract description of a property, as attached to a service
GInterface. This structure must either be statically allocated, or
duplicated and never freed, so it always remains valid.

In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">Quark representing the property's name</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Flags representing read/write access to the property</doc>
        <type name="DBusPropertiesMixinFlags"
              c:type="TpDBusPropertiesMixinFlags"/>
      </field>
      <field name="dbus_signature" writable="1">
        <doc xml:space="preserve">The D-Bus signature of the property</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve">The GType used in a GValue to implement the property</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="DBusPropertiesMixinSetter"
              c:type="TpDBusPropertiesMixinSetter"
              throws="1">
      <doc xml:space="preserve">Signature of a callback used to get the value of a property.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="setter_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DBusTubeChannel"
           c:symbol-prefix="dbus_tube_channel"
           c:type="TpDBusTubeChannel"
           version="0.18.0"
           parent="Channel"
           glib:type-name="TpDBusTubeChannel"
           glib:get-type="tp_dbus_tube_channel_get_type"
           glib:type-struct="DBusTubeChannelClass">
      <doc xml:space="preserve">Data structure representing a #TpDBusTubeChannel.</doc>
      <function name="feature_quark_core"
                c:identifier="tp_dbus_tube_channel_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_async"
              c:identifier="tp_dbus_tube_channel_accept_async"
              version="0.18.0">
        <doc xml:space="preserve">Accept an incoming D-Bus tube. When the tube has been accepted
@callback will be called. You can then call
tp_dbus_tube_channel_accept_finish() to get the #GDBusConnection that will
be used to communicate through the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an incoming #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_dbus_tube_channel_accept_finish"
              version="0.18.0"
              throws="1">
        <doc xml:space="preserve">Finishes to accept an incoming D-Bus tube. The returned #GDBusConnection
is ready to be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference on a #GDBusConnection if the tube
has been successfully accepted and opened; %NULL otherwise.</doc>
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_parameters_vardict"
              c:identifier="tp_dbus_tube_channel_dup_parameters_vardict"
              version="0.19.10">
        <doc xml:space="preserve">Return the parameters of the dbus-tube channel in a variant of
type %G_VARIANT_TYPE_VARDICT whose keys are strings representing
parameter names and values are variants representing corresponding
parameter values set by the offerer when offering this channel.

The GVariant returned is %NULL if this is an outgoing tube that has not
yet been offered or the parameters property has not been set.

Use g_variant_lookup(), g_variant_lookup_value(), or tp_vardict_get_uint32()
and similar functions for convenient access to the values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to a #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameters"
              c:identifier="tp_dbus_tube_channel_get_parameters"
              version="0.18.0"
              introspectable="0">
        <doc xml:space="preserve">Return the #TpDBusTubeChannel:parameters property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
the value of #TpDBusTubeChannel:parameters</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service_name"
              c:identifier="tp_dbus_tube_channel_get_service_name"
              version="0.18.0">
        <doc xml:space="preserve">Return the #TpDBusTubeChannel:service-name property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDBusTubeChannel:service-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offer_async"
              c:identifier="tp_dbus_tube_channel_offer_async"
              version="0.18.0">
        <doc xml:space="preserve">Offer an outgoing D-Bus tube. When the tube has been offered and accepted
@callback will be called. You can then call
tp_dbus_tube_channel_offer_finish() to get the #GDBusConnection that will
be used to communicate through the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an outgoing #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">parameters of the tube, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="offer_finish"
              c:identifier="tp_dbus_tube_channel_offer_finish"
              version="0.18.0"
              throws="1">
        <doc xml:space="preserve">Finishes offering an outgoing D-Bus tube. The returned #GDBusConnection
is ready to be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference on a #GDBusConnection if the tube
has been successfully offered and opened; %NULL otherwise.</doc>
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusTubeChannel</doc>
            <type name="DBusTubeChannel" c:type="TpDBusTubeChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="parameters"
                version="0.18.0"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">A string to #GValue #GHashTable representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.

In high-level language bindings, use
tp_dbus_tube_channel_dup_parameters_vardict() to get the same information
in a more convenient format.</doc>
        <type/>
      </property>
      <property name="parameters-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:space="preserve">A %G_VARIANT_TYPE_VARDICT representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="service-name" version="0.18.0" transfer-ownership="none">
        <doc xml:space="preserve">A string representing the service name that will be used over the tube.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusTubeChannelPrivate"
              c:type="TpDBusTubeChannelPrivate*"/>
      </field>
    </class>
    <record name="DBusTubeChannelClass"
            c:type="TpDBusTubeChannelClass"
            glib:is-gtype-struct-for="DBusTubeChannel"
            version="0.18.0">
      <doc xml:space="preserve">The class of a #TpDBusTubeChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="DBusTubeChannelPrivate"
            c:type="TpDBusTubeChannelPrivate"
            disguised="1">
    </record>
    <constant name="DEBUG_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/debug"
              c:type="TP_DEBUG_OBJECT_PATH">
      <doc xml:space="preserve">The standard path for objects implementing the Telepathy Debug interface
(#TpSvcDebug).</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="DTMFEvent" c:type="TpDTMFEvent">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="digit_0" value="0" c:identifier="TP_DTMF_EVENT_DIGIT_0">
        <doc xml:space="preserve">&lt;![CDATA[0]]&gt;</doc>
      </member>
      <member name="digit_1" value="1" c:identifier="TP_DTMF_EVENT_DIGIT_1">
        <doc xml:space="preserve">&lt;![CDATA[1]]&gt;</doc>
      </member>
      <member name="digit_2" value="2" c:identifier="TP_DTMF_EVENT_DIGIT_2">
        <doc xml:space="preserve">&lt;![CDATA[2]]&gt;</doc>
      </member>
      <member name="digit_3" value="3" c:identifier="TP_DTMF_EVENT_DIGIT_3">
        <doc xml:space="preserve">&lt;![CDATA[3]]&gt;</doc>
      </member>
      <member name="digit_4" value="4" c:identifier="TP_DTMF_EVENT_DIGIT_4">
        <doc xml:space="preserve">&lt;![CDATA[4]]&gt;</doc>
      </member>
      <member name="digit_5" value="5" c:identifier="TP_DTMF_EVENT_DIGIT_5">
        <doc xml:space="preserve">&lt;![CDATA[5]]&gt;</doc>
      </member>
      <member name="digit_6" value="6" c:identifier="TP_DTMF_EVENT_DIGIT_6">
        <doc xml:space="preserve">&lt;![CDATA[6]]&gt;</doc>
      </member>
      <member name="digit_7" value="7" c:identifier="TP_DTMF_EVENT_DIGIT_7">
        <doc xml:space="preserve">&lt;![CDATA[7]]&gt;</doc>
      </member>
      <member name="digit_8" value="8" c:identifier="TP_DTMF_EVENT_DIGIT_8">
        <doc xml:space="preserve">&lt;![CDATA[8]]&gt;</doc>
      </member>
      <member name="digit_9" value="9" c:identifier="TP_DTMF_EVENT_DIGIT_9">
        <doc xml:space="preserve">&lt;![CDATA[9]]&gt;</doc>
      </member>
      <member name="asterisk" value="10" c:identifier="TP_DTMF_EVENT_ASTERISK">
        <doc xml:space="preserve">&lt;![CDATA[*]]&gt;</doc>
      </member>
      <member name="hash" value="11" c:identifier="TP_DTMF_EVENT_HASH">
        <doc xml:space="preserve">&lt;![CDATA[#]]&gt;</doc>
      </member>
      <member name="letter_a" value="12" c:identifier="TP_DTMF_EVENT_LETTER_A">
        <doc xml:space="preserve">&lt;![CDATA[A]]&gt;</doc>
      </member>
      <member name="letter_b" value="13" c:identifier="TP_DTMF_EVENT_LETTER_B">
        <doc xml:space="preserve">&lt;![CDATA[B]]&gt;</doc>
      </member>
      <member name="letter_c" value="14" c:identifier="TP_DTMF_EVENT_LETTER_C">
        <doc xml:space="preserve">&lt;![CDATA[C]]&gt;</doc>
      </member>
      <member name="letter_d" value="15" c:identifier="TP_DTMF_EVENT_LETTER_D">
        <doc xml:space="preserve">&lt;![CDATA[D]]&gt;</doc>
      </member>
    </enumeration>
    <class name="DebugClient"
           c:symbol-prefix="debug_client"
           c:type="TpDebugClient"
           version="0.19.0"
           parent="Proxy"
           glib:type-name="TpDebugClient"
           glib:get-type="tp_debug_client_get_type"
           glib:type-struct="DebugClientClass">
      <doc xml:space="preserve">A proxy object for the debug interface of a Telepathy component.</doc>
      <constructor name="new"
                   c:identifier="tp_debug_client_new"
                   version="0.19.0"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new debug client proxy, or %NULL on invalid arguments</doc>
          <type name="DebugClient" c:type="TpDebugClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="unique_name" transfer-ownership="none">
            <doc xml:space="preserve">the unique name of the process to be debugged; may not be
 %NULL or a well-known name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_debug_client_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_debug_client_init_known_interfaces"
                version="0.19.0">
        <doc xml:space="preserve">Ensure that the known interfaces for TpDebugClient have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_DEBUG_CLIENT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_messages_async"
              c:identifier="tp_debug_client_get_messages_async"
              version="0.19.0">
        <doc xml:space="preserve">Retrieve buffered messages from @self. Once @callback is called,
use tp_debug_client_get_messages_finish() to retrieve the #TpDebugMessage
objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugClient</doc>
            <type name="DebugClient" c:type="TpDebugClient*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">callback to call when the messages have been retrieved</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_messages_finish"
              c:identifier="tp_debug_client_get_messages_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_debug_client_set_enabled_async().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
a #GPtrArray of #TpDebugMessage, free with g_ptr_array_unref()</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="DebugMessage"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugClient</doc>
            <type name="DebugClient" c:type="TpDebugClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_enabled"
              c:identifier="tp_debug_client_is_enabled"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpDebugClient:enabled property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDebugClient:enabled property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugClient</doc>
            <type name="DebugClient" c:type="TpDebugClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_enabled_async"
              c:identifier="tp_debug_client_set_enabled_async"
              version="0.19.0">
        <doc xml:space="preserve">Enable or disable publishing of debug messages on the bus by the component
owning @self's bus name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugClient</doc>
            <type name="DebugClient" c:type="TpDebugClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if debug messages should be published on the bus, %FALSE
otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish"
              c:identifier="tp_debug_client_set_enabled_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Finishes tp_debug_client_set_enabled_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if the operation suceeded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugClient</doc>
            <type name="DebugClient" c:type="TpDebugClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="enabled" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if debug messages are published on the bus.

This property is meaningless until the
%TP_DEBUG_CLIENT_FEATURE_CORE feature has been prepared.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <glib:signal name="new-debug-message" when="last" version="0.19.0">
        <doc xml:space="preserve">Emitted when a #TpDebugMessage is generated if the TpDebugMessage:enabled
property is set to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DebugClientClass"
            c:type="TpDebugClientClass"
            disguised="1"
            glib:is-gtype-struct-for="DebugClient"
            version="0.19.0">
      <doc xml:space="preserve">The class of a #TpDebugClient.</doc>
    </record>
    <record name="DebugClientPrivate"
            c:type="TpDebugClientPrivate"
            disguised="1">
    </record>
    <enumeration name="DebugLevel" c:type="TpDebugLevel">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="error" value="0" c:identifier="TP_DEBUG_LEVEL_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           Log level for errors. Error messages are always fatal, resulting           in the service terminating after something completely           unexpected occurred.         ]]&gt;</doc>
      </member>
      <member name="critical" value="1" c:identifier="TP_DEBUG_LEVEL_CRITICAL">
        <doc xml:space="preserve">&lt;![CDATA[           Log level for critical messages. Critical messages are messages           that the service might predict and it is up to the service itself           to decide whether to terminate following a critical message.         ]]&gt;</doc>
      </member>
      <member name="warning" value="2" c:identifier="TP_DEBUG_LEVEL_WARNING">
        <doc xml:space="preserve">&lt;![CDATA[           Log level for warnings.         ]]&gt;</doc>
      </member>
      <member name="message" value="3" c:identifier="TP_DEBUG_LEVEL_MESSAGE">
        <doc xml:space="preserve">&lt;![CDATA[           Log level for messages.         ]]&gt;</doc>
      </member>
      <member name="info" value="4" c:identifier="TP_DEBUG_LEVEL_INFO">
        <doc xml:space="preserve">&lt;![CDATA[           Log level for information messages.         ]]&gt;</doc>
      </member>
      <member name="debug" value="5" c:identifier="TP_DEBUG_LEVEL_DEBUG">
        <doc xml:space="preserve">&lt;![CDATA[           Log level for debug messages.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="DebugMessage"
           c:symbol-prefix="debug_message"
           c:type="TpDebugMessage"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpDebugMessage"
           glib:get-type="tp_debug_message_get_type"
           glib:type-struct="DebugMessageClass">
      <doc xml:space="preserve">Data structure representing a #TpDebugMessage.</doc>
      <method name="get_category"
              c:identifier="tp_debug_message_get_category"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpDebugMessage:category property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDebugMessage:category property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage" c:type="TpDebugMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domain"
              c:identifier="tp_debug_message_get_domain"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpDebugMessage:domain property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDebugMessage:domain property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage" c:type="TpDebugMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_level"
              c:identifier="tp_debug_message_get_level"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpDebugMessage:level property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDebugMessage:level property</doc>
          <type name="GLib.LogLevelFlags" c:type="GLogLevelFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage" c:type="TpDebugMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message"
              c:identifier="tp_debug_message_get_message"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpDebugMessage:message property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDebugMessage:message property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage" c:type="TpDebugMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_time"
              c:identifier="tp_debug_message_get_time"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpDebugMessage:time property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpDebugMessage:time property</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage" c:type="TpDebugMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="category" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">Category of the debug message, or %NULL if none was specified.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="domain" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">Domain of the debug message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="level" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">A #GLogLevelFlags representing the level of the debug message.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="message" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">Text of the debug message, stripped from its trailing whitespaces.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="time" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">Timestamp of the debug message.</doc>
        <type name="GLib.DateTime"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DebugMessagePriv" c:type="TpDebugMessagePriv*"/>
      </field>
    </class>
    <record name="DebugMessageClass"
            c:type="TpDebugMessageClass"
            glib:is-gtype-struct-for="DebugMessage"
            version="0.19.0">
      <doc xml:space="preserve">The class of a #TpDebugMessage.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="DebugMessagePriv" c:type="TpDebugMessagePriv" disguised="1">
    </record>
    <bitfield name="DeliveryReportingSupportFlags"
              c:type="TpDeliveryReportingSupportFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags indicating the level of support for delivery reporting on this         channel, as found on the         DeliveryReportingSupport property. Any         future flags added to this set will conform to the         convention that the presence of an extra flag implies that         more operations will succeed. Note that CMs may always provide more         reports than are requested in the         Message_Sending_Flags passed to         SendMessage.                     If senders want delivery reports, they should ask for them.  If they           don't want delivery reports, they can just ignore them, so there's no           need to have capability discovery for what will happen if a delivery           report isn't requested.                ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="failures"
              value="1"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES">
        <doc xml:space="preserve">&lt;![CDATA[           Clients MAY expect to receive negative delivery reports if           Message_Sending_Flag_Report_Delivery is specified when sending.         ]]&gt;</doc>
      </member>
      <member name="successes"
              value="2"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES">
        <doc xml:space="preserve">&lt;![CDATA[           Clients MAY expect to receive positive delivery reports if           Message_Sending_Flag_Report_Delivery is specified when sending.         ]]&gt;</doc>
      </member>
      <member name="read"
              value="4"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_READ">
        <doc xml:space="preserve">&lt;![CDATA[           Clients MAY expect to receive Delivery_Status           Read reports if Message_Sending_Flag_Report_Read           is specified when sending.         ]]&gt;</doc>
      </member>
      <member name="deleted"
              value="8"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_DELETED">
        <doc xml:space="preserve">&lt;![CDATA[           Clients MAY expect to receive Delivery_Status           Deleted reports if Message_Sending_Flag_Report_Deleted           is specified when sending.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="DeliveryStatus" c:type="TpDeliveryStatus">
      <doc xml:space="preserve">&lt;![CDATA[         The status of a message as indicated by a delivery report.          If this enum is extended in future specifications, this should           only be to add new, non-overlapping conditions (i.e. all failures           should still be signalled as either Temporarily_Failed           or Permanently_Failed). If additional detail is required (e.g.           distinguishing between the various types of permanent failure) this           will be done using additional           Delivery_Report_Header_Keys.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_DELIVERY_STATUS_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           The message's disposition is unknown.           Clients SHOULD consider all messages to have status           Delivery_Status_Unknown unless otherwise specified; connection           managers SHOULD NOT signal this delivery status explicitly.         ]]&gt;</doc>
      </member>
      <member name="delivered"
              value="1"
              c:identifier="TP_DELIVERY_STATUS_DELIVERED">
        <doc xml:space="preserve">&lt;![CDATA[           The message has been delivered to the intended recipient.         ]]&gt;</doc>
      </member>
      <member name="temporarily_failed"
              value="2"
              c:identifier="TP_DELIVERY_STATUS_TEMPORARILY_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           Delivery of the message has failed. Clients SHOULD notify the user,           but MAY automatically try sending another copy of the message.                         Similar to errors with type="wait" in XMPP; analogous to             4xx errors in SMTP.                    ]]&gt;</doc>
      </member>
      <member name="permanently_failed"
              value="3"
              c:identifier="TP_DELIVERY_STATUS_PERMANENTLY_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           Delivery of the message has failed. Clients SHOULD NOT try again           unless by specific user action. If the user does not modify the           message or alter configuration before re-sending, this error is           likely to happen again.                         Similar to errors with type="cancel", type="modify"             or type="auth" in XMPP; analogous to 5xx errors in SMTP.                    ]]&gt;</doc>
      </member>
      <member name="accepted"
              value="4"
              c:identifier="TP_DELIVERY_STATUS_ACCEPTED">
        <doc xml:space="preserve">&lt;![CDATA[           An intermediate server has accepted the message but the message           has not been yet delivered to the ultimate recipient. The           connection manager might send a Failed report or Delivered report           later.                         Similar to "202 Accepted" success code in SIP; analogous to             251 and 252 responses in SMTP.                    ]]&gt;</doc>
      </member>
      <member name="read" value="5" c:identifier="TP_DELIVERY_STATUS_READ">
        <doc xml:space="preserve">&lt;![CDATA[           The message has been read by the intended recipient.         ]]&gt;</doc>
      </member>
      <member name="deleted"
              value="6"
              c:identifier="TP_DELIVERY_STATUS_DELETED">
        <doc xml:space="preserve">&lt;![CDATA[           The message has been deleted by the intended recipient. This MAY be           signalled on its own if the message is deleted without being read, or           after Read if the message was read before being deleted.         ]]&gt;</doc>
      </member>
    </enumeration>
    <constant name="ERROR_PREFIX"
              value="org.freedesktop.Telepathy.Error"
              c:type="TP_ERROR_PREFIX"
              version="0.7.1">
      <doc xml:space="preserve">The common prefix of Telepathy errors, as a string constant, without
the trailing '.' character.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="Error" c:type="TpError" glib:error-domain="tp_errors">
      <doc xml:space="preserve">Enumerated type representing the Telepathy D-Bus errors.</doc>
      <member name="network_error"
              value="0"
              c:identifier="TP_ERROR_NETWORK_ERROR">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NetworkError:
    Raised when there is an error reading from or writing to the network.</doc>
      </member>
      <member name="not_implemented"
              value="1"
              c:identifier="TP_ERROR_NOT_IMPLEMENTED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NotImplemented:
    Raised when the requested method, channel, etc is not available on this
    connection.</doc>
      </member>
      <member name="invalid_argument"
              value="2"
              c:identifier="TP_ERROR_INVALID_ARGUMENT">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.InvalidArgument:
    Raised when one of the provided arguments is invalid.</doc>
      </member>
      <member name="not_available"
              value="3"
              c:identifier="TP_ERROR_NOT_AVAILABLE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NotAvailable:
    Raised when the requested functionality is temporarily unavailable.</doc>
      </member>
      <member name="permission_denied"
              value="4"
              c:identifier="TP_ERROR_PERMISSION_DENIED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.PermissionDenied:
    The user is not permitted to perform the requested operation.</doc>
      </member>
      <member name="disconnected"
              value="5"
              c:identifier="TP_ERROR_DISCONNECTED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Disconnected:
    The connection is not currently connected and cannot be used.
    This error may also be raised when operations are performed on a
    Connection for which StatusChanged has signalled status Disconnected
    for reason None.</doc>
      </member>
      <member name="invalid_handle"
              value="6"
              c:identifier="TP_ERROR_INVALID_HANDLE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.InvalidHandle:
    An identifier being converted to a handle was syntactically invalid,
    or an invalid handle was used.</doc>
      </member>
      <member name="channel_banned"
              value="7"
              c:identifier="TP_ERROR_CHANNEL_BANNED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Channel.Banned:
    You are banned from the channel.</doc>
      </member>
      <member name="channel_full"
              value="8"
              c:identifier="TP_ERROR_CHANNEL_FULL">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Channel.Full:
    The channel is full.</doc>
      </member>
      <member name="channel_invite_only"
              value="9"
              c:identifier="TP_ERROR_CHANNEL_INVITE_ONLY">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Channel.InviteOnly:
    The requested channel is invite-only.</doc>
      </member>
      <member name="not_yours" value="10" c:identifier="TP_ERROR_NOT_YOURS">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NotYours:
    The requested channel or other resource already exists, and another
    client is responsible for it</doc>
      </member>
      <member name="cancelled" value="11" c:identifier="TP_ERROR_CANCELLED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cancelled:
    Raised by an ongoing request if it is cancelled by user request before
    it has completed, or when operations are performed on an object which
    the user has asked to close (for instance, a Connection where the user
    has called Disconnect, or a Channel where the user has called Close).</doc>
      </member>
      <member name="authentication_failed"
              value="12"
              c:identifier="TP_ERROR_AUTHENTICATION_FAILED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.AuthenticationFailed:
    Raised when authentication with a service was unsuccessful.</doc>
      </member>
      <member name="encryption_not_available"
              value="13"
              c:identifier="TP_ERROR_ENCRYPTION_NOT_AVAILABLE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.EncryptionNotAvailable:
    Raised if a user request insisted that encryption should be used,
    but encryption was not actually available.</doc>
      </member>
      <member name="encryption_error"
              value="14"
              c:identifier="TP_ERROR_ENCRYPTION_ERROR">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.EncryptionError:
    Raised if encryption appears to be available, but could not actually be
    used (for instance if SSL/TLS negotiation fails).</doc>
      </member>
      <member name="cert_not_provided"
              value="15"
              c:identifier="TP_ERROR_CERT_NOT_PROVIDED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.NotProvided:
    Raised if the server did not provide a SSL/TLS certificate.</doc>
      </member>
      <member name="cert_untrusted"
              value="16"
              c:identifier="TP_ERROR_CERT_UNTRUSTED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.Untrusted:
    Raised if the server provided a SSL/TLS certificate signed by an
    untrusted certifying authority.</doc>
      </member>
      <member name="cert_expired"
              value="17"
              c:identifier="TP_ERROR_CERT_EXPIRED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.Expired:
    Raised if the server provided an expired SSL/TLS certificate.</doc>
      </member>
      <member name="cert_not_activated"
              value="18"
              c:identifier="TP_ERROR_CERT_NOT_ACTIVATED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.NotActivated:
    Raised if the server provided an SSL/TLS certificate that will become
    valid at some point in the future.</doc>
      </member>
      <member name="cert_fingerprint_mismatch"
              value="19"
              c:identifier="TP_ERROR_CERT_FINGERPRINT_MISMATCH">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.FingerprintMismatch:
    Raised if the server provided an SSL/TLS certificate that did not have
    the expected fingerprint.</doc>
      </member>
      <member name="cert_hostname_mismatch"
              value="20"
              c:identifier="TP_ERROR_CERT_HOSTNAME_MISMATCH">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.HostnameMismatch:
    Raised if the server provided an SSL/TLS certificate that did not
    match its hostname.</doc>
      </member>
      <member name="cert_self_signed"
              value="21"
              c:identifier="TP_ERROR_CERT_SELF_SIGNED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.SelfSigned:
    Raised if the server provided an SSL/TLS certificate that is
    self-signed and untrusted.</doc>
      </member>
      <member name="cert_invalid"
              value="22"
              c:identifier="TP_ERROR_CERT_INVALID">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.Invalid:
    Raised if the server provided an SSL/TLS certificate that is
    unacceptable in some way that does not have a more specific error.</doc>
      </member>
      <member name="not_capable"
              value="23"
              c:identifier="TP_ERROR_NOT_CAPABLE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NotCapable:
    Raised when requested functionality is unavailable due to a contact
    not having the required capabilities.</doc>
      </member>
      <member name="offline" value="24" c:identifier="TP_ERROR_OFFLINE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Offline:
    Raised when requested functionality is unavailable because a contact is
    offline.</doc>
      </member>
      <member name="channel_kicked"
              value="25"
              c:identifier="TP_ERROR_CHANNEL_KICKED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Channel.Kicked:
    Used to represent a user being ejected from a channel by another user,
    for instance being kicked from a chatroom.</doc>
      </member>
      <member name="busy" value="26" c:identifier="TP_ERROR_BUSY">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Busy:
    Used to represent a user being removed from a channel because of a
    "busy" indication.</doc>
      </member>
      <member name="no_answer" value="27" c:identifier="TP_ERROR_NO_ANSWER">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NoAnswer:
    Used to represent a user being removed from a channel because they did
    not respond, e.g. to a StreamedMedia call.</doc>
      </member>
      <member name="does_not_exist"
              value="28"
              c:identifier="TP_ERROR_DOES_NOT_EXIST">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.DoesNotExist:
    Raised when the requested user does not, in fact, exist.</doc>
      </member>
      <member name="terminated" value="29" c:identifier="TP_ERROR_TERMINATED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Terminated:
    Raised when a channel is terminated for an unspecified reason. In
    particular, this error SHOULD be used whenever normal termination of a
    1-1 StreamedMedia call by the remote user is represented as a D-Bus
    error name.</doc>
      </member>
      <member name="connection_refused"
              value="30"
              c:identifier="TP_ERROR_CONNECTION_REFUSED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ConnectionRefused:
    Raised when a connection is refused.</doc>
      </member>
      <member name="connection_failed"
              value="31"
              c:identifier="TP_ERROR_CONNECTION_FAILED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ConnectionFailed:
    Raised when a connection can't be established.</doc>
      </member>
      <member name="connection_lost"
              value="32"
              c:identifier="TP_ERROR_CONNECTION_LOST">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ConnectionLost:
    Raised when a connection is broken.</doc>
      </member>
      <member name="already_connected"
              value="33"
              c:identifier="TP_ERROR_ALREADY_CONNECTED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.AlreadyConnected:
    Raised on attempts to connect again to an account that is already
    connected, if the protocol or server does not allow this.
    Since 0.7.34</doc>
      </member>
      <member name="connection_replaced"
              value="34"
              c:identifier="TP_ERROR_CONNECTION_REPLACED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ConnectionReplaced:
    Used as disconnection reason for an existing connection if it is
    disconnected because a second connection to the same account is made.
    Since 0.7.34</doc>
      </member>
      <member name="registration_exists"
              value="35"
              c:identifier="TP_ERROR_REGISTRATION_EXISTS">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.RegistrationExists:
    Raised on attempts to register an account on a server when the account
    already exists.
    Since 0.7.34</doc>
      </member>
      <member name="service_busy"
              value="36"
              c:identifier="TP_ERROR_SERVICE_BUSY">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ServiceBusy:
    Raised when a server or other infrastructure rejects a request because
    it is too busy.
    Since 0.7.34</doc>
      </member>
      <member name="resource_unavailable"
              value="37"
              c:identifier="TP_ERROR_RESOURCE_UNAVAILABLE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ResourceUnavailable:
    Raised when a local process rejects a request because it does not have
    enough of a resource, such as memory.
    Since 0.7.34</doc>
      </member>
      <member name="would_break_anonymity"
              value="38"
              c:identifier="TP_ERROR_WOULD_BREAK_ANONYMITY">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.WouldBreakAnonymity:
    Raised when a request cannot be satisfied without violating an
    earlier request for anonymity, and the earlier request specified
    that raising an error is preferable to disclosing the user's
    identity
    Since 0.11.7</doc>
      </member>
      <member name="cert_revoked"
              value="39"
              c:identifier="TP_ERROR_CERT_REVOKED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.Revoked:
    Raised if the server provided an SSL/TLS certificate that has been
    revoked.
    Since 0.11.12</doc>
      </member>
      <member name="cert_insecure"
              value="40"
              c:identifier="TP_ERROR_CERT_INSECURE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.Insecure:
    Raised if the server provided an SSL/TLS certificate that uses an
    insecure cipher algorithm or is cryptographically weak.
    Since 0.11.12</doc>
      </member>
      <member name="cert_limit_exceeded"
              value="41"
              c:identifier="TP_ERROR_CERT_LIMIT_EXCEEDED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Cert.LimitExceeded:
    Raised if the length in bytes of the server certificate, or the depth
    of the server certificate chain, exceed the limits imposed by the
    crypto library.
    Since 0.11.12</doc>
      </member>
      <member name="not_yet" value="42" c:identifier="TP_ERROR_NOT_YET">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.NotYet:
    Raised when the requested functionality is not yet available, but is
    likely to become available after some time has passed.
    Since 0.11.15</doc>
      </member>
      <member name="rejected" value="43" c:identifier="TP_ERROR_REJECTED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Rejected:
    Raised when an incoming or outgoing call is rejected by the receiving
    contact.
    Since 0.13.2</doc>
      </member>
      <member name="picked_up_elsewhere"
              value="44"
              c:identifier="TP_ERROR_PICKED_UP_ELSEWHERE">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.PickedUpElsewhere:
    Raised when a call was terminated as a result of the local user
    picking up the call on a different resource.
    Since 0.13.3</doc>
      </member>
      <member name="confused" value="45" c:identifier="TP_ERROR_CONFUSED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.Confused:
    Raised if a server rejects protocol messages from a connection manager
    claiming that they do not make sense, two local processes fail to
    understand each other, or an apparently impossible situation is
    reached. This has a similar meaning to %TP_DBUS_ERROR_INCONSISTENT but
    can be passed between processes via D-Bus.
    Since 0.13.7</doc>
      </member>
      <member name="service_confused"
              value="46"
              c:identifier="TP_ERROR_SERVICE_CONFUSED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.ServiceConfused:
    Raised when a server or other piece of infrastructure indicates an
    internal error, or when a message that makes no sense is received from
    a server or other piece of infrastructure.
    Since 0.13.7</doc>
      </member>
      <member name="emergency_calls_not_supported"
              value="47"
              c:identifier="TP_ERROR_EMERGENCY_CALLS_NOT_SUPPORTED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.EmergencyCallsNotSupported:
    Raised when a client attempts to dial a number that is recognized as an
    emergency number (e.g. '911' in the USA), but the Connection
    Manager or provider does not support dialling emergency numbers.</doc>
      </member>
      <member name="software_upgrade_required"
              value="48"
              c:identifier="TP_ERROR_SOFTWARE_UPGRADE_REQUIRED">
        <doc xml:space="preserve">org.freedesktop.Telepathy.Error.SoftwareUpgradeRequired:
    Raised when a Connection cannot be established because either the
    Connection Manager or its support library (e.g. wocky, papyon, sofiasip)
    requires upgrading to support a newer protocol version.</doc>
      </member>
      <member name="insufficient_balance"
              value="49"
              c:identifier="TP_ERROR_INSUFFICIENT_BALANCE">
        <doc xml:space="preserve">&lt;code&gt;org.freedesktop.Telepathy.Error.InsufficientBalance&lt;/code&gt;:
    Raised if the user has insufficient balance to place a call.  The key
    'balance-required' MAY be included in CallStateDetails on a Call channel
    (with the same units and scale as AccountBalance) to indicate how much
    credit is required to make this call.</doc>
      </member>
      <member name="media_codecs_incompatible"
              value="50"
              c:identifier="TP_ERROR_MEDIA_CODECS_INCOMPATIBLE">
        <doc xml:space="preserve">&lt;code&gt;org.freedesktop.Telepathy.Error.Media.CodecsIncompatible&lt;/code&gt;:
    Raised when the local streaming implementation has no codecs in common
    with the remote side.
    Since 0.15.6</doc>
      </member>
      <member name="media_unsupported_type"
              value="51"
              c:identifier="TP_ERROR_MEDIA_UNSUPPORTED_TYPE">
        <doc xml:space="preserve">&lt;code&gt;org.freedesktop.Telepathy.Error.Media.UnsupportedType&lt;/code&gt;:
    The media stream type requested is not supported by either the local or
    remote side.
    Since 0.15.6</doc>
      </member>
      <member name="media_streaming_error"
              value="52"
              c:identifier="TP_ERROR_MEDIA_STREAMING_ERROR">
        <doc xml:space="preserve">&lt;code&gt;org.freedesktop.Telepathy.Error.Media.StreamingError&lt;/code&gt;:
    Raised when the call's streaming implementation has some kind of internal
    error.
    Since 0.15.6</doc>
      </member>
      <member name="captcha_not_supported"
              value="53"
              c:identifier="TP_ERROR_CAPTCHA_NOT_SUPPORTED">
        <doc xml:space="preserve">&lt;code&gt;org.freedesktop.Telepathy.Error.Media.CaptchaNotSupported&lt;/code&gt;:
    Raised if no UI is available to present captchas, or if one is
    available but it is unable to answer any of the captchas given.</doc>
      </member>
    </enumeration>
    <enumeration name="FileHashType" c:type="TpFileHashType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_FILE_HASH_TYPE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           No hash.         ]]&gt;</doc>
      </member>
      <member name="md5" value="1" c:identifier="TP_FILE_HASH_TYPE_MD5">
        <doc xml:space="preserve">&lt;![CDATA[           MD5 digest as a string of 32 ASCII hex digits.         ]]&gt;</doc>
      </member>
      <member name="sha1" value="2" c:identifier="TP_FILE_HASH_TYPE_SHA1">
        <doc xml:space="preserve">&lt;![CDATA[           SHA1 digest as a string of ASCII hex digits.         ]]&gt;</doc>
      </member>
      <member name="sha256" value="3" c:identifier="TP_FILE_HASH_TYPE_SHA256">
        <doc xml:space="preserve">&lt;![CDATA[           SHA256 digest as a string of ASCII hex digits.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="FileTransferChannel"
           c:symbol-prefix="file_transfer_channel"
           c:type="TpFileTransferChannel"
           version="0.15.5"
           parent="Channel"
           glib:type-name="TpFileTransferChannel"
           glib:get-type="tp_file_transfer_channel_get_type"
           glib:type-struct="FileTransferChannelClass">
      <doc xml:space="preserve">Data structure representing a #TpFileTransferChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_file_transfer_channel_new"
                   version="0.15.5"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">Convenient function to create a new #TpFileTransferChannel</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_channel() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #TpFileTransferChannel</doc>
          <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the channel,
 as signalled by the NewChannel D-Bus signal or returned by the
 CreateChannel and EnsureChannel D-Bus methods: a mapping from
 strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_file_transfer_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_file_async"
              c:identifier="tp_file_transfer_channel_accept_file_async"
              version="0.17.1">
        <doc xml:space="preserve">Accept an incoming file transfer in the
%TP_FILE_TRANSFER_STATE_PENDING state. Once the accept has been
processed, @callback will be called. You can then call
tp_file_transfer_channel_accept_file_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile where the file should be saved</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">Offset from the start of @file where transfer begins</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the transfer has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_file_finish"
              c:identifier="tp_file_transfer_channel_accept_file_finish"
              version="0.17.1"
              throws="1">
        <doc xml:space="preserve">Finishes a call to tp_file_transfer_channel_accept_file_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the accept operation was a success, or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date"
              c:identifier="tp_file_transfer_channel_get_date"
              version="0.15.5">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:date property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpFileTransferChannel:date
  property</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="tp_file_transfer_channel_get_description"
              version="0.15.5">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:description property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the
  #TpFileTransferChannel:description property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename"
              c:identifier="tp_file_transfer_channel_get_filename"
              version="0.15.5">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:filename property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the
  #TpFileTransferChannel:filename property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metadata"
              c:identifier="tp_file_transfer_channel_get_metadata"
              version="0.17.1">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:metadata property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the
  value of the #TpFileTransferChannel:metadata property</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <array>
              <type name="utf8"/>
            </array>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mime_type"
              c:identifier="tp_file_transfer_channel_get_mime_type"
              version="0.15.5">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:mime-type property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the
  #TpFileTransferChannel:mime-type property</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service_name"
              c:identifier="tp_file_transfer_channel_get_service_name"
              version="0.17.1">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:service-name property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpFileTransferChannel:service-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size"
              c:identifier="tp_file_transfer_channel_get_size"
              version="0.15.5">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:size property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpFileTransferChannel:size property</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="tp_file_transfer_channel_get_state"
              version="0.17.1">
        <doc xml:space="preserve">Returns the #TpFileTransferChannel:state property.

If @reason is not %NULL it is set to the reason why
#TpFileTransferChannel:state changed to its current value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpFileTransferChannel:state property</doc>
          <type name="FileTransferState" c:type="TpFileTransferState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a #TpFileTransferStateChangeReason, or %NULL</doc>
            <type name="FileTransferStateChangeReason"
                  c:type="TpFileTransferStateChangeReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_transferred_bytes"
              c:identifier="tp_file_transfer_channel_get_transferred_bytes"
              version="0.15.5">
        <doc xml:space="preserve">Return the #TpFileTransferChannel:transferred-bytes property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpFileTransferChannel:transferred-bytes property</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="provide_file_async"
              c:identifier="tp_file_transfer_channel_provide_file_async"
              version="0.17.1">
        <doc xml:space="preserve">Provide a file transfer. This should be called when the file
transfer state changes (tp_file_transfer_channel_get_state() and
the "notify::state" signal) to
%TP_FILE_TRANSFER_STATE_ACCEPTED or
%TP_FILE_TRANSFER_STATE_PENDING. Once the file has been provided,
the channel #TpFileTransferChannel:state will change to
%TP_FILE_TRANSFER_STATE_OPEN.

Once the file has been provided, @callback will be called. You
should then call tp_file_transfer_channel_provide_file_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to send to the remote contact</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the transfer has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_file_finish"
              c:identifier="tp_file_transfer_channel_provide_file_finish"
              version="0.17.1"
              throws="1">
        <doc xml:space="preserve">Finishes a call to tp_file_transfer_channel_provide_file_async().


Successful return from this function does not mean that the file
transfer has completed or has even started at all. The state of the
file transfer should be monitored with the "notify::state" signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file has been successfully provided, or
%FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpFileTransferChannel</doc>
            <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="date" transfer-ownership="none">
        <doc xml:space="preserve">A #GDateTime representing the last modification time of the file to be
transferred.

Since 0.15.5</doc>
        <type name="GLib.DateTime"/>
      </property>
      <property name="description" transfer-ownership="none">
        <doc xml:space="preserve">The description of the file transfer, defined by the sender when
sending the file transfer offer.

Since 0.15.5</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="file" version="0.17.1" transfer-ownership="none">
        <doc xml:space="preserve">For incoming file transfers, this property will be set to a
#GFile for the location where the file will be saved (given by
tp_file_transfer_channel_accept_file_async()) when the transfer
starts. The feature %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE must
already be prepared for this property to have a meaningful
value, and to receive change notification.  Once the initial
value is set, this property will not be changed.

For outgoing file transfers, this property is a #GFile for the
location of the file being sent (given by
tp_file_transfer_channel_provide_file_async()). The feature
%TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE does not have to be
prepared and there is no change notification.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="filename" transfer-ownership="none">
        <doc xml:space="preserve">The name of the file on the sender's side. This is therefore given as a
suggested filename for the receiver.

Since 0.15.5</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="initial-offset"
                version="0.17.1"
                transfer-ownership="none">
        <doc xml:space="preserve">The offset in bytes from where the file should be sent.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="metadata"
                version="0.17.1"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">Additional information about the file transfer set by the channel
initiator, or an empty #GHashTable if the initiator did not
provide any additional information.

To provide metadata along with a file offer, include
%TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA in the
channel request. For example:

|[
GHashTable *request;
GHashTable *metadata = g_hash_table_new (g_str_hash, g_str_equal);
const gchar * const values[] = { "Jason Derulo", "Tinie Tempah", NULL };

g_hash_table_insert (metadata, "best buds", values);

request = tp_asv_new (
    TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING, TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER,
    TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_CONTACT,
    TP_PROP_CHANNEL_TARGET_ID, G_TYPE_STRING, "foo@bar.com",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE, G_TYPE_STRING, "text/plain",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE, G_TYPE_INT64, 1320925992,
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION, G_TYPE_STRING, "",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME, G_TYPE_STRING, "test.pdf",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET, G_TYPE_UINT64, 0,
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE, G_TYPE_UINT64, 165710,
    TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA, TP_TYPE_METADATA, metadata,
    NULL);

...
]|

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful.</doc>
        <type/>
      </property>
      <property name="mime-type" version="0.15.5" transfer-ownership="none">
        <doc xml:space="preserve">The MIME type of the file to be transferred.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service-name" version="0.17.1" transfer-ownership="none">
        <doc xml:space="preserve">A string representing the name of the service suggested to handle
this file transfer channel, or %NULL if the initiator did not
provide one.

This is a useful way of requesting file transfer channels with a
hint of what handler they should be handled by on the remote
side. If a channel request is made with this property set (to a
contact who also supports the metadata extension; see the
requestable channel classes for said contact), this property will
be set to the same value on the remote incoming channel and
handlers can match on this in their handler filter. For example,
a remote handler could call the following:

|[
tp_base_client_take_handler_filter (handler, tp_asv_new (
              TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING, TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER,
              TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_CONTACT,
              TP_PROP_CHANNEL_REQUESTED, G_TYPE_BOOLEAN, FALSE,
              TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME, G_TYPE_STRING, "service.name",
              NULL));
]|

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="size" transfer-ownership="none">
        <doc xml:space="preserve">The size of the file to be transferred,
or %G_MAXUINT64 if not known.

Since 0.15.5</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">A TpFileTransferState holding the state of the file transfer.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.

Since 0.17.1</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="transferred-bytes"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:space="preserve">The number of bytes transferred so far in this
file transfer.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileTransferChannelPrivate"
              c:type="TpFileTransferChannelPrivate*"/>
      </field>
    </class>
    <record name="FileTransferChannelClass"
            c:type="TpFileTransferChannelClass"
            glib:is-gtype-struct-for="FileTransferChannel"
            version="0.15.5">
      <doc xml:space="preserve">The class of a #TpFileTransferChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="8">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="FileTransferChannelPrivate"
            c:type="TpFileTransferChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="FileTransferState" c:type="TpFileTransferState">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_FILE_TRANSFER_STATE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           An invalid state type used as a null value. This value MUST NOT           appear in the State property.         ]]&gt;</doc>
      </member>
      <member name="pending"
              value="1"
              c:identifier="TP_FILE_TRANSFER_STATE_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer is waiting to be accepted/closed by the receiver.           The receiver has to call AcceptFile,           then wait for the state to change to Open and check the offset value.         ]]&gt;</doc>
      </member>
      <member name="accepted"
              value="2"
              c:identifier="TP_FILE_TRANSFER_STATE_ACCEPTED">
        <doc xml:space="preserve">&lt;![CDATA[           The receiver has accepted the transfer. The sender now has to           call ProvideFile to actually start the transfer.           The receiver should now wait for the state to change to Open           and check the offset value.         ]]&gt;</doc>
      </member>
      <member name="open" value="3" c:identifier="TP_FILE_TRANSFER_STATE_OPEN">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer is open for traffic.         ]]&gt;</doc>
      </member>
      <member name="completed"
              value="4"
              c:identifier="TP_FILE_TRANSFER_STATE_COMPLETED">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer has been completed successfully.         ]]&gt;</doc>
      </member>
      <member name="cancelled"
              value="5"
              c:identifier="TP_FILE_TRANSFER_STATE_CANCELLED">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer has been cancelled.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="FileTransferStateChangeReason"
                 c:type="TpFileTransferStateChangeReason">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           No reason was specified.         ]]&gt;</doc>
      </member>
      <member name="requested"
              value="1"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED">
        <doc xml:space="preserve">&lt;![CDATA[           The change in state was requested.         ]]&gt;</doc>
      </member>
      <member name="local_stopped"
              value="2"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer was cancelled by the local user.         ]]&gt;</doc>
      </member>
      <member name="remote_stopped"
              value="3"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer was cancelled by the remote user.         ]]&gt;</doc>
      </member>
      <member name="local_error"
              value="4"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer was cancelled because of a local error.         ]]&gt;</doc>
      </member>
      <member name="remote_error"
              value="5"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           The file transfer was cancelled because of a remote error.         ]]&gt;</doc>
      </member>
    </enumeration>
    <record name="GroupMixin" c:type="TpGroupMixin">
      <doc xml:space="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's instance structure.

All fields should be considered read-only.</doc>
      <field name="handle_repo" writable="1">
        <doc xml:space="preserve">The connection's contact handle repository</doc>
        <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
      </field>
      <field name="self_handle" writable="1">
        <doc xml:space="preserve">The local user's handle within this group, or 0 if none.
 Set using tp_group_mixin_init() and tp_group_mixin_change_self_handle().</doc>
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="group_flags" writable="1">
        <doc xml:space="preserve">This group's flags. Set using tp_group_mixin_change_flags();
 defaults to 0.</doc>
        <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
      </field>
      <field name="members" writable="1">
        <doc xml:space="preserve">The members of the group. Alter using
 tp_group_mixin_change_members().</doc>
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="local_pending" writable="1">
        <doc xml:space="preserve">Members awaiting the local user's approval to join the
 group. Alter using tp_group_mixin_change_members().</doc>
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="remote_pending" writable="1">
        <doc xml:space="preserve">Members awaiting remote (e.g. remote user or server)
 approval to join the group. Alter using tp_group_mixin_change_members().</doc>
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="priv" writable="1">
        <doc xml:space="preserve">Pointer to opaque private data</doc>
        <type name="GroupMixinPrivate" c:type="TpGroupMixinPrivate*"/>
      </field>
      <function name="add_handle_owner"
                c:identifier="tp_group_mixin_add_handle_owner"
                introspectable="0">
        <doc xml:space="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.

Changed in 0.7.10: The @owner_handle may be 0. To comply with telepathy-spec
 0.17.6, before adding any channel-specific handle to the members,
 local-pending members or remote-pending members, you must call either
 this function or tp_group_mixin_add_handle_owners().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">A GObject implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="local_handle" transfer-ownership="none">
            <doc xml:space="preserve">A contact handle valid within this group (may not be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="owner_handle" transfer-ownership="none">
            <doc xml:space="preserve">A contact handle valid globally, or 0 if the owner of the
 @local_handle is unknown</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="add_handle_owners"
                c:identifier="tp_group_mixin_add_handle_owners"
                version="0.7.10"
                introspectable="0">
        <doc xml:space="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.

To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">A GObject implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="local_to_owner_handle" transfer-ownership="none">
            <doc xml:space="preserve">A map from contact handles valid within this group
 (which may not be 0) to either contact handles valid globally, or 0 if the
 owner of the corresponding key is unknown; all handles are stored using
 GUINT_TO_POINTER</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="add_members"
                c:identifier="tp_group_mixin_add_members"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A message associated with the addition request, if supported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_flags"
                c:identifier="tp_group_mixin_change_flags"
                introspectable="0">
        <doc xml:space="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.

It is an error to set any of the same bits in both @add and @del.

Changed in 0.7.7: the signal is not emitted if adding @add and
 removing @del had no effect on the existing group flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the groups interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:space="preserve">Flags to be added</doc>
            <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:space="preserve">Flags to be removed</doc>
            <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_members"
                c:identifier="tp_group_mixin_change_members"
                introspectable="0">
        <doc xml:space="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)
 signals were emitted; %FALSE if nothing actually changed and the signals
 were suppressed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A message to be sent to the affected contacts if possible;
 %NULL is allowed, and is mapped to an empty string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be added to the members (if not
 already present) and removed from local pending and remote pending
 (if present)</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be removed from members,
 local pending or remote pending, wherever they are present</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_local_pending" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be added to local pending,
 and removed from members and remote pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_remote_pending" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be added to remote pending,
 and removed from members and local pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">The handle of the contact responsible for this change</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">The reason for this change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_members_detailed"
                c:identifier="tp_group_mixin_change_members_detailed"
                version="0.7.21"
                introspectable="0">
        <doc xml:space="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).

If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)
 signals were emitted; %FALSE if nothing actually changed and the signals
 were suppressed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be added to the members (if not
 already present) and removed from local pending and remote pending
 (if present)</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be removed from members,
 local pending or remote pending, wherever they are present</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_local_pending" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be added to local pending,
 and removed from members and remote pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_remote_pending" transfer-ownership="none">
            <doc xml:space="preserve">A set of contact handles to be added to remote pending,
 and removed from members and local pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:space="preserve">a map from strings to GValues detailing the change</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="change_self_handle"
                c:identifier="tp_group_mixin_change_self_handle"
                introspectable="0">
        <doc xml:space="preserve">Change the self-handle for this group to the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="new_self_handle" transfer-ownership="none">
            <doc xml:space="preserve">The new self-handle for this group</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_group_mixin_finalize"
                introspectable="0">
        <doc xml:space="preserve">Unreference handles and free resources used by this mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_all_members"
                c:identifier="tp_group_mixin_get_all_members"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Get the group's current and pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="members" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GArray of guint representing
the handles of the group's members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GArray of guint
representing the handles of the group's local pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GArray of guint
representing the handles of the group's remote pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_dbus_property"
                c:identifier="tp_group_mixin_get_dbus_property"
                version="0.7.10"
                introspectable="0">
        <doc xml:space="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the group mixin. It can only be used for the Group interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">An object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A quark representing the D-Bus property name, either
 "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members",
 "RemotePendingMembers" or "SelfHandle"</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A GValue pre-initialized to the right type, into which to put the
 value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="unused"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_group_flags"
                c:identifier="tp_group_mixin_get_group_flags"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group mixin using this interface</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return the flags</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_handle_owners"
                c:identifier="tp_group_mixin_get_handle_owners"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on
failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:space="preserve">An array of guint representing locally valid handles</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return an array of guint representing globally valid
 handles, or 0 where unavailable, if %TRUE is returned</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_local_pending_members"
                c:identifier="tp_group_mixin_get_local_pending_members"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Get the group's local-pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_local_pending_members_with_info"
                c:identifier="tp_group_mixin_get_local_pending_members_with_info"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each
containing the handle of a local-pending contact, the handle of a contact
 responsible for adding them to the group (or 0), the reason code
 and a related message (e.g. their request to join the group)</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_members"
                c:identifier="tp_group_mixin_get_members"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Get the group's current members</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_group_mixin_get_offset_quark"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_remote_pending_members"
                c:identifier="tp_group_mixin_get_remote_pending_members"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Get the group's remote-pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return a newly-allocated GArray of guint representing the
handles of the group's remote pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_self_handle"
                c:identifier="tp_group_mixin_get_self_handle"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group mixin using this interface</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve">Used to return the local user's handle in this group</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="iface_init"
                c:identifier="tp_group_mixin_iface_init"
                introspectable="0">
        <doc xml:space="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Unused</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_group_mixin_init"
                introspectable="0">
        <doc xml:space="preserve">Initialize the mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset of the TpGroupMixin structure within the instance
 structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="handle_repo" transfer-ownership="none">
            <doc xml:space="preserve">The connection's handle repository for contacts</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:space="preserve">The handle of the local user in this group, if any</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_dbus_properties"
                c:identifier="tp_group_mixin_init_dbus_properties"
                version="0.7.10"
                introspectable="0">
        <doc xml:space="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of an object with this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_members"
                c:identifier="tp_group_mixin_remove_members"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A message to be sent to those contacts, if supported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_members_with_reason"
                c:identifier="tp_group_mixin_remove_members_with_reason"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A message to be sent to those contacts, if supported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">A #TpChannelGroupChangeReason</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="GroupMixinAddMemberFunc"
              c:type="TpGroupMixinAddMemberFunc"
              throws="1">
      <doc xml:space="preserve">Signature of the callback used to add a member to the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be added.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">The handle of the contact to be added</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GroupMixinClass" c:type="TpGroupMixinClass">
      <doc xml:space="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's class structure.

Initialize this with tp_group_mixin_class_init().

All fields should be considered read-only.</doc>
      <field name="add_member" writable="1">
        <doc xml:space="preserve">The add-member function that was passed to
 tp_group_mixin_class_init()</doc>
        <type name="GroupMixinAddMemberFunc"
              c:type="TpGroupMixinAddMemberFunc"/>
      </field>
      <field name="remove_member" writable="1">
        <doc xml:space="preserve">The remove-member function that was passed to
 tp_group_mixin_class_init()</doc>
        <type name="GroupMixinRemMemberFunc"
              c:type="TpGroupMixinRemMemberFunc"/>
      </field>
      <field name="priv" writable="1">
        <doc xml:space="preserve">Pointer to opaque private data</doc>
        <type name="GroupMixinClassPrivate"
              c:type="TpGroupMixinClassPrivate*"/>
      </field>
      <function name="allow_self_removal"
                c:identifier="tp_group_mixin_class_allow_self_removal"
                version="0.7.27"
                introspectable="0">
        <doc xml:space="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.

This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().

(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of an object implementing the group interface using this
 mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_group_mixin_class_get_offset_quark"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_group_mixin_class_init"
                introspectable="0">
        <doc xml:space="preserve">Configure the mixin for use with the given class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of an object implementing the group interface using this
 mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset of the TpGroupMixinClass structure within the class
 structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="add_func" transfer-ownership="none">
            <doc xml:space="preserve">A callback to be used to add contacts to this group</doc>
            <type name="GroupMixinAddMemberFunc"
                  c:type="TpGroupMixinAddMemberFunc"/>
          </parameter>
          <parameter name="rem_func" transfer-ownership="none">
            <doc xml:space="preserve">A callback to be used to remove contacts from this group.
 This must be %NULL if you will subsequently call
 tp_group_mixin_class_set_remove_with_reason_func().</doc>
            <type name="GroupMixinRemMemberFunc"
                  c:type="TpGroupMixinRemMemberFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_remove_with_reason_func"
                c:identifier="tp_group_mixin_class_set_remove_with_reason_func"
                version="0.5.13"
                introspectable="0">
        <doc xml:space="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of an object implementing the group interface using this
 mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve">A callback to be used to remove contacts from this group with a
 specified reason.</doc>
            <type name="GroupMixinRemMemberWithReasonFunc"
                  c:type="TpGroupMixinRemMemberWithReasonFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="GroupMixinClassPrivate"
            c:type="TpGroupMixinClassPrivate"
            disguised="1">
    </record>
    <record name="GroupMixinPrivate"
            c:type="TpGroupMixinPrivate"
            disguised="1">
    </record>
    <callback name="GroupMixinRemMemberFunc"
              c:type="TpGroupMixinRemMemberFunc"
              throws="1">
      <doc xml:space="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GroupMixinRemMemberWithReasonFunc"
              c:type="TpGroupMixinRemMemberWithReasonFunc"
              throws="1">
      <doc xml:space="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.

Set this with tp_group_mixin_class_set_remove_with_reason_func(), .</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:space="preserve">A #TpChannelGroupChangeReason indicating the reason</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HTTPMethod" c:type="TpHTTPMethod">
      <doc xml:space="preserve">&lt;![CDATA[         The HTTP Method with which to request a URL.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="get" value="0" c:identifier="TP_HTTP_METHOD_GET">
        <doc xml:space="preserve">&lt;![CDATA[           Use the GET method when opening the URL.         ]]&gt;</doc>
      </member>
      <member name="post" value="1" c:identifier="TP_HTTP_METHOD_POST">
        <doc xml:space="preserve">&lt;![CDATA[           Use the POST method when opening the URL. Refer to           HTTP_Post_Data for more details.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="HandleChannelsContext"
           c:symbol-prefix="handle_channels_context"
           c:type="TpHandleChannelsContext"
           version="0.11.6"
           parent="GObject.Object"
           glib:type-name="TpHandleChannelsContext"
           glib:get-type="tp_handle_channels_context_get_type"
           glib:type-struct="HandleChannelsContextClass">
      <doc xml:space="preserve">Data structure representing the context of a Handler.HandleChannels()
call.</doc>
      <method name="accept"
              c:identifier="tp_handle_channels_context_accept"
              version="0.11.6">
        <doc xml:space="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.

The caller is responsible for closing channels with
tp_cli_channel_call_close() when it has finished handling them.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleChannelsContext</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delay"
              c:identifier="tp_handle_channels_context_delay"
              version="0.11.6">
        <doc xml:space="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpHandleChannelsContext before calling this function, and
is responsible for calling either
tp_handle_channels_context_accept() or
tp_handle_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleChannelsContext</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fail"
              c:identifier="tp_handle_channels_context_fail"
              version="0.11.6">
        <doc xml:space="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleChannelsContext</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handler_info"
              c:identifier="tp_handle_channels_context_get_handler_info"
              version="0.11.14">
        <doc xml:space="preserve">Return any extra information that accompanied this request to handle
channels (the Handler_Info argument from the HandleChannels D-Bus method).
Well-known keys for this map will be defined by the Telepathy D-Bus
Interface Specification; at the time of writing, none have been defined.

The returned hash table is only valid for as long as @self is.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">extensible
 extra handler information, in a form suitable for use with
 tp_asv_get_string() etc.</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel-handling context</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_requests"
              c:identifier="tp_handle_channels_context_get_requests"
              version="0.13.14">
        <doc xml:space="preserve">Return a list of the #TpChannelRequest which have been satisfied by the
channels associated with #self.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a newly allocated #GList of reffed #TpChannelRequest.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel-handling context</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.6"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
HandleChannels call.
Can only be written during construction.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="handler-info"
                version="0.11.6"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GHashTable where the keys are string and values are GValue instances.
It represents the Handler_info hash table that has been passed to
HandleChannels.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="requests-satisfied"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="user-action-time"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The time at which user action occurred, or one of the
special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME
(see #TpAccountChannelRequest:user-action-time for details)

Read-only except during construction.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <glib:signal name="done" when="last" detailed="1" version="0.11.6">
        <doc xml:space="preserve">Emitted when tp_handle_channels_context_accept has been called on @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="HandleChannelsContextClass"
            c:type="TpHandleChannelsContextClass"
            disguised="1"
            glib:is-gtype-struct-for="HandleChannelsContext"
            version="0.11.6">
      <doc xml:space="preserve">The class of a #TpHandleChannelsContext.</doc>
    </record>
    <record name="HandleChannelsContextPrivate"
            c:type="TpHandleChannelsContextPrivate"
            disguised="1">
    </record>
    <interface name="HandleRepoIface"
               c:symbol-prefix="handle_repo_iface"
               c:type="TpHandleRepoIface"
               glib:type-name="TpHandleRepoIface"
               glib:get-type="tp_handle_repo_iface_get_type">
      <doc xml:space="preserve">Dummy typedef representing any implementation of this interface.</doc>
      <property name="handle-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
    </interface>
    <record name="HandleRepoIfaceClass"
            c:type="TpHandleRepoIfaceClass"
            disguised="1">
      <doc xml:space="preserve">The class of a handle repository interface. The structure layout is
only available within telepathy-glib, for the handle repository
implementations' benefit.</doc>
    </record>
    <record name="HandleSet"
            c:type="TpHandleSet"
            glib:type-name="TpHandleSet"
            glib:get-type="tp_handle_set_get_type"
            c:symbol-prefix="handle_set">
      <doc xml:space="preserve">A set of handles. This is similar to a #TpIntset (and implemented using
one), but adding a handle to the set also references it.</doc>
      <constructor name="new"
                   c:identifier="tp_handle_set_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_containing"
                   c:identifier="tp_handle_set_new_containing"
                   version="0.13.0"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #TpHandleSet from a specified handle repository and single
handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a valid handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_array"
                   c:identifier="tp_handle_set_new_from_array"
                   version="0.11.7"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">array of handles to be referenced by this set</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_intset"
                   c:identifier="tp_handle_set_new_from_intset"
                   version="0.13.0"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #TpHandleSet from a specified handle repository and
set of handles.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="intset" transfer-ownership="none">
            <doc xml:space="preserve">a set of handles, which must all be valid</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="tp_handle_set_add" introspectable="0">
        <doc xml:space="preserve">Add a handle to a #TpHandleSet, and reference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleSet to add this handle to</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">handle to add</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="tp_handle_set_clear"
              version="0.11.6"
              introspectable="0">
        <doc xml:space="preserve">Remove every handle from @set, releasing the references it holds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleSet to clear</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="tp_handle_set_copy"
              version="0.11.6"
              introspectable="0">
        <doc xml:space="preserve">Creates a new #TpHandleSet with the same contents as @other.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new set</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">another handle set</doc>
            <type name="HandleSet" c:type="const TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="tp_handle_set_destroy"
              introspectable="0">
        <doc xml:space="preserve">Delete a #TpHandleSet and unreference any handles that it holds</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleSet to destroy</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="difference_update"
              c:identifier="tp_handle_set_difference_update"
              introspectable="0">
        <doc xml:space="preserve">Remove a set of handles from a handle set, dereferencing those which are
members. The TpIntset returned must be freed with tp_intset_destroy.

If you want to be able to inspect the handles in the set returned,
you must ensure that this function does not cause their refcount to drop
to zero, for instance by temporarily taking a reference to all the
handles in @remove, calling this function, doing something with the
result and discarding the temporary references.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the handles which were dereferenced and removed (some subset
 of @remove).</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleSet to update</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
          <parameter name="remove" transfer-ownership="none">
            <doc xml:space="preserve">a #TpIntset of handles to remove</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_handle_set_dump">
        <doc xml:space="preserve">Format a #TpHandleSet for debug output.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string representation of the
 handle set suitable for debug output</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a handle set</doc>
            <type name="HandleSet" c:type="const TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach"
              c:identifier="tp_handle_set_foreach"
              introspectable="0">
        <doc xml:space="preserve">Call @func(@set, @handle, @userdata) for each handle in @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A set of handles</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">A callback</doc>
            <type name="HandleSetMemberFunc" c:type="TpHandleSetMemberFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Arbitrary data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="tp_handle_set_is_empty"
              version="0.11.6"
              introspectable="0">
        <doc xml:space="preserve">Return the same thing as &lt;code&gt;(tp_handle_set_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the set has no members</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleSet to check</doc>
            <type name="HandleSet" c:type="const TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_member"
              c:identifier="tp_handle_set_is_member"
              introspectable="0">
        <doc xml:space="preserve">Check if the handle is in this set</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the handle is in this set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A #TpHandleSet</doc>
            <type name="HandleSet" c:type="const TpHandleSet*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">handle to check</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="tp_handle_set_peek" introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the underlying #TpIntset used by this #TpHandleSet</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleSet to peek at</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove"
              c:identifier="tp_handle_set_remove"
              introspectable="0">
        <doc xml:space="preserve">Remove a handle from a #TpHandleSet, and unreference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">FALSE if the handle was invalid, or was not in this set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">#TpHandleSet to remove this handle from</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">handle to remove</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="tp_handle_set_size" introspectable="0">
        <doc xml:space="preserve">&lt;!--no further documentation needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of handles in this set</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A set of handles</doc>
            <type name="HandleSet" c:type="const TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_array"
              c:identifier="tp_handle_set_to_array"
              introspectable="0">
        <doc xml:space="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;</doc>
        <return-value>
          <doc xml:space="preserve">a newly-allocated GArray of guint representing
the handles in the set</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A handle set</doc>
            <type name="HandleSet" c:type="const TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_identifier_map"
              c:identifier="tp_handle_set_to_identifier_map">
        <doc xml:space="preserve">Returns a dictionary mapping each handle in @self to the corresponding
identifier, as if retrieved by calling tp_handle_inspect() on each handle.
The type of the returned value is described as
&lt;code&gt;Handle_Identifier_Map&lt;/code&gt; in the Telepathy specification.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a map from the
 handles in @self to the corresponding identifier.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Handle"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a handle set</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update"
              c:identifier="tp_handle_set_update"
              introspectable="0">
        <doc xml:space="preserve">Add a set of handles to a handle set, referencing those which are not
already members. The TpIntset returned must be freed with tp_intset_destroy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the handles which were added (some subset of @add)</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandleSet to update</doc>
            <type name="HandleSet" c:type="TpHandleSet*"/>
          </instance-parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:space="preserve">a #TpIntset of handles to add</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <function name="qdata"
                c:identifier="tp_handle_set_qdata"
                introspectable="0"
                deprecated="1">
        <doc xml:space="preserve">Associates a blob of data with a given handle and a given key

If @destroy is set, then the data is freed when the handle is freed.

Since version 0.13.8, handles always last as long as the
connection, so @destroy will not be called until the connection
disconnects.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. It is not recommended to use this function
 because the associated data won't be freed until the connection disconnects.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:space="preserve">A handle repository implementation</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">A handle to set data on</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="key_id" transfer-ownership="none">
            <doc xml:space="preserve">Key id to associate data with</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to associate with handle</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify to call to destroy the data,
          or NULL if not needed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="HandleSetMemberFunc"
              c:type="TpHandleSetMemberFunc"
              introspectable="0">
      <doc xml:space="preserve">Signature of the callback used to iterate over the handle set in
tp_handle_set_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <doc xml:space="preserve">The set of handles on which tp_handle_set_foreach() was called</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A handle in the set</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="userdata"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Arbitrary user data as supplied to tp_handle_set_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HandleType" c:type="TpHandleType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_HANDLE_TYPE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           A "null" handle type used to indicate the absence of a handle.           When a handle type and a handle appear as a pair, if the handle           type is zero, the handle must also be zero.         ]]&gt;</doc>
      </member>
      <member name="contact" value="1" c:identifier="TP_HANDLE_TYPE_CONTACT">
        <doc xml:space="preserve">&lt;![CDATA[           A contact         ]]&gt;</doc>
      </member>
      <member name="room" value="2" c:identifier="TP_HANDLE_TYPE_ROOM">
        <doc xml:space="preserve">&lt;![CDATA[           A chat room         ]]&gt;</doc>
      </member>
      <member name="list" value="3" c:identifier="TP_HANDLE_TYPE_LIST">
        <doc xml:space="preserve">&lt;![CDATA[           A server-generated contact list (see Channel.Interface.Group)         ]]&gt;</doc>
      </member>
      <member name="group" value="4" c:identifier="TP_HANDLE_TYPE_GROUP">
        <doc xml:space="preserve">&lt;![CDATA[           A user-defined contact list (see Channel.Interface.Group)         ]]&gt;</doc>
      </member>
    </enumeration>
    <constant name="IFACE_ACCOUNT"
              value="org.freedesktop.Telepathy.Account"
              c:type="TP_IFACE_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Account.Interface.Addressing"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_AVATAR"
              value="org.freedesktop.Telepathy.Account.Interface.Avatar"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_AVATAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_STORAGE"
              value="org.freedesktop.Telepathy.Account.Interface.Storage"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_STORAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_MANAGER"
              value="org.freedesktop.Telepathy.AccountManager"
              c:type="TP_IFACE_ACCOUNT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_AUTHENTICATION_TLS_CERTIFICATE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate"
              c:type="TP_IFACE_AUTHENTICATION_TLS_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT"
              value="org.freedesktop.Telepathy.Call1.Content"
              c:type="TP_IFACE_CALL_CONTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_AUDIO_CONTROL"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.AudioControl"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_AUDIO_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_DTMF"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.DTMF"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_DTMF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_MEDIA"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_VIDEO_CONTROL"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_VIDEO_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPFeedback"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTPHeaderExtensions"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_STREAM"
              value="org.freedesktop.Telepathy.Call1.Stream"
              c:type="TP_IFACE_CALL_STREAM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_STREAM_ENDPOINT"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint"
              c:type="TP_IFACE_CALL_STREAM_ENDPOINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_STREAM_INTERFACE_MEDIA"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media"
              c:type="TP_IFACE_CALL_STREAM_INTERFACE_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL"
              value="org.freedesktop.Telepathy.Channel"
              c:type="TP_IFACE_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER"
              value="org.freedesktop.Telepathy.ChannelDispatcher"
              c:type="TP_IFACE_CHANNEL_DISPATCHER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER_INTERFACE_MESSAGES1"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.Messages1"
              c:type="TP_IFACE_CHANNEL_DISPATCHER_INTERFACE_MESSAGES1">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList"
              c:type="TP_IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCH_OPERATION"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation"
              c:type="TP_IFACE_CHANNEL_DISPATCH_OPERATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ANONYMITY"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ANONYMITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CALL_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.CallState"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CALL_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CHAT_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.ChatState"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CHAT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CONFERENCE"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CONFERENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DESTROYABLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Destroyable"
              c:type="TP_IFACE_CHANNEL_INTERFACE_DESTROYABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DTMF"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF"
              c:type="TP_IFACE_CHANNEL_INTERFACE_DTMF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata"
              c:type="TP_IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_GROUP"
              value="org.freedesktop.Telepathy.Channel.Interface.Group"
              c:type="TP_IFACE_CHANNEL_INTERFACE_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_HOLD"
              value="org.freedesktop.Telepathy.Channel.Interface.Hold"
              c:type="TP_IFACE_CHANNEL_INTERFACE_HOLD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling"
              c:type="TP_IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MESSAGES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages"
              c:type="TP_IFACE_CHANNEL_INTERFACE_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_PASSWORD"
              value="org.freedesktop.Telepathy.Channel.Interface.Password"
              c:type="TP_IFACE_CHANNEL_INTERFACE_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ROOM"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ROOM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ROOM_CONFIG"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ROOM_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SECURABLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SECURABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SMS"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SUBJECT"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SUBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_TUBE"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube"
              c:type="TP_IFACE_CHANNEL_INTERFACE_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_REQUEST"
              value="org.freedesktop.Telepathy.ChannelRequest"
              c:type="TP_IFACE_CHANNEL_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CALL"
              value="org.freedesktop.Telepathy.Channel.Type.Call1"
              c:type="TP_IFACE_CHANNEL_TYPE_CALL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Channel.Type.ContactList"
              c:type="TP_IFACE_CHANNEL_TYPE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_SEARCH"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch"
              c:type="TP_IFACE_CHANNEL_TYPE_CONTACT_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_DBUS_TUBE"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube"
              c:type="TP_IFACE_CHANNEL_TYPE_DBUS_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_FILE_TRANSFER"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer"
              c:type="TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_ROOM_LIST"
              value="org.freedesktop.Telepathy.Channel.Type.RoomList"
              c:type="TP_IFACE_CHANNEL_TYPE_ROOM_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Type.ServerAuthentication"
              c:type="TP_IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection"
              c:type="TP_IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAMED_MEDIA"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"
              c:type="TP_IFACE_CHANNEL_TYPE_STREAMED_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAM_TUBE"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube"
              c:type="TP_IFACE_CHANNEL_TYPE_STREAM_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TEXT"
              value="org.freedesktop.Telepathy.Channel.Type.Text"
              c:type="TP_IFACE_CHANNEL_TYPE_TEXT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TUBES"
              value="org.freedesktop.Telepathy.Channel.Type.Tubes"
              c:type="TP_IFACE_CHANNEL_TYPE_TUBES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT"
              value="org.freedesktop.Telepathy.Client"
              c:type="TP_IFACE_CLIENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_APPROVER"
              value="org.freedesktop.Telepathy.Client.Approver"
              c:type="TP_IFACE_CLIENT_APPROVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_HANDLER"
              value="org.freedesktop.Telepathy.Client.Handler"
              c:type="TP_IFACE_CLIENT_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_INTERFACE_REQUESTS"
              value="org.freedesktop.Telepathy.Client.Interface.Requests"
              c:type="TP_IFACE_CLIENT_INTERFACE_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_OBSERVER"
              value="org.freedesktop.Telepathy.Client.Observer"
              c:type="TP_IFACE_CLIENT_OBSERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION"
              value="org.freedesktop.Telepathy.Connection"
              c:type="TP_IFACE_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Connection.Interface.Addressing1"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ALIASING"
              value="org.freedesktop.Telepathy.Connection.Interface.Aliasing"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ALIASING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ANONYMITY"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ANONYMITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_AVATARS"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars"
              c:type="TP_IFACE_CONNECTION_INTERFACE_AVATARS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_BALANCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance"
              c:type="TP_IFACE_CONNECTION_INTERFACE_BALANCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.Capabilities"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CELLULAR"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CELLULAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CLIENT_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.ClientTypes"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CLIENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACTS"
              value="org.freedesktop.Telepathy.Connection.Interface.Contacts"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_INFO"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_LOCATION"
              value="org.freedesktop.Telepathy.Connection.Interface.Location"
              c:type="TP_IFACE_CONNECTION_INTERFACE_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification"
              c:type="TP_IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_POWER_SAVING"
              value="org.freedesktop.Telepathy.Connection.Interface.PowerSaving"
              c:type="TP_IFACE_CONNECTION_INTERFACE_POWER_SAVING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Presence"
              c:type="TP_IFACE_CONNECTION_INTERFACE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_RENAMING"
              value="org.freedesktop.Telepathy.Connection.Interface.Renaming"
              c:type="TP_IFACE_CONNECTION_INTERFACE_RENAMING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_REQUESTS"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests"
              c:type="TP_IFACE_CONNECTION_INTERFACE_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SIDECARS1"
              value="org.freedesktop.Telepathy.Connection.Interface.Sidecars1"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SIDECARS1">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_MANAGER"
              value="org.freedesktop.Telepathy.ConnectionManager"
              c:type="TP_IFACE_CONNECTION_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_DAEMON"
              value="org.freedesktop.DBus"
              c:type="TP_IFACE_DBUS_DAEMON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_INTROSPECTABLE"
              value="org.freedesktop.DBus.Introspectable"
              c:type="TP_IFACE_DBUS_INTROSPECTABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_PEER"
              value="org.freedesktop.DBus.Peer"
              c:type="TP_IFACE_DBUS_PEER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_PROPERTIES"
              value="org.freedesktop.DBus.Properties"
              c:type="TP_IFACE_DBUS_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DEBUG"
              value="org.freedesktop.Telepathy.Debug"
              c:type="TP_IFACE_DEBUG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_MEDIA_SESSION_HANDLER"
              value="org.freedesktop.Telepathy.Media.SessionHandler"
              c:type="TP_IFACE_MEDIA_SESSION_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_MEDIA_STREAM_HANDLER"
              value="org.freedesktop.Telepathy.Media.StreamHandler"
              c:type="TP_IFACE_MEDIA_STREAM_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROPERTIES_INTERFACE"
              value="org.freedesktop.Telepathy.Properties"
              c:type="TP_IFACE_PROPERTIES_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL"
              value="org.freedesktop.Telepathy.Protocol"
              c:type="TP_IFACE_PROTOCOL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_AVATARS"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_AVATARS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_PRESENCE"
              value="org.freedesktop.Telepathy.Protocol.Interface.Presence"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="INTERNAL_CONNECTION_STATUS_NEW"
              value="-1"
              c:type="TP_INTERNAL_CONNECTION_STATUS_NEW"
              introspectable="0">
      <doc xml:space="preserve">A special value for #TpConnectionStatus, used within GLib connection
managers to indicate that the connection is disconnected because
connection has never been attempted (as distinct from disconnected
after connection has started, either by user request or an error).

Must never be visible on the D-Bus - %TP_CONNECTION_STATUS_DISCONNECTED
is sent instead.</doc>
      <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
    </constant>
    <callback name="IntFunc" c:type="TpIntFunc">
      <doc xml:space="preserve">A callback function acting on unsigned integers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="i" transfer-ownership="none">
          <doc xml:space="preserve">The relevant integer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="userdata"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Opaque user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Intset"
            c:type="TpIntset"
            glib:type-name="TpIntset"
            glib:get-type="tp_intset_get_type"
            c:symbol-prefix="intset">
      <doc xml:space="preserve">Opaque type representing a set of unsigned integers.

Before 0.11.16, this type was called &lt;type&gt;TpIntSet&lt;/type&gt;, which is
now a backwards compatibility typedef.</doc>
      <constructor name="new" c:identifier="tp_intset_new">
        <doc xml:space="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </constructor>
      <constructor name="new_containing"
                   c:identifier="tp_intset_new_containing"
                   version="0.7.26">
        <doc xml:space="preserve">Allocate a new integer set containing the given integer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new integer set containing @element, to be destroyed with
tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">integer to add to a new set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="sized_new" c:identifier="tp_intset_sized_new">
        <doc xml:space="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">ignored (it was previously 1 more than the largest integer you
 expect to store)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="tp_intset_add">
        <doc xml:space="preserve">Add an integer into a TpIntset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </instance-parameter>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">integer to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="tp_intset_clear">
        <doc xml:space="preserve">Unset every integer in the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="tp_intset_copy">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A set containing the same integers as @orig, to be freed with
tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="orig" transfer-ownership="none">
            <doc xml:space="preserve">A set of integers</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="tp_intset_destroy">
        <doc xml:space="preserve">Free all memory used by the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="difference" c:identifier="tp_intset_difference">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The set of those integers which are in @left and not in @right
(analogous to the bitwise operation left &amp; (~right)), to be freed with
tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">The left operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="difference_update"
              c:identifier="tp_intset_difference_update"
              version="0.13.10">
        <doc xml:space="preserve">Remove each integer in @other from @self, analogous to the bitwise
operation self &amp;= (~other).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the set to change</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">members to remove</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_intset_dump">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string which the caller must free with g_free, listing the
numbers in @set in a human-readable format</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">An integer set</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="tp_intset_foreach">
        <doc xml:space="preserve">Call @func(element, @userdata) for each element of @set, in order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">@TpIntFunc to use to iterate the set</doc>
            <type name="IntFunc" c:type="TpIntFunc"/>
          </parameter>
          <parameter name="userdata"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to each call of @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersection" c:identifier="tp_intset_intersection">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The set of those integers which are in both @left and @right
(analogous to the bitwise operation left &amp; right), to be freed with
tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">The left operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="tp_intset_is_empty"
              version="0.11.6">
        <doc xml:space="preserve">Return the same thing as &lt;code&gt;(tp_intset_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @set is empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">a set of integers</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_equal" c:identifier="tp_intset_is_equal">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @left and @right contain the same bits</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">A set of integers</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">A set of integers</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_member" c:identifier="tp_intset_is_member">
        <doc xml:space="preserve">Tests if @element is a member of @set</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @element is in @set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">integer to test</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="tp_intset_remove">
        <doc xml:space="preserve">Remove an integer from a TpIntset</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @element was previously in @set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </instance-parameter>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">integer to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="tp_intset_size">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of integers in @set</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A set of integers</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="symmetric_difference"
              c:identifier="tp_intset_symmetric_difference">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The set of those integers which are in either @left or @right
but not both (analogous to the bitwise operation left ^ right), to be freed
with tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">The left operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_array" c:identifier="tp_intset_to_array">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GArray of guint (which must
 be freed by the caller) containing the same integers as @set.</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set to convert</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="union" c:identifier="tp_intset_union">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The set of those integers which are in either @left or @right
(analogous to the bitwise operation left | right), to be freed with
tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">The left operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union_update"
              c:identifier="tp_intset_union_update"
              version="0.13.10">
        <doc xml:space="preserve">Add each integer in @other to @self, analogous to the bitwise operation
self |= other.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the set to change</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">members to add</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <function name="from_array" c:identifier="tp_intset_from_array">
        <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A set containing the same integers as @array.</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">An array of guint</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="IntsetFastIter" c:type="TpIntsetFastIter" version="0.11.6">
      <doc xml:space="preserve">An opaque structure representing iteration in undefined order over a set of
integers. Must be initialized with tp_intset_fast_iter_init().

Before 0.11.16, this type was called &lt;type&gt;TpIntSetFastIter&lt;/type&gt;,
which is now a backwards compatibility typedef.

Usage is similar to #GHashTableIter:

&lt;informalexample&gt;&lt;programlisting&gt;
TpIntsetFastIter iter;
guint element;

tp_intset_fast_iter_init (&amp;amp;iter, intset);

while (tp_intset_fast_iter_next (&amp;amp;iter, &amp;amp;element))
{
  printf ("%u is in the intset\n", element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <field name="_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="init"
              c:identifier="tp_intset_fast_iter_init"
              version="0.11.6">
        <doc xml:space="preserve">Initialize @iter to iterate over @set in arbitrary order. @iter will become
invalid if @set is modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an iterator</doc>
            <type name="IntsetFastIter" c:type="TpIntsetFastIter*"/>
          </instance-parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">a set</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="tp_intset_fast_iter_next"
              version="0.11.6">
        <doc xml:space="preserve">Advances @iter and retrieves the integer it now points to. Iteration
is not necessarily in numerical order.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the end of the set has been reached</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an iterator</doc>
            <type name="IntsetFastIter" c:type="TpIntsetFastIter*"/>
          </instance-parameter>
          <parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve">a location to store a new integer, in arbitrary order</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="IntsetIter" c:type="TpIntsetIter" deprecated="1">
      <doc xml:space="preserve">A structure representing iteration over a set of integers. Must be
initialized with either TP_INTSET_ITER_INIT() or tp_intset_iter_init().

Since 0.11.6, consider using #TpIntsetFastIter if iteration in
numerical order is not required.

Before 0.11.16, this type was called &lt;type&gt;TpIntSetIter&lt;/type&gt;,
which is now a backwards compatibility typedef.</doc>
      <doc-deprecated xml:space="preserve">since 0.19.0. Use #TpIntsetFastIter instead</doc-deprecated>
      <field name="set" writable="1">
        <doc xml:space="preserve">The set iterated over.</doc>
        <type name="Intset" c:type="const TpIntset*"/>
      </field>
      <field name="element" writable="1">
        <doc xml:space="preserve">Must be (guint)(-1) before iteration starts. Set to the next
 element in the set by tp_intset_iter_next(); undefined after
 tp_intset_iter_next() returns %FALSE.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <method name="init" c:identifier="tp_intset_iter_init" deprecated="1">
        <doc xml:space="preserve">Reset the iterator @iter to the beginning and make it iterate over @set.</doc>
        <doc-deprecated xml:space="preserve">since 0.19.0. Use #TpIntsetFastIter instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An integer set iterator to be initialized.</doc>
            <type name="IntsetIter" c:type="TpIntsetIter*"/>
          </instance-parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">An integer set to be used by that iterator</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="tp_intset_iter_next">
        <doc xml:space="preserve">If there are integers in (@iter-&gt;set) higher than (@iter-&gt;element), set
(iter-&gt;element) to the next one and return %TRUE. Otherwise return %FALSE.

Usage:

&lt;informalexample&gt;&lt;programlisting&gt;
TpIntsetIter iter = TP_INTSET_INIT (intset);
while (tp_intset_iter_next (&amp;amp;iter))
{
  printf ("%u is in the intset\n", iter.element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

Since 0.11.6, consider using #TpIntsetFastIter if iteration in
numerical order is not required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if (@iter-&gt;element) has been advanced</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator originally initialized with TP_INTSET_INIT(set)</doc>
            <type name="IntsetIter" c:type="TpIntsetIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="tp_intset_iter_reset" deprecated="1">
        <doc xml:space="preserve">Reset the iterator @iter to the beginning. It must already be associated
with a set.</doc>
        <doc-deprecated xml:space="preserve">since 0.19.0. Use #TpIntsetFastIter instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An integer set iterator to be reset.</doc>
            <type name="IntsetIter" c:type="TpIntsetIter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="LocalHoldState" c:type="TpLocalHoldState">
      <doc xml:space="preserve">&lt;![CDATA[         The hold state of a channel.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unheld"
              value="0"
              c:identifier="TP_LOCAL_HOLD_STATE_UNHELD">
        <doc xml:space="preserve">&lt;![CDATA[           All streams are unheld (the call is active). New channels SHOULD           have this hold state.         ]]&gt;</doc>
      </member>
      <member name="held" value="1" c:identifier="TP_LOCAL_HOLD_STATE_HELD">
        <doc xml:space="preserve">&lt;![CDATA[           All streams are held (the call is on hold)         ]]&gt;</doc>
      </member>
      <member name="pending_hold"
              value="2"
              c:identifier="TP_LOCAL_HOLD_STATE_PENDING_HOLD">
        <doc xml:space="preserve">&lt;![CDATA[           The connection manager is attempting to move to state Held, but           has not yet completed that operation. It is unspecified whether           any, all or none of the streams making up the channel are on hold.           Examining the Hold state of Call Contents (if applicable) may           provide more useful information.         ]]&gt;</doc>
      </member>
      <member name="pending_unhold"
              value="3"
              c:identifier="TP_LOCAL_HOLD_STATE_PENDING_UNHOLD">
        <doc xml:space="preserve">&lt;![CDATA[           The connection manager is attempting to move to state Unheld, but           has not yet completed that operation. It is unspecified whether           any, all or none of the streams making up the channel are on hold.           Examining the Hold state of Call Contents (if applicable) may           provide more useful information.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="LocalHoldStateReason" c:type="TpLocalHoldStateReason">
      <doc xml:space="preserve">&lt;![CDATA[         The reason for a change to the Local_Hold_State. Clients MUST         treat unknown values as equivalent to Local_Hold_State_Reason_None.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           The reason cannot be described by any of the predefined values           (connection managers SHOULD avoid this reason, but clients MUST           handle it gracefully)         ]]&gt;</doc>
      </member>
      <member name="requested"
              value="1"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_REQUESTED">
        <doc xml:space="preserve">&lt;![CDATA[           The change is in response to a user request         ]]&gt;</doc>
      </member>
      <member name="resource_not_available"
              value="2"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE">
        <doc xml:space="preserve">&lt;![CDATA[           The change is because some resource was not available         ]]&gt;</doc>
      </member>
    </enumeration>
    <bitfield name="LocationFeatures" c:type="TpLocationFeatures">
      <doc xml:space="preserve">&lt;![CDATA[         Flags describing the Location features which may be supported on any         given connection.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="location_feature_can_set"
              value="1"
              c:identifier="TP_LOCATION_FEATURE_CAN_SET">
        <doc xml:space="preserve">&lt;![CDATA[           Indicates that setting your own location with           SetLocation is supported on this           connection.         ]]&gt;</doc>
      </member>
    </bitfield>
    <bitfield name="MailNotificationFlags" c:type="TpMailNotificationFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags representing capabilities provided by a connection manager.           Those values can be used as bitfield. Some flags depend on, or           conflict with, each other.          Connections SHOULD implement as many of these features as the           underlying protocol allows, preferring to implement           Supports_Unread_Mails instead of Emits_Mails_Received if both are           possible.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="supports_unread_mail_count"
              value="1"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_UNREAD_MAIL_COUNT">
        <doc xml:space="preserve">&lt;![CDATA[           This Connection provides the number of unread e-mails (or e-mail           threads) in the main folder of your e-mail account, as the           UnreadMailCount property. The           connection manager will update this value by emitting the           UnreadMailsChanged signal.         ]]&gt;</doc>
      </member>
      <member name="supports_unread_mails"
              value="2"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_UNREAD_MAILS">
        <doc xml:space="preserve">&lt;![CDATA[           This Connection provides a detailed list of unread e-mails, as the           UnreadMails property. If this flag           is set, Supports_Unread_Mail_Count MUST be set, and           Emits_Mails_Received MUST NOT be set.           The Connection will update the list by emitting the           UnreadMailsChanged signals.         ]]&gt;</doc>
      </member>
      <member name="emits_mails_received"
              value="4"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_EMITS_MAILS_RECEIVED">
        <doc xml:space="preserve">&lt;![CDATA[           This Connection emits the MailsReceived           signal, which provides details about newly arrived e-mails but does           not maintain their read/unread status afterwards. This flag MUST NOT           be combined with Supports_Unread_Mails.         ]]&gt;</doc>
      </member>
      <member name="supports_request_inbox_url"
              value="8"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_REQUEST_INBOX_URL">
        <doc xml:space="preserve">&lt;![CDATA[           This Connection can provide a URL (with optional POST data) to           open the the inbox of the e-mail account in a web-based client, via           the RequestInboxURL method.         ]]&gt;</doc>
      </member>
      <member name="supports_request_mail_url"
              value="16"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_REQUEST_MAIL_URL">
        <doc xml:space="preserve">&lt;![CDATA[           This Connection can provide a URL (with optional POST data) to open             a specific mail in a web-based client, via the             RequestMailURL method. This feature             is not useful unless either Emits_Mails_Received or             Supports_Unread_Mails is set.            If this flag is not set, clients SHOULD fall back to using             RequestInboxURL if available.         ]]&gt;</doc>
      </member>
      <member name="thread_based"
              value="32"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_THREAD_BASED">
        <doc xml:space="preserve">&lt;![CDATA[           Each Mail represents a thread of e-mails, which             MAY have more than one sender.                         Google Talk notifies users about new mail in terms of unread               threads, rather than unread e-mails.                    ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="MediaStreamBaseProto" c:type="TpMediaStreamBaseProto">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="udp"
              value="0"
              c:identifier="TP_MEDIA_STREAM_BASE_PROTO_UDP">
        <doc xml:space="preserve">&lt;![CDATA[UDP (User Datagram Protocol)]]&gt;</doc>
      </member>
      <member name="tcp"
              value="1"
              c:identifier="TP_MEDIA_STREAM_BASE_PROTO_TCP">
        <doc xml:space="preserve">&lt;![CDATA[TCP (Transmission Control Protocol)]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="MediaStreamDirection" c:type="TpMediaStreamDirection">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_NONE">
        <doc xml:space="preserve">&lt;![CDATA[Media are not being sent or received]]&gt;</doc>
      </member>
      <member name="send"
              value="1"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_SEND">
        <doc xml:space="preserve">&lt;![CDATA[Media are being sent, but not received]]&gt;</doc>
      </member>
      <member name="receive"
              value="2"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_RECEIVE">
        <doc xml:space="preserve">&lt;![CDATA[Media are being received, but not sent]]&gt;</doc>
      </member>
      <member name="bidirectional"
              value="3"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL">
        <doc xml:space="preserve">&lt;![CDATA[Media are being sent and received]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="MediaStreamError" c:type="TpMediaStreamError">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_MEDIA_STREAM_ERROR_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           An unknown error occured.         ]]&gt;</doc>
      </member>
      <member name="eos" value="1" c:identifier="TP_MEDIA_STREAM_ERROR_EOS">
        <doc xml:space="preserve">&lt;![CDATA[           The end of the stream was reached.         ]]&gt;</doc>
      </member>
      <member name="codec_negotiation_failed"
              value="2"
              c:identifier="TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           There are no common codecs between the local side           and the other particpants in the call. The possible codecs are not           signalled here: the streaming implementation is assumed to report           them in an implementation-dependent way, e.g. Farsight should use           GstMissingElement.         ]]&gt;</doc>
      </member>
      <member name="connection_failed"
              value="3"
              c:identifier="TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           A network connection for the Media could not be established or was           lost.         ]]&gt;</doc>
      </member>
      <member name="network_error"
              value="4"
              c:identifier="TP_MEDIA_STREAM_ERROR_NETWORK_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There was an error in the networking stack           (other than the connection failure).         ]]&gt;</doc>
      </member>
      <member name="no_codecs"
              value="5"
              c:identifier="TP_MEDIA_STREAM_ERROR_NO_CODECS">
        <doc xml:space="preserve">&lt;![CDATA[           There are no installed codecs for this media type.         ]]&gt;</doc>
      </member>
      <member name="invalid_cm_behavior"
              value="6"
              c:identifier="TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR">
        <doc xml:space="preserve">&lt;![CDATA[           The CM is doing something wrong.         ]]&gt;</doc>
      </member>
      <member name="media_error"
              value="7"
              c:identifier="TP_MEDIA_STREAM_ERROR_MEDIA_ERROR">
        <doc xml:space="preserve">&lt;![CDATA[           There was an error in the media processing stack.         ]]&gt;</doc>
      </member>
    </enumeration>
    <bitfield name="MediaStreamPendingSend" c:type="TpMediaStreamPendingSend">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_send"
              value="1"
              c:identifier="TP_MEDIA_STREAM_PENDING_LOCAL_SEND">
        <doc xml:space="preserve">&lt;![CDATA[             The local user has been asked to send media by the remote user.             Call RequestStreamDirection to             indicate whether or not this is acceptable.         ]]&gt;</doc>
      </member>
      <member name="remote_send"
              value="2"
              c:identifier="TP_MEDIA_STREAM_PENDING_REMOTE_SEND">
        <doc xml:space="preserve">&lt;![CDATA[             The remote user has been asked to send media by the local user.             The StreamDirectionChanged signal             will be emitted when the remote user accepts or rejects this             change.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="MediaStreamState" c:type="TpMediaStreamState">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="disconnected"
              value="0"
              c:identifier="TP_MEDIA_STREAM_STATE_DISCONNECTED">
        <doc xml:space="preserve">&lt;![CDATA[The stream is disconnected.]]&gt;</doc>
      </member>
      <member name="connecting"
              value="1"
              c:identifier="TP_MEDIA_STREAM_STATE_CONNECTING">
        <doc xml:space="preserve">&lt;![CDATA[The stream is trying to connect.]]&gt;</doc>
      </member>
      <member name="connected"
              value="2"
              c:identifier="TP_MEDIA_STREAM_STATE_CONNECTED">
        <doc xml:space="preserve">&lt;![CDATA[The stream is connected.]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="MediaStreamTransportType"
                 c:type="TpMediaStreamTransportType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local"
              value="0"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL">
        <doc xml:space="preserve">&lt;![CDATA[           A local address         ]]&gt;</doc>
      </member>
      <member name="derived"
              value="1"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED">
        <doc xml:space="preserve">&lt;![CDATA[           An external address derived by a method such as STUN         ]]&gt;</doc>
      </member>
      <member name="relay"
              value="2"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY">
        <doc xml:space="preserve">&lt;![CDATA[           An external stream relay         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="MediaStreamType" c:type="TpMediaStreamType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="audio" value="0" c:identifier="TP_MEDIA_STREAM_TYPE_AUDIO">
        <doc xml:space="preserve">&lt;![CDATA[An audio stream]]&gt;</doc>
      </member>
      <member name="video" value="1" c:identifier="TP_MEDIA_STREAM_TYPE_VIDEO">
        <doc xml:space="preserve">&lt;![CDATA[A video stream]]&gt;</doc>
      </member>
    </enumeration>
    <class name="Message"
           c:symbol-prefix="message"
           c:type="TpMessage"
           parent="GObject.Object"
           glib:type-name="TpMessage"
           glib:get-type="tp_message_get_type"
           glib:type-struct="MessageClass">
      <doc xml:space="preserve">Opaque structure representing a message in the Telepathy messages interface
(an array of at least one mapping from string to variant, where the first
mapping contains message headers and subsequent mappings contain the
message body).

This base class provides convenience API for most of the common keys that
can appear in the header. One notable exception is the sender of the
message. Inside a connection manager, messages are represented by the
#TpCMMessage subclass, and you should use tp_cm_message_get_sender().
When composing a message in a client using #TpClientMessage, messages do
not have an explicit sender (the sender is automatically the local user).
When a client sees a sent or received message signalled by the connection
manager (represented by #TpSignalledMessage), the message's sender (if any)
can be accessed with tp_signalled_message_get_sender().</doc>
      <method name="append_part"
              c:identifier="tp_message_append_part"
              version="0.7.21">
        <doc xml:space="preserve">Append a body part to the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the part number</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="count_parts"
              c:identifier="tp_message_count_parts"
              version="0.7.21">
        <doc xml:space="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of parts in the message, including the headers in
part 0</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete_key"
              c:identifier="tp_message_delete_key"
              version="0.7.21">
        <doc xml:space="preserve">Remove the given key and its value from the given part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key previously existed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_part"
              c:identifier="tp_message_delete_part"
              version="0.7.21">
        <doc xml:space="preserve">Delete the given body part from the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly greater than 0, and strictly
 less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="tp_message_destroy"
              version="0.7.21">
        <doc xml:space="preserve">Since 0.13.9 this function is a simple wrapper around
g_object_unref()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_part"
              c:identifier="tp_message_dup_part"
              version="0.19.10">
        <doc xml:space="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 the current contents of the given part, or %NULL if the part number is
 out of range</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_type"
              c:identifier="tp_message_get_message_type"
              version="0.13.10">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of this message</doc>
          <type name="ChannelTextMessageType"
                c:type="TpChannelTextMessageType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pending_message_id"
              c:identifier="tp_message_get_pending_message_id"
              version="0.15.3">
        <doc xml:space="preserve">Return the incoming message ID of @self. Only incoming messages have such
ID, for outgoing ones this function returns 0 and set @valid to %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the incoming message ID.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="valid"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">either %NULL, or a location in which to store %TRUE if @self
contains a pending message ID.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_received_timestamp"
              c:identifier="tp_message_get_received_timestamp"
              version="0.13.9">
        <doc xml:space="preserve">Return when this message was received locally, as a number of seconds since
the beginning of 1970 in the UTC timezone (the same representation used by
g_date_time_new_from_unix_utc(), for instance), or 0 if not known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a Unix timestamp, or 0</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sent_timestamp"
              c:identifier="tp_message_get_sent_timestamp"
              version="0.13.9">
        <doc xml:space="preserve">Return when this message was sent, as a number of seconds since the
beginning of 1970 in the UTC timezone (the same representation used by
g_date_time_new_from_unix_utc(), for instance), or 0 if not known.

If this protocol does not track the time at which the message was
initially sent, this timestamp might be approximated by using the
time at which it arrived at a central server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a Unix timestamp, or 0</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specific_to_interface"
              c:identifier="tp_message_get_specific_to_interface"
              version="0.13.9">
        <doc xml:space="preserve">If this message is specific to a particular D-Bus interface and should
be ignored by clients without knowledge of that interface, return the
name of the interface.

If this message is an ordinary message or delivery report, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a D-Bus interface name, or %NULL for ordinary
 messages and delivery reports</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_supersedes"
              c:identifier="tp_message_get_supersedes"
              version="0.13.9">
        <doc xml:space="preserve">If this message replaces a previous message, return the value of
tp_message_get_token() for that previous message. Otherwise, return %NULL.

For instance, a user interface could replace the superseded
message with this message, or grey out the superseded message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a non-empty opaque identifier, or %NULL if none</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_token"
              c:identifier="tp_message_get_token"
              version="0.13.9">
        <doc xml:space="preserve">Return this message's identifier in the underlying protocol. This is
&lt;emphasis&gt;not&lt;/emphasis&gt; guaranteed to be unique, even within the scope
of a single channel or contact: the only guarantee made is that two
messages with different non-empty tokens are different messages.

If there is no suitable token, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a non-empty opaque identifier, or %NULL if none</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_delivery_report"
              c:identifier="tp_message_is_delivery_report"
              version="0.13.9">
        <doc xml:space="preserve">If this message is a delivery report indicating success or failure of
delivering a message, return %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this is a delivery report</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_mutable"
              c:identifier="tp_message_is_mutable"
              version="0.13.9">
        <doc xml:space="preserve">Check if @self is mutable. Only mutable messages can be modified using
functions such as tp_message_set_string().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message is mutable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_rescued"
              c:identifier="tp_message_is_rescued"
              version="0.13.9">
        <doc xml:space="preserve">Returns %TRUE if this incoming message has been seen in a previous channel
during the lifetime of the Connection, but had not been acknowledged when
that channel closed, causing an identical channel (in which the message now
appears) to open.

Loggers should check this flag to avoid duplicating messages, for instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this message was seen in a previous Channel on this
 Connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_scrollback"
              c:identifier="tp_message_is_scrollback"
              version="0.13.9">
        <doc xml:space="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this message is part of a replay of message history, for
 instance in an XMPP chatroom.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="tp_message_peek" version="0.7.21">
        <doc xml:space="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
 the #GHashTable used to implement the given part, or %NULL if the
 part number is out of range. The hash table is only valid as long as the
 message is valid and the part is not deleted.</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_handle"
              c:identifier="tp_message_ref_handle"
              version="0.7.21"
              deprecated="1">
        <doc xml:space="preserve">Reference the given handle until this message is destroyed.</doc>
        <doc-deprecated xml:space="preserve">since 0.13.9. Handles are now immortal so there is
no point to ref them. Furthermore, the only handle that should be stored
in a TpMessage is message-sender which should be set using
tp_cm_message_set_sender().</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">a handle type, greater than %TP_HANDLE_TYPE_NONE and less than
 %TP_NUM_HANDLE_TYPES</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a handle of the given type</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="tp_message_set" version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have a copy of @source as its value.

If @source represents a data structure containing handles, they should
all be referenced with tp_message_ref_handle() first.

In high-level language bindings, use tp_message_set_variant() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a value, encoded as dbus-glib would</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean"
              c:identifier="tp_message_set_boolean"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @b as a boolean value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_bytes"
              c:identifier="tp_message_set_bytes"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @bytes as a byte-array value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">a number of bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bytes"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an array of @len bytes</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handle"
              c:identifier="tp_message_set_handle"
              version="0.7.21"
              deprecated="1">
        <doc xml:space="preserve">If @handle_or_0 is not zero, reference it with tp_message_ref_handle().

Set @key in part @part of @self to have @handle_or_0 as an unsigned integer
value.

Since 0.13.9 this function has been deprecated in favor or
tp_cm_message_set_sender() as 'message-sender' is the only handle
you can put in a #TpCMMessage.</doc>
        <doc-deprecated xml:space="preserve">since 0.13.9. Use tp_cm_message_set_sender()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCMMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:space="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="handle_or_0" transfer-ownership="none">
            <doc xml:space="preserve">a handle of that type, or 0</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int32"
              c:identifier="tp_message_set_int32"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @i as a signed integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">an integer value</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64"
              c:identifier="tp_message_set_int64"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @i as a signed integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">an integer value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string"
              c:identifier="tp_message_set_string"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @s as a string value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a string value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_printf"
              c:identifier="tp_message_set_string_printf"
              version="0.7.21"
              introspectable="0">
        <doc xml:space="preserve">Set @key in part @part of @self to have a string value constructed from a
printf-style format string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:space="preserve">a printf-style format string for the string value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments for the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint32"
              c:identifier="tp_message_set_uint32"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @u as an unsigned integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="u" transfer-ownership="none">
            <doc xml:space="preserve">an unsigned integer value</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64"
              c:identifier="tp_message_set_uint64"
              version="0.7.21">
        <doc xml:space="preserve">Set @key in part @part of @self to have @u as an unsigned integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="u" transfer-ownership="none">
            <doc xml:space="preserve">an unsigned integer value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_variant"
              c:identifier="tp_message_set_variant"
              version="0.19.10">
        <doc xml:space="preserve">Set @key in part @part of @self to have @value as its value.

If @value is a floating reference (see g_variant_ref_sink()), then this
function will take ownership of it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a message</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_message"
              c:identifier="tp_message_take_message"
              version="0.7.21"
              deprecated="1">
        <doc xml:space="preserve">Set @key in part @part of @self to have @message as an aa{sv} value (that
is, an array of Message_Part), and take ownership of @message.  The caller
should not use @message after passing it to this function.  All handle
references owned by @message will subsequently belong to and be released
with @self.</doc>
        <doc-deprecated xml:space="preserve">since 0.13.9. Use tp_cm_message_take_message()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpCMMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a part number, which must be strictly less than the number
 returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">another (distinct) message created for the same #TpBaseConnection</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_text"
              c:identifier="tp_message_to_text"
              version="0.13.9">
        <doc xml:space="preserve">Concatene all the text parts contained in @message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the
text content of #message</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </instance-parameter>
          <parameter name="out_flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL, the #TpChannelTextMessageFlags of @message</doc>
            <type name="ChannelTextMessageFlags"
                  c:type="TpChannelTextMessageFlags*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="MessageClass"
            c:type="TpMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="Message">
    </record>
    <bitfield name="MessagePartSupportFlags"
              c:type="TpMessagePartSupportFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags indicating the level of support for message parts on this           channel. They are designed such that setting more flags always           implies that the channel has more capabilities.          If no flags are set, this indicates that messages may contain           a single message part whose content-type is any of the types           from SupportedContentTypes, possibly with some alternatives.          There is no flag indicating support for alternatives. This is           because the SendMessage implementation can always accept messages           containing alternatives, even if the underlying protocol does not,           by deleting all alternatives except the first (most preferred)           that is supported.                     Each of the flags so far implies the previous flag, so we could           have used a simple enumeration here; however, we've defined           the message-part support indicator as a flag set for future           expansion.                   See SupportedContentTypes for some           examples.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="one_attachment"
              value="1"
              c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT">
        <doc xml:space="preserve">&lt;![CDATA[           SendMessage will accept messages           containing a textual message body,           plus a single attachment of any type listed in the           SupportedContentTypes property. It does not make sense for this           flag to be set if Message_Part_Support_Flag_Data_Only is not also set           (because the connection manager can trivially provide an empty text           part if necessary).         ]]&gt;</doc>
      </member>
      <member name="multiple_attachments"
              value="2"
              c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS">
        <doc xml:space="preserve">&lt;![CDATA[           SendMessage will accept messages containing a textual message body,           plus an arbitrary number of attachments of any type listed in the           SupportedContentTypes property. It does not make sense for this           flag to be set if Message_Part_Support_Flag_One_Attachment is not           also set.         ]]&gt;</doc>
      </member>
    </bitfield>
    <bitfield name="MessageSendingFlags" c:type="TpMessageSendingFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags altering the way a message is sent. The "most usual" action         should always be to have these flags unset. Some indication of which         flags are supported is provided by the         DeliveryReportingSupport property.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="delivery"
              value="1"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY">
        <doc xml:space="preserve">&lt;![CDATA[           Provide a successful delivery report if possible, even if this is             not the default for this protocol. Ignored if delivery reports are             not possible on this protocol.                         In some protocols, like XMPP, it is not conventional to request               or send positive delivery notifications.                       Delivery failure reports SHOULD always be sent, but if this flag             is present, the connection manager MAY also try harder to obtain             failed delivery reports or allow them to be matched to outgoing             messages.         ]]&gt;</doc>
      </member>
      <member name="read"
              value="2"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_READ">
        <doc xml:space="preserve">&lt;![CDATA[           Provide a delivery report when the message is read by the             recipient, even if this is not the default for this protocol.             Ignored if read reports are not possible on this protocol.         ]]&gt;</doc>
      </member>
      <member name="deleted"
              value="4"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELETED">
        <doc xml:space="preserve">&lt;![CDATA[           Provide a delivery report when the message is deleted by the             recipient, even if this is not the default for this protocol.             Ignored if such reports are not possible on this protocol.         ]]&gt;</doc>
      </member>
    </bitfield>
    <constant name="NUM_ACCESS_CONTROL_TYPES"
              value="7"
              c:type="TP_NUM_ACCESS_CONTROL_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpAccessControlType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_CONTENT_DISPOSITIONS"
              value="2"
              c:type="TP_NUM_CALL_CONTENT_DISPOSITIONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCallContentDisposition.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_CONTENT_PACKETIZATION_TYPES"
              value="3"
              c:type="TP_NUM_CALL_CONTENT_PACKETIZATION_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCallContentPacketizationType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_STATES" value="7" c:type="TP_NUM_CALL_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCallState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_STATE_CHANGE_REASONS"
              value="14"
              c:type="TP_NUM_CALL_STATE_CHANGE_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCallStateChangeReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_STREAM_CANDIDATE_TYPES"
              value="6"
              c:type="TP_NUM_CALL_STREAM_CANDIDATE_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCallStreamCandidateType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CAPTCHA_CANCEL_REASONS"
              value="3"
              c:type="TP_NUM_CAPTCHA_CANCEL_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCaptchaCancelReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CAPTCHA_STATUSES"
              value="5"
              c:type="TP_NUM_CAPTCHA_STATUSES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpCaptchaStatus.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_CHAT_STATES"
              value="5"
              c:type="TP_NUM_CHANNEL_CHAT_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpChannelChatState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_CONTACT_SEARCH_STATES"
              value="5"
              c:type="TP_NUM_CHANNEL_CONTACT_SEARCH_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpChannelContactSearchState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_GROUP_CHANGE_REASONS"
              value="12"
              c:type="TP_NUM_CHANNEL_GROUP_CHANGE_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpChannelGroupChangeReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_TEXT_MESSAGE_TYPES"
              value="5"
              c:type="TP_NUM_CHANNEL_TEXT_MESSAGE_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpChannelTextMessageType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_TEXT_SEND_ERRORS"
              value="6"
              c:type="TP_NUM_CHANNEL_TEXT_SEND_ERRORS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpChannelTextSendError.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONNECTION_PRESENCE_TYPES"
              value="9"
              c:type="TP_NUM_CONNECTION_PRESENCE_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpConnectionPresenceType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONNECTION_STATUSES"
              value="3"
              c:type="TP_NUM_CONNECTION_STATUSES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpConnectionStatus.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONNECTION_STATUS_REASONS"
              value="17"
              c:type="TP_NUM_CONNECTION_STATUS_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpConnectionStatusReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONTACT_FEATURES"
              value="11"
              c:type="TP_NUM_CONTACT_FEATURES"
              version="0.19.0">
      <doc xml:space="preserve">1 higher than the highest #TpContactFeature supported by this version of
telepathy-glib.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONTACT_LIST_STATES"
              value="4"
              c:type="TP_NUM_CONTACT_LIST_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpContactListState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONTACT_METADATA_STORAGE_TYPES"
              value="4"
              c:type="TP_NUM_CONTACT_METADATA_STORAGE_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpContactMetadataStorageType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DBUS_ERRORS"
              value="11"
              c:type="TP_NUM_DBUS_ERRORS"
              version="0.19.0">
      <doc xml:space="preserve">1 more than the highest valid #TpDBusError at the time of compilation</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DEBUG_LEVELS" value="6" c:type="TP_NUM_DEBUG_LEVELS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpDebugLevel.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DELIVERY_STATUSES"
              value="7"
              c:type="TP_NUM_DELIVERY_STATUSES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpDeliveryStatus.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DTMF_EVENTS" value="16" c:type="TP_NUM_DTMF_EVENTS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpDTMFEvent.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_FILE_HASH_TYPES"
              value="4"
              c:type="TP_NUM_FILE_HASH_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpFileHashType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_FILE_TRANSFER_STATES"
              value="6"
              c:type="TP_NUM_FILE_TRANSFER_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpFileTransferState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_FILE_TRANSFER_STATE_CHANGE_REASONS"
              value="6"
              c:type="TP_NUM_FILE_TRANSFER_STATE_CHANGE_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpFileTransferStateChangeReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_HANDLE_TYPES" value="5" c:type="TP_NUM_HANDLE_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpHandleType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_HTTP_METHODS" value="2" c:type="TP_NUM_HTTP_METHODS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpHTTPMethod.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_LOCAL_HOLD_STATES"
              value="4"
              c:type="TP_NUM_LOCAL_HOLD_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpLocalHoldState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_LOCAL_HOLD_STATE_REASONS"
              value="3"
              c:type="TP_NUM_LOCAL_HOLD_STATE_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpLocalHoldStateReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_BASE_PROTOS"
              value="2"
              c:type="TP_NUM_MEDIA_STREAM_BASE_PROTOS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpMediaStreamBaseProto.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_DIRECTIONS"
              value="4"
              c:type="TP_NUM_MEDIA_STREAM_DIRECTIONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpMediaStreamDirection.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_ERRORS"
              value="8"
              c:type="TP_NUM_MEDIA_STREAM_ERRORS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpMediaStreamError.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_STATES"
              value="3"
              c:type="TP_NUM_MEDIA_STREAM_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpMediaStreamState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_TRANSPORT_TYPES"
              value="3"
              c:type="TP_NUM_MEDIA_STREAM_TRANSPORT_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpMediaStreamTransportType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_TYPES"
              value="2"
              c:type="TP_NUM_MEDIA_STREAM_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpMediaStreamType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_RCPT_XR_RTT_MODES"
              value="2"
              c:type="TP_NUM_RCPT_XR_RTT_MODES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpRCPTXRRTTMode.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_RICH_PRESENCE_ACCESS_CONTROL_TYPES"
              value="4"
              c:type="TP_NUM_RICH_PRESENCE_ACCESS_CONTROL_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpRichPresenceAccessControlType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SASL_ABORT_REASONS"
              value="2"
              c:type="TP_NUM_SASL_ABORT_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpSASLAbortReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SASL_STATUSES" value="7" c:type="TP_NUM_SASL_STATUSES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpSASLStatus.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SENDING_STATES"
              value="4"
              c:type="TP_NUM_SENDING_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpSendingState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SERVICE_POINT_TYPES"
              value="3"
              c:type="TP_NUM_SERVICE_POINT_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpServicePointType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SOCKET_ACCESS_CONTROLS"
              value="4"
              c:type="TP_NUM_SOCKET_ACCESS_CONTROLS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpSocketAccessControl.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SOCKET_ADDRESS_TYPES"
              value="4"
              c:type="TP_NUM_SOCKET_ADDRESS_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpSocketAddressType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_COMPONENTS"
              value="3"
              c:type="TP_NUM_STREAM_COMPONENTS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpStreamComponent.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_ENDPOINT_STATES"
              value="5"
              c:type="TP_NUM_STREAM_ENDPOINT_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpStreamEndpointState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_FLOW_STATES"
              value="4"
              c:type="TP_NUM_STREAM_FLOW_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpStreamFlowState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_TRANSPORT_TYPES"
              value="7"
              c:type="TP_NUM_STREAM_TRANSPORT_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpStreamTransportType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SUBSCRIPTION_STATES"
              value="5"
              c:type="TP_NUM_SUBSCRIPTION_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpSubscriptionState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TLS_CERTIFICATE_REJECT_REASONS"
              value="10"
              c:type="TP_NUM_TLS_CERTIFICATE_REJECT_REASONS">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpTLSCertificateRejectReason.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TLS_CERTIFICATE_STATES"
              value="3"
              c:type="TP_NUM_TLS_CERTIFICATE_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpTLSCertificateState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TUBE_CHANNEL_STATES"
              value="4"
              c:type="TP_NUM_TUBE_CHANNEL_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpTubeChannelState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TUBE_STATES" value="3" c:type="TP_NUM_TUBE_STATES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpTubeState.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TUBE_TYPES" value="2" c:type="TP_NUM_TUBE_TYPES">
      <doc xml:space="preserve">1 higher than the highest valid value of #TpTubeType.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="ObserveChannelsContext"
           c:symbol-prefix="observe_channels_context"
           c:type="TpObserveChannelsContext"
           version="0.11.5"
           parent="GObject.Object"
           glib:type-name="TpObserveChannelsContext"
           glib:get-type="tp_observe_channels_context_get_type"
           glib:type-struct="ObserveChannelsContextClass">
      <doc xml:space="preserve">Data structure representing the context of a Observer.ObserveChannels()
call.</doc>
      <method name="accept"
              c:identifier="tp_observe_channels_context_accept"
              version="0.11.5">
        <doc xml:space="preserve">Called by #TpBaseClientClassObserveChannelsImpl when it's done so the D-Bus
method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext</doc>
            <type name="ObserveChannelsContext"
                  c:type="TpObserveChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delay"
              c:identifier="tp_observe_channels_context_delay"
              version="0.11.5">
        <doc xml:space="preserve">Called by #TpBaseClientClassObserveChannelsImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpObserveChannelsContext before calling this function, and
is responsible for calling either tp_observe_channels_context_accept() or
tp_observe_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext</doc>
            <type name="ObserveChannelsContext"
                  c:type="TpObserveChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fail"
              c:identifier="tp_observe_channels_context_fail"
              version="0.11.5">
        <doc xml:space="preserve">Called by #TpBaseClientClassObserveChannelsImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext</doc>
            <type name="ObserveChannelsContext"
                  c:type="TpObserveChannelsContext*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_requests"
              c:identifier="tp_observe_channels_context_get_requests"
              version="0.13.14">
        <doc xml:space="preserve">Return a list of the #TpChannelRequest which have been satisfied by the
channels associated with #self.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a newly allocated #GList of reffed #TpChannelRequest.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext</doc>
            <type name="ObserveChannelsContext"
                  c:type="TpObserveChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_recovering"
              c:identifier="tp_observe_channels_context_is_recovering"
              version="0.11.5">
        <doc xml:space="preserve">If this call to ObserveChannels is for channels that already
existed before this observer started (because the observer used
tp_base_client_set_observer_recover()), return %TRUE.

In most cases, the result is %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE for pre-existing channels, %FALSE for new channels</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpObserveChannelsContext</doc>
            <type name="ObserveChannelsContext"
                  c:type="TpObserveChannelsContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpAccount object representing the Account that has been passed to
ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpConnection object representing the Connection that has been passed
to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.5"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
ObserveChannels call.
Can only be written during construction.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="dispatch-operation"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to ObserveChannels,
or %NULL if none has been passed.
Read-only except during construction.</doc>
        <type name="ChannelDispatchOperation"/>
      </property>
      <property name="observer-info"
                version="0.11.5"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GHashTable where the keys are string and values are GValue instances.
It represents the Observer_Info hash table that has been passed to
ObserveChannels.
It's recommended to use high-level method such as
tp_observe_channels_context_is_recovering() to access to its content.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="requests"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
    </class>
    <record name="ObserveChannelsContextClass"
            c:type="TpObserveChannelsContextClass"
            disguised="1"
            glib:is-gtype-struct-for="ObserveChannelsContext"
            version="0.11.5">
      <doc xml:space="preserve">The class of a #TpObserveChannelsContext.</doc>
    </record>
    <record name="ObserveChannelsContextPrivate"
            c:type="TpObserveChannelsContextPrivate"
            disguised="1">
    </record>
    <constant name="PROP_ACCOUNT_AUTOMATIC_PRESENCE"
              value="org.freedesktop.Telepathy.Account.AutomaticPresence"
              c:type="TP_PROP_ACCOUNT_AUTOMATIC_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CHANGING_PRESENCE"
              value="org.freedesktop.Telepathy.Account.ChangingPresence"
              c:type="TP_PROP_ACCOUNT_CHANGING_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION"
              value="org.freedesktop.Telepathy.Account.Connection"
              c:type="TP_PROP_ACCOUNT_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR"
              value="org.freedesktop.Telepathy.Account.ConnectionError"
              c:type="TP_PROP_ACCOUNT_CONNECTION_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Account.ConnectionErrorDetails"
              c:type="TP_PROP_ACCOUNT_CONNECTION_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS"
              value="org.freedesktop.Telepathy.Account.ConnectionStatus"
              c:type="TP_PROP_ACCOUNT_CONNECTION_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS_REASON"
              value="org.freedesktop.Telepathy.Account.ConnectionStatusReason"
              c:type="TP_PROP_ACCOUNT_CONNECTION_STATUS_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECT_AUTOMATICALLY"
              value="org.freedesktop.Telepathy.Account.ConnectAutomatically"
              c:type="TP_PROP_ACCOUNT_CONNECT_AUTOMATICALLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CURRENT_PRESENCE"
              value="org.freedesktop.Telepathy.Account.CurrentPresence"
              c:type="TP_PROP_ACCOUNT_CURRENT_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_DISPLAY_NAME"
              value="org.freedesktop.Telepathy.Account.DisplayName"
              c:type="TP_PROP_ACCOUNT_DISPLAY_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_ENABLED"
              value="org.freedesktop.Telepathy.Account.Enabled"
              c:type="TP_PROP_ACCOUNT_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_HAS_BEEN_ONLINE"
              value="org.freedesktop.Telepathy.Account.HasBeenOnline"
              c:type="TP_PROP_ACCOUNT_HAS_BEEN_ONLINE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_ICON"
              value="org.freedesktop.Telepathy.Account.Icon"
              c:type="TP_PROP_ACCOUNT_ICON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACES"
              value="org.freedesktop.Telepathy.Account.Interfaces"
              c:type="TP_PROP_ACCOUNT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES"
              value="org.freedesktop.Telepathy.Account.Interface.Addressing.URISchemes"
              c:type="TP_PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR"
              value="org.freedesktop.Telepathy.Account.Interface.Avatar.Avatar"
              c:type="TP_PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageIdentifier"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageProvider"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageRestrictions"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageSpecificInformation"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INTERFACES"
              value="org.freedesktop.Telepathy.AccountManager.Interfaces"
              c:type="TP_PROP_ACCOUNT_MANAGER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS"
              value="org.freedesktop.Telepathy.AccountManager.InvalidAccounts"
              c:type="TP_PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES"
              value="org.freedesktop.Telepathy.AccountManager.SupportedAccountProperties"
              c:type="TP_PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS"
              value="org.freedesktop.Telepathy.AccountManager.ValidAccounts"
              c:type="TP_PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_NICKNAME"
              value="org.freedesktop.Telepathy.Account.Nickname"
              c:type="TP_PROP_ACCOUNT_NICKNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_NORMALIZED_NAME"
              value="org.freedesktop.Telepathy.Account.NormalizedName"
              c:type="TP_PROP_ACCOUNT_NORMALIZED_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_PARAMETERS"
              value="org.freedesktop.Telepathy.Account.Parameters"
              c:type="TP_PROP_ACCOUNT_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_REQUESTED_PRESENCE"
              value="org.freedesktop.Telepathy.Account.RequestedPresence"
              c:type="TP_PROP_ACCOUNT_REQUESTED_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_SERVICE"
              value="org.freedesktop.Telepathy.Account.Service"
              c:type="TP_PROP_ACCOUNT_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_SUPERSEDES"
              value="org.freedesktop.Telepathy.Account.Supersedes"
              c:type="TP_PROP_ACCOUNT_SUPERSEDES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_VALID"
              value="org.freedesktop.Telepathy.Account.Valid"
              c:type="TP_PROP_ACCOUNT_VALID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.CertificateChainData"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.CertificateType"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.Rejections"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.State"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_DISPOSITION"
              value="org.freedesktop.Telepathy.Call1.Content.Disposition"
              c:type="TP_PROP_CALL_CONTENT_DISPOSITION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACES"
              value="org.freedesktop.Telepathy.Call1.Content.Interfaces"
              c:type="TP_PROP_CALL_CONTENT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_INPUT_VOLUME"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.AudioControl.RequestedInputVolume"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_INPUT_VOLUME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_OUTPUT_VOLUME"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.AudioControl.RequestedOutputVolume"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_OUTPUT_VOLUME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_DTMF_CURRENTLY_SENDING_TONES"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.DTMF.CurrentlySendingTones"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_DTMF_CURRENTLY_SENDING_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_DTMF_DEFERRED_TONES"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.DTMF.DeferredTones"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_DTMF_DEFERRED_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_EVENT"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.CurrentDTMFEvent"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_EVENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_STATE"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.CurrentDTMFState"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_LOCAL_MEDIA_DESCRIPTIONS"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.LocalMediaDescriptions"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_LOCAL_MEDIA_DESCRIPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_MEDIA_DESCRIPTION_OFFER"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.MediaDescriptionOffer"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_MEDIA_DESCRIPTION_OFFER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_PACKETIZATION"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.Packetization"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_PACKETIZATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_REMOTE_MEDIA_DESCRIPTIONS"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.RemoteMediaDescriptions"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_REMOTE_MEDIA_DESCRIPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_BITRATE"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.Bitrate"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_FRAMERATE"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.Framerate"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_FRAMERATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MANUAL_KEY_FRAMES"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.ManualKeyFrames"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MANUAL_KEY_FRAMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MTU"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.MTU"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_VIDEO_RESOLUTION"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.VideoResolution"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_VIDEO_RESOLUTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_CODECS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Codecs"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_CODECS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_FURTHER_NEGOTIATION_REQUIRED"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.FurtherNegotiationRequired"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_FURTHER_NEGOTIATION_REQUIRED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_HAS_REMOTE_INFORMATION"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.HasRemoteInformation"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_HAS_REMOTE_INFORMATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACES"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interfaces"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DLRR_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.DLRRMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DLRR_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DUPLICATE_RLE_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.DuplicateRLEMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DUPLICATE_RLE_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_ENABLE_METRICS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.EnableMetrics"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_ENABLE_METRICS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_LOSS_RLE_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.LossRLEMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_LOSS_RLE_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_PACKET_RECEIPT_TIMES_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.PacketReceiptTimesMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_PACKET_RECEIPT_TIMES_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_RTT_MODE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.RTTMode"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_RTT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_STATISTICS_FLAGS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.StatisticsFlags"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_STATISTICS_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_DOES_AVPF"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPFeedback.DoesAVPF"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_DOES_AVPF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_FEEDBACK_MESSAGES"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPFeedback.FeedbackMessages"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_FEEDBACK_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS_HEADER_EXTENSIONS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTPHeaderExtensions.HeaderExtensions"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS_HEADER_EXTENSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_REMOTE_CONTACT"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.RemoteContact"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_REMOTE_CONTACT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_SSRCS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.SSRCs"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_SSRCS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_NAME"
              value="org.freedesktop.Telepathy.Call1.Content.Name"
              c:type="TP_PROP_CALL_CONTENT_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_STREAMS"
              value="org.freedesktop.Telepathy.Call1.Content.Streams"
              c:type="TP_PROP_CALL_CONTENT_STREAMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_TYPE"
              value="org.freedesktop.Telepathy.Call1.Content.Type"
              c:type="TP_PROP_CALL_CONTENT_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_CAN_REQUEST_RECEIVING"
              value="org.freedesktop.Telepathy.Call1.Stream.CanRequestReceiving"
              c:type="TP_PROP_CALL_STREAM_CAN_REQUEST_RECEIVING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_CONTROLLING"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.Controlling"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_CONTROLLING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_ENDPOINT_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.EndpointState"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_ENDPOINT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_IS_ICE_LITE"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.IsICELite"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_IS_ICE_LITE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_REMOTE_CANDIDATES"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.RemoteCandidates"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_REMOTE_CANDIDATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_REMOTE_CREDENTIALS"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.RemoteCredentials"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_REMOTE_CREDENTIALS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_SELECTED_CANDIDATE_PAIRS"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.SelectedCandidatePairs"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_SELECTED_CANDIDATE_PAIRS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_TRANSPORT"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.Transport"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_TRANSPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACES"
              value="org.freedesktop.Telepathy.Call1.Stream.Interfaces"
              c:type="TP_PROP_CALL_STREAM_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_ENDPOINTS"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.Endpoints"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_ENDPOINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_HAS_SERVER_INFO"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.HasServerInfo"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_HAS_SERVER_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_ICE_RESTART_PENDING"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.ICERestartPending"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_ICE_RESTART_PENDING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CANDIDATES"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.LocalCandidates"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CANDIDATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CREDENTIALS"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.LocalCredentials"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CREDENTIALS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_RECEIVING_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.ReceivingState"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_RECEIVING_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_RELAY_INFO"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.RelayInfo"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_RELAY_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_SENDING_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.SendingState"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_SENDING_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_STUN_SERVERS"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.STUNServers"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_STUN_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_TRANSPORT"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.Transport"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_TRANSPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_LOCAL_SENDING_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.LocalSendingState"
              c:type="TP_PROP_CALL_STREAM_LOCAL_SENDING_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_REMOTE_MEMBERS"
              value="org.freedesktop.Telepathy.Call1.Stream.RemoteMembers"
              c:type="TP_PROP_CALL_STREAM_REMOTE_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_REMOTE_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Call1.Stream.RemoteMemberIdentifiers"
              c:type="TP_PROP_CALL_STREAM_REMOTE_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_CHANNEL_TYPE"
              value="org.freedesktop.Telepathy.Channel.ChannelType"
              c:type="TP_PROP_CHANNEL_CHANNEL_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interfaces"
              c:type="TP_PROP_CHANNEL_DISPATCHER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList.DispatchOperations"
              c:type="TP_PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS"
              value="org.freedesktop.Telepathy.ChannelDispatcher.SupportsRequestHints"
              c:type="TP_PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Account"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Channels"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Connection"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Interfaces"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.PossibleHandlers"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.InitiatorHandle"
              c:type="TP_PROP_CHANNEL_INITIATOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_ID"
              value="org.freedesktop.Telepathy.Channel.InitiatorID"
              c:type="TP_PROP_CHANNEL_INITIATOR_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACES"
              value="org.freedesktop.Telepathy.Channel.Interfaces"
              c:type="TP_PROP_CHANNEL_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityMandatory"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityModes"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymousID"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAN_RETRY_CAPTCHA"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CanRetryCaptcha"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAN_RETRY_CAPTCHA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CaptchaError"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CaptchaErrorDetails"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_STATUS"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CaptchaStatus"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES"
              value="org.freedesktop.Telepathy.Channel.Interface.ChatState.ChatStates"
              c:type="TP_PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.Channels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialChannels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialInviteeHandles"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialInviteeIDs"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InvitationMessage"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.OriginalChannels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.CurrentlySendingTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.DeferredTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.InitialTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata.Metadata"
              c:type="TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata.ServiceName"
              c:type="TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.GroupFlags"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.HandleOwners"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.LocalPendingMembers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.Members"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.MemberIdentifiers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.RemotePendingMembers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.SelfHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.DeliveryReportingSupport"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessagePartSupportFlags"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessageTypes"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.PendingMessages"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.SupportedContentTypes"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Anonymous"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.CanUpdateConfiguration"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.ConfigurationRetrieved"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Description"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.InviteOnly"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Limit"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Moderated"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.MutableProperties"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Password"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.PasswordHint"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.PasswordProtected"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Persistent"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Private"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Title"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.CreationTimestamp"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATOR"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.Creator"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.CreatorHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.RoomName"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_SERVER"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.Server"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.AuthorizationIdentity"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.AvailableMechanisms"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.CanTryAgain"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.DefaultRealm"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.DefaultUsername"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.HasInitialData"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.MaySaveResponse"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLError"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLErrorDetails"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLStatus"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable.Encrypted"
              c:type="TP_PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable.Verified"
              c:type="TP_PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.CurrentServicePoint"
              c:type="TP_PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.InitialServicePoint"
              c:type="TP_PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SMS_FLASH"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS.Flash"
              c:type="TP_PROP_CHANNEL_INTERFACE_SMS_FLASH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS.SMSChannel"
              c:type="TP_PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Actor"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.ActorHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.CanSet"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Subject"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Timestamp"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube.Parameters"
              c:type="TP_PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube.State"
              c:type="TP_PROP_CHANNEL_INTERFACE_TUBE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUESTED"
              value="org.freedesktop.Telepathy.Channel.Requested"
              c:type="TP_PROP_CHANNEL_REQUESTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_ACCOUNT"
              value="org.freedesktop.Telepathy.ChannelRequest.Account"
              c:type="TP_PROP_CHANNEL_REQUEST_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_HINTS"
              value="org.freedesktop.Telepathy.ChannelRequest.Hints"
              c:type="TP_PROP_CHANNEL_REQUEST_HINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelRequest.Interfaces"
              c:type="TP_PROP_CHANNEL_REQUEST_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_PREFERRED_HANDLER"
              value="org.freedesktop.Telepathy.ChannelRequest.PreferredHandler"
              c:type="TP_PROP_CHANNEL_REQUEST_PREFERRED_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_REQUESTS"
              value="org.freedesktop.Telepathy.ChannelRequest.Requests"
              c:type="TP_PROP_CHANNEL_REQUEST_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_USER_ACTION_TIME"
              value="org.freedesktop.Telepathy.ChannelRequest.UserActionTime"
              c:type="TP_PROP_CHANNEL_REQUEST_USER_ACTION_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE"
              value="org.freedesktop.Telepathy.Channel.TargetHandle"
              c:type="TP_PROP_CHANNEL_TARGET_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE_TYPE"
              value="org.freedesktop.Telepathy.Channel.TargetHandleType"
              c:type="TP_PROP_CHANNEL_TARGET_HANDLE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_ID"
              value="org.freedesktop.Telepathy.Channel.TargetID"
              c:type="TP_PROP_CHANNEL_TARGET_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallFlags"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallMembers"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallState"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_STATE_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallStateDetails"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_STATE_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_STATE_REASON"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallStateReason"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_STATE_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CONTENTS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.Contents"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CONTENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_HARDWARE_STREAMING"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.HardwareStreaming"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_HARDWARE_STREAMING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialAudio"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialAudioName"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_TRANSPORT"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialTransport"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_TRANSPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialVideo"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialVideoName"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.MemberIdentifiers"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_MUTABLE_CONTENTS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.MutableContents"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_MUTABLE_CONTENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.AvailableSearchKeys"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Limit"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.SearchState"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Server"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.DBusNames"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.ServiceName"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.SupportedAccessControls"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.AvailableSocketTypes"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHash"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHashType"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentType"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Date"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Description"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Filename"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_FILE_COLLECTION"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.FileCollection"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILE_COLLECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.InitialOffset"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Size"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.State"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.TransferredBytes"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_URI"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.URI"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_ROOM_LIST_SERVER"
              value="org.freedesktop.Telepathy.Channel.Type.RoomList.Server"
              c:type="TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD"
              value="org.freedesktop.Telepathy.Channel.Type.ServerAuthentication.AuthenticationMethod"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.Hostname"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.ReferenceIdentities"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.ServerCertificate"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.ImmutableStreams"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialAudio"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialVideo"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube.Service"
              c:type="TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube.SupportedSocketTypes"
              c:type="TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Approver.ApproverChannelFilter"
              c:type="TP_PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_BYPASS_APPROVAL"
              value="org.freedesktop.Telepathy.Client.Handler.BypassApproval"
              c:type="TP_PROP_CLIENT_HANDLER_BYPASS_APPROVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_CAPABILITIES"
              value="org.freedesktop.Telepathy.Client.Handler.Capabilities"
              c:type="TP_PROP_CLIENT_HANDLER_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLED_CHANNELS"
              value="org.freedesktop.Telepathy.Client.Handler.HandledChannels"
              c:type="TP_PROP_CLIENT_HANDLER_HANDLED_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Handler.HandlerChannelFilter"
              c:type="TP_PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_INTERFACES"
              value="org.freedesktop.Telepathy.Client.Interfaces"
              c:type="TP_PROP_CLIENT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_DELAY_APPROVERS"
              value="org.freedesktop.Telepathy.Client.Observer.DelayApprovers"
              c:type="TP_PROP_CLIENT_OBSERVER_DELAY_APPROVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter"
              c:type="TP_PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_RECOVER"
              value="org.freedesktop.Telepathy.Client.Observer.Recover"
              c:type="TP_PROP_CLIENT_OBSERVER_RECOVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_HAS_IMMORTAL_HANDLES"
              value="org.freedesktop.Telepathy.Connection.HasImmortalHandles"
              c:type="TP_PROP_CONNECTION_HAS_IMMORTAL_HANDLES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACES"
              value="org.freedesktop.Telepathy.Connection.Interfaces"
              c:type="TP_PROP_CONNECTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityMandatory"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityModes"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.SupportedAnonymityModes"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarBytes"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.SupportedAvatarMIMETypes"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance.AccountBalance"
              c:type="TP_PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance.ManageCreditURI"
              c:type="TP_PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_IMSI"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.IMSI"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_IMSI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageNationalCharacterSet"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageReducedCharacterSet"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageServiceCentre"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageValidityPeriod"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.OverrideMessageServiceCentre"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES"
              value="org.freedesktop.Telepathy.Connection.Interface.Contacts.ContactAttributeInterfaces"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking.ContactBlockingCapabilities"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.DisjointGroups"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.Groups"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.GroupStorage"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.ContactInfoFlags"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.SupportedFields"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.CanChangeContactList"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.ContactListPersists"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.ContactListState"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_DOWNLOAD_AT_CONNECTION"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.DownloadAtConnection"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_DOWNLOAD_AT_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.RequestUsesMessage"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControl"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControlTypes"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.SupportedLocationFeatures"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.MailAddress"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.MailNotificationFlags"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.UnreadMails"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.UnreadMailCount"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE"
              value="org.freedesktop.Telepathy.Connection.Interface.PowerSaving.PowerSavingActive"
              c:type="TP_PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests.Channels"
              c:type="TP_PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests.RequestableChannelClasses"
              c:type="TP_PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS"
              value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint.KnownServicePoints"
              c:type="TP_PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.MaximumStatusMessageLength"
              c:type="TP_PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.Statuses"
              c:type="TP_PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_INTERFACES"
              value="org.freedesktop.Telepathy.ConnectionManager.Interfaces"
              c:type="TP_PROP_CONNECTION_MANAGER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_PROTOCOLS"
              value="org.freedesktop.Telepathy.ConnectionManager.Protocols"
              c:type="TP_PROP_CONNECTION_MANAGER_PROTOCOLS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_SELF_HANDLE"
              value="org.freedesktop.Telepathy.Connection.SelfHandle"
              c:type="TP_PROP_CONNECTION_SELF_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_SELF_ID"
              value="org.freedesktop.Telepathy.Connection.SelfID"
              c:type="TP_PROP_CONNECTION_SELF_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_STATUS"
              value="org.freedesktop.Telepathy.Connection.Status"
              c:type="TP_PROP_CONNECTION_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_DEBUG_ENABLED"
              value="org.freedesktop.Telepathy.Debug.Enabled"
              c:type="TP_PROP_DEBUG_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY"
              value="org.freedesktop.Telepathy.Media.StreamHandler.CreatedLocally"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL"
              value="org.freedesktop.Telepathy.Media.StreamHandler.NATTraversal"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_RELAY_INFO"
              value="org.freedesktop.Telepathy.Media.StreamHandler.RelayInfo"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_RELAY_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS"
              value="org.freedesktop.Telepathy.Media.StreamHandler.STUNServers"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_AUTHENTICATION_TYPES"
              value="org.freedesktop.Telepathy.Protocol.AuthenticationTypes"
              c:type="TP_PROP_PROTOCOL_AUTHENTICATION_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_CONNECTION_INTERFACES"
              value="org.freedesktop.Telepathy.Protocol.ConnectionInterfaces"
              c:type="TP_PROP_PROTOCOL_CONNECTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_ENGLISH_NAME"
              value="org.freedesktop.Telepathy.Protocol.EnglishName"
              c:type="TP_PROP_PROTOCOL_ENGLISH_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_ICON"
              value="org.freedesktop.Telepathy.Protocol.Icon"
              c:type="TP_PROP_PROTOCOL_ICON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACES"
              value="org.freedesktop.Telepathy.Protocol.Interfaces"
              c:type="TP_PROP_PROTOCOL_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing.AddressableURISchemes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing.AddressableVCardFields"
              c:type="TP_PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarBytes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MinimumAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MinimumAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.RecommendedAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.RecommendedAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.SupportedAvatarMIMETypes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Presence.Statuses"
              c:type="TP_PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_PARAMETERS"
              value="org.freedesktop.Telepathy.Protocol.Parameters"
              c:type="TP_PROP_PROTOCOL_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES"
              value="org.freedesktop.Telepathy.Protocol.RequestableChannelClasses"
              c:type="TP_PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_VCARD_FIELD"
              value="org.freedesktop.Telepathy.Protocol.VCardField"
              c:type="TP_PROP_PROTOCOL_VCARD_FIELD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="PresenceMixin" c:type="TpPresenceMixin">
      <doc xml:space="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_presence_mixin_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="PresenceMixinPrivate" c:type="TpPresenceMixinPrivate*"/>
      </field>
      <function name="emit_one_presence_update"
                c:identifier="tp_presence_mixin_emit_one_presence_update"
                introspectable="0">
        <doc xml:space="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">A connection object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">The handle of the contact to emit the signal for</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The new status to emit</doc>
            <type name="PresenceStatus" c:type="const TpPresenceStatus*"/>
          </parameter>
        </parameters>
      </function>
      <function name="emit_presence_update"
                c:identifier="tp_presence_mixin_emit_presence_update"
                introspectable="0">
        <doc xml:space="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">A connection object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contact_presences" transfer-ownership="none">
            <doc xml:space="preserve">A mapping of contact handles to #TpPresenceStatus
 structures with the presence data to emit</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_presence_mixin_finalize"
                introspectable="0">
        <doc xml:space="preserve">Free resources held by the presence mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An object with this mixin.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_presence_mixin_get_offset_quark"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="iface_init"
                c:identifier="tp_presence_mixin_iface_init"
                introspectable="0">
        <doc xml:space="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an
 object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_presence_mixin_init"
                introspectable="0">
        <doc xml:space="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
                        G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_iface_init"
                c:identifier="tp_presence_mixin_simple_presence_iface_init"
                version="0.7.13"
                introspectable="0">
        <doc xml:space="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in
an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_init_dbus_properties"
                c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties"
                version="0.7.13"
                introspectable="0">
        <doc xml:space="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.

This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of an object with this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_register_with_contacts_mixin"
                c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin"
                introspectable="0">
        <doc xml:space="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">An instance that of the implementation that uses both the Contacts
mixin and this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceMixinClass" c:type="TpPresenceMixinClass">
      <doc xml:space="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_presence_mixin_class_init().

If the protocol imposes a limit on the length of status messages, one should
implement @get_maximum_status_message_length. If this callback is not
implemented, it is assumed that there is no limit. The callback function
should be set after calling tp_presence_mixin_class_init(), like so:

|[
TpPresenceMixinClass *mixin_class;

tp_presence_mixin_class_init ((GObjectClass *) klass,
    G_STRUCT_OFFSET (SomeObjectClass, presence_mixin));
mixin_class = TP_PRESENCE_MIXIN_CLASS (klass);
mixin_class-&gt;get_maximum_status_message_length =
    some_object_get_maximum_status_message_length;
]|

All other fields should be considered read-only.</doc>
      <field name="status_available" writable="1">
        <doc xml:space="preserve">The status-available function that was passed to
 tp_presence_mixin_class_init()</doc>
        <type name="PresenceMixinStatusAvailableFunc"
              c:type="TpPresenceMixinStatusAvailableFunc"/>
      </field>
      <field name="get_contact_statuses" introspectable="0" writable="1">
        <doc xml:space="preserve">The get-contact-statuses function that was passed to
 tp_presence_mixin_class_init()</doc>
        <type name="PresenceMixinGetContactStatusesFunc"
              c:type="TpPresenceMixinGetContactStatusesFunc"/>
      </field>
      <field name="set_own_status" writable="1">
        <doc xml:space="preserve">The set-own-status function that was passed to
 tp_presence_mixin_class_init()</doc>
        <type name="PresenceMixinSetOwnStatusFunc"
              c:type="TpPresenceMixinSetOwnStatusFunc"/>
      </field>
      <field name="statuses" writable="1">
        <doc xml:space="preserve">The presence statuses array that was passed to
 tp_presence_mixin_class_init()</doc>
        <type name="PresenceStatusSpec" c:type="const TpPresenceStatusSpec*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PresenceMixinClassPrivate"
              c:type="TpPresenceMixinClassPrivate*"/>
      </field>
      <field name="get_maximum_status_message_length" writable="1">
        <doc xml:space="preserve">The callback used to discover the
 the limit for status messages length, if any. Since: 0.14.5</doc>
        <type name="PresenceMixinGetMaximumStatusMessageLengthFunc"
              c:type="TpPresenceMixinGetMaximumStatusMessageLengthFunc"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <function name="get_offset_quark"
                c:identifier="tp_presence_mixin_class_get_offset_quark"
                introspectable="0">
        <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_presence_mixin_class_init"
                introspectable="0">
        <doc xml:space="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
                              G_STRUCT_OFFSET (SomeObjectClass,
                                               presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:space="preserve">The class of the implementation that uses this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The byte offset of the TpPresenceMixinClass within the class
structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="status_available" transfer-ownership="none">
            <doc xml:space="preserve">A callback to be used to determine if a given presence
 status can be set on a particular connection. Should usually be %NULL, to
 consider all statuses with #TpPresenceStatusSpec.self set to %TRUE to be
 settable.</doc>
            <type name="PresenceMixinStatusAvailableFunc"
                  c:type="TpPresenceMixinStatusAvailableFunc"/>
          </parameter>
          <parameter name="get_contact_statuses" transfer-ownership="none">
            <doc xml:space="preserve">A callback to be used get the current presence status
 for contacts. This is used in implementations of various D-Bus methods and
 hence must be provided.</doc>
            <type name="PresenceMixinGetContactStatusesFunc"
                  c:type="TpPresenceMixinGetContactStatusesFunc"/>
          </parameter>
          <parameter name="set_own_status" transfer-ownership="none">
            <doc xml:space="preserve">A callback to be used to commit changes to the user's own
 presence status to the server. This is used in implementations of various
 D-Bus methods and hence must be provided.</doc>
            <type name="PresenceMixinSetOwnStatusFunc"
                  c:type="TpPresenceMixinSetOwnStatusFunc"/>
          </parameter>
          <parameter name="statuses" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpPresenceStatusSpec structures representing all
 presence statuses supported by the protocol, terminated by a NULL name.</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceMixinClassPrivate"
            c:type="TpPresenceMixinClassPrivate"
            disguised="1">
    </record>
    <callback name="PresenceMixinGetContactStatusesFunc"
              c:type="TpPresenceMixinGetContactStatusesFunc"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Signature of the callback used to get the stored presence status of
contacts. The returned hash table should have contact handles mapped to
their respective presence statuses in #TpPresenceStatus structs.

The returned hash table will be freed with g_hash_table_unref. The
callback is responsible for ensuring that this does any cleanup that
may be necessary.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The contact presence on success, %NULL with
 error set on error</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">An array of #TpHandle for the contacts to get presence status for</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinGetMaximumStatusMessageLengthFunc"
              c:type="TpPresenceMixinGetMaximumStatusMessageLengthFunc"
              version="0.14.5">
      <doc xml:space="preserve">Signature of a callback used to determine the maximum length of status
messages. If this callback is provided and returns non-zero, the
#TpPresenceMixinSetOwnStatusFunc implementation is responsible for
truncating the message to fit this limit, if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximum number of UTF-8 characters which may appear in a status
message, or 0 if there is no limit.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceMixinPrivate"
            c:type="TpPresenceMixinPrivate"
            disguised="1">
    </record>
    <callback name="PresenceMixinSetOwnStatusFunc"
              c:type="TpPresenceMixinSetOwnStatusFunc"
              throws="1">
      <doc xml:space="preserve">Signature of the callback used to commit changes to the user's own presence
status in SetStatuses. It is also used in ClearStatus and RemoveStatus to
reset the user's own status back to the "default" one with a %NULL status
argument.

The optional_arguments hash table in @status, if not NULL, will have been
filtered so it only contains recognised parameters, so the callback
need not (and cannot) check for unrecognised parameters. However, the
types of the parameters are not currently checked, so the callback is
responsible for doing so.

The callback is responsible for emitting PresenceUpdate, if appropriate,
by calling tp_presence_mixin_emit_presence_update().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the operation was successful, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve">The status to set, or NULL for whatever the protocol defines as a
 "default" status</doc>
          <type name="PresenceStatus" c:type="const TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinStatusAvailableFunc"
              c:type="TpPresenceMixinStatusAvailableFunc">
      <doc xml:space="preserve">Signature of a callback to be used to determine if a given presence
status can be set on the connection. Most users of this mixin do not need to
supply an implementation of this callback: the value of
#TpPresenceStatusSpec.self is enough to determine whether this is a
user-settable presence, so %NULL should be passed to
tp_presence_mixin_class_init() for this callback.

One place where this callback may be needed is on XMPP: not all server
implementation support the user becoming invisible. So an XMPP
implementation would implement this function, so thatonce connectedthe
hidden status is only available if the server supports it. Before the
connection is connected, this callback should return %TRUE for every status
that might possibly be supported: this allows the user to at least try to
sign in as invisible.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the status can be set on this connection; %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An instance of a #TpBaseConnection subclass implementing the presence
 interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="which" transfer-ownership="none">
          <doc xml:space="preserve">An index into the array of #TpPresenceStatusSpec provided to
 tp_presence_mixin_class_init()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceStatus" c:type="TpPresenceStatus">
      <doc xml:space="preserve">Structure representing a presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.

In modern Telepathy connection managers, the only optional
argument should be a %G_TYPE_STRING named "message", on statuses
that have an optional human-readable message. All other optional arguments
are deprecated.</doc>
      <field name="index" writable="1">
        <doc xml:space="preserve">Index of the presence status in the provided supported presence
 statuses array</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="optional_arguments" writable="1">
        <doc xml:space="preserve">A GHashTable mapping of string identifiers to GValues
 of the optional status arguments, if any. If there are no optional
 arguments, this pointer may be NULL.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="free"
              c:identifier="tp_presence_status_free"
              introspectable="0">
        <doc xml:space="preserve">Deallocate all resources associated with a presence status structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to the presence status structure to free.</doc>
            <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="tp_presence_status_new"
                introspectable="0">
        <doc xml:space="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.

In modern Telepathy connection managers, the only optional
argument should be a %G_TYPE_STRING named "message", on statuses
that have an optional human-readable message. All other optional arguments
are deprecated.</doc>
        <return-value>
          <doc xml:space="preserve">A pointer to the newly allocated presence status structure.</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </return-value>
        <parameters>
          <parameter name="which" transfer-ownership="none">
            <doc xml:space="preserve">Index of the presence status in the provided supported presence
 statuses array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="optional_arguments" transfer-ownership="none">
            <doc xml:space="preserve">Optional arguments for the presence statuses. Can be
 NULL if there are no optional arguments. The presence status object makes a
 copy of the hashtable, so you should free the original.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceStatusOptionalArgumentSpec"
            c:type="TpPresenceStatusOptionalArgumentSpec">
      <doc xml:space="preserve">Structure specifying a supported optional argument for a presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">Name of the argument as passed over D-Bus</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="dtype" writable="1">
        <doc xml:space="preserve">D-Bus type signature of the argument</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="PresenceStatusSpec"
            c:type="TpPresenceStatusSpec"
            glib:type-name="TpPresenceStatusSpec"
            glib:get-type="tp_presence_status_spec_get_type"
            c:symbol-prefix="presence_status_spec">
      <doc xml:space="preserve">Structure specifying a supported presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">String identifier of the presence status</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="presence_type" writable="1">
        <doc xml:space="preserve">A type value, as specified by #TpConnectionPresenceType</doc>
        <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
      </field>
      <field name="self" writable="1">
        <doc xml:space="preserve">Indicates if this status may be set on yourself</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="optional_arguments" writable="1">
        <doc xml:space="preserve">An array of #TpPresenceStatusOptionalArgumentSpec
 structures representing the optional arguments for this status, terminated
 by a NULL name. If there are no optional arguments for a status, this can
 be NULL. In modern Telepathy connection managers, the only optional
 argument should be a string (type "s") named "message" on statuses
 that have an optional human-readable message. All other optional arguments
 are deprecated.</doc>
        <type name="PresenceStatusOptionalArgumentSpec"
              c:type="const TpPresenceStatusOptionalArgumentSpec*"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PresenceStatusSpecPrivate"
              c:type="TpPresenceStatusSpecPrivate*"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_presence_status_spec_new"
                   version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpPresenceStatusSpec</doc>
          <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the new presence status</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the category into which this presence status falls</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="can_set_on_self" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the user can set this presence status
 on themselves</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="has_message" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if this presence status is accompanied by an
 optional human-readable message</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="can_set_on_self"
              c:identifier="tp_presence_status_spec_can_set_on_self"
              version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the user can set this presence status on themselves (most
 statuses), or %FALSE if they cannot directly set it on
 themselves (typically used for %TP_CONNECTION_PRESENCE_TYPE_OFFLINE
 and %TP_CONNECTION_PRESENCE_TYPE_ERROR)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a presence status specification</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="tp_presence_status_spec_copy"
              version="0.23.1">
        <doc xml:space="preserve">Copy a presence status specification.

If @self has optional arguments other than a string named "message",
they are not copied. Optional arguments with other names or types
are deprecated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpPresenceStatusSpec resembling @self</doc>
          <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a presence status specification</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="tp_presence_status_spec_free"
              version="0.23.1">
        <doc xml:space="preserve">Free a presence status specification produced by
tp_presence_status_spec_new() or tp_presence_status_spec_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="full">
            <doc xml:space="preserve">a presence status specification</doc>
            <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_presence_status_spec_get_name"
              version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of this presence status,
 such as "available" or "out-to-lunch".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a presence status specification</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presence_type"
              c:identifier="tp_presence_status_spec_get_presence_type"
              version="0.23.1">
        <doc xml:space="preserve">Return the category into which this presence type falls. For instance,
for XMPP's "" (do not disturb) status, this would return
%TP_CONNECTION_PRESENCE_TYPE_BUSY.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnectionPresenceType</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a presence status specification</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_message"
              c:identifier="tp_presence_status_spec_has_message"
              version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this presence status is accompanied by an optional
 human-readable message</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a presence status specification</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="PresenceStatusSpecPrivate"
            c:type="TpPresenceStatusSpecPrivate"
            disguised="1">
    </record>
    <bitfield name="PropertyFlags" c:type="TpPropertyFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="read" value="1" c:identifier="TP_PROPERTY_FLAG_READ">
        <doc xml:space="preserve">&lt;![CDATA[The property can be read]]&gt;</doc>
      </member>
      <member name="write" value="2" c:identifier="TP_PROPERTY_FLAG_WRITE">
        <doc xml:space="preserve">&lt;![CDATA[The property can be written]]&gt;</doc>
      </member>
    </bitfield>
    <class name="Protocol"
           c:symbol-prefix="protocol"
           c:type="TpProtocol"
           version="0.11.11"
           parent="Proxy"
           glib:type-name="TpProtocol"
           glib:get-type="tp_protocol_get_type"
           glib:type-struct="ProtocolClass">
      <doc xml:space="preserve">A base class for connection managers' protocols.</doc>
      <constructor name="new"
                   c:identifier="tp_protocol_new"
                   version="0.11.11"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new protocol proxy, or %NULL on invalid arguments</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">proxy for the D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:space="preserve">the connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol_name" transfer-ownership="none">
            <doc xml:space="preserve">the protocol name (such as "jabber")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">the immutable D-Bus properties for this protocol</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_vardict"
                   c:identifier="tp_protocol_new_vardict"
                   version="0.23.3"
                   throws="1">
        <doc xml:space="preserve">Create a new protocol proxy.

If @immutable_properties is a floating reference, this function will
take ownership of it, much like g_variant_ref_sink(). See documentation of
that function for details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new protocol proxy, or %NULL on invalid arguments</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">proxy for the D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:space="preserve">the connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol_name" transfer-ownership="none">
            <doc xml:space="preserve">the protocol name (such as "jabber")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">the immutable D-Bus properties for this protocol</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_protocol_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_parameters"
                c:identifier="tp_protocol_get_feature_quark_parameters">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_protocol_init_known_interfaces"
                version="0.11.11">
        <doc xml:space="preserve">Ensure that the known interfaces for TpProtocol have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_PROTOCOL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_params"
              c:identifier="tp_protocol_borrow_params"
              version="0.17.6"
              introspectable="0"
              deprecated="1">
        <doc xml:space="preserve">Returns an array of parameters supported by this connection manager,
without additional memory allocations. The returned array is owned by
@self, and must not be used after @self has been freed.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use tp_protocol_dup_params()
 instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of #TpConnectionManagerParam structures,
 terminated by one whose @name is %NULL</doc>
          <type name="ConnectionManagerParam"
                c:type="const TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_register"
              c:identifier="tp_protocol_can_register"
              version="0.11.11">
        <doc xml:space="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_immutable_properties"
              c:identifier="tp_protocol_dup_immutable_properties"
              version="0.23.3">
        <doc xml:space="preserve">Return the #TpProtocol:protocol-properties-vardict property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of
#TpProtocol:protocol-properties-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProtocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_param"
              c:identifier="tp_protocol_dup_param"
              version="0.17.6">
        <doc xml:space="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a structure representing the parameter @param,
 or %NULL if not supported. Free with tp_connection_manager_param_free()</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_param_names"
              c:identifier="tp_protocol_dup_param_names"
              version="0.11.11">
        <doc xml:space="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.

The result is copied and must be freed by the caller with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of
 #TpProtocol:param-names</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_params"
              c:identifier="tp_protocol_dup_params"
              version="0.17.6">
        <doc xml:space="preserve">Returns a list of parameters supported by this connection manager.

The returned list must be freed by the caller, for instance with
&lt;literal&gt;g_list_free_full (l,
(GDestroyNotify) tp_connection_manager_param_free)&lt;/literal&gt;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a list of #TpConnectionManagerParam structures, owned by the caller</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ConnectionManagerParam"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_presence_statuses"
              c:identifier="tp_protocol_dup_presence_statuses">
        <doc xml:space="preserve">Return the presence statuses that might be supported by connections
to this protocol.

It is possible that some of these statuses will not actually be supported
by a connection: for instance, an XMPP connection manager would
include "hidden" in this list, even though not all XMPP servers allow
users to be online-but-hidden.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
 list of statuses, or %NULL if unknown</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PresenceStatusSpec"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_addressable_uri_schemes"
              c:identifier="tp_protocol_get_addressable_uri_schemes"
              version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpProtocol:addressable-uri-schemes</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_addressable_vcard_fields"
              c:identifier="tp_protocol_get_addressable_vcard_fields"
              version="0.23.1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpProtocol:addressable-vcard-fields</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_authentication_types"
              c:identifier="tp_protocol_get_authentication_types"
              version="0.13.9">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpProtocol:authentication-types</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_avatar_requirements"
              c:identifier="tp_protocol_get_avatar_requirements"
              version="0.15.6">
        <doc xml:space="preserve">Return the #TpProtocol:avatar-requirements property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpProtocol:avatar-requirements</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProtocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_protocol_get_capabilities"
              version="0.11.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TpProtocol:capabilities, which must be referenced
 (if non-%NULL) if it will be kept</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cm_name"
              c:identifier="tp_protocol_get_cm_name"
              version="0.19.1">
        <doc xml:space="preserve">Return the #TpProtocol:cm-name property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpProtocol:cm-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProtocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_english_name"
              c:identifier="tp_protocol_get_english_name"
              version="0.11.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the non-%NULL, non-empty value of #TpProtocol:english-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_name"
              c:identifier="tp_protocol_get_icon_name"
              version="0.11.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the non-%NULL, non-empty value of #TpProtocol:icon-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_protocol_get_name"
              version="0.11.11">
        <doc xml:space="preserve">Return the same thing as the protocol-name property, for convenient use
in C code. The returned string is valid for as long as @self exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpProtocol:protocol-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_param"
              c:identifier="tp_protocol_get_param"
              version="0.11.11">
        <doc xml:space="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a structure representing the parameter @param, or %NULL if not
         supported</doc>
          <type name="ConnectionManagerParam"
                c:type="const TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vcard_field"
              c:identifier="tp_protocol_get_vcard_field"
              version="0.11.11">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpProtocol:vcard-field</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol object</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_param"
              c:identifier="tp_protocol_has_param"
              version="0.11.11">
        <doc xml:space="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @self supports the parameter @param.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="identify_account_async"
              c:identifier="tp_protocol_identify_account_async"
              version="0.23.1">
        <doc xml:space="preserve">Return a string that could identify the account with the given
parameters. In most protocols that string is a normalized 'account'
parameter, but some protocols have more complex requirements;
for instance, on IRC, the 'account' (nickname) is insufficient,
and must be combined with a server or network name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="vardict" transfer-ownership="none">
            <doc xml:space="preserve">the account parameters as a #GVariant of
 type %G_VARIANT_TYPE_VARDICT. If it is floating, ownership will
 be taken, as if via g_variant_ref_sink().</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">may be used to cancel the async request</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when
 the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="identify_account_finish"
              c:identifier="tp_protocol_identify_account_finish"
              version="0.23.1"
              throws="1">
        <doc xml:space="preserve">Interpret the result of tp_protocol_identify_account_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string identifying the account,
 or %NULL on error</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_contact_async"
              c:identifier="tp_protocol_normalize_contact_async"
              version="0.23.1">
        <doc xml:space="preserve">Perform best-effort offline contact normalization. This does syntactic
normalization (e.g. transforming case-insensitive text to lower-case),
but does not query servers or anything similar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">a contact identifier, possibly invalid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">may be used to cancel the async request</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when
 the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_contact_finish"
              c:identifier="tp_protocol_normalize_contact_finish"
              version="0.23.1"
              throws="1">
        <doc xml:space="preserve">Interpret the result of tp_protocol_normalize_contact_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the normalized form of @contact,
 or %NULL on error</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_contact_uri_async"
              c:identifier="tp_protocol_normalize_contact_uri_async"
              version="0.23.1">
        <doc xml:space="preserve">Perform best-effort offline contact normalization, for a contact in
the form of a URI. This method will fail if the URI is not in a
scheme supported by this protocol or connection manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a contact URI, possibly invalid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">may be used to cancel the async request</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_contact_uri_finish"
              c:identifier="tp_protocol_normalize_contact_uri_finish"
              version="0.23.1"
              throws="1">
        <doc xml:space="preserve">Interpret the result of tp_protocol_normalize_contact_uri_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the normalized form of @uri,
 or %NULL on error</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_vcard_address_async"
              c:identifier="tp_protocol_normalize_vcard_address_async"
              version="0.23.1">
        <doc xml:space="preserve">Perform best-effort offline contact normalization, for a contact in
the form of a vCard field. This method will fail if the vCard field
is not supported by this protocol or connection manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">a vCard field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an address that is a value of @field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">may be used to cancel the async request</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_vcard_address_finish"
              c:identifier="tp_protocol_normalize_vcard_address_finish"
              version="0.23.1"
              throws="1">
        <doc xml:space="preserve">Interpret the result of tp_protocol_normalize_vcard_address_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the normalized form of @value,
 or %NULL on error</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a protocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="addressable-uri-schemes"
                version="0.23.1"
                transfer-ownership="none">
        <doc xml:space="preserve">A non-%NULL #GStrv of URI schemes supported by this protocol.
If this protocol does not support addressing contacts by URI,
the list is empty.

For instance, a SIP connection manager that supports calling contacts
by SIP URI (sip:alice&amp;commat;example.com, sips:bob&amp;commat;example.com)
or telephone number (tel:+1-555-0123) might have
{ "sip", "sips", "tel", NULL }.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="addressable-vcard-fields"
                version="0.23.1"
                transfer-ownership="none">
        <doc xml:space="preserve">A non-%NULL #GStrv of vCard fields supported by this protocol.
If this protocol does not support addressing contacts by a vCard field,
the list is empty.

For instance, a SIP connection manager that supports calling contacts
by SIP URI (vCard field SIP) or telephone number (vCard field TEL)
might have { "sip", "tel", NULL }.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="authentication-types"
                version="0.13.9"
                transfer-ownership="none">
        <doc xml:space="preserve">A non-%NULL #GStrv of interfaces which provide information as to
what kind of authentication channels can possibly appear before
the connection reaches the CONNECTED state, or %NULL if
%TP_PROTOCOL_FEATURE_CORE has not been prepared.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="avatar-requirements"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpAvatarRequirements representing the avatar requirements on this
protocol, or %NULL if %TP_PROTOCOL_FEATURE_CORE has not been prepared or
if the protocol doesn't support avatars.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="capabilities"
                version="0.11.11"
                transfer-ownership="none">
        <doc xml:space="preserve">The classes of channel that can be requested from connections to this
protocol, or %NULL if this is unknown or the %TP_PROTOCOL_FEATURE_CORE
feature has not been prepared.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="cm-name"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The name of the connection manager this protocol is on.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="english-name"
                version="0.11.11"
                transfer-ownership="none">
        <doc xml:space="preserve">The name of the protocol in a form suitable for display to users,
such as "AIM" or "Yahoo!", or a string based on #TpProtocol:protocol-name
(currently constructed by putting the first character in title case,
but this is not guaranteed) if no better name is available or the
%TP_PROTOCOL_FEATURE_CORE feature has not been prepared.

This is effectively in the C locale (international English); user
interfaces requiring a localized protocol name should look one up in their
own message catalog based on either #TpProtocol:protocol-name or
#TpProtocol:english-name, but should use this English version as a
fallback if no translated version can be found.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="icon-name" version="0.11.11" transfer-ownership="none">
        <doc xml:space="preserve">The name of an icon in the system's icon theme. If none was supplied
by the Protocol, or the %TP_PROTOCOL_FEATURE_CORE feature has not been
prepared, a default is used; currently, this is "im-" plus
#TpProtocol:protocol-name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="param-names" version="0.11.11" transfer-ownership="none">
        <doc xml:space="preserve">A list of parameter names supported by this connection manager
for this protocol, or %NULL if %TP_PROTOCOL_FEATURE_PARAMETERS has not
been prepared.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="protocol-name"
                version="0.11.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The machine-readable name of the protocol, taken from the Telepathy
D-Bus Interface Specification, such as "jabber" or "local-xmpp".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol-properties"
                version="0.11.11"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The immutable properties of this Protocol, as provided at construction
time. This is a map from string to #GValue, which must not be modified.

If the immutable properties were not provided at construction time,
the %TP_PROTOCOL_FEATURE_PARAMETERS and %TP_PROTOCOL_FEATURE_CORE features
will both be unavailable, and this #TpProtocol object will only be useful
as a way to access lower-level D-Bus calls.</doc>
        <type/>
      </property>
      <property name="protocol-properties-vardict"
                version="0.23.3"
                transfer-ownership="none">
        <doc xml:space="preserve">The immutable properties of this Protocol, as provided at construction
time. This is a #G_VARIANT_TYPE_VARDICT #GVariant,
which must not be modified.

If the immutable properties were not provided at construction time,
the %TP_PROTOCOL_FEATURE_PARAMETERS and %TP_PROTOCOL_FEATURE_CORE features
will both be unavailable, and this #TpProtocol object will only be useful
as a way to access lower-level D-Bus calls.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="vcard-field" version="0.11.11" transfer-ownership="none">
        <doc xml:space="preserve">The most common vCard field used for this protocol's contact
identifiers, normalized to lower case, or %NULL if there is no such field
or the %TP_PROTOCOL_FEATURE_CORE feature has not been prepared.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProtocolPrivate" c:type="TpProtocolPrivate*"/>
      </field>
    </class>
    <record name="ProtocolClass"
            c:type="TpProtocolClass"
            disguised="1"
            glib:is-gtype-struct-for="Protocol"
            version="0.11.11">
      <doc xml:space="preserve">The class of a #TpProtocol.</doc>
    </record>
    <record name="ProtocolClassPrivate"
            c:type="TpProtocolClassPrivate"
            disguised="1">
    </record>
    <record name="ProtocolPrivate" c:type="TpProtocolPrivate" disguised="1">
    </record>
    <class name="Proxy"
           c:symbol-prefix="proxy"
           c:type="TpProxy"
           version="0.7.1"
           parent="GObject.Object"
           glib:type-name="TpProxy"
           glib:get-type="tp_proxy_get_type"
           glib:type-struct="ProxyClass">
      <doc xml:space="preserve">Structure representing a Telepathy client-side proxy.</doc>
      <method name="dbus_error_to_gerror"
              c:identifier="tp_proxy_dbus_error_to_gerror"
              version="0.7.24"
              throws="1">
        <doc xml:space="preserve">Convert a D-Bus error name into a GError as if it was returned by a method
on this proxy. This method is useful when D-Bus error names are emitted in
signals, such as Connection.ConnectionError and
Group.MembersChangedDetailed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
          <parameter name="dbus_error" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus error name, for instance from the callback for
             tp_cli_connection_connect_to_connection_error()</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="debug_message" transfer-ownership="none">
            <doc xml:space="preserve">a debug message that accompanied the error name, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_proxy_get_bus_name"
              version="0.7.17">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bus name of the application exporting the object. The caller
 must copy the string with g_strdup() if it will be kept.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_connection"
              c:identifier="tp_proxy_get_dbus_connection"
              version="0.7.17"
              introspectable="0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value>
          <doc xml:space="preserve">a borrowed reference to the D-Bus connection used by this object.
 The caller must reference the returned pointer with
 dbus_g_connection_ref() if it will be kept.</doc>
          <type c:type="DBusGConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_proxy_get_dbus_daemon"
              version="0.7.17">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a borrowed reference to the #TpDBusDaemon for
 this object, if any; always %NULL if this object is itself a
 #TpDBusDaemon. The caller must reference the returned object with
 g_object_ref() if it will be kept.</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_factory"
              c:identifier="tp_proxy_get_factory"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same value as #TpProxy:factory property</doc>
          <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_invalidated"
              c:identifier="tp_proxy_get_invalidated"
              version="0.7.17">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the reason this proxy was invalidated, or %NULL if has not been
 invalidated. The caller must copy the error, for instance with
 g_error_copy(), if it will be kept.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_path"
              c:identifier="tp_proxy_get_object_path"
              version="0.7.17">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object path of the remote object. The caller must copy the
 string with g_strdup() if it will be kept.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpProxy or subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_interface"
              c:identifier="tp_proxy_has_interface"
              version="0.7.1">
        <doc xml:space="preserve">Return whether this proxy is known to have a particular interface. In
versions older than 0.11.11, this was a macro wrapper around
tp_proxy_has_interface_by_id().

For objects that discover their interfaces at runtime, this method will
indicate that interfaces are missing until they are known to be present.
In subclasses that define features for use with tp_proxy_prepare_async(),
successfully preparing the "core" feature for that subclass (such as
%TP_CHANNEL_FEATURE_CORE or %TP_CONNECTION_FEATURE_CORE) implies that the
interfaces are known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #TpProxy (or subclass)</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus interface required, as a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_interface_by_id"
              c:identifier="tp_proxy_has_interface_by_id"
              version="0.7.1">
        <doc xml:space="preserve">Return whether this proxy is known to have a particular interface, by its
quark ID. This is equivalent to using g_quark_to_string() followed by
tp_proxy_has_interface(), but more efficient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #TpProxy (or subclass)</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:space="preserve">quark representing the D-Bus interface required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared"
              c:identifier="tp_proxy_is_prepared"
              version="0.11.3">
        <doc xml:space="preserve">Return %TRUE if @feature has been prepared successfully, or %FALSE if
@feature has not been requested, has not been prepared yet, or is not
available on this object at all.

(For instance, if @feature is %TP_CHANNEL_FEATURE_CHAT_STATES and @self
is a #TpChannel in a protocol that doesn't actually implement chat states,
or is not a #TpChannel at all, then this method will return %FALSE.)

To prepare features, call tp_proxy_prepare_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @feature has been prepared successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an instance of a #TpProxy subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a feature that is supported by @self's class</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_proxy_prepare_async"
              version="0.11.3">
        <doc xml:space="preserve">#TpProxy itself does not support any features, but subclasses like
#TpChannel can support features, which can either be core functionality like
%TP_CHANNEL_FEATURE_CORE, or extended functionality like
%TP_CHANNEL_FEATURE_CHAT_STATES.

Proxy instances start with no features prepared. When features are
requested via tp_proxy_prepare_async(), the proxy starts to do the
necessary setup to use those features.

tp_proxy_prepare_async() always waits for core functionality of the proxy's
class to be prepared, even if it is not specifically requested: for
instance, because %TP_CHANNEL_FEATURE_CORE is core functionality of a
#TpChannel,

|[
TpChannel *channel = ...;

tp_proxy_prepare_async (channel, NULL, callback, user_data);
]|

is equivalent to

|[
TpChannel *channel = ...;
GQuark features[] = { TP_CHANNEL_FEATURE_CORE, 0 };

tp_proxy_prepare_async (channel, features, callback, user_data);
]|

If a feature represents core functionality (like %TP_CHANNEL_FEATURE_CORE),
failure to prepare it will result in tp_proxy_prepare_async() finishing
unsuccessfully: if failure to prepare the feature indicates that the proxy
is no longer useful, it will also emit #TpProxy::invalidated.

If a feature represents non-essential functionality
(like %TP_CHANNEL_FEATURE_CHAT_STATES), or is not supported by the object
at all, then failure to prepare it is not fatal:
tp_proxy_prepare_async() will complete successfully, but
tp_proxy_is_prepared() will still return %FALSE for the feature, and
accessor methods for the feature will typically return a dummy value.

Some #TpProxy subclasses automatically start to prepare their core
features when instantiated, and features will sometimes become prepared as
a side-effect of other actions, but to ensure that a feature is present you
must generally call tp_proxy_prepare_async() and wait for the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an instance of a #TpProxy subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an array
 of desired features, ending with 0; %NULL is equivalent to an array
 containing only 0</doc>
            <array c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">if not %NULL, called exactly once, when the features have all
 been prepared or failed to prepare, or after the proxy is invalidated</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_proxy_prepare_finish"
              version="0.11.3"
              throws="1">
        <doc xml:space="preserve">Check for error in a call to tp_proxy_prepare_async(). An error here
generally indicates that either the asynchronous call was cancelled,
or @self has emitted #TpProxy::invalidated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE (setting @error) if tp_proxy_prepare_async() failed
 or was cancelled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an instance of a #TpProxy subclass</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback of tp_proxy_prepare_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus-name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus bus name for this object. Read-only except during construction.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dbus-connection"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus connection for this object. Read-only except during
construction.</doc>
        <type/>
      </property>
      <property name="dbus-daemon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus daemon for this object (this object itself, if it is a
TpDBusDaemon). Read-only except during construction.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="factory"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpSimpleClientFactory used to create this proxy,
or %NULL if this proxy was not created through a factory.</doc>
        <type name="SimpleClientFactory"/>
      </property>
      <property name="interfaces" transfer-ownership="none">
        <doc xml:space="preserve">Known D-Bus interface names for this object.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="object-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus object path for this object. Read-only except during
construction.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="dbus_daemon" readable="0" private="1">
        <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
      </field>
      <field name="dbus_connection"
             introspectable="0"
             readable="0"
             private="1">
        <type c:type="DBusGConnection*"/>
      </field>
      <field name="bus_name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="invalidated" readable="0" private="1">
        <type name="GLib.Error" c:type="GError*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyPrivate" c:type="TpProxyPrivate*"/>
      </field>
      <glib:signal name="interface-added"
                   when="last"
                   detailed="1"
                   introspectable="0">
        <doc xml:space="preserve">Emitted when this proxy has gained an interface. It is not guaranteed
to be emitted immediately, but will be emitted before the interface is
first used (at the latest: before it's returned from
tp_proxy_get_interface_by_id(), any signal is connected, or any
method is called).

The intended use is to call dbus_g_proxy_add_signals(). This signal
should only be used by TpProy implementations</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">the GQuark representing the interface</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">the dbus-glib proxy representing the interface</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated" when="last" detailed="1">
        <doc xml:space="preserve">Emitted when this proxy has been become invalid for
whatever reason. Any more specific signal should be emitted first.

An invalidated proxy is one which can make no more method calls and will
emit no more D-Bus signals. This is typically because the D-Bus object
represented by the proxy ceased to exist, or there was some error
obtaining the initial state.

Any pending or future method calls made on this proxy will fail gracefully
with the same error as returned by tp_proxy_get_invalidated().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">domain of a GError indicating why this proxy was invalidated</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">error code of a GError indicating why this proxy was invalidated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a message associated with the error</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ProxyClass"
            c:type="TpProxyClass"
            glib:is-gtype-struct-for="Proxy"
            version="0.7.1">
      <doc xml:space="preserve">The class of a #TpProxy. The struct fields not documented here are reserved.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class structure</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="interface">
        <doc xml:space="preserve">If set non-zero by a subclass, #TpProxy will
   automatically add this interface in its constructor</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="must_have_unique_name" bits="1">
        <doc xml:space="preserve">If set %TRUE by a subclass, the #TpProxy
   constructor will fail if a well-known bus name is given</doc>
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="_reserved_flags" readable="0" bits="31" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_internal_list_features" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="3">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="ProxyFeature" c:type="TpProxyFeature" version="0.11.3">
      <doc xml:space="preserve">Structure representing a feature.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">a #GQuark representing the name of the feature</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="core" writable="1">
        <doc xml:space="preserve">if %TRUE, every non-core feature of the class depends on this one,
and every feature (core or not) in subclasses depends on this one</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="prepare_async" writable="1">
        <doc xml:space="preserve">called when the feature has to be prepared</doc>
        <type name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync"/>
      </field>
      <field name="prepare_before_signalling_connected_async" writable="1">
        <doc xml:space="preserve">only relevant for
TpConnection sub-classes; same as @prepare_async but for
features wanting to have a chance to prepare themself before the
TpConnection object announce its %TP_CONNECTION_STATUS_CONNECTED status</doc>
        <type name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync"/>
      </field>
      <field name="interfaces_needed" writable="1">
        <doc xml:space="preserve">an array of #GQuark representing interfaces which have
to be implemented on the object in order to be able to prepare the feature</doc>
        <type name="GLib.Quark" c:type="const GQuark*"/>
      </field>
      <field name="depends_on" writable="1">
        <doc xml:space="preserve">an array of #GQuark representing other features which have to
be prepared before trying to prepare this feature</doc>
        <type name="GLib.Quark" c:type="const GQuark*"/>
      </field>
      <field name="can_retry" writable="1">
        <doc xml:space="preserve">If %TRUE, allow retrying preparation of this feature even if it
failed once already; if %FALSE any attempt of preparing the feature after
the preparation already failed once will immediately fail with re-calling
@prepare_async</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyFeaturePrivate" c:type="TpProxyFeaturePrivate*"/>
      </field>
    </record>
    <record name="ProxyFeaturePrivate"
            c:type="TpProxyFeaturePrivate"
            disguised="1">
    </record>
    <record name="ProxyPendingCall" c:type="TpProxyPendingCall" disguised="1">
      <method name="cancel" c:identifier="tp_proxy_pending_call_cancel">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pc" transfer-ownership="none">
            <type name="ProxyPendingCall" c:type="TpProxyPendingCall*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync">
      <doc xml:space="preserve">Function called when @feature has to be prepared for @proxy.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:space="preserve">the object on which @feature has to be prepared</doc>
          <type name="Proxy" c:type="TpProxy*"/>
        </parameter>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark representing the feature to prepare</doc>
          <type name="ProxyFeature" c:type="const TpProxyFeature*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve">called when the feature has been prepared, or the preparation
failed</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ProxyPrivate" c:type="TpProxyPrivate" disguised="1">
    </record>
    <record name="ProxySignalConnection"
            c:type="TpProxySignalConnection"
            disguised="1">
      <method name="disconnect"
              c:identifier="tp_proxy_signal_connection_disconnect">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sc" transfer-ownership="none">
            <type name="ProxySignalConnection"
                  c:type="TpProxySignalConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="RCPTXRRTTMode" c:type="TpRCPTXRRTTMode">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="all" value="0" c:identifier="TP_RCPT_XR_RTT_MODE_ALL">
        <doc xml:space="preserve">&lt;![CDATA[           Both RTP data senders and data receivers MAY send DLRR           blocks.         ]]&gt;</doc>
      </member>
      <member name="sender"
              value="1"
              c:identifier="TP_RCPT_XR_RTT_MODE_SENDER">
        <doc xml:space="preserve">&lt;![CDATA[           Only active RTP senders MAY send DLRR blocks, i.e., non RTP           senders SHALL NOT send DLRR blocks.         ]]&gt;</doc>
      </member>
    </enumeration>
    <bitfield name="RTCPXRStatisticsFlags" c:type="TpRTCPXRStatisticsFlags">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="loss"
              value="1"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_LOSS">
        <doc xml:space="preserve">&lt;![CDATA[           Loss report flag, as defined in RFC3611 section 4.6.         ]]&gt;</doc>
      </member>
      <member name="duplicate"
              value="2"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_DUPLICATE">
        <doc xml:space="preserve">&lt;![CDATA[           Duplicate report flag, as defined in RFC3611 section 4.6.         ]]&gt;</doc>
      </member>
      <member name="jitter"
              value="4"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_JITTER">
        <doc xml:space="preserve">&lt;![CDATA[           Jitter flag, as defined in RFC3611 section 4.6.         ]]&gt;</doc>
      </member>
      <member name="ttl"
              value="8"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_TTL">
        <doc xml:space="preserve">&lt;![CDATA[           First bit of TTL or Hop Limit flag, as defined in RFC3611 section           4.6.         ]]&gt;</doc>
      </member>
      <member name="hl"
              value="16"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_HL">
        <doc xml:space="preserve">&lt;![CDATA[           Second bit of TTL or Hop Limit flag, as defined in RFC3611 section           4.6.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="RichPresenceAccessControlType"
                 c:type="TpRichPresenceAccessControlType">
      <doc xml:space="preserve">&lt;![CDATA[         A type of access control for Rich_Presence_Access_Control.           For most types, the exact access control is given by an associated           variant.                     These are the access control types from XMPP publish/subscribe           (XEP-0060).                   Location           uses this for historical reasons, new interfaces will use           Access_Control_Type.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="whitelist"
              value="0"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST">
        <doc xml:space="preserve">&lt;![CDATA[           The associated variant is a list of contacts (signature 'au',           Contact_Handle[]) who can see the extended presence information.         ]]&gt;</doc>
      </member>
      <member name="publish_list"
              value="1"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST">
        <doc xml:space="preserve">&lt;![CDATA[           All contacts in the user's 'publish' contact list can see the           extended presence information. The associated variant is ignored.         ]]&gt;</doc>
      </member>
      <member name="group"
              value="2"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP">
        <doc xml:space="preserve">&lt;![CDATA[           The associated variant is a handle of type Group (signature 'u',           Group_Handle) representing a group of contacts who can see the           extended presence information.         ]]&gt;</doc>
      </member>
      <member name="open"
              value="3"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN">
        <doc xml:space="preserve">&lt;![CDATA[           Anyone with access to the service can see the extended presence           information.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="RoomInfo"
           c:symbol-prefix="room_info"
           c:type="TpRoomInfo"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpRoomInfo"
           glib:get-type="tp_room_info_get_type"
           glib:type-struct="RoomInfoClass">
      <doc xml:space="preserve">Data structure representing a #TpRoomInfo.</doc>
      <method name="get_channel_type"
              c:identifier="tp_room_info_get_channel_type"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string representing the D-Bus interface name of
the channel type of the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="tp_room_info_get_description"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a description of the room's overall purpose</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handle"
              c:identifier="tp_room_info_get_handle"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #TpHandle of the room</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handle_name"
              c:identifier="tp_room_info_get_handle_name"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the identifier of the room (as would be returned
by inspecting the #TpHandle returned by tp_room_info_get_handle())</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_invite_only"
              c:identifier="tp_room_info_get_invite_only"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if you cannot join the room, but must be invited</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
          <parameter name="known" transfer-ownership="none">
            <doc xml:space="preserve">either %NULL, or a location in which to store %TRUE if the
returned value is meaningful</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_members_count"
              c:identifier="tp_room_info_get_members_count"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of members in the room</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
          <parameter name="known" transfer-ownership="none">
            <doc xml:space="preserve">either %NULL, or a location in which to store %TRUE if the
returned value is meaningful</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_room_info_get_name"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the human-readable name of the room if different
from the handle</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_requires_password"
              c:identifier="tp_room_info_get_requires_password"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the room requires a password to enter</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
          <parameter name="known" transfer-ownership="none">
            <doc xml:space="preserve">either %NULL, or a location in which to store %TRUE if the
returned value is meaningful</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_room_id"
              c:identifier="tp_room_info_get_room_id"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the human-readable identifier of the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_server"
              c:identifier="tp_room_info_get_server"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the DNS name of the server hosting the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject"
              c:identifier="tp_room_info_get_subject"
              version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current subject of conversation in the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo" c:type="TpRoomInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RoomInfoPriv" c:type="TpRoomInfoPriv*"/>
      </field>
    </class>
    <record name="RoomInfoClass"
            c:type="TpRoomInfoClass"
            glib:is-gtype-struct-for="RoomInfo"
            version="0.19.0">
      <doc xml:space="preserve">The class of a #TpRoomInfo.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="RoomInfoPriv" c:type="TpRoomInfoPriv" disguised="1">
    </record>
    <class name="RoomList"
           c:symbol-prefix="room_list"
           c:type="TpRoomList"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpRoomList"
           glib:get-type="tp_room_list_get_type"
           glib:type-struct="RoomListClass">
      <doc xml:space="preserve">Data structure representing a #TpRoomList.</doc>
      <implements name="Gio.AsyncInitable"/>
      <constructor name="new_finish"
                   c:identifier="tp_room_list_new_finish"
                   version="0.19.0"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpRoomList object, or %NULL
in case of error.</doc>
          <type name="RoomList" c:type="TpRoomList*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async"
                c:identifier="tp_room_list_new_async"
                version="0.19.0">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount for the room listing</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">the DNS name of the server whose rooms should listed</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization
is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_account"
              c:identifier="tp_room_list_get_account"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpRoomList:account property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpRoomList:account property</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomList</doc>
            <type name="RoomList" c:type="TpRoomList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_server"
              c:identifier="tp_room_list_get_server"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpRoomList:server property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpRoomList:server property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomList</doc>
            <type name="RoomList" c:type="TpRoomList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_listing"
              c:identifier="tp_room_list_is_listing"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpRoomList:listing property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpRoomList:listing property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomList</doc>
            <type name="RoomList" c:type="TpRoomList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="tp_room_list_start" version="0.19.0">
        <doc xml:space="preserve">Start listing rooms using @self. Use the TpRoomList::got-rooms
signal to get the rooms found.
Errors will be reported using the TpRoomList::failed signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomList</doc>
            <type name="RoomList" c:type="TpRoomList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpAccount to use for the room listing.</doc>
        <type name="Account"/>
      </property>
      <property name="listing" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel is currently listing rooms.

This property is meaningless until the
%TP_ROOM_LIST_FEATURE_LISTING feature has been prepared.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="server"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The DNS name of the server whose rooms are listed by this channel, or
%NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RoomListPrivate" c:type="TpRoomListPrivate*"/>
      </field>
      <glib:signal name="failed" when="last" version="0.19.0">
        <doc xml:space="preserve">Fired when something goes wrong while listing the channels; see @error
for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError indicating the reason of the error</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="got-room" when="last" version="0.19.0">
        <doc xml:space="preserve">Fired each time a room is found during the listing process.
User should take his own reference on @room if he plans to
continue using it once the signal callback has returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="room" transfer-ownership="none">
            <doc xml:space="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="RoomListClass"
            c:type="TpRoomListClass"
            glib:is-gtype-struct-for="RoomList"
            version="0.19.0">
      <doc xml:space="preserve">The class of a #TpRoomList.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="RoomListPrivate" c:type="TpRoomListPrivate" disguised="1">
    </record>
    <enumeration name="SASLAbortReason" c:type="TpSASLAbortReason">
      <doc xml:space="preserve">&lt;![CDATA[         A reason why SASL authentication was aborted by the client.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="invalid_challenge"
              value="0"
              c:identifier="TP_SASL_ABORT_REASON_INVALID_CHALLENGE">
        <doc xml:space="preserve">&lt;![CDATA[           The server sent an invalid challenge or data.         ]]&gt;</doc>
      </member>
      <member name="user_abort"
              value="1"
              c:identifier="TP_SASL_ABORT_REASON_USER_ABORT">
        <doc xml:space="preserve">&lt;![CDATA[           The user aborted the authentication.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="SASLStatus" c:type="TpSASLStatus">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="not_started"
              value="0"
              c:identifier="TP_SASL_STATUS_NOT_STARTED">
        <doc xml:space="preserve">&lt;![CDATA[           The initial state. The Handler SHOULD either           call AbortSASL, or connect to the           NewChallenge signal then call           StartMechanism or           StartMechanismWithData.         ]]&gt;</doc>
      </member>
      <member name="in_progress"
              value="1"
              c:identifier="TP_SASL_STATUS_IN_PROGRESS">
        <doc xml:space="preserve">&lt;![CDATA[           The challenge/response exchange is in progress. The Handler SHOULD           call either Respond or           AcceptSASL exactly once per emission           of NewChallenge, or call           AbortSASL at any time.         ]]&gt;</doc>
      </member>
      <member name="server_succeeded"
              value="2"
              c:identifier="TP_SASL_STATUS_SERVER_SUCCEEDED">
        <doc xml:space="preserve">&lt;![CDATA[           The server has indicated successful authentication, and the           connection manager is waiting for confirmation from the Handler.           The Handler must call either AcceptSASL or           AbortSASL to indicate whether it           considers authentication to have been successful.         ]]&gt;</doc>
      </member>
      <member name="client_accepted"
              value="3"
              c:identifier="TP_SASL_STATUS_CLIENT_ACCEPTED">
        <doc xml:space="preserve">&lt;![CDATA[           The Handler has indicated successful authentication, and the           connection manager is waiting for confirmation from the server.           The state will progress to either Succeeded or Server_Failed when           confirmation is received.         ]]&gt;</doc>
      </member>
      <member name="succeeded"
              value="4"
              c:identifier="TP_SASL_STATUS_SUCCEEDED">
        <doc xml:space="preserve">&lt;![CDATA[           Everyone is happy (the server sent success, and the client has called           AcceptSASL). Connection to the server           will proceed as soon as this state is reached. The Handler SHOULD           call Close           to close the channel.         ]]&gt;</doc>
      </member>
      <member name="server_failed"
              value="5"
              c:identifier="TP_SASL_STATUS_SERVER_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           The server has indicated an authentication failure.           If CanTryAgain is true,           the client may try to authenticate again, by calling           StartMechanism or           StartMechanismWithData again.           Otherwise, it should give up completely, by calling Close           on the channel.         ]]&gt;</doc>
      </member>
      <member name="client_failed"
              value="6"
              c:identifier="TP_SASL_STATUS_CLIENT_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           The client has indicated an authentication failure. The           possible actions are the same as for Server_Failed.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="SendingState" c:type="TpSendingState">
      <doc xml:space="preserve">&lt;![CDATA[         Enum indicating whether a contact is sending media.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_SENDING_STATE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           The contact is not sending media and has not been asked to           do so.         ]]&gt;</doc>
      </member>
      <member name="pending_send"
              value="1"
              c:identifier="TP_SENDING_STATE_PENDING_SEND">
        <doc xml:space="preserve">&lt;![CDATA[           The contact has been asked to start sending media.         ]]&gt;</doc>
      </member>
      <member name="sending" value="2" c:identifier="TP_SENDING_STATE_SENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The contact is sending media.         ]]&gt;</doc>
      </member>
      <member name="pending_stop_sending"
              value="3"
              c:identifier="TP_SENDING_STATE_PENDING_STOP_SENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The contact has been asked to stop sending media.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="ServicePointType" c:type="TpServicePointType">
      <doc xml:space="preserve">&lt;![CDATA[         The various types of service points a channel might connect to.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_SERVICE_POINT_TYPE_NONE">
        <doc xml:space="preserve">&lt;![CDATA[           The channel is not communicating with a service point, or it is not           known whether it is communicating with a service point (e.g. an           ordinary call).         ]]&gt;</doc>
      </member>
      <member name="emergency"
              value="1"
              c:identifier="TP_SERVICE_POINT_TYPE_EMERGENCY">
        <doc xml:space="preserve">&lt;![CDATA[           The service point is a generic emergency point.         ]]&gt;</doc>
      </member>
      <member name="counseling"
              value="2"
              c:identifier="TP_SERVICE_POINT_TYPE_COUNSELING">
        <doc xml:space="preserve">&lt;![CDATA[           The service point is some kind of counseling service (ie, mental health           or child-services counseling).         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="SignalledMessage"
           c:symbol-prefix="signalled_message"
           c:type="TpSignalledMessage"
           version="0.13.9"
           parent="Message"
           glib:type-name="TpSignalledMessage"
           glib:get-type="tp_signalled_message_get_type"
           glib:type-struct="SignalledMessageClass">
      <doc xml:space="preserve">Opaque structure representing a received message using the Telepathy
messages interface</doc>
      <function name="get_sender"
                c:identifier="tp_signalled_message_get_sender"
                version="0.13.9">
        <doc xml:space="preserve">Returns a #TpContact representing the sender of @message if known, %NULL
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the sender of the message</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSignalledMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
        </parameters>
      </function>
      <property name="sender"
                version="0.13.9"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpContact representing the sender of the message, if known, or %NULL
otherwise.</doc>
        <type name="Contact"/>
      </property>
    </class>
    <record name="SignalledMessageClass"
            c:type="TpSignalledMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="SignalledMessage">
    </record>
    <class name="SimpleApprover"
           c:symbol-prefix="simple_approver"
           c:type="TpSimpleApprover"
           version="0.11.5"
           parent="BaseClient"
           glib:type-name="TpSimpleApprover"
           glib:get-type="tp_simple_approver_get_type"
           glib:type-struct="SimpleApproverClass">
      <doc xml:space="preserve">Data structure representing a simple Approver implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_approver_new"
                   version="0.11.5"
                   deprecated="1">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleApprover instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_approver_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_simple_approver_new_with_am() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:space="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with @user_data as its argument when the #TpSimpleApprover
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_approver_new_with_am"
                   version="0.11.14">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:space="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:space="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with @user_data as its argument when the #TpSimpleApprover
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_approver_new_with_factory"
                   version="0.15.5">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">an #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:space="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with @user_data as its argument when the #TpSimpleApprover
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpSimpleApproverAddDispatchOperationImpl callback implementing the
AddDispatchOperation D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GDestroyNotify function called to free #TpSimpleApprover:user-data
when the #TpSimpleApprover is destroyed.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="user-data"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The user-data pointer passed to #TpSimpleApprover:callback.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleApproverPrivate" c:type="TpSimpleApproverPrivate*"/>
      </field>
    </class>
    <callback name="SimpleApproverAddDispatchOperationImpl"
              c:type="TpSimpleApproverAddDispatchOperationImpl"
              version="0.11.5">
      <doc xml:space="preserve">Signature of the implementation of the AddDispatchOperation method.

This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="approver" transfer-ownership="none">
          <doc xml:space="preserve">a #TpSimpleApprover instance</doc>
          <type name="SimpleApprover" c:type="TpSimpleApprover*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared
if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpChannel,
 all having %TP_CHANNEL_FEATURE_CORE prepared</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #TpChannelDispatchOperation or %NULL;
 the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAddDispatchOperationContext representing the context of this
 D-Bus call</doc>
          <type name="AddDispatchOperationContext"
                c:type="TpAddDispatchOperationContext*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="6">
          <doc xml:space="preserve">arbitrary user-supplied data passed to tp_simple_approver_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleApproverClass"
            c:type="TpSimpleApproverClass"
            glib:is-gtype-struct-for="SimpleApprover"
            version="0.11.5">
      <doc xml:space="preserve">The class of a #TpSimpleApprover.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="SimpleApproverPrivate"
            c:type="TpSimpleApproverPrivate"
            disguised="1">
    </record>
    <class name="SimpleClientFactory"
           c:symbol-prefix="simple_client_factory"
           c:type="TpSimpleClientFactory"
           version="0.15.5"
           parent="GObject.Object"
           glib:type-name="TpSimpleClientFactory"
           glib:get-type="tp_simple_client_factory_get_type"
           glib:type-struct="SimpleClientFactoryClass">
      <doc xml:space="preserve">Data structure representing a #TpSimpleClientFactory</doc>
      <constructor name="new"
                   c:identifier="tp_simple_client_factory_new"
                   version="0.15.5">
        <doc xml:space="preserve">Creates a new #TpSimpleClientFactory instance. If @dbus is %NULL,
tp_dbus_daemon_dup() will be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleClientFactory</doc>
          <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
        </return-value>
        <parameters>
          <parameter name="dbus"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #TpDBusDaemon, or %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="create_account" introspectable="0" throws="1">
        <return-value>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_channel" introspectable="0" throws="1">
        <return-value>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_connection" introspectable="0" throws="1">
        <return-value>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_contact" introspectable="0">
        <return-value>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_account_features"
                      invoker="dup_account_features"
                      version="0.15.5">
        <doc xml:space="preserve">Return a zero-terminated #GArray containing the #TpAccount features that
should be prepared on @account.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
 #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_channel_features"
                      invoker="dup_channel_features"
                      version="0.15.5">
        <doc xml:space="preserve">Return a zero-terminated #GArray containing the #TpChannel features that
should be prepared on @channel.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
 #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_connection_features"
                      invoker="dup_connection_features"
                      version="0.15.5">
        <doc xml:space="preserve">Return a zero-terminated #GArray containing the #TpConnection features that
should be prepared on @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
 #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_contact_features"
                      invoker="dup_contact_features"
                      version="0.15.5">
        <doc xml:space="preserve">Return a #GArray containing the #TpContactFeature that should be prepared on
all contacts of @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly
 allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ContactFeature"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_account_features"
              c:identifier="tp_simple_client_factory_add_account_features"
              version="0.15.5">
        <doc xml:space="preserve">Add @features to the desired features to be prepared on #TpAccount
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_account_features().

It is not necessary to add %TP_ACCOUNT_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpAccount
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an array
 of desired features, ending with 0; %NULL is equivalent to an array
 containing only 0</doc>
            <array c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs"
              c:identifier="tp_simple_client_factory_add_account_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_simple_client_factory_add_account_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with 0</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features"
              c:identifier="tp_simple_client_factory_add_channel_features"
              version="0.15.5">
        <doc xml:space="preserve">Add @features to the desired features to be prepared on #TpChannel
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_channel_features().

It is not necessary to add %TP_CHANNEL_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpChannel
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an array
 of desired features, ending with 0; %NULL is equivalent to an array
 containing only 0</doc>
            <array c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs"
              c:identifier="tp_simple_client_factory_add_channel_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_simple_client_factory_add_channel_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with 0</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features"
              c:identifier="tp_simple_client_factory_add_connection_features"
              version="0.15.5">
        <doc xml:space="preserve">Add @features to the desired features to be prepared on #TpConnection
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_connection_features().

It is not necessary to add %TP_CONNECTION_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpConnection
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an array
 of desired features, ending with 0; %NULL is equivalent to an array
 containing only 0</doc>
            <array c:type="const GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs"
              c:identifier="tp_simple_client_factory_add_connection_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_simple_client_factory_add_connection_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with 0</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_contact_features"
              c:identifier="tp_simple_client_factory_add_contact_features"
              version="0.15.5">
        <doc xml:space="preserve">Add @features to the desired features to be prepared on #TpContact
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_contact_features().

Note that these features will not be added to existing #TpContact
objects; the user must call tp_connection_upgrade_contacts() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:space="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an array of desired
 features (may be %NULL if @n_features is 0)</doc>
            <array length="0"
                   zero-terminated="0"
                   c:type="const TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_contact_features_varargs"
              c:identifier="tp_simple_client_factory_add_contact_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:space="preserve">The same as tp_simple_client_factory_add_contact_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the first feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the second and subsequent features, if any, ending with
 %TP_CONTACT_FEATURE_INVALID</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_account_features"
              c:identifier="tp_simple_client_factory_dup_account_features"
              version="0.15.5">
        <doc xml:space="preserve">Return a zero-terminated #GArray containing the #TpAccount features that
should be prepared on @account.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
 #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_channel_features"
              c:identifier="tp_simple_client_factory_dup_channel_features"
              version="0.15.5">
        <doc xml:space="preserve">Return a zero-terminated #GArray containing the #TpChannel features that
should be prepared on @channel.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
 #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_connection_features"
              c:identifier="tp_simple_client_factory_dup_connection_features"
              version="0.15.5">
        <doc xml:space="preserve">Return a zero-terminated #GArray containing the #TpConnection features that
should be prepared on @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
 #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_features"
              c:identifier="tp_simple_client_factory_dup_contact_features"
              version="0.15.5">
        <doc xml:space="preserve">Return a #GArray containing the #TpContactFeature that should be prepared on
all contacts of @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly
 allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ContactFeature"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_account"
              c:identifier="tp_simple_client_factory_ensure_account"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Returns a #TpAccount proxy for the account at @object_path. The returned
#TpAccount is cached; the same #TpAccount object will be returned by this
function repeatedly, as long as at least one reference exists.

Note that the returned #TpAccount is not guaranteed to be ready; the caller
is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_account_features()).

This function is rather low-level. tp_account_manager_dup_valid_accounts()
and #TpAccountManager::validity-changed are more appropriate for most
applications.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to a #TpAccount;
 see tp_account_new().</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of an account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the account, or %NULL.</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel"
              c:identifier="tp_simple_client_factory_ensure_channel"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Returns a #TpChannel proxy for the channel at @object_path on @connection.
The returned #TpChannel is cached; the same #TpChannel object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpChannel is not guaranteed to be ready; the
caller is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_channel_features()).

This function is rather low-level.
#TpAccountChannelRequest and #TpBaseClient are more appropriate ways
to obtain channels for most applications.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to a #TpChannel;
 see tp_channel_new_from_properties().</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection whose #TpProxy:factory is this object</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of a channel on @connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the channel</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_connection"
              c:identifier="tp_simple_client_factory_ensure_connection"
              version="0.15.5"
              throws="1">
        <doc xml:space="preserve">Returns a #TpConnection proxy for the connection at @object_path.
The returned #TpConnection is cached; the same #TpConnection object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpConnection is not guaranteed to be ready; the
caller is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_connection_features()).

This function is rather low-level. #TpAccount:connection is more
appropriate for most applications.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to a #TpConnection;
 see tp_connection_new().</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of a connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the connection.</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact"
              c:identifier="tp_simple_client_factory_ensure_contact"
              version="0.15.5">
        <doc xml:space="preserve">Returns a #TpContact representing @identifier (and @handle) on @connection.
The returned #TpContact is cached; the same #TpContact object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpContact is not guaranteed to be ready; the caller
is responsible for calling tp_connection_upgrade_contacts() with the desired
features (as given by tp_simple_client_factory_dup_contact_features()).

For this function to work properly, tp_connection_has_immortal_handles()
must return %TRUE for @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to a #TpContact.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection whose #TpProxy:factory is this object</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a #TpHandle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">a string representing the contact's identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact_by_id_async"
              c:identifier="tp_simple_client_factory_ensure_contact_by_id_async"
              version="0.19.1">
        <doc xml:space="preserve">Same as tp_connection_dup_contact_by_id_async(), but prepare the
contact with all features previously passed to
tp_simple_client_factory_add_contact_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">a string representing the contact's identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact_by_id_finish"
              c:identifier="tp_simple_client_factory_ensure_contact_by_id_finish"
              version="0.19.1"
              throws="1">
        <doc xml:space="preserve">Finishes tp_simple_client_factory_ensure_contact_by_id_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TpContact or %NULL on error.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_simple_client_factory_get_dbus_daemon"
              version="0.15.5">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the #TpSimpleClientFactory:dbus-daemon
 property</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_async"
              c:identifier="tp_simple_client_factory_upgrade_contacts_async"
              version="0.19.1">
        <doc xml:space="preserve">Same as tp_connection_upgrade_contacts_async(), but prepare contacts with all
features previously passed to
tp_simple_client_factory_add_contact_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection whose #TpProxy:factory is this object</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:space="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #TpContact objects
 associated with @self</doc>
            <array length="1" zero-terminated="0" c:type="TpContact* const*">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_finish"
              c:identifier="tp_simple_client_factory_upgrade_contacts_finish"
              version="0.19.1"
              throws="1">
        <doc xml:space="preserve">Finishes tp_simple_client_factory_upgrade_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contacts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
 a location to set a #GPtrArray of upgraded #TpContact, or %NULL.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <property name="dbus-daemon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus daemon for this object.</doc>
        <type name="DBusDaemon"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleClientFactoryPrivate"
              c:type="TpSimpleClientFactoryPrivate*"/>
      </field>
    </class>
    <record name="SimpleClientFactoryClass"
            c:type="TpSimpleClientFactoryClass"
            glib:is-gtype-struct-for="SimpleClientFactory"
            version="0.15.5">
      <doc xml:space="preserve">The class structure for #TpSimpleClientFactory.

#TpSimpleClientFactory maintains a cache of previously-constructed proxy
objects, so the implementations of @create_account,
@create_connection, @create_channel, and @create_contact may assume that a
new object should be created when they are called. The default
implementations create unadorned instances of the relevant classes;
subclasses of the factory may choose to create more interesting proxy
subclasses.

The default implementation of @dup_channel_features returns
#TP_CHANNEL_FEATURE_CORE, plus all features passed to
tp_simple_client_factory_add_channel_features() by the application.
Subclasses may override this method to prepare more interesting features
from subclasses of #TpChannel, for instance. The default implementations of
the other &lt;function&gt;dup_x_features&lt;/function&gt; methods behave similarly.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="create_account" introspectable="0">
        <callback name="create_account" introspectable="0" throws="1">
          <return-value>
            <type name="Account" c:type="TpAccount*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="const GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_account_features">
        <callback name="dup_account_features">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated
 #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">a #TpAccount</doc>
              <type name="Account" c:type="TpAccount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_connection" introspectable="0">
        <callback name="create_connection" introspectable="0" throws="1">
          <return-value>
            <type name="Connection" c:type="TpConnection*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="const GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_connection_features">
        <callback name="dup_connection_features">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated
 #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #TpConnection</doc>
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_channel" introspectable="0">
        <callback name="create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="const GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_channel_features">
        <callback name="dup_channel_features">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated
 #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <doc xml:space="preserve">a #TpChannel</doc>
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_contact" introspectable="0">
        <callback name="create_contact" introspectable="0">
          <return-value>
            <type name="Contact" c:type="TpContact*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <type name="Handle" c:type="TpHandle"/>
            </parameter>
            <parameter name="identifier" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_contact_features">
        <callback name="dup_contact_features">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly
 allocated #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="ContactFeature"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #TpSimpleClientFactory object</doc>
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #TpConnection</doc>
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="20">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="SimpleClientFactoryPrivate"
            c:type="TpSimpleClientFactoryPrivate"
            disguised="1">
    </record>
    <class name="SimpleHandler"
           c:symbol-prefix="simple_handler"
           c:type="TpSimpleHandler"
           version="0.11.6"
           parent="BaseClient"
           glib:type-name="TpSimpleHandler"
           glib:get-type="tp_simple_handler_get_type"
           glib:type-struct="SimpleHandlerClass">
      <doc xml:space="preserve">Data structure representing a simple Handler implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_handler_new"
                   version="0.11.6"
                   deprecated="1">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleHandler instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_handler_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_simple_handler_new_with_am() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Handler.BypassApproval D-Bus property
(see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:space="preserve">whether this handler should implement Requests (see
tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:space="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with @user_data as its argument when the #TpSimpleHandler
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_handler_new_with_am"
                   version="0.11.14">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:space="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Handler.BypassApproval D-Bus property
(see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:space="preserve">whether this handler should implement Requests (see
tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:space="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with @user_data as its argument when the #TpSimpleHandler
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_handler_new_with_factory"
                   version="0.15.5">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Handler.BypassApproval D-Bus property
(see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:space="preserve">whether this handler should implement Requests (see
tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:space="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with @user_data as its argument when the #TpSimpleHandler
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="bypass-approval"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The value of the Handler.BypassApproval D-Bus property.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="callback"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpSimpleHandlerHandleChannelsImpl callback implementing the
HandleChannels D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GDestroyNotify function called to free #TpSimpleHandler:user-data
when the #TpSimpleHandler is destroyed.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="requests"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the Handler will implement the Requests interface</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="user-data"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The user-data pointer passed to #TpSimpleHandler:callback.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleHandlerPrivate" c:type="TpSimpleHandlerPrivate*"/>
      </field>
    </class>
    <record name="SimpleHandlerClass"
            c:type="TpSimpleHandlerClass"
            glib:is-gtype-struct-for="SimpleHandler"
            version="0.11.6">
      <doc xml:space="preserve">The class of a #TpSimpleHandler.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleHandlerHandleChannelsImpl"
              c:type="TpSimpleHandlerHandleChannelsImpl"
              version="0.11.6">
      <doc xml:space="preserve">Signature of the implementation of the HandleChannels method.

This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handler" transfer-ownership="none">
          <doc xml:space="preserve">a #TpSimpleHandler instance</doc>
          <type name="SimpleHandler" c:type="TpSimpleHandler*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared
if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpChannel,
 all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
#TpChannelRequest having their object-path defined but are not guaranteed
to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:space="preserve">the time at which user action occurred, or one of the
 special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
 %TP_USER_ACTION_TIME_CURRENT_TIME
 (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #TpHandleChannelsContext representing the context of this
 D-Bus call</doc>
          <type name="HandleChannelsContext"
                c:type="TpHandleChannelsContext*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="7">
          <doc xml:space="preserve">arbitrary user-supplied data passed to tp_simple_handler_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleHandlerPrivate"
            c:type="TpSimpleHandlerPrivate"
            disguised="1">
    </record>
    <class name="SimpleObserver"
           c:symbol-prefix="simple_observer"
           c:type="TpSimpleObserver"
           version="0.11.5"
           parent="BaseClient"
           glib:type-name="TpSimpleObserver"
           glib:get-type="tp_simple_observer_get_type"
           glib:type-struct="SimpleObserverClass">
      <doc xml:space="preserve">Data structure representing a simple Observer implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_observer_new"
                   version="0.11.5"
                   deprecated="1">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleObserver instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_observer_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <doc-deprecated xml:space="preserve">New code should use tp_simple_observer_new_with_am() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:space="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with the user_data as argument, when the #TpSimpleObserver
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_observer_new_with_am"
                   version="0.11.14">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:space="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with the user_data as argument, when the #TpSimpleObserver
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_observer_new_with_factory"
                   version="0.15.5">
        <doc xml:space="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:space="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:space="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:space="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called with the user_data as argument, when the #TpSimpleObserver
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The TpSimpleObserverObserveChannelsImpl callback implementing the
ObserveChannels D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GDestroyNotify function called to free the user-data pointer when
the #TpSimpleObserver is destroyed.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="recover"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The value of the Observer.Recover D-Bus property.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="user-data"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The user-data pointer passed to the callback implementing the
ObserveChannels D-Bus method.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleObserverPrivate" c:type="TpSimpleObserverPrivate*"/>
      </field>
    </class>
    <record name="SimpleObserverClass"
            c:type="TpSimpleObserverClass"
            glib:is-gtype-struct-for="SimpleObserver"
            version="0.11.5">
      <doc xml:space="preserve">The class of a #TpSimpleObserver.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleObserverObserveChannelsImpl"
              c:type="TpSimpleObserverObserveChannelsImpl"
              version="0.11.5">
      <doc xml:space="preserve">Signature of the implementation of the ObserveChannels method.

This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="observer" transfer-ownership="none">
          <doc xml:space="preserve">a #TpSimpleObserver instance</doc>
          <type name="SimpleObserver" c:type="TpSimpleObserver*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared
if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpChannel,
 all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #TpChannelDispatchOperation or %NULL;
 the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
 #TpChannelRequest, all having their object-path defined but are not
 guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #TpObserveChannelsContext representing the context of this
 D-Bus call</doc>
          <type name="ObserveChannelsContext"
                c:type="TpObserveChannelsContext*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="7">
          <doc xml:space="preserve">arbitrary user-supplied data passed to tp_simple_observer_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleObserverPrivate"
            c:type="TpSimpleObserverPrivate"
            disguised="1">
    </record>
    <enumeration name="SocketAccessControl" c:type="TpSocketAccessControl">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="localhost"
              value="0"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_LOCALHOST">
        <doc xml:space="preserve">&lt;![CDATA[           The IP or Unix socket can be accessed by any local user (e.g.             a Unix socket that accepts all local connections, or an IP socket             listening on 127.0.0.1 (or ::1) or rejecting connections not from             that address). The associated variant must be ignored.            For a D-Bus tube, this means that the "same user" access             control typically provided by default in D-Bus implementations             SHOULD be disabled. If the socket is only available to local users             (e.g. a Unix socket, an IPv4 socket bound to 127.0.0.1, or an             IPv6 socket bound to ::1), the ANONYMOUS             authentication mechanism MAY be enabled.         ]]&gt;</doc>
      </member>
      <member name="port"
              value="1"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_PORT">
        <doc xml:space="preserve">&lt;![CDATA[           May only be used on IP sockets, and only for Stream tubes.                      The associated variant must contain           a struct Socket_Address_IPv4 (or Socket_Address_IPv6)           containing the string form of an IP address of the appropriate           version, and a port number. The socket can only be accessed if the           connecting process has that address and port number; all other           connections will be rejected.         ]]&gt;</doc>
      </member>
      <member name="netmask"
              value="2"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_NETMASK">
        <doc xml:space="preserve">&lt;![CDATA[           May only be used on IP sockets. The associated variant must contain           a struct Socket_Netmask_IPv4 (or Socket_Netmask_IPv6) with           signature (sy), containing the string form of an           IP address of the appropriate version, and a prefix length "n".           The socket can only be accessed if the first n bits of the           connecting address match the first n bits of the given address.         ]]&gt;</doc>
      </member>
      <member name="credentials"
              value="3"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_CREDENTIALS">
        <doc xml:space="preserve">&lt;![CDATA[           The high-level meaning of this access control type is that             only the same user (e.g. same numeric Unix uid) is allowed to             interact with the tube. Exactly how this is achieved varies by             channel type.            For StreamTube channels, this access control type             may only be used on UNIX sockets.             The connecting process must send a byte when             it first connects, which is not considered to be part of the data             stream. If the operating system uses sendmsg() with SCM_CREDS or             SCM_CREDENTIALS to pass credentials over sockets, the connecting             process must do so if possible; if not, it must still send the             byte, without any attached credentials. (This mechanism is             very similar to the first byte of a D-Bus connection, except that             in D-Bus the byte is always zero, whereas in Tubes it can be             nonzero.)            For DBusTube channels, this access control type             may be used on any type of socket, and there is no extra byte             added by Telepathy at the beginning of the stream: all bytes in             the stream are part of the D-Bus tube connection. The connecting             process should prove its identity via any of the SASL             authentication mechanisms usually used for D-Bus (in typical             D-Bus implementations this involves either sending and receiving             credentials as above, or demonstrating the ability to write to a             file in the user's home directory).            In either case, the listening process will disconnect the             connection unless it can determine by OS-specific means that             the connecting process has the same user ID as the listening             process.            In either tube type, the associated variant must be ignored.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="SocketAddressType" c:type="TpSocketAddressType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unix" value="0" c:identifier="TP_SOCKET_ADDRESS_TYPE_UNIX">
        <doc xml:space="preserve">&lt;![CDATA[           A Unix socket. The address variant contains a byte-array, signature 'ay',           containing the path of the socket.         ]]&gt;</doc>
      </member>
      <member name="abstract_unix"
              value="1"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX">
        <doc xml:space="preserve">&lt;![CDATA[           An abstract Unix socket. The address variant contains a byte-array,           signature 'ay', containing the path of the socket including the           leading null byte.         ]]&gt;</doc>
      </member>
      <member name="ipv4" value="2" c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV4">
        <doc xml:space="preserve">&lt;![CDATA[           An IPv4 socket. The address variant contains a Socket_Address_IPv4,           i.e. a structure with signature (sq)           in which the string is an IPv4 dotted-quad address literal           (and must not be a DNS name), while the 16-bit unsigned integer is           the port number.         ]]&gt;</doc>
      </member>
      <member name="ipv6" value="3" c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV6">
        <doc xml:space="preserve">&lt;![CDATA[           An IPv6 socket. The address variant contains a Socket_Address_IPv6,           i.e. a structure with signature (sq)           in which the string is an IPv6 address literal as specified in           RFC2373 (and must not be a DNS name), while the 16-bit unsigned           integer is the port number.         ]]&gt;</doc>
      </member>
    </enumeration>
    <bitfield name="StorageRestrictionFlags"
              c:type="TpStorageRestrictionFlags">
      <doc xml:space="preserve">&lt;![CDATA[         Flags indicating restrictions imposed on an Account by its storage         method.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="parameters"
              value="1"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PARAMETERS">
        <doc xml:space="preserve">&lt;![CDATA[           The account's Parameters property can't be changed by calling           UpdateParameters.         ]]&gt;</doc>
      </member>
      <member name="enabled"
              value="2"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_ENABLED">
        <doc xml:space="preserve">&lt;![CDATA[           The account can't be enabled/disabled by setting the Enabled property.         ]]&gt;</doc>
      </member>
      <member name="presence"
              value="4"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PRESENCE">
        <doc xml:space="preserve">&lt;![CDATA[           The account's presence can't be changed by setting the RequestedPresence and AutomaticPresence properties.         ]]&gt;</doc>
      </member>
      <member name="service"
              value="8"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_SERVICE">
        <doc xml:space="preserve">&lt;![CDATA[           The account's Service           property cannot be changed.         ]]&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="StreamComponent" c:type="TpStreamComponent">
      <doc xml:space="preserve">&lt;![CDATA[         Media streams can use more than one UDP socket: one for RTP (data)         and one for RTCP (control). Most of the time, they are adjacent         to each other, but some protocols (xmpp) signal each port separately.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_STREAM_COMPONENT_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           The stream transport type is unknown or not applicable           (should not appear over dbus).         ]]&gt;</doc>
      </member>
      <member name="data" value="1" c:identifier="TP_STREAM_COMPONENT_DATA">
        <doc xml:space="preserve">&lt;![CDATA[           This is the high-traffic data socket, containing the audio/video           data for the stream.         ]]&gt;</doc>
      </member>
      <member name="control"
              value="2"
              c:identifier="TP_STREAM_COMPONENT_CONTROL">
        <doc xml:space="preserve">&lt;![CDATA[           This is the low-traffic control socket, usually containing feedback           about packet loss etc.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="StreamEndpointState" c:type="TpStreamEndpointState">
      <doc xml:space="preserve">&lt;![CDATA[         Represents the state of ICE negotiation for a single component of a         stream to an endpoint.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="connecting"
              value="0"
              c:identifier="TP_STREAM_ENDPOINT_STATE_CONNECTING">
        <doc xml:space="preserve">&lt;![CDATA[           Candidate gathering and connectivity checks are in progress.         ]]&gt;</doc>
      </member>
      <member name="provisionally_connected"
              value="1"
              c:identifier="TP_STREAM_ENDPOINT_STATE_PROVISIONALLY_CONNECTED">
        <doc xml:space="preserve">&lt;![CDATA[           The streaming implementation has found at least one working           candidate pair. It is possible to send media at this point, but the           controlling side has yet to negotiate the final candidates for use           in this call.         ]]&gt;</doc>
      </member>
      <member name="fully_connected"
              value="2"
              c:identifier="TP_STREAM_ENDPOINT_STATE_FULLY_CONNECTED">
        <doc xml:space="preserve">&lt;![CDATA[           This component of the stream is connected, and an updated offer has           been sent and accepted (finalising the candidates to be used for the           call). This should be set by the CM in response to           AcceptSelectedCandidatePair.         ]]&gt;</doc>
      </member>
      <member name="exhausted_candidates"
              value="3"
              c:identifier="TP_STREAM_ENDPOINT_STATE_EXHAUSTED_CANDIDATES">
        <doc xml:space="preserve">&lt;![CDATA[           The streaming implementation has tried connecting to all of the           available candidates and none of them have connected. This is           distinct from Failed, because the CM might be able to provide more           candidates later (more likely in XMPP than SIP).         ]]&gt;</doc>
      </member>
      <member name="failed"
              value="4"
              c:identifier="TP_STREAM_ENDPOINT_STATE_FAILED">
        <doc xml:space="preserve">&lt;![CDATA[           The CM and streaming implementation are in agreement that it is           impossible to connect to this endpoint. This value should only be           set by the CM.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="StreamFlowState" c:type="TpStreamFlowState">
      <doc xml:space="preserve">&lt;![CDATA[         The type of SendingState         and ReceivingState.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="stopped"
              value="0"
              c:identifier="TP_STREAM_FLOW_STATE_STOPPED">
        <doc xml:space="preserve">&lt;![CDATA[           No data is flowing (or expected to be flowing) at this time.         ]]&gt;</doc>
      </member>
      <member name="pending_start"
              value="1"
              c:identifier="TP_STREAM_FLOW_STATE_PENDING_START">
        <doc xml:space="preserve">&lt;![CDATA[           The streaming implementation has been told to start or receiving,           but has not yet indicated that it is doing so.         ]]&gt;</doc>
      </member>
      <member name="pending_stop"
              value="2"
              c:identifier="TP_STREAM_FLOW_STATE_PENDING_STOP">
        <doc xml:space="preserve">&lt;![CDATA[           The streaming implementation has been told to stop sending or           receiving data, but it has not yet indicated that it has done so.         ]]&gt;</doc>
      </member>
      <member name="started"
              value="3"
              c:identifier="TP_STREAM_FLOW_STATE_STARTED">
        <doc xml:space="preserve">&lt;![CDATA[           The streaming implementation is successfully sending or receiving           data, and everything is going swimmingly.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="StreamTransportType" c:type="TpStreamTransportType">
      <doc xml:space="preserve">&lt;![CDATA[         A transport that can be used for streaming.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           The stream transport type is unknown or not applicable           (for streams that do not have a configurable transport).         ]]&gt;</doc>
      </member>
      <member name="raw_udp"
              value="1"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_RAW_UDP">
        <doc xml:space="preserve">&lt;![CDATA[           Raw UDP, with or without STUN. All streaming clients are assumed to           support this transport, so there is no handler capability token for           it in the Call1 interface.           [This corresponds to "none" or "stun" in the old Media.StreamHandler           interface.]         ]]&gt;</doc>
      </member>
      <member name="ice" value="2" c:identifier="TP_STREAM_TRANSPORT_TYPE_ICE">
        <doc xml:space="preserve">&lt;![CDATA[           Interactive Connectivity Establishment, as defined by RFC           5245. Note that this value covers ICE-UDP only.           [This corresponds to "ice-udp" in the old           Media.StreamHandler interface.]         ]]&gt;</doc>
      </member>
      <member name="gtalk_p2p"
              value="3"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_GTALK_P2P">
        <doc xml:space="preserve">&lt;![CDATA[           Google Talk peer-to-peer connectivity establishment, as implemented           by libjingle 0.3.           [This corresponds to "gtalk-p2p" in the old Media.StreamHandler           interface.]         ]]&gt;</doc>
      </member>
      <member name="wlm_2009"
              value="4"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_WLM_2009">
        <doc xml:space="preserve">&lt;![CDATA[           The transport used by Windows Live Messenger 2009 or later, which           resembles ICE draft 19.           [This corresponds to "wlm-2009" in the old Media.StreamHandler           interface.]         ]]&gt;</doc>
      </member>
      <member name="shm" value="5" c:identifier="TP_STREAM_TRANSPORT_TYPE_SHM">
        <doc xml:space="preserve">&lt;![CDATA[           Shared memory transport, as implemented by the GStreamer           shmsrc and shmsink plugins.         ]]&gt;</doc>
      </member>
      <member name="multicast"
              value="6"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_MULTICAST">
        <doc xml:space="preserve">&lt;![CDATA[           Multicast transport.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="StreamTubeChannel"
           c:symbol-prefix="stream_tube_channel"
           c:type="TpStreamTubeChannel"
           version="0.13.2"
           parent="Channel"
           glib:type-name="TpStreamTubeChannel"
           glib:get-type="tp_stream_tube_channel_get_type"
           glib:type-struct="StreamTubeChannelClass">
      <doc xml:space="preserve">Data structure representing a #TpStreamTubeChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_stream_tube_channel_new"
                   version="0.13.2"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">Creates a new #TpStreamTubeChannel proxy object from the provided path and
properties. Most developers will not need to use this function; use
#TpAutomaticProxyFactory to automatically create #TpStreamTubeChannel proxy
objects.</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_channel() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-created #TpStreamTubeChannel proxy</doc>
          <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the channel,
 as signalled by the NewChannel D-Bus signal or returned by the
 CreateChannel and EnsureChannel D-Bus methods: a mapping from
 strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <method name="accept_async"
              c:identifier="tp_stream_tube_channel_accept_async"
              version="0.13.2">
        <doc xml:space="preserve">Accept an incoming stream tube. When the tube has been accepted, @callback
will be called. You can then call tp_stream_tube_channel_accept_finish()
to get a #TpStreamTubeConnection connected to the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an incoming #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the tube has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_stream_tube_channel_accept_finish"
              version="0.13.2"
              throws="1">
        <doc xml:space="preserve">Finishes accepting an incoming stream tube. The returned
#TpStreamTubeConnection can then be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #TpStreamTubeConnection</doc>
          <type name="StreamTubeConnection" c:type="TpStreamTubeConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_parameters_vardict"
              c:identifier="tp_stream_tube_channel_dup_parameters_vardict"
              version="0.19.10">
        <doc xml:space="preserve">Return the parameters of the dbus-tube channel in a variant of
type %G_VARIANT_TYPE_VARDICT whose keys are strings representing
parameter names and values are variants representing corresponding
parameter values set by the offerer when offering this channel.

The GVariant returned is %NULL if this is an outgoing tube that has not
yet been offered or the parameters property has not been set.

Use g_variant_lookup(), g_variant_lookup_value(), or tp_vardict_get_uint32()
and similar functions for convenient access to the values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to a #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameters"
              c:identifier="tp_stream_tube_channel_get_parameters"
              version="0.13.2"
              introspectable="0">
        <doc xml:space="preserve">Return the #TpStreamTubeChannel:parameters property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
the value of #TpStreamTubeChannel:parameters</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="tp_stream_tube_channel_get_service"
              version="0.13.2">
        <doc xml:space="preserve">Return the #TpStreamTubeChannel:service property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpStreamTubeChannel:service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offer_async"
              c:identifier="tp_stream_tube_channel_offer_async"
              version="0.13.2">
        <doc xml:space="preserve">Offer an outgoing stream tube. When the tube has been offered, @callback
will be called. You can then call tp_stream_tube_channel_offer_finish()
to get the result of the operation.

You have to connect to the #TpStreamTubeChannel::incoming signal to get a
#TpStreamTubeConnection each time a contact establishes a connection to
the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an outgoing #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">parameters of the tube, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="offer_finish"
              c:identifier="tp_stream_tube_channel_offer_finish"
              version="0.13.2"
              throws="1">
        <doc xml:space="preserve">Finishes offering an outgoing stream tube.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE when a Tube has been successfully offered; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeChannel</doc>
            <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="parameters"
                version="0.13.2"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">A string to #GValue #GHashTable representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.

In high-level language bindings, use
#TpStreamTubeChannel:parameters-vardict or
tp_stream_tube_channel_dup_parameters_vardict() to get the same
information in a more convenient format.</doc>
        <type/>
      </property>
      <property name="parameters-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:space="preserve">A %G_VARIANT_TYPE_VARDICT representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="service" version="0.13.2" transfer-ownership="none">
        <doc xml:space="preserve">A string representing the service name that will be used over the tube.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="StreamTubeChannelPrivate"
              c:type="TpStreamTubeChannelPrivate*"/>
      </field>
      <glib:signal name="incoming" when="last">
        <doc xml:space="preserve">The ::incoming signal is emitted on offered Tubes when a new incoming
connection is made from a remote user (one accepting the Tube).

Consumers of this signal must take their own references to
@tube_connection</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tube_connection" transfer-ownership="none">
            <doc xml:space="preserve">the #TpStreamTubeConnection for the connection</doc>
            <type name="StreamTubeConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTubeChannelClass"
            c:type="TpStreamTubeChannelClass"
            glib:is-gtype-struct-for="StreamTubeChannel"
            version="0.13.2">
      <doc xml:space="preserve">The class of a #TpStreamTubeChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="StreamTubeChannelPrivate"
            c:type="TpStreamTubeChannelPrivate"
            disguised="1">
    </record>
    <class name="StreamTubeConnection"
           c:symbol-prefix="stream_tube_connection"
           c:type="TpStreamTubeConnection"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpStreamTubeConnection"
           glib:get-type="tp_stream_tube_connection_get_type"
           glib:type-struct="StreamTubeConnectionClass">
      <doc xml:space="preserve">Data structure representing a connection on a #TpStreamTubeChannel.</doc>
      <method name="get_channel"
              c:identifier="tp_stream_tube_connection_get_channel"
              version="0.13.2">
        <doc xml:space="preserve">Return the #TpStreamTubeConnection:channel property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpStreamTubeConnection:channel</doc>
          <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeConnection</doc>
            <type name="StreamTubeConnection"
                  c:type="TpStreamTubeConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contact"
              c:identifier="tp_stream_tube_connection_get_contact"
              version="0.13.2">
        <doc xml:space="preserve">Return the #TpStreamTubeConnection:contact property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpStreamTubeConnection:contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeConnection</doc>
            <type name="StreamTubeConnection"
                  c:type="TpStreamTubeConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_socket_connection"
              c:identifier="tp_stream_tube_connection_get_socket_connection"
              version="0.13.2">
        <doc xml:space="preserve">Return the #TpStreamTubeConnection:socket-connection property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpStreamTubeConnection:socket-connection</doc>
          <type name="Gio.SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpStreamTubeConnection</doc>
            <type name="StreamTubeConnection"
                  c:type="TpStreamTubeConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="channel"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpStreamTubeChannel channel associated with this connection

This property can't be %NULL.</doc>
        <type name="StreamTubeChannel"/>
      </property>
      <property name="contact"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #TpContact with who we are exchanging data through this tube, or
%NULL if we can't safely identify the contact.

If not %NULL, the #TpContact objects is guaranteed to have all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <type name="Contact"/>
      </property>
      <property name="socket-connection"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GSocketConnection used to transfer data through this connection.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Gio.SocketConnection"/>
      </property>
      <glib:signal name="closed" when="last" version="0.13.2">
        <doc xml:space="preserve">The ::closed signal is emitted when the connection manager reports that
a tube connection has been closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError representing the error reported by the
connection manager</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTubeConnectionClass"
            c:type="TpStreamTubeConnectionClass"
            disguised="1"
            glib:is-gtype-struct-for="StreamTubeConnection"
            version="0.13.2">
      <doc xml:space="preserve">The class of a #TpStreamTubeConnection.</doc>
    </record>
    <record name="StreamTubeConnectionPrivate"
            c:type="TpStreamTubeConnectionPrivate"
            disguised="1">
    </record>
    <enumeration name="SubscriptionState" c:type="TpSubscriptionState">
      <doc xml:space="preserve">&lt;![CDATA[         An enumeration indicating whether presence subscription is denied,           denied but pending permission, or allowed. The exact semantics           vary according to where this type is used: see the           subscribe and           publish contact attributes for           details.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_SUBSCRIPTION_STATE_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[The presence subscription state is           unknown.]]&gt;</doc>
      </member>
      <member name="no" value="1" c:identifier="TP_SUBSCRIPTION_STATE_NO">
        <doc xml:space="preserve">&lt;![CDATA[Presence information cannot be seen, and either the           subscription state Removed_Remotely does not apply, or it is           not known whether that state applies.         ]]&gt;</doc>
      </member>
      <member name="removed_remotely"
              value="2"
              c:identifier="TP_SUBSCRIPTION_STATE_REMOVED_REMOTELY">
        <doc xml:space="preserve">&lt;![CDATA[Presence information cannot be seen because the           remote contact took action: either the local user's request to           see the remote contact's presence was denied, or the remote           contact requested to see the local user's presence but then           cancelled their request.]]&gt;</doc>
      </member>
      <member name="ask" value="3" c:identifier="TP_SUBSCRIPTION_STATE_ASK">
        <doc xml:space="preserve">&lt;![CDATA[Presence information cannot be seen. Permission           to see presence information has been requested, and the request           has not yet been declined or accepted.]]&gt;</doc>
      </member>
      <member name="yes" value="4" c:identifier="TP_SUBSCRIPTION_STATE_YES">
        <doc xml:space="preserve">&lt;![CDATA[Presence information can be seen.]]&gt;</doc>
      </member>
    </enumeration>
    <class name="TLSCertificate"
           c:symbol-prefix="tls_certificate"
           c:type="TpTLSCertificate"
           version="0.19.0"
           parent="Proxy"
           glib:type-name="TpTLSCertificate"
           glib:get-type="tp_tls_certificate_get_type"
           glib:type-struct="TLSCertificateClass">
      <doc xml:space="preserve">A #TpProxy subclass representing a server or peer's TLS certificate
being presented for acceptance/rejection.</doc>
      <constructor name="new"
                   c:identifier="tp_tls_certificate_new"
                   version="0.19.0"
                   throws="1">
        <doc xml:space="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new TLS certificate proxy. Prepare the
 feature %TP_TLS_CERTIFICATE_FEATURE_CORE to make it useful.</doc>
          <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="conn_or_chan" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection or #TpChannel parent for this object, whose
 invalidation will also result in invalidation of the returned object</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of this TLS certificate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_tls_certificate_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_tls_certificate_init_known_interfaces"
                version="0.19.0">
        <doc xml:space="preserve">Ensure that the known interfaces for TpTLSCertificate have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_TLS_CERTIFICATE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="accept_async"
              c:identifier="tp_tls_certificate_accept_async"
              version="0.19.0">
        <doc xml:space="preserve">Accept this certificate, asynchronously. In or after @callback,
you may call tp_tls_certificate_accept_finish() to check the result.

#GObject::notify::state will also be emitted when the connection manager
signals that the certificate has been accepted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">called on success or failure</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_tls_certificate_accept_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Check the result of tp_tls_certificate_accept_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if acceptance was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback by
 tp_tls_certificate_accept_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_rejection"
              c:identifier="tp_tls_certificate_add_rejection"
              version="0.19.0">
        <doc xml:space="preserve">Add a pending reason for rejection. The first call to this method is
considered "most important". After calling this method as many times
as are required, call tp_tls_certificate_reject_async() to reject the
certificate.

If @details is a floating reference (see g_variant_ref_sink()),
ownership of @details is taken by this function. This means
you can pass the result of g_variant_new() or g_variant_new_parsed()
directly to this function without additional reference-count management.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the reason for rejection</doc>
            <type name="TLSCertificateRejectReason"
                  c:type="TpTLSCertificateRejectReason"/>
          </parameter>
          <parameter name="dbus_error" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus error name such as %TP_ERROR_STR_CERT_REVOKED, or
 %NULL to derive one from @reason</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="details"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a variant of type
%G_VARIANT_TYPE_VARDICT containing the details of the rejection, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cert_data"
              c:identifier="tp_tls_certificate_get_cert_data"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificate:cert-data property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTLSCertificate:cert-data property</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GLib.Bytes"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cert_type"
              c:identifier="tp_tls_certificate_get_cert_type"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificate:cert-type property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTLSCertificate:cert-type property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nth_rejection"
              c:identifier="tp_tls_certificate_get_nth_rejection"
              version="0.19.0">
        <doc xml:space="preserve">If this certificate has been rejected and @n is less than the number of
rejection reasons, return a #TpTLSCertificateRejection representing the
@n&lt;!----&gt;th rejection reason (starting from 0).

With @n == 0 this is equivalent to tp_tls_certificate_get_rejection().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #TpTLSCertificateRejection, or %NULL</doc>
          <type name="TLSCertificateRejection"
                c:type="TpTLSCertificateRejection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the rejection reason to return; if 0, return the same thing as
 tp_tls_certificate_get_detailed_rejection()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rejection"
              c:identifier="tp_tls_certificate_get_rejection"
              version="0.19.0">
        <doc xml:space="preserve">If this certificate has been rejected, return a #TpTLSCertificateRejection
indicating the first rejection reason (by convention,
the most important).

If you want to list all the things that are wrong with the certificate
(for instance, it might be self-signed and also have expired)
you can call tp_tls_certificate_get_nth_rejection(), increasing @n until
it returns %NULL.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #TpTLSCertificateRejection, or %NULL</doc>
          <type name="TLSCertificateRejection"
                c:type="TpTLSCertificateRejection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="tp_tls_certificate_get_state"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificate:state property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTLSCertificate:state property</doc>
          <type name="TLSCertificateState" c:type="TpTLSCertificateState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reject_async"
              c:identifier="tp_tls_certificate_reject_async"
              version="0.19.0">
        <doc xml:space="preserve">Reject this certificate, asynchronously.

Before calling this method, you must call
tp_tls_certificate_add_rejection() at least once, to set the reason(s)
for rejection (for instance, a certificate might be both self-signed and
expired).

In or after @callback,
you may call tp_tls_certificate_reject_finish() to check the result.

#GObject::notify::state will also be emitted when the connection manager
signals that the certificate has been rejected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">called on success or failure</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reject_finish"
              c:identifier="tp_tls_certificate_reject_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Check the result of tp_tls_certificate_reject_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if rejection was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a TLS certificate</doc>
            <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback by
 tp_tls_certificate_reject_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="cert-data" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">The raw data of the certificate or certificate chain, represented
as a #GPtrArray of #GBytes. It should be interpreted
according to #TpTLSCertificate:cert-type.

The first certificate in this array is the server's certificate,
followed by its issuer, followed by the issuer's issuer and so on.

For "x509" certificates, each certificate is an X.509 certificate in
binary (DER) format.

For "pgp" certificates, each certificate is a binary OpenPGP key.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="cert-type" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">The type of the certificate, typically either "x509" or "pgp".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpConnection or #TpChannel which owns this TLS certificate. If the
parent object is invalidated, the certificate is also invalidated, and
this property is set to %NULL.</doc>
        <type name="Proxy"/>
      </property>
      <property name="state" version="0.19.0" transfer-ownership="none">
        <doc xml:space="preserve">The state of this TLS certificate as a #TpTLSCertificateState,
initially %TP_TLS_CERTIFICATE_STATE_PENDING.

#GObject::notify::state will be emitted when this changes.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TLSCertificatePrivate" c:type="TpTLSCertificatePrivate*"/>
      </field>
    </class>
    <record name="TLSCertificateClass"
            c:type="TpTLSCertificateClass"
            glib:is-gtype-struct-for="TLSCertificate"
            version="0.19.0">
      <doc xml:space="preserve">The class of a #TpTLSCertificate.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_future" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="3">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TLSCertificateClassPrivate"
              c:type="TpTLSCertificateClassPrivate*"/>
      </field>
    </record>
    <record name="TLSCertificateClassPrivate"
            c:type="TpTLSCertificateClassPrivate"
            disguised="1">
    </record>
    <record name="TLSCertificatePrivate"
            c:type="TpTLSCertificatePrivate"
            disguised="1">
    </record>
    <enumeration name="TLSCertificateRejectReason"
                 c:type="TpTLSCertificateRejectReason">
      <doc xml:space="preserve">&lt;![CDATA[         Possible reasons to reject a TLS certificate.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_UNKNOWN">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate has been rejected for another reason           not listed in this enumeration.         ]]&gt;</doc>
      </member>
      <member name="untrusted"
              value="1"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_UNTRUSTED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate is not trusted.         ]]&gt;</doc>
      </member>
      <member name="expired"
              value="2"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_EXPIRED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate is expired.         ]]&gt;</doc>
      </member>
      <member name="not_activated"
              value="3"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_NOT_ACTIVATED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate is not active yet.         ]]&gt;</doc>
      </member>
      <member name="fingerprint_mismatch"
              value="4"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_FINGERPRINT_MISMATCH">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate provided does not have the expected           fingerprint.         ]]&gt;</doc>
      </member>
      <member name="hostname_mismatch"
              value="5"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_HOSTNAME_MISMATCH">
        <doc xml:space="preserve">&lt;![CDATA[           The hostname certified does not match the provided one.         ]]&gt;</doc>
      </member>
      <member name="self_signed"
              value="6"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_SELF_SIGNED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate is self-signed.         ]]&gt;</doc>
      </member>
      <member name="revoked"
              value="7"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_REVOKED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate has been revoked.         ]]&gt;</doc>
      </member>
      <member name="insecure"
              value="8"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_INSECURE">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate uses an insecure cipher algorithm, or is           cryptographically weak.         ]]&gt;</doc>
      </member>
      <member name="limit_exceeded"
              value="9"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_LIMIT_EXCEEDED">
        <doc xml:space="preserve">&lt;![CDATA[           The length in bytes of the certificate, or the depth of the           certificate chain exceed the limits imposed by the crypto           library.         ]]&gt;</doc>
      </member>
    </enumeration>
    <class name="TLSCertificateRejection"
           c:symbol-prefix="tls_certificate_rejection"
           c:type="TpTLSCertificateRejection"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpTLSCertificateRejection"
           glib:get-type="tp_tls_certificate_rejection_get_type"
           glib:type-struct="TLSCertificateRejectionClass">
      <doc xml:space="preserve">Data structure representing a #TpTLSCertificateRejection.</doc>
      <method name="get_dbus_error"
              c:identifier="tp_tls_certificate_rejection_get_dbus_error"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificateRejection:dbus-error property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTLSCertificateRejection:dbus-error property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificateRejection</doc>
            <type name="TLSCertificateRejection"
                  c:type="TpTLSCertificateRejection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_details"
              c:identifier="tp_tls_certificate_rejection_get_details"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificateRejection:details property</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of #TpTLSCertificateRejection:details property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificateRejection</doc>
            <type name="TLSCertificateRejection"
                  c:type="TpTLSCertificateRejection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_error"
              c:identifier="tp_tls_certificate_rejection_get_error"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificateRejection:error property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTLSCertificateRejection:error property</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificateRejection</doc>
            <type name="TLSCertificateRejection"
                  c:type="TpTLSCertificateRejection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reason"
              c:identifier="tp_tls_certificate_rejection_get_reason"
              version="0.19.0">
        <doc xml:space="preserve">Return the #TpTLSCertificateRejection:reason property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTLSCertificateRejection:reason property</doc>
          <type name="TLSCertificateRejectReason"
                c:type="TpTLSCertificateRejectReason"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificateRejection</doc>
            <type name="TLSCertificateRejection"
                  c:type="TpTLSCertificateRejection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="raise_error"
              c:identifier="tp_tls_certificate_rejection_raise_error"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve">Convenient function to raise the #TpTLSCertificateRejection:error
property in language binding supporting this feature.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTLSCertificateRejection</doc>
            <type name="TLSCertificateRejection"
                  c:type="TpTLSCertificateRejection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="dbus-error"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus error name of the rejection</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="details"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #G_VARIANT_TYPE_VARDICT containing the details of the rejection</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="error"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">a #GError (likely to be in the %TP_ERROR domain) indicating the reason
of the rejection</doc>
        <type name="GLib.Error"/>
      </property>
      <property name="reason"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">#TpTLSCertificateRejectReason representing the reason of the rejection</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TLSCertificateRejectionPriv"
              c:type="TpTLSCertificateRejectionPriv*"/>
      </field>
    </class>
    <record name="TLSCertificateRejectionClass"
            c:type="TpTLSCertificateRejectionClass"
            glib:is-gtype-struct-for="TLSCertificateRejection"
            version="0.19.0">
      <doc xml:space="preserve">The class of a #TpTLSCertificateRejection.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="TLSCertificateRejectionPriv"
            c:type="TpTLSCertificateRejectionPriv"
            disguised="1">
    </record>
    <enumeration name="TLSCertificateState" c:type="TpTLSCertificateState">
      <doc xml:space="preserve">&lt;![CDATA[         The possible states for a TLSCertificate         object.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="pending"
              value="0"
              c:identifier="TP_TLS_CERTIFICATE_STATE_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate is currently waiting to be accepted or rejected.         ]]&gt;</doc>
      </member>
      <member name="accepted"
              value="1"
              c:identifier="TP_TLS_CERTIFICATE_STATE_ACCEPTED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate has been verified.         ]]&gt;</doc>
      </member>
      <member name="rejected"
              value="2"
              c:identifier="TP_TLS_CERTIFICATE_STATE_REJECTED">
        <doc xml:space="preserve">&lt;![CDATA[           The certificate has been rejected.         ]]&gt;</doc>
      </member>
    </enumeration>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/gtalk-p2p"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/ice-udp"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-2009"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-8.5"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/audio"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_GTALK_P2P"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/gtalk-p2p"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_GTALK_P2P">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_ICE"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/ice"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_ICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_SHM"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/shm"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_SHM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/video"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_WLM_2009"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/wlm-2009"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_WLM_2009">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_CONTACT_ID"
              value="org.freedesktop.Telepathy.Connection/contact-id"
              c:type="TP_TOKEN_CONNECTION_CONTACT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ADDRESSING_ADDRESSES"
              value="org.freedesktop.Telepathy.Connection.Interface.Addressing1/addresses"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ADDRESSING_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ADDRESSING_URIS"
              value="org.freedesktop.Telepathy.Connection.Interface.Addressing1/uris"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ADDRESSING_URIS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS"
              value="org.freedesktop.Telepathy.Connection.Interface.Aliasing/alias"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars/token"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS"
              value="org.freedesktop.Telepathy.Connection.Interface.Capabilities/caps"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.ClientTypes/client-types"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking/blocked"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities/capabilities"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups/groups"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo/info"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/publish"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/publish-request"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/subscribe"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION"
              value="org.freedesktop.Telepathy.Connection.Interface.Location/location"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence/presence"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="TextChannel"
           c:symbol-prefix="text_channel"
           c:type="TpTextChannel"
           version="0.13.10"
           parent="Channel"
           glib:type-name="TpTextChannel"
           glib:get-type="tp_text_channel_get_type"
           glib:type-struct="TextChannelClass">
      <doc xml:space="preserve">Data structure representing a #TpTextChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_text_channel_new"
                   version="0.13.10"
                   deprecated="1"
                   throws="1">
        <doc xml:space="preserve">Convenient function to create a new #TpTextChannel</doc>
        <doc-deprecated xml:space="preserve">Use tp_simple_client_factory_ensure_channel() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #TpTextChannel</doc>
          <type name="TextChannel" c:type="TpTextChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:space="preserve">
 the immutable properties of the channel,
 as signalled by the NewChannel D-Bus signal or returned by the
 CreateChannel and EnsureChannel D-Bus methods: a mapping from
 strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_chat_states"
                c:identifier="tp_text_channel_get_feature_quark_chat_states">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_incoming_messages"
                c:identifier="tp_text_channel_get_feature_quark_incoming_messages">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_sms"
                c:identifier="tp_text_channel_get_feature_quark_sms">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="ack_all_pending_messages_async"
              c:identifier="tp_text_channel_ack_all_pending_messages_async"
              version="0.15.3">
        <doc xml:space="preserve">Acknowledge all the pending messages. This is equivalent of calling
tp_text_channel_ack_messages_async() with the list of #TpSignalledMessage
returned by tp_text_channel_dup_pending_messages().

Once the messages have been acked, @callback will be called.
You can then call tp_text_channel_ack_all_pending_messages_finish() to get
the result of the operation.

See tp_text_channel_ack_message_async() about acknowledging messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a callback to call when the messages have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_all_pending_messages_finish"
              c:identifier="tp_text_channel_ack_all_pending_messages_finish"
              version="0.15.3"
              throws="1">
        <doc xml:space="preserve">Finish an asynchronous acknowledgement operation of all messages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the messages have been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_message_async"
              c:identifier="tp_text_channel_ack_message_async"
              version="0.13.10">
        <doc xml:space="preserve">Acknowledge @message. Once the message has been acked, @callback will be
called. You can then call tp_text_channel_ack_message_finish() to get the
result of the operation.

A message should be acknowledged once it has been shown to the user by the
Handler of the channel. So Observers and Approvers should NOT acknowledge
messages themselves.
Once a message has been acknowledged, it is removed from the
pending-message queue and so the #TpTextChannel::pending-message-removed
signal is fired.

You should use the #TpSignalledMessage received from
tp_text_channel_dup_pending_messages() or the
#TpTextChannel::message-received signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSignalledMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the message have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_message_finish"
              c:identifier="tp_text_channel_ack_message_finish"
              version="0.13.10"
              throws="1">
        <doc xml:space="preserve">Finishes acknowledging a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message has been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_text_channel_ack_message_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_messages_async"
              c:identifier="tp_text_channel_ack_messages_async"
              version="0.13.10">
        <doc xml:space="preserve">Acknowledge all the messages in @messages.
Once the messages have been acked, @callback will be called.
You can then call tp_text_channel_ack_messages_finish() to get the
result of the operation.

You should use the #TpSignalledMessage received from
tp_text_channel_dup_pending_messages() or the
#TpTextChannel::message-received signal.

See tp_text_channel_ack_message_async() about acknowledging messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of
#TpSignalledMessage</doc>
            <type name="GLib.List" c:type="const GList*">
              <type name="SignalledMessage"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the message have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_messages_finish"
              c:identifier="tp_text_channel_ack_messages_finish"
              version="0.13.10"
              throws="1">
        <doc xml:space="preserve">Finishes acknowledging a list of messages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the messages have been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_text_channel_ack_messages_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_pending_messages"
              c:identifier="tp_text_channel_dup_pending_messages"
              version="0.19.9">
        <doc xml:space="preserve">Return a newly allocated list of unacknowledged #TpSignalledMessage
objects.

It is guaranteed that the #TpSignalledMessage:sender of each
#TpSignalledMessage has all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
a #GList of reffed #TpSignalledMessage</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SignalledMessage"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_chat_state"
              c:identifier="tp_text_channel_get_chat_state"
              version="0.19.0">
        <doc xml:space="preserve">Return the chat state for the given contact. If tp_proxy_is_prepared()
would return %FALSE for the feature %TP_TEXT_CHANNEL_FEATURE_CHAT_STATES,
the result will always be %TP_CHANNEL_CHAT_STATE_INACTIVE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the chat state for @contact, or %TP_CHANNEL_CHAT_STATE_INACTIVE
 if their chat state is not known</doc>
          <type name="ChannelChatState" c:type="TpChannelChatState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a channel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_delivery_reporting_support"
              c:identifier="tp_text_channel_get_delivery_reporting_support"
              version="0.13.10">
        <doc xml:space="preserve">Return the #TpTextChannel:delivery-reporting-support property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTextChannel:delivery-reporting-support property</doc>
          <type name="DeliveryReportingSupportFlags"
                c:type="TpDeliveryReportingSupportFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message_part_support_flags"
              c:identifier="tp_text_channel_get_message_part_support_flags"
              version="0.13.10">
        <doc xml:space="preserve">Return the #TpTextChannel:message-part-support-flags property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTextChannel:message-part-support-flags</doc>
          <type name="MessagePartSupportFlags"
                c:type="TpMessagePartSupportFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message_types"
              c:identifier="tp_text_channel_get_message_types"
              version="0.13.16">
        <doc xml:space="preserve">Return the #TpTextChannel:message-types property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
the value of #TpTextChannel:message-types</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ChannelTextMessageType"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pending_messages"
              c:identifier="tp_text_channel_get_pending_messages"
              version="0.13.10"
              deprecated="1">
        <doc xml:space="preserve">Return a newly allocated list of unacknowledged #TpSignalledMessage
objects.

It is guaranteed that the #TpSignalledMessage:sender of each
#TpSignalledMessage has all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <doc-deprecated xml:space="preserve">Since 0.19.9. New code should use
 tp_text_channel_dup_pending_messages() instead.</doc-deprecated>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
a #GList of borrowed #TpSignalledMessage</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SignalledMessage"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sms_flash"
              c:identifier="tp_text_channel_get_sms_flash"
              version="0.15.1">
        <doc xml:space="preserve">Return the #TpTextChannel:sms-flash property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTextChannel:sms-flash property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sms_length_async"
              c:identifier="tp_text_channel_get_sms_length_async"
              version="0.15.1">
        <doc xml:space="preserve">Starts an async call to get the number of 140 octet chunks required to
send a #message via SMS on #self, as well as the number of remaining
characters available in the final chunk and, if possible,
an estimate of the cost.

Once the request has been satisfied, @callback will be called.
You can then call tp_text_channel_get_sms_length_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpClientMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sms_length_finish"
              c:identifier="tp_text_channel_get_sms_length_finish"
              version="0.15.1"
              throws="1">
        <doc xml:space="preserve">Finishes an async SMS length request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the number of 140 octet chunks required to send
the message has been retrieved, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="chunks_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL used to return
the number of 140 octet chunks required to send the message.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="remaining_characters"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL used to return
the number of further characters that can be fit in the final chunk.
A negative value indicates that the message will be truncated by
abs(@remaining_characters).
The value #G_MININT32 indicates the message will be truncated by
an unknown amount.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="estimated_cost"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL used to return
the estimated cost of sending this message.
The currency and scale of this value are the same as the
values of the #TpConnection:balance-scale and
#TpConnection:balance-currency properties.
A value of -1 indicates the cost could not be estimated.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supported_content_types"
              c:identifier="tp_text_channel_get_supported_content_types"
              version="0.13.10">
        <doc xml:space="preserve">Return the #TpTextChannel:supported-content-types property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
the value of #TpTextChannel:supported-content-types</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sms_channel"
              c:identifier="tp_text_channel_is_sms_channel"
              version="0.15.1">
        <doc xml:space="preserve">Return the #TpTextChannel:is-sms-channel property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #TpTextChannel:is-sms-channel property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_message_async"
              c:identifier="tp_text_channel_send_message_async"
              version="0.13.10">
        <doc xml:space="preserve">Submit a message to the server for sending. Once the message has been
submitted to the sever, @callback will be called. You can then call
tp_text_channel_send_message_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpClientMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting how the message is sent</doc>
            <type name="MessageSendingFlags" c:type="TpMessageSendingFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback to call when the message has been submitted to the
server</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_finish"
              c:identifier="tp_text_channel_send_message_finish"
              version="0.13.10"
              throws="1">
        <doc xml:space="preserve">Completes a call to tp_text_channel_send_message_async().

@token can be used to match any incoming delivery or failure reports
against the sent message. If this function returns true but the returned
token is %NULL, the message was sent successfully but the protocol does not
provide a way to identify it later.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message has been submitted to the server, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_text_channel_send_message_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="token"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if not %NULL, used to return the
token of the sent message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chat_state_async"
              c:identifier="tp_text_channel_set_chat_state_async"
              version="0.13.10">
        <doc xml:space="preserve">Set the local state on channel @self to @state.
Once the state has been set, @callback will be called.
You can then call tp_text_channel_set_chat_state_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelChatState to set</doc>
            <type name="ChannelChatState" c:type="TpChannelChatState"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback to call when the chat state has been set</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chat_state_finish"
              c:identifier="tp_text_channel_set_chat_state_finish"
              version="0.13.10"
              throws="1">
        <doc xml:space="preserve">Completes a call to tp_text_channel_set_chat_state_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the chat state has been changed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult passed to the callback for tp_text_channel_set_chat_state_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_message_type"
              c:identifier="tp_text_channel_supports_message_type"
              version="0.13.16">
        <doc xml:space="preserve">Check if message of type @message_type can be sent on this channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if message of type @message_type can be sent on @self, %FALSE
otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #TpTextChannel</doc>
            <type name="TextChannel" c:type="TpTextChannel*"/>
          </instance-parameter>
          <parameter name="message_type" transfer-ownership="none">
            <doc xml:space="preserve">a #TpChannelTextMessageType</doc>
            <type name="ChannelTextMessageType"
                  c:type="TpChannelTextMessageType"/>
          </parameter>
        </parameters>
      </method>
      <property name="delivery-reporting-support"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpDeliveryReportingSupportFlags indicating features supported
by this channel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="is-sms-channel"
                version="0.15.1"
                transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if messages sent and received on this channel are transmitted
via SMS.

This property is not guaranteed to have a meaningful value until
TP_TEXT_CHANNEL_FEATURE_SMS has been prepared.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="message-part-support-flags"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:space="preserve">A #TpMessagePartSupportFlags indicating the level of support for
message parts on this channel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="message-types"
                version="0.13.16"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GArray containing the #TpChannelTextMessageType which may be sent on
this channel.</doc>
        <type/>
      </property>
      <property name="sms-flash" version="0.15.1" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if this channel is exclusively for receiving class 0 SMSes
(and no SMSes can be sent using tp_text_channel_send_message_async()
on this channel). If %FALSE, no incoming class 0 SMSes will appear
on this channel.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="supported-content-types"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GStrv containing the MIME types supported by this channel, with more
preferred MIME types appearing earlier in the array.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TextChannelPrivate" c:type="TpTextChannelPrivate*"/>
      </field>
      <glib:signal name="contact-chat-state-changed"
                   when="last"
                   detailed="1"
                   version="0.19.0">
        <doc xml:space="preserve">Emitted when a contact's chat state changes after tp_proxy_prepare_async()
has finished preparing features %TP_TEXT_CHANNEL_FEATURE_CHAT_STATES,
%TP_CHANNEL_FEATURE_GROUP and %TP_CHANNEL_FEATURE_CONTACTS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:space="preserve">a #TpContact for the local user or another contact</doc>
            <type name="Contact"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new #TpChannelChatState for the contact</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message-received" when="last" version="0.13.10">
        <doc xml:space="preserve">The ::message-received signal is emitted when a new message has been
received on @self.

The same @message object will be used by the
#TpTextChannel::pending-message-removed signal once @message has been
acked so you can simply compare pointers to identify the message.

Note that this signal is only fired once the
#TP_TEXT_CHANNEL_FEATURE_INCOMING_MESSAGES has been prepared.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message-sent" when="last" version="0.13.10">
        <doc xml:space="preserve">The ::message-sent signal is emitted when @message
has been submitted for sending.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the #TpMessageSendingFlags affecting how the message was sent</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">an opaque token used to match any incoming delivery or failure
reports against this message, or %NULL if the message is not
readily identifiable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="pending-message-removed"
                   when="last"
                   version="0.13.10">
        <doc xml:space="preserve">The ::pending-message-removed signal is emitted when @message
has been acked and so removed from the pending messages list.

Note that this signal is only fired once the
#TP_TEXT_CHANNEL_FEATURE_INCOMING_MESSAGES has been prepared.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TextChannelClass"
            c:type="TpTextChannelClass"
            glib:is-gtype-struct-for="TextChannel"
            version="0.13.10">
      <doc xml:space="preserve">The class of a #TpTextChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="TextChannelPrivate"
            c:type="TpTextChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="TubeChannelState" c:type="TpTubeChannelState">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_pending"
              value="0"
              c:identifier="TP_TUBE_CHANNEL_STATE_LOCAL_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The initiator offered the tube. The tube is waiting to be           accepted/closed locally. If the client accepts the tube, the tube's           state will be Open.         ]]&gt;</doc>
      </member>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_TUBE_CHANNEL_STATE_REMOTE_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The tube is waiting to be accepted/closed remotely. If the           recipient accepts the tube, the tube's state will be Open.         ]]&gt;</doc>
      </member>
      <member name="open" value="2" c:identifier="TP_TUBE_CHANNEL_STATE_OPEN">
        <doc xml:space="preserve">&lt;![CDATA[           The initiator offered the tube and the recipient accepted it. The           tube is open for traffic. The tube's state stays in this state until           it is closed.         ]]&gt;</doc>
      </member>
      <member name="not_offered"
              value="3"
              c:identifier="TP_TUBE_CHANNEL_STATE_NOT_OFFERED">
        <doc xml:space="preserve">&lt;![CDATA[           The tube channel has been requested but the tube is not yet offered.           The client should offer the tube to the recipient and the tube's           state will be Remote_Pending. The method used to offer the tube           depends on the tube type.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="TubeState" c:type="TpTubeState">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_pending"
              value="0"
              c:identifier="TP_TUBE_STATE_LOCAL_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The tube is waiting to be accepted/closed locally.         ]]&gt;</doc>
      </member>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_TUBE_STATE_REMOTE_PENDING">
        <doc xml:space="preserve">&lt;![CDATA[           The tube is waiting to be accepted/closed remotely.         ]]&gt;</doc>
      </member>
      <member name="open" value="2" c:identifier="TP_TUBE_STATE_OPEN">
        <doc xml:space="preserve">&lt;![CDATA[           The tube is open for traffic.         ]]&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="TubeType" c:type="TpTubeType">
      <doc xml:space="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="dbus" value="0" c:identifier="TP_TUBE_TYPE_DBUS">
        <doc xml:space="preserve">&lt;![CDATA[           The tube is D-Bus tube as described by the             org.freedesktop.Telepathy.Channel.Type.DBusTube interface.         ]]&gt;</doc>
      </member>
      <member name="stream" value="1" c:identifier="TP_TUBE_TYPE_STREAM">
        <doc xml:space="preserve">&lt;![CDATA[           The tube is stream tube as described by the             org.freedesktop.Telepathy.Channel.Type.StreamTube interface.         ]]&gt;</doc>
      </member>
    </enumeration>
    <constant name="UNKNOWN_CONNECTION_STATUS"
              value="-1"
              c:type="TP_UNKNOWN_CONNECTION_STATUS"
              version="0.7.1">
      <doc xml:space="preserve">An invalid connection status used in #TpConnection to indicate that the
status has not yet been discovered.</doc>
      <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
    </constant>
    <constant name="UNKNOWN_HANDLE_TYPE"
              value="-1"
              c:type="TP_UNKNOWN_HANDLE_TYPE"
              version="0.7.0">
      <doc xml:space="preserve">An invalid handle type (-1 cast to TpHandleType) used to represent an
unknown handle type.</doc>
      <type name="HandleType" c:type="TpHandleType"/>
    </constant>
    <constant name="USER_ACTION_TIME_NOT_USER_ACTION"
              value="0"
              c:type="TP_USER_ACTION_TIME_NOT_USER_ACTION"
              version="0.11.13">
      <doc xml:space="preserve">The "user action time" used by methods like
tp_account_channel_request_new() to represent channel requests that are
not a result of user action.

See also #TpAccountChannelRequest:user-action-time,
tp_user_action_time_from_x11(), tp_user_action_time_should_present() and
%TP_USER_ACTION_TIME_CURRENT_TIME.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <record name="WeakRef" c:type="TpWeakRef" disguised="1" version="0.11.3">
      <doc xml:space="preserve">A simple wrapper for a weak reference to a #GObject, suitable for use in
asynchronous calls which should only affect the object if it hasn't already
been freed.

As well as wrapping a weak reference to an object, this structure can
contain an extra pointer to arbitrary data. This is useful for asynchronous
calls which act on an object and some second piece of data, which are quite
common in practice.

If more than one piece of auxiliary data is required, the @user_data
argument to the constructor can be a struct or a #GValueArray.</doc>
      <method name="destroy"
              c:identifier="tp_weak_ref_destroy"
              version="0.11.3"
              introspectable="0">
        <doc xml:space="preserve">Free a weak reference wrapper. This drops the weak reference to the
object (if it still exists), and frees the user data with the user-supplied
destructor function if one was provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="full">
            <doc xml:space="preserve">a weak reference</doc>
            <type name="WeakRef" c:type="TpWeakRef*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_object"
              c:identifier="tp_weak_ref_dup_object"
              version="0.11.3"
              introspectable="0">
        <doc xml:space="preserve">If the weakly referenced object still exists, return a new reference to
it. Otherwise, return %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference, or %NULL</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a weak reference</doc>
            <type name="WeakRef" c:type="TpWeakRef*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data"
              c:identifier="tp_weak_ref_get_user_data"
              version="0.11.3"
              introspectable="0">
        <doc xml:space="preserve">Return the additional data that was passed to tp_weak_ref_new().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the additional data supplied in tp_weak_ref_new(), which may be
 %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a weak reference</doc>
            <type name="WeakRef" c:type="TpWeakRef*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="tp_weak_ref_new"
                version="0.11.3"
                introspectable="0">
        <doc xml:space="preserve">Return a new weak reference wrapper for @object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new weak-reference wrapper

Free-function: tp_weak_ref_destroy()</doc>
          <type name="WeakRef" c:type="TpWeakRef*"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object to which to take a weak reference</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional additional data to store alongside the weak ref</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destructor for @user_data, called when the weak ref
 is freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function name="asv_dump" c:identifier="tp_asv_dump" introspectable="0">
      <doc xml:space="preserve">Dumps the a{sv} map to the debugging console.

The purpose of this function is give the programmer the ability to easily
inspect the contents of an a{sv} map for debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boolean"
              c:identifier="tp_asv_get_boolean"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and boolean, return it,
and set *@valid to %TRUE if @valid is not %NULL.

Otherwise return %FALSE, and set *@valid to %FALSE if @valid is not %NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a boolean value for @key</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Either %NULL, or a location to store %TRUE if the key actually
 exists and has a boolean value</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boxed"
              c:identifier="tp_asv_get_boxed"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and is of the desired type,
return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it, for instance with
g_boxed_copy(), if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the value of @key, or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">The type that the key's value should have, which must be derived
 from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_bytes"
              c:identifier="tp_asv_get_bytes"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and is an array of bytes
(its GType is %DBUS_TYPE_G_UCHAR_ARRAY), return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with
g_boxed_copy (DBUS_TYPE_G_UCHAR_ARRAY, ...) if you need to keep
it for longer.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the string value
of @key, or %NULL</doc>
        <array name="GLib.Array" c:type="const GArray*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_double"
              c:identifier="tp_asv_get_double"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and has any numeric type used by
dbus-glib (guchar, gint, guint, gint64, guint64 or gdouble),
return it as a double, and if @valid is not %NULL, set *@valid to %TRUE.

Otherwise, return 0.0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the double precision floating-point value of @key, or 0.0</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Either %NULL, or a location in which to store %TRUE on success
or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int32"
              c:identifier="tp_asv_get_int32"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the 32-bit signed integer value of @key, or 0</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Either %NULL, or a location in which to store %TRUE on success
or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int64"
              c:identifier="tp_asv_get_int64"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint64, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the 64-bit signed integer value of @key, or 0</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Either %NULL, or a location in which to store %TRUE on success
or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_object_path"
              c:identifier="tp_asv_get_object_path"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and is an object path, return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the object-path value of @key, or
%NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_string"
              c:identifier="tp_asv_get_string"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and is a string, return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the string value of @key, or %NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_strv"
              c:identifier="tp_asv_get_strv"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present and is an array of strings (strv),
return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdupv() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the %NULL-terminated string-array
value of @key, or %NULL</doc>
        <array c:type="const gchar* const*">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint32"
              c:identifier="tp_asv_get_uint32"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a guint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the 32-bit unsigned integer value of @key, or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Either %NULL, or a location in which to store %TRUE on success
or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint64"
              c:identifier="tp_asv_get_uint64"
              version="0.7.9">
      <doc xml:space="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and is non-negative,
return it, and if @valid is not %NULL, set *@valid to %TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the 64-bit unsigned integer value of @key, or 0</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are
strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Either %NULL, or a location in which to store %TRUE on success
or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_lookup"
              c:identifier="tp_asv_lookup"
              version="0.7.9"
              introspectable="0">
      <doc xml:space="preserve">If a value for @key in @asv is present, return it. Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with (for instance)
g_value_copy() if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @key, or %NULL</doc>
        <type name="GObject.Value" c:type="const GValue*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_new"
              c:identifier="tp_asv_new"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Creates a new #GHashTable for use with a{sv} maps, containing the values
passed in as parameters.

The #GHashTable is synonymous with:
&lt;informalexample&gt;&lt;programlisting&gt;
GHashTable *asv = g_hash_table_new_full (g_str_hash, g_str_equal,
   NULL, (GDestroyNotify) tp_g_value_slice_free);
&lt;/programlisting&gt;&lt;/informalexample&gt;
Followed by manual insertion of each of the parameters.

Parameters are stored in slice-allocated GValues and should be set using
tp_asv_set_*() and retrieved using tp_asv_get_*().

tp_g_value_slice_new() and tp_g_value_slice_dup() may also be used to insert
into the map if required.
&lt;informalexample&gt;&lt;programlisting&gt;
g_hash_table_insert (parameters, "account",
   tp_g_value_slice_new_string ("bob@mcbadgers.com"));
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;example&gt;
 &lt;title&gt;Using tp_asv_new()&lt;/title&gt;
 &lt;programlisting&gt;
GHashTable *parameters = tp_asv_new (
   "answer", G_TYPE_INT, 42,
   "question", G_TYPE_STRING, "We just don't know",
   NULL);&lt;/programlisting&gt;
&lt;/example&gt;

Allocated values will be automatically free'd when overwritten, removed or
the hash table destroyed with g_hash_table_unref().</doc>
      <return-value>
        <doc xml:space="preserve">a newly created #GHashTable for storing a{sv} maps, free with
g_hash_table_unref().</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:space="preserve">the name of the first key (or NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">type and value for the first key, followed by a NULL-terminated list
 of (key, type, value) tuples</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boolean"
              c:identifier="tp_asv_set_boolean"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boolean(), tp_g_value_slice_new_boolean()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boxed"
              c:identifier="tp_asv_set_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(), tp_g_value_slice_new_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_bytes"
              c:identifier="tp_asv_set_bytes"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_bytes(), tp_g_value_slice_new_bytes()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to copy</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="bytes"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">location of an array of bytes to be copied (this may be %NULL
if and only if length is 0)</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_double"
              c:identifier="tp_asv_set_double"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_double(), tp_g_value_slice_new_double()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int32"
              c:identifier="tp_asv_set_int32"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_int32(), tp_g_value_slice_new_int()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int64"
              c:identifier="tp_asv_set_int64"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_int64(), tp_g_value_slice_new_int64()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_object_path"
              c:identifier="tp_asv_set_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_boxed"
              c:identifier="tp_asv_set_static_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(),
tp_g_value_slice_new_static_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_object_path"
              c:identifier="tp_asv_set_static_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_static_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_string"
              c:identifier="tp_asv_set_static_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(),
tp_g_value_slice_new_static_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_string"
              c:identifier="tp_asv_set_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(), tp_g_value_slice_new_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_strv"
              c:identifier="tp_asv_set_strv"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_strv()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated string array</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint32"
              c:identifier="tp_asv_set_uint32"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_uint32(), tp_g_value_slice_new_uint()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint64"
              c:identifier="tp_asv_set_uint64"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_uint64(), tp_g_value_slice_new_uint64()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_boxed"
              c:identifier="tp_asv_take_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(), tp_g_value_slice_new_take_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_bytes"
              c:identifier="tp_asv_take_bytes"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_bytes(), tp_g_value_slice_new_take_bytes()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a non-NULL #GArray of %guchar, ownership of which will be taken by
the #GValue</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_object_path"
              c:identifier="tp_asv_take_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_take_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_string"
              c:identifier="tp_asv_take_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:space="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(),
tp_g_value_slice_new_take_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_list_copy"
              c:identifier="tp_contact_info_list_copy"
              moved-to="ContactInfoList.copy"
              version="0.11.7"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value>
        <doc xml:space="preserve">a new #GList of newly allocated #TpContactInfoField, free it with
 tp_contact_info_list_free()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpContactInfoField</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_list_free"
              c:identifier="tp_contact_info_list_free"
              moved-to="ContactInfoList.free"
              version="0.11.7"
              introspectable="0">
      <doc xml:space="preserve">Free all memory used by the #GList and its elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpContactInfoField</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_spec_list_copy"
              c:identifier="tp_contact_info_spec_list_copy"
              moved-to="ContactInfoSpecList.copy"
              version="0.11.7"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value>
        <doc xml:space="preserve">a new #GList of newly allocated #TpContactInfoFieldSpec,
 free it with tp_contact_info_spec_list_free()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpContactInfoFieldSpec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_spec_list_free"
              c:identifier="tp_contact_info_spec_list_free"
              moved-to="ContactInfoSpecList.free"
              version="0.11.7"
              introspectable="0">
      <doc xml:space="preserve">Free all memory used by the #GList and its elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #TpContactInfoFieldSpec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_add_contact_attributes_iface"
              c:identifier="tp_contacts_mixin_add_contact_attributes_iface"
              moved-to="ContactsMixin.add_contact_attributes_iface"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:space="preserve">Name of the interface that has ContactAttributes</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fill_contact_attributes" transfer-ownership="none">
          <doc xml:space="preserve">Contact attribute filler function</doc>
          <type name="ContactsMixinFillContactAttributesFunc"
                c:type="TpContactsMixinFillContactAttributesFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_class_get_offset_quark"
              c:identifier="tp_contacts_mixin_class_get_offset_quark"
              moved-to="ContactsMixinClass.get_offset_quark"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_class_init"
              c:identifier="tp_contacts_mixin_class_init"
              moved-to="ContactsMixinClass.init"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
                         G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The byte offset of the TpContactsMixinClass within the class
         structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_finalize"
              c:identifier="tp_contacts_mixin_finalize"
              moved-to="ContactsMixin.finalize"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">Free resources held by the contacts mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_contact_attributes"
              c:identifier="tp_contacts_mixin_get_contact_attributes"
              moved-to="ContactsMixin.get_contact_attributes"
              introspectable="0">
      <doc xml:space="preserve">Get contact attributes for the given contacts. Provide attributes for all requested
interfaces. If contact attributes are not immediately known, the behaviour is defined
by the interface; the attribute should either be omitted from the result or replaced
with a default value.</doc>
      <return-value>
        <doc xml:space="preserve">A dictionary mapping the contact handles to contact attributes.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">A connection instance that uses this mixin. The connection must be connected.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">List of handles to retrieve contacts for. Any invalid handles will be
dropped from the returned mapping.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="interfaces" transfer-ownership="none">
          <doc xml:space="preserve">A list of interfaces to retrieve attributes from.</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="assumed_interfaces" transfer-ownership="none">
          <doc xml:space="preserve">A list of additional interfaces to retrieve attributes
 from. This can be used for interfaces documented as automatically included,
 like %TP_IFACE_CONNECTION for GetContactAttributes,
 or %TP_IFACE_CONNECTION and %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST for
 GetContactListAttributes.</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The DBus client's unique name. If this is not NULL, the requested handles
will be held on behalf of this client.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_offset_quark"
              c:identifier="tp_contacts_mixin_get_offset_quark"
              moved-to="ContactsMixin.get_offset_quark"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_iface_init"
              c:identifier="tp_contacts_mixin_iface_init"
              moved-to="ContactsMixin.iface_init"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object
class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_init"
              c:identifier="tp_contacts_mixin_init"
              moved-to="ContactsMixin.init"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
                    G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_set_contact_attribute"
              c:identifier="tp_contacts_mixin_set_contact_attribute"
              moved-to="ContactsMixin.set_contact_attribute"
              version="0.7.14"
              introspectable="0">
      <doc xml:space="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="contact_attributes" transfer-ownership="none">
          <doc xml:space="preserve">contacts attribute hash as passed to
  TpContactsMixinFillContactAttributesFunc</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">Handle to set the attribute on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">attribute name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">slice allocated GValue containing the value of the attribute, for
instance with tp_g_value_slice_new. Ownership of the GValue is taken over by
the mixin</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_bus_name"
              c:identifier="tp_dbus_check_valid_bus_name"
              version="0.7.1"
              throws="1">
      <doc xml:space="preserve">Check that the given string is a valid D-Bus bus name of an appropriate
type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a possible bus name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="allow_types" transfer-ownership="none">
          <doc xml:space="preserve">some combination of %TP_DBUS_NAME_TYPE_UNIQUE,
 %TP_DBUS_NAME_TYPE_WELL_KNOWN or %TP_DBUS_NAME_TYPE_BUS_DAEMON
 (often this will be %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON or
 %TP_DBUS_NAME_TYPE_ANY)</doc>
          <type name="DBusNameType" c:type="TpDBusNameType"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_interface_name"
              c:identifier="tp_dbus_check_valid_interface_name"
              version="0.7.1"
              throws="1">
      <doc xml:space="preserve">Check that the given string is a valid D-Bus interface name. This is
also appropriate to use to check for valid error names.

Since GIO 2.26, g_dbus_is_interface_name() should always return the same
thing, although the GLib function does not raise an error explaining why
the interface name is incorrect.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a possible interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_member_name"
              c:identifier="tp_dbus_check_valid_member_name"
              version="0.7.1"
              throws="1">
      <doc xml:space="preserve">Check that the given string is a valid D-Bus member (method or signal) name.

Since GIO 2.26, g_dbus_is_member_name() should always return the same
thing, although the GLib function does not raise an error explaining why
the interface name is incorrect.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a possible member name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_object_path"
              c:identifier="tp_dbus_check_valid_object_path"
              version="0.7.1"
              throws="1">
      <doc xml:space="preserve">Check that the given string is a valid D-Bus object path. Since GLib 2.24,
g_variant_is_object_path() should always return the same thing as this
function, although it doesn't provide an error explaining why the object
path is invalid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @path is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">a possible object path</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_errors_quark" c:identifier="tp_dbus_errors_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="dbus_g_method_return_not_implemented"
              c:identifier="tp_dbus_g_method_return_not_implemented"
              introspectable="0">
      <doc xml:space="preserve">Return the Telepathy error NotImplemented from the method invocation
given by @context.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">The D-Bus method invocation context</doc>
          <type c:type="DBusGMethodInvocation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_class_init"
              c:identifier="tp_dbus_properties_mixin_class_init"
              moved-to="DBusPropertiesMixinClass.init"
              version="0.7.3">
      <doc xml:space="preserve">Initialize the class @cls to use the D-Bus Properties mixin.
The given struct member, of size sizeof(TpDBusPropertiesMixinClass),
will be used to store property implementation information.

Each property and each interface must have been declared as a member of
a GInterface implemented by @cls, using
tp_svc_interface_set_dbus_properties_info().

Before calling this function, the array @interfaces must have been
placed in the #TpDBusPropertiesMixinClass structure; if it would be empty,
it may instead be %NULL.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Changed in 0.7.9: TpDBusPropertiesMixinClass::interfaces may now be %NULL,
which means that only interfaces whose properties are set up using
tp_dbus_properties_mixin_implement_interface() will be used.

Changed in 0.7.15: @offset may now be 0, in which case the
#TpDBusPropertiesMixinClass can be omitted from @cls.  It is treated as if
it were present, but with all fields (including
TpDBusPropertiesMixinClass::interfaces) being %NULL, so only interfaces
whose properties are set using
tp_dbus_properties_mixin_implement_interface() will be used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:space="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">the offset within @cls of a TpDBusPropertiesMixinClass structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_dup_all"
              c:identifier="tp_dbus_properties_mixin_dup_all"
              version="0.21.2">
      <doc xml:space="preserve">Get all the properties of a particular interface. This implementation
never returns an error: it will return an empty map if the interface
is unknown.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a map
 from property name (without the interface name) to value</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_emit_properties_changed"
              c:identifier="tp_dbus_properties_mixin_emit_properties_changed"
              version="0.15.6">
      <doc xml:space="preserve">Emits the PropertiesChanged signal for the provided properties. Depending on
the EmitsChangedSignal annotations in the introspection XML, either the new
value of the property will be included in the signal, or merely the fact
that the property has changed.

For example, the MPRIS specification defines a TrackList interface with two
properties, one of which is annotated with EmitsChangedSignal=true and one
annotated with EmitsChangedSignal=invalidates. The following call would
include the new value of CanEditTracks and list Tracks as invalidated:

|[
   const gchar *properties[] = { "CanEditTracks", "Tracks", NULL };

   tp_dbus_properties_mixin_emit_properties_changed (G_OBJECT (self),
       "org.mpris.MediaPlayer2.TrackList", properties);
]|

It is an error to pass a property to this
function if the property is annotated with EmitsChangedSignal=false, or is
unannotated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">the interface on which properties have changed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="properties"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a %NULL-terminated array of (unqualified)
 property names whose values have changed.</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_emit_properties_changed_varargs"
              c:identifier="tp_dbus_properties_mixin_emit_properties_changed_varargs"
              version="0.15.6"
              introspectable="0">
      <doc xml:space="preserve">A shortcut for calling tp_dbus_properties_mixin_emit_properties_changed().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">the interface on which properties have changed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">property names (unqualified) whose values have changed, terminated by
 %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_fill_properties_hash"
              c:identifier="tp_dbus_properties_mixin_fill_properties_hash"
              version="0.11.11"
              introspectable="0">
      <doc xml:space="preserve">Retrieves the values of several D-Bus properties from an object, and adds
them to a hash mapping the fully-qualified name of the property to its
value. This is equivalent to calling tp_dbus_properties_mixin_get() for
each property and adding it to the table yourself, with the proviso that
this function will g_assert() if retrieving a property fails (for instance,
because it does not exist).

Note that in particular, @table does not have the same memory-allocation
model as the hash tables required by tp_asv_set_string() and similar
functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="table" transfer-ownership="none">
          <doc xml:space="preserve">a hash table where the keys are
 strings copied with g_strdup() and the values are slice-allocated
 #GValue&lt;!-- --&gt;s</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:space="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:space="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">more (interface name, property name) pairs, terminated by %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_get"
              c:identifier="tp_dbus_properties_mixin_get"
              version="0.7.13"
              throws="1">
      <doc xml:space="preserve">Initialize @value with the type of the property @property_name on
@interface_name, and write the value of that property into it as if
by calling the D-Bus method org.freedesktop.DBus.Properties.Get.

If Get would return a D-Bus error, @value remains unset and @error
is filled in instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE (filling @value) on success, %FALSE (setting @error)
 on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:space="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">an unset GValue (initialized to all zeroes)</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_getter_gobject_properties"
              c:identifier="tp_dbus_properties_mixin_getter_gobject_properties">
      <doc xml:space="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that
the @getter_data is the name of a readable #GObject property of an
appropriate type, and uses it for the value of the D-Bus property.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A GValue pre-initialized to the right type, into which to put
 the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl,
 which must be a string containing the GObject property's name</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_iface_init"
              c:identifier="tp_dbus_properties_mixin_iface_init">
      <doc xml:space="preserve">Declare that the DBus.Properties interface represented by @g_iface
is implemented using this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a pointer to a #TpSvcDBusPropertiesClass structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_implement_interface"
              c:identifier="tp_dbus_properties_mixin_implement_interface"
              introspectable="0">
      <doc xml:space="preserve">Declare that, in addition to any interfaces set in
tp_dbus_properties_mixin_class_init(), the given class (and its subclasses)
will implement the properties of the interface @iface using the callbacks
@getter and @setter and the properties given by @props.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Typically, the static array @interfaces in the #TpDBusPropertiesMixinClass
should be used for interfaces whose properties are implemented directly by
the class @cls, and this function should be used for interfaces whose
properties are implemented by mixins.

It is an error for the same interface to appear in the array @interfaces
in the #TpDBusPropertiesMixinClass, and also be set up by this function.

If a class C and a subclass S both implement the properties of the same
interface, only the implementations from the subclass S will be used,
regardless of whether the implementations in C and/or S were set up by
this function or via the array @interfaces in the
#TpDBusPropertiesMixinClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:space="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:space="preserve">a quark representing the the name of the interface to implement</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="getter" transfer-ownership="none">
          <doc xml:space="preserve">a callback to get properties on this interface, or %NULL if they
 are all write-only</doc>
          <type name="DBusPropertiesMixinGetter"
                c:type="TpDBusPropertiesMixinGetter"/>
        </parameter>
        <parameter name="setter" transfer-ownership="none">
          <doc xml:space="preserve">a callback to set properties on this interface, or %NULL if they
 are all read-only</doc>
          <type name="DBusPropertiesMixinSetter"
                c:type="TpDBusPropertiesMixinSetter"/>
        </parameter>
        <parameter name="props" transfer-ownership="none">
          <doc xml:space="preserve">an array of #TpDBusPropertiesMixinPropImpl representing individual
 properties, terminated by one with @name == %NULL</doc>
          <type name="DBusPropertiesMixinPropImpl"
                c:type="TpDBusPropertiesMixinPropImpl*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_make_properties_hash"
              c:identifier="tp_dbus_properties_mixin_make_properties_hash"
              introspectable="0">
      <doc xml:space="preserve">Retrieves the values of several D-Bus properties from an object, and builds
a hash mapping the fully-qualified name of the property to its value.  This
is equivalent to calling tp_dbus_properties_mixin_get() for each property
and building the table yourself, with the proviso that this function will
g_assert() if retrieving a property fails (for instance, because it does not
exist).

Additional keys and values can be inserted into the returned hash table;
if this is done, the inserted keys and values will be freed when the
hash table is destroyed. The keys must be allocated with g_strdup() or
equivalent, and the values must be slice-allocated (for instance with
tp_g_value_slice_new_string() or a similar function).

Note that in particular, tp_asv_set_string() and similar functions should
not be used with this hash table.</doc>
      <return-value>
        <doc xml:space="preserve">a hash table mapping (gchar *) fully-qualified property names to
         GValues, which must be freed by the caller (at which point its
         contents will also be freed).</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:space="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:space="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">more (interface name, property name) pairs, terminated by %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_set"
              c:identifier="tp_dbus_properties_mixin_set"
              version="0.15.8"
              throws="1">
      <doc xml:space="preserve">Sets a property to the value specified by @value, as if by
calling the D-Bus method org.freedesktop.DBus.Properties.Set.

If Set would return a D-Bus error, sets @error and returns %FALSE</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success; %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:space="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a GValue containing the new value for this property.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_setter_gobject_properties"
              c:identifier="tp_dbus_properties_mixin_setter_gobject_properties"
              throws="1">
      <doc xml:space="preserve">An implementation of #TpDBusPropertiesMixinSetter which assumes that the
@setter_data is the name of a writable #GObject property of an appropriate
type, and sets that property to the given value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="setter_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl,
 which must be a string containing the GObject property's name</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_divert_messages"
              c:identifier="tp_debug_divert_messages"
              version="0.7.1">
      <doc xml:space="preserve">Open the given file for writing and duplicate its file descriptor to
be used for stdout and stderr. This has the effect of closing the previous
stdout and stderr, and sending all messages that would have gone there
to the given file instead.

By default the file is truncated and hence overwritten each time the
process is executed.
Since version 0.7.14, if the filename is prefixed with '+' then the
file is not truncated and output is added at the end of the file.

Passing %NULL to this function is guaranteed to have no effect. This is
so you can call it with the recommended usage
&lt;literal&gt;tp_debug_divert_messages (g_getenv ("MYAPP_LOGFILE"))&lt;/literal&gt;
and it won't do anything if the environment variable is not set.

This function still works if telepathy-glib was compiled without debug
support.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">A file to which to divert stdout and stderr, or %NULL to
 do nothing</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_all_flags"
              c:identifier="tp_debug_set_all_flags"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Activate all possible debug modes. This also activates persistent mode,
which should have been orthogonal.</doc>
      <doc-deprecated xml:space="preserve">since 0.6.1. Use tp_debug_set_flags ("all") and
tp_debug_set_persistent() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_set_flags"
              c:identifier="tp_debug_set_flags"
              version="0.6.1">
      <doc xml:space="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set.

The parsing matches that of g_parse_debug_string().

If telepathy-glib was compiled with --disable-debug (not recommended),
this function has no practical effect, since the debug messages it would
enable were removed at compile time.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:space="preserve">The flags to set, comma-separated. If %NULL or empty,
 no additional flags are set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_env"
              c:identifier="tp_debug_set_flags_from_env"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Equivalent to
&lt;literal&gt;tp_debug_set_flags_from_string (g_getenv (var))&lt;/literal&gt;,
and has the same problem with persistence being included in "all".</doc>
      <doc-deprecated xml:space="preserve">since 0.6.1. Use tp_debug_set_flags(g_getenv(...)) and
tp_debug_set_persistent() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="var" transfer-ownership="none">
          <doc xml:space="preserve">The name of the environment variable to parse</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_string"
              c:identifier="tp_debug_set_flags_from_string"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set. Unlike tp_debug_set_flags(), this enables persistence like
tp_debug_set_persistent() if the "persist" flag is present or the string
is "all" - this turns out to be unhelpful, as persistence should be
orthogonal.

The parsing matches that of g_parse_debug_string().</doc>
      <doc-deprecated xml:space="preserve">since 0.6.1. Use tp_debug_set_flags() and
tp_debug_set_persistent() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:space="preserve">The flags to set, comma-separated. If %NULL or empty,
 no additional flags are set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_persistent"
              c:identifier="tp_debug_set_persistent">
      <doc xml:space="preserve">Used to enable persistent operation of the connection manager process for
debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="persistent" transfer-ownership="none">
          <doc xml:space="preserve">TRUE prevents the connection manager mainloop from exiting,
             FALSE enables exiting if there are no connections
             (the default behavior).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_timestamped_log_handler"
              c:identifier="tp_debug_timestamped_log_handler"
              version="0.7.1">
      <doc xml:space="preserve">A #GLogFunc that prepends the UTC time (currently in ISO 8601 format,
with microsecond resolution) to the message, then calls
g_log_default_handler.

Intended usage is:

&lt;informalexample&gt;&lt;programlisting&gt;if (g_getenv ("MYPROG_TIMING") != NULL)
  g_log_set_default_handler (tp_debug_timestamped_log_handler, NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;

If telepathy-glib was compiled with --disable-debug (not recommended),
this function is equivalent to g_log_default_handler().

Changed in 0.9.0: timestamps are now printed in UTC, in
RFC-3339 format. Previously, they were printed in local time, in a
format similar to RFC-3339.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:space="preserve">the message's log domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the log level of the message</doc>
          <type name="GLib.LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">the message to process</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="ignored"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">not used</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_dbus_name"
              c:identifier="tp_error_get_dbus_name"
              version="0.7.31">
      <doc xml:space="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the D-Bus error name corresponding to @error.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">a member of the #TpError enum.</doc>
          <type name="Error" c:type="TpError"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark"
              c:identifier="tp_error_quark"
              version="0.11.13">
      <doc xml:space="preserve">Return the error domain quark for #TpError.</doc>
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_disconnected_quark"
              c:identifier="tp_errors_disconnected_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_quark"
              c:identifier="tp_errors_quark"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">&lt;!-- --&gt;</doc>
      <doc-deprecated xml:space="preserve">Use tp_error_quark() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_removed_from_group_quark"
              c:identifier="tp_errors_removed_from_group_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="escape_as_identifier"
              c:identifier="tp_escape_as_identifier">
      <doc xml:space="preserve">Escape an arbitrary string so it follows the rules for a C identifier,
and hence an object path component, interface element component,
bus name component or member name in D-Bus.

Unlike g_strcanon this is a reversible encoding, so it preserves
distinctness.

The escaping consists of replacing all non-alphanumerics, and the first
character if it's a digit, with an underscore and two lower-case hex
digits:

   "0123abc_xyz\x01\xff" -&gt; _30123abc_5fxyz_01_ff

i.e. similar to URI encoding, but with _ taking the role of %, and a
smaller allowed set. As a special case, "" is escaped to "_" (just for
completeness, really).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the escaped string, which must be freed by
 the caller with #g_free</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The string to be escaped</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_finalize"
              c:identifier="tp_external_group_mixin_finalize"
              version="0.5.13"
              introspectable="0">
      <doc xml:space="preserve">Remove the external group mixin. This function should usually be called
in the dispose or finalize function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the groups interface using an external group
   mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_get_dbus_property"
              c:identifier="tp_external_group_mixin_get_dbus_property"
              version="0.7.10"
              introspectable="0">
      <doc xml:space="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the external group mixin. It can only be used for the Group
interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:space="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus property name, either
 "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members",
 "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A GValue pre-initialized to the right type, into which to put the
 value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_iface_init"
              c:identifier="tp_external_group_mixin_iface_init"
              version="0.5.13"
              introspectable="0">
      <doc xml:space="preserve">Fill in the vtable entries needed to implement the group interface using
the group mixin of another object. This function should usually be called
via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init"
              c:identifier="tp_external_group_mixin_init"
              version="0.5.13"
              introspectable="0">
      <doc xml:space="preserve">Fill in the qdata needed to implement the group interface using
the group mixin of another object. This function should usually be called
in the instance constructor.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the groups interface using an external group
   mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="obj_with_mixin" transfer-ownership="none">
          <doc xml:space="preserve">A GObject with the group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init_dbus_properties"
              c:identifier="tp_external_group_mixin_init_dbus_properties"
              version="0.7.10"
              introspectable="0">
      <doc xml:space="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to channels containing the
mixin used by this class with tp_group_mixin_change_flags() to indicate that
the DBus properties are available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_hash_table_update"
              c:identifier="tp_g_hash_table_update"
              version="0.7.0"
              introspectable="0">
      <doc xml:space="preserve">Add each item in @source to @target, replacing any existing item with the
same key. @key_dup and @value_dup are used to duplicate the items; in
principle they could also be used to convert between types.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">The hash table to be updated</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">The hash table to update it with (read-only)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key_dup" transfer-ownership="none">
          <doc xml:space="preserve">function to duplicate a key from @source so it can be be stored
          in @target. If NULL, the key is not copied, but is used as-is</doc>
          <type name="GObject.BoxedCopyFunc" c:type="GBoxedCopyFunc"/>
        </parameter>
        <parameter name="value_dup" transfer-ownership="none">
          <doc xml:space="preserve">function to duplicate a value from @source so it can be stored
            in @target. If NULL, the value is not copied, but is used as-is</doc>
          <type name="GObject.BoxedCopyFunc" c:type="GBoxedCopyFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_key_file_get_int64"
              c:identifier="tp_g_key_file_get_int64"
              version="0.7.31"
              introspectable="0"
              deprecated="1"
              throws="1">
      <doc xml:space="preserve">Returns the value associated with @key under @group_name as a signed
64-bit integer. This is similar to g_key_file_get_integer() but can return
64-bit results without truncation.</doc>
      <doc-deprecated xml:space="preserve">Since 0.21.0. Use g_key_file_get_int64() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value associated with the key as a signed 64-bit integer, or
0 if the key was not found or could not be parsed.</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="key_file" transfer-ownership="none">
          <doc xml:space="preserve">a non-%NULL #GKeyFile</doc>
          <type name="GLib.KeyFile" c:type="GKeyFile*"/>
        </parameter>
        <parameter name="group_name" transfer-ownership="none">
          <doc xml:space="preserve">a non-%NULL group name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">a non-%NULL key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_key_file_get_uint64"
              c:identifier="tp_g_key_file_get_uint64"
              version="0.7.31"
              introspectable="0"
              deprecated="1"
              throws="1">
      <doc xml:space="preserve">Returns the value associated with @key under @group_name as an unsigned
64-bit integer. This is similar to g_key_file_get_integer() but can return
large positive results without truncation.</doc>
      <doc-deprecated xml:space="preserve">Since 0.21.0. Use g_key_file_get_uint64() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value associated with the key as an unsigned 64-bit integer,
or 0 if the key was not found or could not be parsed.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="key_file" transfer-ownership="none">
          <doc xml:space="preserve">a non-%NULL #GKeyFile</doc>
          <type name="GLib.KeyFile" c:type="GKeyFile*"/>
        </parameter>
        <parameter name="group_name" transfer-ownership="none">
          <doc xml:space="preserve">a non-%NULL group name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">a non-%NULL key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_ptr_array_contains"
              c:identifier="tp_g_ptr_array_contains"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--no further documentation needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @needle is one of the elements of @haystack</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:space="preserve">The pointer array to be searched</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="needle"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The pointer to look for</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_ptr_array_extend"
              c:identifier="tp_g_ptr_array_extend"
              version="0.14.3"
              introspectable="0">
      <doc xml:space="preserve">Appends all elements of @source to @target. Note that this only copies the
pointers from @source; any duplication or reference-incrementing must be
performed by the caller.

After this function has been called, it is safe to call
g_ptr_array_free() on @source and also free the actual pointer array,
as long as doing so does not free the data pointed to by the new
items in @target.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray to copy items to</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray to copy items from</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_invalid_handle_type"
              c:identifier="tp_g_set_error_invalid_handle_type"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Set the error NotImplemented for an invalid handle type,
with an appropriate message.

Changed in version 0.7.23: previously, the error was
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">An invalid handle type</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_unsupported_handle_type"
              c:identifier="tp_g_set_error_unsupported_handle_type"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Set the error NotImplemented for a handle type which is valid but is not
supported by this connection manager, with an appropriate message.

Changed in version 0.7.23: previously, the error was
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">An unsupported handle type</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_signal_connect_object"
              c:identifier="tp_g_signal_connect_object"
              version="0.9.2"
              introspectable="0">
      <doc xml:space="preserve">Connects a #GCallback function to a signal for a particular object, as if
with g_signal_connect(). Additionally, arranges for the signal handler to be
disconnected if @gobject is destroyed.

This is similar to g_signal_connect_data(), but uses a closure which
ensures that the @gobject stays alive during the call to @c_handler
by temporarily adding a reference count to @gobject.

This is similar to g_signal_connect_object(), but doesn't have the
documented bug that everyone is too scared to fix. Also, it does not allow
you to pass in NULL as @gobject

This is intended to be a convenient way for objects to use themselves as
user_data for callbacks without having to explicitly disconnect all the
handlers in their finalizers.

Changed in 0.10.4 and 0.11.3: %G_CONNECT_AFTER is now respected.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handler id</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the instance to connect to.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="c_handler" transfer-ownership="none">
          <doc xml:space="preserve">the #GCallback to connect.</doc>
          <type name="GObject.Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="gobject"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the object to pass as data to @c_handler.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="connect_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GConnectFlags. Only
 %G_CONNECT_AFTER and %G_CONNECT_SWAPPED are supported by this function.</doc>
          <type name="GObject.ConnectFlags" c:type="GConnectFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_dup"
              c:identifier="tp_g_value_slice_dup"
              version="0.5.14"
              introspectable="0">
      <doc xml:space="preserve">&lt;!-- 'Returns' says it all --&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated copy of @value, to be freed with
tp_g_value_slice_free() or g_slice_free().</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_free"
              c:identifier="tp_g_value_slice_free"
              introspectable="0">
      <doc xml:space="preserve">Unset and free a slice-allocated GValue.

&lt;literal&gt;(GDestroyNotify) tp_g_value_slice_free&lt;/literal&gt; can be used
as a destructor for values in a #GHashTable, for example.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A GValue which was allocated with the g_slice API</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_bus" c:identifier="tp_get_bus" introspectable="0">
      <doc xml:space="preserve">Returns a connection to the D-Bus daemon on which this process was
activated if it was launched by D-Bus service activation, or the session
bus otherwise.

If dbus_g_bus_get() fails, exit with error code 1.

Note that this function is not suitable for use in applications which can
be useful even in the absence of D-Bus - it is designed for use in
connection managers, which are not at all useful without a D-Bus
connection. See &amp;lt;https://bugs.freedesktop.org/show_bug.cgi?id=18832&amp;gt;.
Most processes should use tp_dbus_daemon_dup() instead.</doc>
      <return-value>
        <doc xml:space="preserve">a connection to the starter or session D-Bus daemon.</doc>
        <type c:type="DBusGConnection*"/>
      </return-value>
    </function>
    <function name="get_bus_proxy"
              c:identifier="tp_get_bus_proxy"
              introspectable="0"
              deprecated="1"
              deprecated-version="0.7.26">
      <doc xml:space="preserve">Return a #DBusGProxy for the bus daemon object. The same caveats as for
tp_get_bus() apply.</doc>
      <doc-deprecated xml:space="preserve">Use tp_dbus_daemon_dup() in new code.</doc-deprecated>
      <return-value>
        <doc xml:space="preserve">a proxy for the bus daemon object on the starter or session bus.</doc>
        <type c:type="DBusGProxy*"/>
      </return-value>
    </function>
    <function name="group_mixin_add_handle_owner"
              c:identifier="tp_group_mixin_add_handle_owner"
              moved-to="GroupMixin.add_handle_owner"
              introspectable="0">
      <doc xml:space="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.

Changed in 0.7.10: The @owner_handle may be 0. To comply with telepathy-spec
 0.17.6, before adding any channel-specific handle to the members,
 local-pending members or remote-pending members, you must call either
 this function or tp_group_mixin_add_handle_owners().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_handle" transfer-ownership="none">
          <doc xml:space="preserve">A contact handle valid within this group (may not be 0)</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="owner_handle" transfer-ownership="none">
          <doc xml:space="preserve">A contact handle valid globally, or 0 if the owner of the
 @local_handle is unknown</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_handle_owners"
              c:identifier="tp_group_mixin_add_handle_owners"
              moved-to="GroupMixin.add_handle_owners"
              version="0.7.10"
              introspectable="0">
      <doc xml:space="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.

To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_to_owner_handle" transfer-ownership="none">
          <doc xml:space="preserve">A map from contact handles valid within this group
 (which may not be 0) to either contact handles valid globally, or 0 if the
 owner of the corresponding key is unknown; all handles are stored using
 GUINT_TO_POINTER</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_members"
              c:identifier="tp_group_mixin_add_members"
              moved-to="GroupMixin.add_members"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message associated with the addition request, if supported</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_flags"
              c:identifier="tp_group_mixin_change_flags"
              moved-to="GroupMixin.change_flags"
              introspectable="0">
      <doc xml:space="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.

It is an error to set any of the same bits in both @add and @del.

Changed in 0.7.7: the signal is not emitted if adding @add and
 removing @del had no effect on the existing group flags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the groups interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:space="preserve">Flags to be added</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:space="preserve">Flags to be removed</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members"
              c:identifier="tp_group_mixin_change_members"
              moved-to="GroupMixin.change_members"
              introspectable="0">
      <doc xml:space="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)
 signals were emitted; %FALSE if nothing actually changed and the signals
 were suppressed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message to be sent to the affected contacts if possible;
 %NULL is allowed, and is mapped to an empty string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be added to the members (if not
 already present) and removed from local pending and remote pending
 (if present)</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be removed from members,
 local pending or remote pending, wherever they are present</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be added to local pending,
 and removed from members and remote pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be added to remote pending,
 and removed from members and local pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="actor" transfer-ownership="none">
          <doc xml:space="preserve">The handle of the contact responsible for this change</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:space="preserve">The reason for this change</doc>
          <type name="ChannelGroupChangeReason"
                c:type="TpChannelGroupChangeReason"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members_detailed"
              c:identifier="tp_group_mixin_change_members_detailed"
              moved-to="GroupMixin.change_members_detailed"
              version="0.7.21"
              introspectable="0">
      <doc xml:space="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).

If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)
 signals were emitted; %FALSE if nothing actually changed and the signals
 were suppressed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be added to the members (if not
 already present) and removed from local pending and remote pending
 (if present)</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be removed from members,
 local pending or remote pending, wherever they are present</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be added to local pending,
 and removed from members and remote pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:space="preserve">A set of contact handles to be added to remote pending,
 and removed from members and local pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="details" transfer-ownership="none">
          <doc xml:space="preserve">a map from strings to GValues detailing the change</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_self_handle"
              c:identifier="tp_group_mixin_change_self_handle"
              moved-to="GroupMixin.change_self_handle"
              introspectable="0">
      <doc xml:space="preserve">Change the self-handle for this group to the given value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="new_self_handle" transfer-ownership="none">
          <doc xml:space="preserve">The new self-handle for this group</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_allow_self_removal"
              c:identifier="tp_group_mixin_class_allow_self_removal"
              moved-to="GroupMixinClass.allow_self_removal"
              version="0.7.27"
              introspectable="0">
      <doc xml:space="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.

This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().

(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of an object implementing the group interface using this
 mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_get_offset_quark"
              c:identifier="tp_group_mixin_class_get_offset_quark"
              moved-to="GroupMixinClass.get_offset_quark"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_class_init"
              c:identifier="tp_group_mixin_class_init"
              moved-to="GroupMixinClass.init"
              introspectable="0">
      <doc xml:space="preserve">Configure the mixin for use with the given class.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of an object implementing the group interface using this
 mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The offset of the TpGroupMixinClass structure within the class
 structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="add_func" transfer-ownership="none">
          <doc xml:space="preserve">A callback to be used to add contacts to this group</doc>
          <type name="GroupMixinAddMemberFunc"
                c:type="TpGroupMixinAddMemberFunc"/>
        </parameter>
        <parameter name="rem_func" transfer-ownership="none">
          <doc xml:space="preserve">A callback to be used to remove contacts from this group.
 This must be %NULL if you will subsequently call
 tp_group_mixin_class_set_remove_with_reason_func().</doc>
          <type name="GroupMixinRemMemberFunc"
                c:type="TpGroupMixinRemMemberFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_set_remove_with_reason_func"
              c:identifier="tp_group_mixin_class_set_remove_with_reason_func"
              moved-to="GroupMixinClass.set_remove_with_reason_func"
              version="0.5.13"
              introspectable="0">
      <doc xml:space="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of an object implementing the group interface using this
 mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:space="preserve">A callback to be used to remove contacts from this group with a
 specified reason.</doc>
          <type name="GroupMixinRemMemberWithReasonFunc"
                c:type="TpGroupMixinRemMemberWithReasonFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_finalize"
              c:identifier="tp_group_mixin_finalize"
              moved-to="GroupMixin.finalize"
              introspectable="0">
      <doc xml:space="preserve">Unreference handles and free resources used by this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_all_members"
              c:identifier="tp_group_mixin_get_all_members"
              moved-to="GroupMixin.get_all_members"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Get the group's current and pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="members" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GArray of guint representing
the handles of the group's members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="local_pending" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GArray of guint
representing the handles of the group's local pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="remote_pending" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GArray of guint
representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_dbus_property"
              c:identifier="tp_group_mixin_get_dbus_property"
              moved-to="GroupMixin.get_dbus_property"
              version="0.7.10"
              introspectable="0">
      <doc xml:space="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the group mixin. It can only be used for the Group interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:space="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A quark representing the D-Bus property name, either
 "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members",
 "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A GValue pre-initialized to the right type, into which to put the
 value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_group_flags"
              c:identifier="tp_group_mixin_get_group_flags"
              moved-to="GroupMixin.get_group_flags"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return the flags</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_handle_owners"
              c:identifier="tp_group_mixin_get_handle_owners"
              moved-to="GroupMixin.get_handle_owners"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on
failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">An array of guint representing locally valid handles</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return an array of guint representing globally valid
 handles, or 0 where unavailable, if %TRUE is returned</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members"
              c:identifier="tp_group_mixin_get_local_pending_members"
              moved-to="GroupMixin.get_local_pending_members"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Get the group's local-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members_with_info"
              c:identifier="tp_group_mixin_get_local_pending_members_with_info"
              moved-to="GroupMixin.get_local_pending_members_with_info"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each
containing the handle of a local-pending contact, the handle of a contact
 responsible for adding them to the group (or 0), the reason code
 and a related message (e.g. their request to join the group)</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_members"
              c:identifier="tp_group_mixin_get_members"
              moved-to="GroupMixin.get_members"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Get the group's current members</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_offset_quark"
              c:identifier="tp_group_mixin_get_offset_quark"
              moved-to="GroupMixin.get_offset_quark"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_get_remote_pending_members"
              c:identifier="tp_group_mixin_get_remote_pending_members"
              moved-to="GroupMixin.get_remote_pending_members"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Get the group's remote-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return a newly-allocated GArray of guint representing the
handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_self_handle"
              c:identifier="tp_group_mixin_get_self_handle"
              moved-to="GroupMixin.get_self_handle"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:space="preserve">Used to return the local user's handle in this group</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_iface_init"
              c:identifier="tp_group_mixin_iface_init"
              moved-to="GroupMixin.iface_init"
              introspectable="0">
      <doc xml:space="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init"
              c:identifier="tp_group_mixin_init"
              moved-to="GroupMixin.init"
              introspectable="0">
      <doc xml:space="preserve">Initialize the mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The offset of the TpGroupMixin structure within the instance
 structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="handle_repo" transfer-ownership="none">
          <doc xml:space="preserve">The connection's handle repository for contacts</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="self_handle" transfer-ownership="none">
          <doc xml:space="preserve">The handle of the local user in this group, if any</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init_dbus_properties"
              c:identifier="tp_group_mixin_init_dbus_properties"
              moved-to="GroupMixin.init_dbus_properties"
              version="0.7.10"
              introspectable="0">
      <doc xml:space="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members"
              c:identifier="tp_group_mixin_remove_members"
              moved-to="GroupMixin.remove_members"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members_with_reason"
              c:identifier="tp_group_mixin_remove_members_with_reason"
              moved-to="GroupMixin.remove_members_with_reason"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:space="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:space="preserve">A #TpChannelGroupChangeReason</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_hold"
              c:identifier="tp_handle_client_hold"
              introspectable="0"
              deprecated="1"
              throws="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_release"
              c:identifier="tp_handle_client_release"
              introspectable="0"
              deprecated="1"
              throws="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure" c:identifier="tp_handle_ensure" throws="1">
      <doc xml:space="preserve">Return a handle for the given string, creating one if necessary. The string
is normalized, if possible.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handle corresponding to the given string, or 0 if it
is invalid.</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:space="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure_async"
              c:identifier="tp_handle_ensure_async"
              version="0.19.2"
              introspectable="0">
      <doc xml:space="preserve">Asyncronously normalize an identifier and create an handle for it. This could
involve a server round-trip. This should be used instead of
tp_handle_ensure() for user provided contact identifiers, but it is not
necessary for identifiers from the server.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the #TpBaseConnection using this handle repo</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:space="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="5">
          <doc xml:space="preserve">a callback to call when the operation finishes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure_finish"
              c:identifier="tp_handle_ensure_finish"
              version="0.19.2"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Finishes tp_handle_ensure_async()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">non-0 #TpHandle if the operation was successful, otherwise 0.</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">a #GAsyncResult</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_get_qdata"
              c:identifier="tp_handle_get_qdata"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <doc-deprecated xml:space="preserve">Since 0.19.9. It is not recommended to use this function
 because the associated data won't be freed until the connection disconnects.</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data associated with a given key on a given handle; %NULL
if there is no associated data.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A handle to get data from</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">Key id of data to fetch</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_inspect"
              c:identifier="tp_handle_inspect"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string represented by the given handle, or NULL if the
handle is absent from the repository. The string is owned by the
handle repository and will remain valid as long as a reference to
the handle exists.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_is_valid"
              c:identifier="tp_handle_is_valid"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle is nonzero and is present in the repository,
else %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A handle of the type stored in the repository @self</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_lookup"
              c:identifier="tp_handle_lookup"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Return the handle for the given string. The string is normalized if
possible. If no handle already exists for the string, none is created.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handle corresponding to the given string, or 0 if it
does not exist or is invalid</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:space="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ref"
              c:identifier="tp_handle_ref"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.

Changed in 0.13.6: @handle is now returned; previously,
this function didn't return anything.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the same @handle</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_set_qdata"
              c:identifier="tp_handle_set_qdata"
              moved-to="HandleSet.qdata"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Associates a blob of data with a given handle and a given key

If @destroy is set, then the data is freed when the handle is freed.

Since version 0.13.8, handles always last as long as the
connection, so @destroy will not be called until the connection
disconnects.</doc>
      <doc-deprecated xml:space="preserve">Since 0.19.9. It is not recommended to use this function
 because the associated data won't be freed until the connection disconnects.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A handle to set data on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">Key id to associate data with</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">data to associate with handle</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">A #GDestroyNotify to call to destroy the data,
          or NULL if not needed.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_is_valid"
              c:identifier="tp_handle_type_is_valid"
              throws="1">
      <doc xml:space="preserve">If the given handle type is valid, return %TRUE. If not, set @error
and return %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle type is valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">A handle type, valid or not, to be checked</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_to_string"
              c:identifier="tp_handle_type_to_string">
      <doc xml:space="preserve">&lt;!----&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a human-readable string describing the handle type, e.g. "contact".
 For invalid handle types, returns "(no handle)" for 0 or
 "(invalid handle type)" for others.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">A handle type, which need not be valid</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref"
              c:identifier="tp_handle_unref"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_are_valid"
              c:identifier="tp_handles_are_valid"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle is present in the repository, else %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">Array of TpHandle representing handles of the type stored in
          the repository @self</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:space="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_hold"
              c:identifier="tp_handles_client_hold"
              introspectable="0"
              deprecated="1"
              throws="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_release"
              c:identifier="tp_handles_client_release"
              introspectable="0"
              deprecated="1"
              throws="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_ref"
              c:identifier="tp_handles_ref"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_supported_and_valid"
              c:identifier="tp_handles_supported_and_valid"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Return %TRUE if the given handle type is supported (i.e. repos[handle_type]
is not %NULL) and the given handles are all valid in that repository.
If not, set @error and return %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle type is supported and the handles are all
valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:space="preserve">An array of possibly null pointers to handle repositories, indexed
        by handle type, where a null pointer means an unsupported handle
        type</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface**"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:space="preserve">The handle type</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">A GArray of guint representing handles of the given type</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:space="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_unref"
              c:identifier="tp_handles_unref"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <doc-deprecated xml:space="preserve">This is no-op so can be safely removed.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:space="preserve">not used</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="iface_quark_account" c:identifier="tp_iface_quark_account">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_addressing"
              c:identifier="tp_iface_quark_account_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_avatar"
              c:identifier="tp_iface_quark_account_interface_avatar">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_storage"
              c:identifier="tp_iface_quark_account_interface_storage">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_manager"
              c:identifier="tp_iface_quark_account_manager">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_authentication_tls_certificate"
              c:identifier="tp_iface_quark_authentication_tls_certificate">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content"
              c:identifier="tp_iface_quark_call_content">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_audio_control"
              c:identifier="tp_iface_quark_call_content_interface_audio_control">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_dtmf"
              c:identifier="tp_iface_quark_call_content_interface_dtmf">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_media"
              c:identifier="tp_iface_quark_call_content_interface_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_video_control"
              c:identifier="tp_iface_quark_call_content_interface_video_control">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description"
              c:identifier="tp_iface_quark_call_content_media_description">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description_interface_rtcp_extended_reports"
              c:identifier="tp_iface_quark_call_content_media_description_interface_rtcp_extended_reports">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description_interface_rtcp_feedback"
              c:identifier="tp_iface_quark_call_content_media_description_interface_rtcp_feedback">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description_interface_rtp_header_extensions"
              c:identifier="tp_iface_quark_call_content_media_description_interface_rtp_header_extensions">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_stream"
              c:identifier="tp_iface_quark_call_stream">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_stream_endpoint"
              c:identifier="tp_iface_quark_call_stream_endpoint">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_stream_interface_media"
              c:identifier="tp_iface_quark_call_stream_interface_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel" c:identifier="tp_iface_quark_channel">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatch_operation"
              c:identifier="tp_iface_quark_channel_dispatch_operation">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher"
              c:identifier="tp_iface_quark_channel_dispatcher">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher_interface_messages1"
              c:identifier="tp_iface_quark_channel_dispatcher_interface_messages1">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher_interface_operation_list"
              c:identifier="tp_iface_quark_channel_dispatcher_interface_operation_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_anonymity"
              c:identifier="tp_iface_quark_channel_interface_anonymity">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_call_state"
              c:identifier="tp_iface_quark_channel_interface_call_state">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_captcha_authentication"
              c:identifier="tp_iface_quark_channel_interface_captcha_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_chat_state"
              c:identifier="tp_iface_quark_channel_interface_chat_state">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_conference"
              c:identifier="tp_iface_quark_channel_interface_conference">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_destroyable"
              c:identifier="tp_iface_quark_channel_interface_destroyable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_dtmf"
              c:identifier="tp_iface_quark_channel_interface_dtmf">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_file_transfer_metadata"
              c:identifier="tp_iface_quark_channel_interface_file_transfer_metadata">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_group"
              c:identifier="tp_iface_quark_channel_interface_group">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_hold"
              c:identifier="tp_iface_quark_channel_interface_hold">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_media_signalling"
              c:identifier="tp_iface_quark_channel_interface_media_signalling">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_messages"
              c:identifier="tp_iface_quark_channel_interface_messages">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_password"
              c:identifier="tp_iface_quark_channel_interface_password">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_room"
              c:identifier="tp_iface_quark_channel_interface_room">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_room_config"
              c:identifier="tp_iface_quark_channel_interface_room_config">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_sasl_authentication"
              c:identifier="tp_iface_quark_channel_interface_sasl_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_securable"
              c:identifier="tp_iface_quark_channel_interface_securable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_service_point"
              c:identifier="tp_iface_quark_channel_interface_service_point">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_sms"
              c:identifier="tp_iface_quark_channel_interface_sms">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_subject"
              c:identifier="tp_iface_quark_channel_interface_subject">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_tube"
              c:identifier="tp_iface_quark_channel_interface_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_request"
              c:identifier="tp_iface_quark_channel_request">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_call"
              c:identifier="tp_iface_quark_channel_type_call">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_list"
              c:identifier="tp_iface_quark_channel_type_contact_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_search"
              c:identifier="tp_iface_quark_channel_type_contact_search">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_dbus_tube"
              c:identifier="tp_iface_quark_channel_type_dbus_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_file_transfer"
              c:identifier="tp_iface_quark_channel_type_file_transfer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_room_list"
              c:identifier="tp_iface_quark_channel_type_room_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_server_authentication"
              c:identifier="tp_iface_quark_channel_type_server_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_server_tls_connection"
              c:identifier="tp_iface_quark_channel_type_server_tls_connection">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_stream_tube"
              c:identifier="tp_iface_quark_channel_type_stream_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_streamed_media"
              c:identifier="tp_iface_quark_channel_type_streamed_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_text"
              c:identifier="tp_iface_quark_channel_type_text">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_tubes"
              c:identifier="tp_iface_quark_channel_type_tubes">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client" c:identifier="tp_iface_quark_client">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_approver"
              c:identifier="tp_iface_quark_client_approver">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_handler"
              c:identifier="tp_iface_quark_client_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_interface_requests"
              c:identifier="tp_iface_quark_client_interface_requests">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_observer"
              c:identifier="tp_iface_quark_client_observer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection"
              c:identifier="tp_iface_quark_connection">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_addressing"
              c:identifier="tp_iface_quark_connection_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_aliasing"
              c:identifier="tp_iface_quark_connection_interface_aliasing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_anonymity"
              c:identifier="tp_iface_quark_connection_interface_anonymity">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_avatars"
              c:identifier="tp_iface_quark_connection_interface_avatars">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_balance"
              c:identifier="tp_iface_quark_connection_interface_balance">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_capabilities"
              c:identifier="tp_iface_quark_connection_interface_capabilities">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_cellular"
              c:identifier="tp_iface_quark_connection_interface_cellular">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_client_types"
              c:identifier="tp_iface_quark_connection_interface_client_types">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_blocking"
              c:identifier="tp_iface_quark_connection_interface_contact_blocking">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_capabilities"
              c:identifier="tp_iface_quark_connection_interface_contact_capabilities">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_groups"
              c:identifier="tp_iface_quark_connection_interface_contact_groups">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_info"
              c:identifier="tp_iface_quark_connection_interface_contact_info">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_list"
              c:identifier="tp_iface_quark_connection_interface_contact_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contacts"
              c:identifier="tp_iface_quark_connection_interface_contacts">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_location"
              c:identifier="tp_iface_quark_connection_interface_location">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_mail_notification"
              c:identifier="tp_iface_quark_connection_interface_mail_notification">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_power_saving"
              c:identifier="tp_iface_quark_connection_interface_power_saving">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_presence"
              c:identifier="tp_iface_quark_connection_interface_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_renaming"
              c:identifier="tp_iface_quark_connection_interface_renaming">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_requests"
              c:identifier="tp_iface_quark_connection_interface_requests">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_service_point"
              c:identifier="tp_iface_quark_connection_interface_service_point">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_sidecars1"
              c:identifier="tp_iface_quark_connection_interface_sidecars1">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_simple_presence"
              c:identifier="tp_iface_quark_connection_interface_simple_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_manager"
              c:identifier="tp_iface_quark_connection_manager">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_daemon"
              c:identifier="tp_iface_quark_dbus_daemon">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_introspectable"
              c:identifier="tp_iface_quark_dbus_introspectable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_peer"
              c:identifier="tp_iface_quark_dbus_peer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_properties"
              c:identifier="tp_iface_quark_dbus_properties">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_debug" c:identifier="tp_iface_quark_debug">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_session_handler"
              c:identifier="tp_iface_quark_media_session_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_stream_handler"
              c:identifier="tp_iface_quark_media_stream_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_properties_interface"
              c:identifier="tp_iface_quark_properties_interface">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol"
              c:identifier="tp_iface_quark_protocol">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_addressing"
              c:identifier="tp_iface_quark_protocol_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_avatars"
              c:identifier="tp_iface_quark_protocol_interface_avatars">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_presence"
              c:identifier="tp_iface_quark_protocol_interface_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="intset_from_array"
              c:identifier="tp_intset_from_array"
              moved-to="Intset.from_array">
      <doc xml:space="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A set containing the same integers as @array.</doc>
        <type name="Intset" c:type="TpIntset*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">An array of guint</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers"
              c:identifier="tp_list_connection_managers"
              version="0.7.1"
              deprecated="1">
      <doc xml:space="preserve">List the available (running or installed) connection managers. Call the
callback when done.

Since 0.7.26, this function will wait for each #TpConnectionManager
to be ready, so all connection managers passed to @callback will have
their %TP_CONNECTION_MANAGER_FEATURE_CORE feature prepared, unless an error
occurred while launching that connection manager.</doc>
      <doc-deprecated xml:space="preserve">since 0.19.1, use tp_list_connection_managers_async()</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:space="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:space="preserve">callback to be called when listing the CMs
 succeeds or fails; not called if the @weak_object goes away</doc>
          <type name="ConnectionManagerListCb"
                c:type="TpConnectionManagerListCb"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user-supplied data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">callback to destroy the user-supplied data, called after
  @callback, but also if the @weak_object goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">if not %NULL, will be weakly
 referenced; the callback will not be called, and the call will be
 cancelled, if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers_async"
              c:identifier="tp_list_connection_managers_async"
              version="0.17.6">
      <doc xml:space="preserve">List the available (running or installed) connection managers,
asynchronously, and wait for their %TP_CONNECTION_MANAGER_FEATURE_CORE
feature to be ready.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dbus_daemon"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #TpDBusDaemon, or %NULL to use
 tp_dbus_daemon_dup()</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve">a callback to call with a list of CMs</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers_finish"
              c:identifier="tp_list_connection_managers_finish"
              version="0.17.6"
              throws="1">
      <doc xml:space="preserve">Finish listing the available connection managers.

Free the list after use, for instance with
&lt;literal&gt;g_list_free_full (list, g_object_unref)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
 newly allocated list of references to #TpConnectionManager objects</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="ConnectionManager"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the result of tp_list_connection_managers_async()</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_names"
              c:identifier="tp_list_connection_names"
              version="0.7.1">
      <doc xml:space="preserve">List the bus names of all the connections that currently exist, together
with the connection manager name and the protocol name for each connection.
Call the callback when done.

The bus names passed to the callback can be used to construct #TpConnection
objects for any connections that are of interest.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:space="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:space="preserve">callback to be called when listing the connections succeeds or
  fails; not called if the D-Bus connection fails completely or if the
  @weak_object goes away</doc>
          <type name="ConnectionNameListCb" c:type="TpConnectionNameListCb"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user-supplied data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">callback to destroy the user-supplied data, called after
  @callback, but also if the D-Bus connection fails or if the @weak_object
  goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">if not %NULL, will be weakly referenced; the callback will
  not be called if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mixin_class_get_offset"
              c:identifier="tp_mixin_class_get_offset"
              introspectable="0">
      <doc xml:space="preserve">If the type of @klass, or any of its ancestor types, has had an offset
attached using qdata with the given @quark, return that offset; if not,
return 0.

In older telepathy-glib versions, calling this function on an instance that
did not have the mixin was considered to be a programming error. Since
version 0.13.9, 0 is returned, without error.

This is used to implement the telepathy-glib mixin classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the offset of the mixin class</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="klass"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to a GObjectClass-derived class structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:space="preserve">A quark that was used to store the offset with g_type_set_qdata()</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="mixin_instance_get_offset"
              c:identifier="tp_mixin_instance_get_offset"
              introspectable="0">
      <doc xml:space="preserve">If the type of @instance, or any of its ancestor types, has had an offset
attached using qdata with the given @quark, return that offset. If not,
return 0.

In older telepathy-glib versions, calling this function on an instance that
did not have the mixin was considered to be a programming error. Since
version 0.13.9, 0 is returned, without error.

This is used to implement the telepathy-glib mixin classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the offset of the mixin</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to a GObject-derived instance structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:space="preserve">A quark that was used to store the offset with g_type_set_qdata()</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="mixin_offset_cast"
              c:identifier="tp_mixin_offset_cast"
              introspectable="0">
      <doc xml:space="preserve">Extend a pointer by an offset, provided the offset is not 0.
This is used to cast from an object instance to one of the telepathy-glib
mixin classes.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer @offset bytes beyond @instance</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="instance"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to a structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The offset of a structure member in bytes, which must not be 0</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_class_get_offset_quark"
              c:identifier="tp_presence_mixin_class_get_offset_quark"
              moved-to="PresenceMixinClass.get_offset_quark"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_class_init"
              c:identifier="tp_presence_mixin_class_init"
              moved-to="PresenceMixinClass.init"
              introspectable="0">
      <doc xml:space="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
                              G_STRUCT_OFFSET (SomeObjectClass,
                                               presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The byte offset of the TpPresenceMixinClass within the class
structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="status_available" transfer-ownership="none">
          <doc xml:space="preserve">A callback to be used to determine if a given presence
 status can be set on a particular connection. Should usually be %NULL, to
 consider all statuses with #TpPresenceStatusSpec.self set to %TRUE to be
 settable.</doc>
          <type name="PresenceMixinStatusAvailableFunc"
                c:type="TpPresenceMixinStatusAvailableFunc"/>
        </parameter>
        <parameter name="get_contact_statuses" transfer-ownership="none">
          <doc xml:space="preserve">A callback to be used get the current presence status
 for contacts. This is used in implementations of various D-Bus methods and
 hence must be provided.</doc>
          <type name="PresenceMixinGetContactStatusesFunc"
                c:type="TpPresenceMixinGetContactStatusesFunc"/>
        </parameter>
        <parameter name="set_own_status" transfer-ownership="none">
          <doc xml:space="preserve">A callback to be used to commit changes to the user's own
 presence status to the server. This is used in implementations of various
 D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinSetOwnStatusFunc"
                c:type="TpPresenceMixinSetOwnStatusFunc"/>
        </parameter>
        <parameter name="statuses" transfer-ownership="none">
          <doc xml:space="preserve">An array of #TpPresenceStatusSpec structures representing all
 presence statuses supported by the protocol, terminated by a NULL name.</doc>
          <type name="PresenceStatusSpec"
                c:type="const TpPresenceStatusSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_one_presence_update"
              c:identifier="tp_presence_mixin_emit_one_presence_update"
              moved-to="PresenceMixin.emit_one_presence_update"
              introspectable="0">
      <doc xml:space="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">The handle of the contact to emit the signal for</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve">The new status to emit</doc>
          <type name="PresenceStatus" c:type="const TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_presence_update"
              c:identifier="tp_presence_mixin_emit_presence_update"
              moved-to="PresenceMixin.emit_presence_update"
              introspectable="0">
      <doc xml:space="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contact_presences" transfer-ownership="none">
          <doc xml:space="preserve">A mapping of contact handles to #TpPresenceStatus
 structures with the presence data to emit</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_finalize"
              c:identifier="tp_presence_mixin_finalize"
              moved-to="PresenceMixin.finalize"
              introspectable="0">
      <doc xml:space="preserve">Free resources held by the presence mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_get_offset_quark"
              c:identifier="tp_presence_mixin_get_offset_quark"
              moved-to="PresenceMixin.get_offset_quark"
              introspectable="0">
      <doc xml:space="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_iface_init"
              c:identifier="tp_presence_mixin_iface_init"
              moved-to="PresenceMixin.iface_init"
              introspectable="0">
      <doc xml:space="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an
 object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_init"
              c:identifier="tp_presence_mixin_init"
              moved-to="PresenceMixin.init"
              introspectable="0">
      <doc xml:space="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
                        G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_iface_init"
              c:identifier="tp_presence_mixin_simple_presence_iface_init"
              moved-to="PresenceMixin.simple_presence_iface_init"
              version="0.7.13"
              introspectable="0">
      <doc xml:space="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in
an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_init_dbus_properties"
              c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties"
              moved-to="PresenceMixin.simple_presence_init_dbus_properties"
              version="0.7.13"
              introspectable="0">
      <doc xml:space="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.

This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:space="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_register_with_contacts_mixin"
              c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin"
              moved-to="PresenceMixin.simple_presence_register_with_contacts_mixin"
              introspectable="0">
      <doc xml:space="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">An instance that of the implementation that uses both the Contacts
mixin and this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_status_new"
              c:identifier="tp_presence_status_new"
              moved-to="PresenceStatus.new"
              introspectable="0">
      <doc xml:space="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.

In modern Telepathy connection managers, the only optional
argument should be a %G_TYPE_STRING named "message", on statuses
that have an optional human-readable message. All other optional arguments
are deprecated.</doc>
      <return-value>
        <doc xml:space="preserve">A pointer to the newly allocated presence status structure.</doc>
        <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
      </return-value>
      <parameters>
        <parameter name="which" transfer-ownership="none">
          <doc xml:space="preserve">Index of the presence status in the provided supported presence
 statuses array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="optional_arguments" transfer-ownership="none">
          <doc xml:space="preserve">Optional arguments for the presence statuses. Can be
 NULL if there are no optional arguments. The presence status object makes a
 copy of the hashtable, so you should free the original.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="simple_async_report_success_in_idle"
              c:identifier="tp_simple_async_report_success_in_idle"
              version="0.11.9">
      <doc xml:space="preserve">Create a new #GSimpleAsyncResult with no operation result, and call
g_simple_async_result_complete_in_idle() on it.

This is like a successful version of g_simple_async_report_error_in_idle(),
suitable for asynchronous functions that (conceptually) either succeed and
return nothing, or raise an error, such as tp_proxy_prepare_async().

The corresponding finish function should not call a function that attempts
to get a result, such as g_simple_async_result_get_op_res_gpointer().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the source object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve">the callback</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data for @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="source_tag"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the source tag for the #GSimpleAsyncResult</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdiff" c:identifier="tp_strdiff" introspectable="0">
      <doc xml:space="preserve">Return %TRUE if the given strings are different. Unlike #strcmp this
function will handle null pointers, treating them as distinct from any
string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if @left and @right are both %NULL, or if
         neither is %NULL and both have the same contents; %TRUE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">The first string to compare (may be NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">The second string to compare (may be NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strv_contains"
              c:identifier="tp_strv_contains"
              version="0.7.15"
              introspectable="0">
      <doc xml:space="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">TRUE if @str is an element of @strv, according to strcmp().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="strv" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated array of strings, or %NULL (which is treated as an
       empty strv)</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a non-NULL string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_get_dbus_properties_info"
              c:identifier="tp_svc_interface_get_dbus_properties_info"
              version="0.15.8"
              introspectable="0">
      <doc xml:space="preserve">Retrieves the D-Bus property metadata for the given interface, if any.
This function is typically not useful outside telepathy-glib itself, but may
be useful for domain-specific variations on the theme of SetProperty. If in
doubt, you probably don't need this function.</doc>
      <return-value>
        <doc xml:space="preserve">D-Bus property metadata for @g_interface, or %NULL if it has
 none.</doc>
        <type name="DBusPropertiesMixinIfaceInfo"
              c:type="TpDBusPropertiesMixinIfaceInfo*"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:space="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_set_dbus_properties_info"
              c:identifier="tp_svc_interface_set_dbus_properties_info"
              version="0.7.3">
      <doc xml:space="preserve">Declare that @g_interface implements the given D-Bus interface, with the
given properties. This may only be called once per GInterface, usually from
a section of its base_init function that only runs once.

This is typically only used within generated code; there is normally no
reason to call it manually.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:space="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">an interface description</doc>
          <type name="DBusPropertiesMixinIfaceInfo"
                c:type="TpDBusPropertiesMixinIfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_action_time_from_x11"
              c:identifier="tp_user_action_time_from_x11"
              version="0.11.13">
      <doc xml:space="preserve">Convert an X11 timestamp into a user action time as used in Telepathy.

This also works for the timestamps used by GDK 2, GDK 3 and Clutter 1.0;
it may or may not work with other toolkits or versions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a nonzero Telepathy user action time, or
 %TP_USER_ACTION_TIME_CURRENT_TIME</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="x11_time" transfer-ownership="none">
          <doc xml:space="preserve">an X11 timestamp, or 0 to indicate the current time</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_action_time_should_present"
              c:identifier="tp_user_action_time_should_present"
              version="0.11.13">
      <doc xml:space="preserve">Interpret a Telepathy user action time to decide whether a Handler should
attempt to gain focus. If %TRUE is returned, it would be appropriate to
call gtk_window_present_with_time() using @x11_time as input, for instance.

@x11_time is used to return a timestamp in the right format for X11,
GDK 2, GDK 3 and Clutter 1.0; it may or may not work with other
toolkits or versions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it would be appropriate to present a window</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:space="preserve">the Telepathy user action time</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="x11_time"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">a pointer to guint32 used to
 return an X11 timestamp, or 0 to indicate the current time; if
 %FALSE is returned, the value placed here is not meaningful</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_make_valid"
              c:identifier="tp_utf8_make_valid"
              version="0.13.15">
      <doc xml:space="preserve">Validate that the provided string is valid UTF8. If not,
replace all invalid bytes with unicode replacement
character (U+FFFD).

This method is a verbatim copy of glib's internal
_g_utf8_make_valid&lt;!-- --&gt;() function, and will be deprecated as
soon as the glib one becomes public.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new valid UTF8 string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">string to coerce into UTF8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_build"
              c:identifier="tp_value_array_build"
              version="0.9.2"
              introspectable="0">
      <doc xml:space="preserve">Creates a new #GValueArray for use with structs, containing the values
passed in as parameters. The values are copied or reffed as appropriate for
their type.

&lt;example&gt;
  &lt;title&gt; using tp_value_array_build&lt;/title&gt;
   &lt;programlisting&gt;
GValueArray *array = tp_value_array_build (2,
   G_TYPE_STRING, host,
   G_TYPE_UINT, port,
   G_TYPE_INVALID);
   &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created #GValueArray, free with tp_value_array_free()</doc>
        <type name="GObject.ValueArray" c:type="GValueArray*"/>
      </return-value>
      <parameters>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">The number of elements that should be in the array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">The type of the first argument.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">The value of the first item in the struct followed by a list of type,
value pairs terminated by G_TYPE_INVALID.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_free"
              c:identifier="tp_value_array_free"
              version="0.23.0">
      <doc xml:space="preserve">Free @va. This is exactly the same as g_value_array_free(), but does not
provoke deprecation warnings from GLib when used in conjunction with
tp_value_array_build() and tp_value_array_unpack().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="va" transfer-ownership="none">
          <doc xml:space="preserve">a #GValueArray</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_unpack"
              c:identifier="tp_value_array_unpack"
              version="0.11.0"
              introspectable="0">
      <doc xml:space="preserve">Unpacks a #GValueArray into separate variables.

The contents of the values aren't copied into the variables, and so become
invalid when @array is freed.

&lt;example&gt;
  &lt;title&gt;using tp_value_array_unpack&lt;/title&gt;
   &lt;programlisting&gt;
const gchar *host;
guint port;

tp_value_array_unpack (array, 2,
   &amp;host,
   &amp;port);
   &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">the array to unpack</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">The number of elements that should be in the array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a list of correctly typed pointers to store the values in</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="weak_ref_new"
              c:identifier="tp_weak_ref_new"
              moved-to="WeakRef.new"
              version="0.11.3"
              introspectable="0">
      <doc xml:space="preserve">Return a new weak reference wrapper for @object.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new weak-reference wrapper

Free-function: tp_weak_ref_destroy()</doc>
        <type name="WeakRef" c:type="TpWeakRef*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">an object to which to take a weak reference</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optional additional data to store alongside the weak ref</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">destructor for @user_data, called when the weak ref
 is freed</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
